(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.cartodb || (g.cartodb = {})).deepInsights = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  createDashboard: require('./src/create-dashboard')
};

},{"./src/create-dashboard":25}],2:[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],3:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = require('./src/js/main');

},{"./src/js/main":9}],4:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

function oldAdd(element, className) {
  var classes = element.className.split(' ');
  if (classes.indexOf(className) < 0) {
    classes.push(className);
  }
  element.className = classes.join(' ');
}

function oldRemove(element, className) {
  var classes = element.className.split(' ');
  var idx = classes.indexOf(className);
  if (idx >= 0) {
    classes.splice(idx, 1);
  }
  element.className = classes.join(' ');
}

exports.add = function (element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    oldAdd(element, className);
  }
};

exports.remove = function (element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    oldRemove(element, className);
  }
};

exports.list = function (element) {
  if (element.classList) {
    return Array.prototype.slice.apply(element.classList);
  } else {
    return element.className.split(' ');
  }
};

},{}],5:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var DOM = {};

DOM.e = function (tagName, className) {
  var element = document.createElement(tagName);
  element.className = className;
  return element;
};

DOM.appendTo = function (child, parent) {
  parent.appendChild(child);
  return child;
};

function cssGet(element, styleName) {
  return window.getComputedStyle(element)[styleName];
}

function cssSet(element, styleName, styleValue) {
  if (typeof styleValue === 'number') {
    styleValue = styleValue.toString() + 'px';
  }
  element.style[styleName] = styleValue;
  return element;
}

function cssMultiSet(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val.toString() + 'px';
    }
    element.style[key] = val;
  }
  return element;
}

DOM.css = function (element, styleNameOrObject, styleValue) {
  if (typeof styleNameOrObject === 'object') {
    // multiple set with object
    return cssMultiSet(element, styleNameOrObject);
  } else {
    if (typeof styleValue === 'undefined') {
      return cssGet(element, styleNameOrObject);
    } else {
      return cssSet(element, styleNameOrObject, styleValue);
    }
  }
};

DOM.matches = function (element, query) {
  if (typeof element.matches !== 'undefined') {
    return element.matches(query);
  } else {
    if (typeof element.matchesSelector !== 'undefined') {
      return element.matchesSelector(query);
    } else if (typeof element.webkitMatchesSelector !== 'undefined') {
      return element.webkitMatchesSelector(query);
    } else if (typeof element.mozMatchesSelector !== 'undefined') {
      return element.mozMatchesSelector(query);
    } else if (typeof element.msMatchesSelector !== 'undefined') {
      return element.msMatchesSelector(query);
    }
  }
};

DOM.remove = function (element) {
  if (typeof element.remove !== 'undefined') {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
};

DOM.queryChildren = function (element, selector) {
  return Array.prototype.filter.call(element.childNodes, function (child) {
    return DOM.matches(child, selector);
  });
};

module.exports = DOM;

},{}],6:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var EventElement = function (element) {
  this.element = element;
  this.events = {};
};

EventElement.prototype.bind = function (eventName, handler) {
  if (typeof this.events[eventName] === 'undefined') {
    this.events[eventName] = [];
  }
  this.events[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function (eventName, handler) {
  var isHandlerProvided = (typeof handler !== 'undefined');
  this.events[eventName] = this.events[eventName].filter(function (hdlr) {
    if (isHandlerProvided && hdlr !== handler) {
      return true;
    }
    this.element.removeEventListener(eventName, hdlr, false);
    return false;
  }, this);
};

EventElement.prototype.unbindAll = function () {
  for (var name in this.events) {
    this.unbind(name);
  }
};

var EventManager = function () {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function (element) {
  var ee = this.eventElements.filter(function (eventElement) {
    return eventElement.element === element;
  })[0];
  if (typeof ee === 'undefined') {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function (element, eventName, handler) {
  this.eventElement(element).unbind(eventName, handler);
};

EventManager.prototype.unbindAll = function () {
  for (var i = 0; i < this.eventElements.length; i++) {
    this.eventElements[i].unbindAll();
  }
};

EventManager.prototype.once = function (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (e) {
    ee.unbind(eventName, onceHandler);
    handler(e);
  };
  ee.bind(eventName, onceHandler);
};

module.exports = EventManager;

},{}],7:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = (function () {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }
  return function () {
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
           s4() + '-' + s4() + s4() + s4();
  };
})();

},{}],8:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('./class')
  , d = require('./dom');

exports.toInt = function (x) {
  return parseInt(x, 10) || 0;
};

exports.clone = function (obj) {
  if (obj === null) {
    return null;
  } else if (typeof obj === 'object') {
    var result = {};
    for (var key in obj) {
      result[key] = this.clone(obj[key]);
    }
    return result;
  } else {
    return obj;
  }
};

exports.extend = function (original, source) {
  var result = this.clone(original);
  for (var key in source) {
    result[key] = this.clone(source[key]);
  }
  return result;
};

exports.isEditable = function (el) {
  return d.matches(el, "input,[contenteditable]") ||
         d.matches(el, "select,[contenteditable]") ||
         d.matches(el, "textarea,[contenteditable]") ||
         d.matches(el, "button,[contenteditable]");
};

exports.removePsClasses = function (element) {
  var clsList = cls.list(element);
  for (var i = 0; i < clsList.length; i++) {
    var className = clsList[i];
    if (className.indexOf('ps-') === 0) {
      cls.remove(element, className);
    }
  }
};

exports.outerWidth = function (element) {
  return this.toInt(d.css(element, 'width')) +
         this.toInt(d.css(element, 'paddingLeft')) +
         this.toInt(d.css(element, 'paddingRight')) +
         this.toInt(d.css(element, 'borderLeftWidth')) +
         this.toInt(d.css(element, 'borderRightWidth'));
};

exports.startScrolling = function (element, axis) {
  cls.add(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.add(element, 'ps-' + axis);
  } else {
    cls.add(element, 'ps-x');
    cls.add(element, 'ps-y');
  }
};

exports.stopScrolling = function (element, axis) {
  cls.remove(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.remove(element, 'ps-' + axis);
  } else {
    cls.remove(element, 'ps-x');
    cls.remove(element, 'ps-y');
  }
};

exports.env = {
  isWebKit: 'WebkitAppearance' in document.documentElement.style,
  supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: window.navigator.msMaxTouchPoints !== null
};

},{"./class":4,"./dom":5}],9:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var destroy = require('./plugin/destroy')
  , initialize = require('./plugin/initialize')
  , update = require('./plugin/update');

module.exports = {
  initialize: initialize,
  update: update,
  destroy: destroy
};

},{"./plugin/destroy":11,"./plugin/initialize":19,"./plugin/update":23}],10:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = {
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  stopPropagationOnClick: true,
  suppressScrollX: false,
  suppressScrollY: false,
  swipePropagation: true,
  useBothWheelAxes: false,
  useKeyboard: true,
  useSelectionScroll: false,
  wheelPropagation: false,
  wheelSpeed: 1
};

},{}],11:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances');

module.exports = function (element) {
  var i = instances.get(element);

  if (!i) {
    return;
  }

  i.event.unbindAll();
  d.remove(i.scrollbarX);
  d.remove(i.scrollbarY);
  d.remove(i.scrollbarXRail);
  d.remove(i.scrollbarYRail);
  h.removePsClasses(element);

  instances.remove(element);
};

},{"../lib/dom":5,"../lib/helper":8,"./instances":20}],12:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindClickRailHandler(element, i) {
  function pageOffset(el) {
    return el.getBoundingClientRect();
  }
  var stopPropagation = window.Event.prototype.stopPropagation.bind;

  if (i.settings.stopPropagationOnClick) {
    i.event.bind(i.scrollbarY, 'click', stopPropagation);
  }
  i.event.bind(i.scrollbarYRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarYHeight / 2);
    var positionTop = i.railYRatio * (e.pageY - window.scrollY - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
    var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
    var positionRatio = positionTop / maxPositionTop;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    updateScroll(element, 'top', (i.contentHeight - i.containerHeight) * positionRatio);
    updateGeometry(element);

    e.stopPropagation();
  });

  if (i.settings.stopPropagationOnClick) {
    i.event.bind(i.scrollbarX, 'click', stopPropagation);
  }
  i.event.bind(i.scrollbarXRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarXWidth / 2);
    var positionLeft = i.railXRatio * (e.pageX - window.scrollX - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
    var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
    var positionRatio = positionLeft / maxPositionLeft;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    updateScroll(element, 'left', ((i.contentWidth - i.containerWidth) * positionRatio) - i.negativeScrollAdjustment);
    updateGeometry(element);

    e.stopPropagation();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindClickRailHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],13:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../../lib/dom')
  , h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindMouseScrollXHandler(element, i) {
  var currentLeft = null;
  var currentPageX = null;

  function updateScrollLeft(deltaX) {
    var newLeft = currentLeft + (deltaX * i.railXRatio);
    var maxLeft = i.scrollbarXRail.getBoundingClientRect().left + (i.railXRatio * (i.railXWidth - i.scrollbarXWidth));

    if (newLeft < 0) {
      i.scrollbarXLeft = 0;
    } else if (newLeft > maxLeft) {
      i.scrollbarXLeft = maxLeft;
    } else {
      i.scrollbarXLeft = newLeft;
    }

    var scrollLeft = h.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - (i.railXRatio * i.scrollbarXWidth))) - i.negativeScrollAdjustment;
    updateScroll(element, 'left', scrollLeft);
  }

  var mouseMoveHandler = function (e) {
    updateScrollLeft(e.pageX - currentPageX);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'x');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
    currentPageX = e.pageX;
    currentLeft = h.toInt(d.css(i.scrollbarX, 'left')) * i.railXRatio;
    h.startScrolling(element, 'x');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

function bindMouseScrollYHandler(element, i) {
  var currentTop = null;
  var currentPageY = null;

  function updateScrollTop(deltaY) {
    var newTop = currentTop + (deltaY * i.railYRatio);
    var maxTop = i.scrollbarYRail.getBoundingClientRect().top + (i.railYRatio * (i.railYHeight - i.scrollbarYHeight));

    if (newTop < 0) {
      i.scrollbarYTop = 0;
    } else if (newTop > maxTop) {
      i.scrollbarYTop = maxTop;
    } else {
      i.scrollbarYTop = newTop;
    }

    var scrollTop = h.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - (i.railYRatio * i.scrollbarYHeight)));
    updateScroll(element, 'top', scrollTop);
  }

  var mouseMoveHandler = function (e) {
    updateScrollTop(e.pageY - currentPageY);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'y');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
    currentPageY = e.pageY;
    currentTop = h.toInt(d.css(i.scrollbarY, 'top')) * i.railYRatio;
    h.startScrolling(element, 'y');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseScrollXHandler(element, i);
  bindMouseScrollYHandler(element, i);
};

},{"../../lib/dom":5,"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],14:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindKeyboardHandler(element, i) {
  var hovered = false;
  i.event.bind(element, 'mouseenter', function () {
    hovered = true;
  });
  i.event.bind(element, 'mouseleave', function () {
    hovered = false;
  });

  var shouldPrevent = false;
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented()) {
      return;
    }

    if (!hovered) {
      return;
    }

    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      // go deeper if element is a webcomponent
      while (activeElement.shadowRoot) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      if (h.isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
    case 37: // left
      deltaX = -30;
      break;
    case 38: // up
      deltaY = 30;
      break;
    case 39: // right
      deltaX = 30;
      break;
    case 40: // down
      deltaY = -30;
      break;
    case 33: // page up
      deltaY = 90;
      break;
    case 32: // space bar
      if (e.shiftKey) {
        deltaY = 90;
      } else {
        deltaY = -90;
      }
      break;
    case 34: // page down
      deltaY = -90;
      break;
    case 35: // end
      if (e.ctrlKey) {
        deltaY = -i.contentHeight;
      } else {
        deltaY = -i.containerHeight;
      }
      break;
    case 36: // home
      if (e.ctrlKey) {
        deltaY = element.scrollTop;
      } else {
        deltaY = i.containerHeight;
      }
      break;
    default:
      return;
    }

    updateScroll(element, 'top', element.scrollTop - deltaY);
    updateScroll(element, 'left', element.scrollLeft + deltaX);
    updateGeometry(element);

    shouldPrevent = shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent) {
      e.preventDefault();
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindKeyboardHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],15:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindMouseWheelHandler(element, i) {
  var shouldPrevent = false;

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    return [deltaX, deltaY];
  }

  function shouldBeConsumedByTextarea(deltaX, deltaY) {
    var hoveredTextarea = element.querySelector('textarea:hover');
    if (hoveredTextarea) {
      var maxScrollTop = hoveredTextarea.scrollHeight - hoveredTextarea.clientHeight;
      if (maxScrollTop > 0) {
        if (!(hoveredTextarea.scrollTop === 0 && deltaY > 0) &&
            !(hoveredTextarea.scrollTop === maxScrollTop && deltaY < 0)) {
          return true;
        }
      }
      var maxScrollLeft = hoveredTextarea.scrollLeft - hoveredTextarea.clientWidth;
      if (maxScrollLeft > 0) {
        if (!(hoveredTextarea.scrollLeft === 0 && deltaX < 0) &&
            !(hoveredTextarea.scrollLeft === maxScrollLeft && deltaX > 0)) {
          return true;
        }
      }
    }
    return false;
  }

  function mousewheelHandler(e) {
    // FIXME: this is a quick fix for the select problem in FF and IE.
    // If there comes an effective way to deal with the problem,
    // this lines should be removed.
    if (!h.env.isWebKit && element.querySelector('select:focus')) {
      return;
    }

    var delta = getDeltaFromEvent(e);

    var deltaX = delta[0];
    var deltaY = delta[1];

    if (shouldBeConsumedByTextarea(deltaX, deltaY)) {
      return;
    }

    shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
      updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
      } else {
        updateScroll(element, 'top', element.scrollTop + (deltaX * i.settings.wheelSpeed));
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
      } else {
        updateScroll(element, 'left', element.scrollLeft - (deltaY * i.settings.wheelSpeed));
      }
      shouldPrevent = true;
    }

    updateGeometry(element);

    shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
    if (shouldPrevent) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseWheelHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],16:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('../instances')
  , updateGeometry = require('../update-geometry');

function bindNativeScrollHandler(element, i) {
  i.event.bind(element, 'scroll', function () {
    updateGeometry(element);
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindNativeScrollHandler(element, i);
};

},{"../instances":20,"../update-geometry":21}],17:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindSelectionHandler(element, i) {
  function getRangeNode() {
    var selection = window.getSelection ? window.getSelection() :
                    document.getSelection ? document.getSelection() : '';
    if (selection.toString().length === 0) {
      return null;
    } else {
      return selection.getRangeAt(0).commonAncestorContainer;
    }
  }

  var scrollingLoop = null;
  var scrollDiff = {top: 0, left: 0};
  function startScrolling() {
    if (!scrollingLoop) {
      scrollingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(scrollingLoop);
          return;
        }

        updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
        updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
        updateGeometry(element);
      }, 50); // every .1 sec
    }
  }
  function stopScrolling() {
    if (scrollingLoop) {
      clearInterval(scrollingLoop);
      scrollingLoop = null;
    }
    h.stopScrolling(element);
  }

  var isSelected = false;
  i.event.bind(i.ownerDocument, 'selectionchange', function () {
    if (element.contains(getRangeNode())) {
      isSelected = true;
    } else {
      isSelected = false;
      stopScrolling();
    }
  });
  i.event.bind(window, 'mouseup', function () {
    if (isSelected) {
      isSelected = false;
      stopScrolling();
    }
  });

  i.event.bind(window, 'mousemove', function (e) {
    if (isSelected) {
      var mousePosition = {x: e.pageX, y: e.pageY};
      var containerGeometry = {
        left: element.offsetLeft,
        right: element.offsetLeft + element.offsetWidth,
        top: element.offsetTop,
        bottom: element.offsetTop + element.offsetHeight
      };

      if (mousePosition.x < containerGeometry.left + 3) {
        scrollDiff.left = -5;
        h.startScrolling(element, 'x');
      } else if (mousePosition.x > containerGeometry.right - 3) {
        scrollDiff.left = 5;
        h.startScrolling(element, 'x');
      } else {
        scrollDiff.left = 0;
      }

      if (mousePosition.y < containerGeometry.top + 3) {
        if (containerGeometry.top + 3 - mousePosition.y < 5) {
          scrollDiff.top = -5;
        } else {
          scrollDiff.top = -20;
        }
        h.startScrolling(element, 'y');
      } else if (mousePosition.y > containerGeometry.bottom - 3) {
        if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
          scrollDiff.top = 5;
        } else {
          scrollDiff.top = 20;
        }
        h.startScrolling(element, 'y');
      } else {
        scrollDiff.top = 0;
      }

      if (scrollDiff.top === 0 && scrollDiff.left === 0) {
        stopScrolling();
      } else {
        startScrolling();
      }
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindSelectionHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],18:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
          ((deltaY > 0) && (scrollTop === 0))) {
        return !i.settings.swipePropagation;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
          ((deltaX > 0) && (scrollLeft === 0))) {
        return !i.settings.swipePropagation;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    updateScroll(element, 'top', element.scrollTop - differenceY);
    updateScroll(element, 'left', element.scrollLeft - differenceX);

    updateGeometry(element);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  var inGlobalTouch = false;
  var inLocalTouch = false;

  function globalTouchStart() {
    inGlobalTouch = true;
  }
  function globalTouchEnd() {
    inGlobalTouch = false;
  }

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (shouldHandle(e)) {
      inLocalTouch = true;

      var touch = getTouch(e);

      startOffset.pageX = touch.pageX;
      startOffset.pageY = touch.pageY;

      startTime = (new Date()).getTime();

      if (easingLoop !== null) {
        clearInterval(easingLoop);
      }

      e.stopPropagation();
    }
  }
  function touchMove(e) {
    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = (new Date()).getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPreventDefault(differenceX, differenceY)) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (!inGlobalTouch && inLocalTouch) {
      inLocalTouch = false;

      clearInterval(easingLoop);
      easingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (supportsTouch) {
    i.event.bind(window, 'touchstart', globalTouchStart);
    i.event.bind(window, 'touchend', globalTouchEnd);
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  }

  if (supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(window, 'pointerdown', globalTouchStart);
      i.event.bind(window, 'pointerup', globalTouchEnd);
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(window, 'MSPointerDown', globalTouchStart);
      i.event.bind(window, 'MSPointerUp', globalTouchEnd);
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
}

module.exports = function (element, supportsTouch, supportsIePointer) {
  var i = instances.get(element);
  bindTouchHandler(element, i, supportsTouch, supportsIePointer);
};

},{"../instances":20,"../update-geometry":21,"../update-scroll":22}],19:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('../lib/class')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateGeometry = require('./update-geometry');

// Handlers
var clickRailHandler = require('./handler/click-rail')
  , dragScrollbarHandler = require('./handler/drag-scrollbar')
  , keyboardHandler = require('./handler/keyboard')
  , mouseWheelHandler = require('./handler/mouse-wheel')
  , nativeScrollHandler = require('./handler/native-scroll')
  , selectionHandler = require('./handler/selection')
  , touchHandler = require('./handler/touch');

module.exports = function (element, userSettings) {
  userSettings = typeof userSettings === 'object' ? userSettings : {};

  cls.add(element, 'ps-container');

  // Create a plugin instance.
  var i = instances.add(element);

  i.settings = h.extend(i.settings, userSettings);

  clickRailHandler(element);
  dragScrollbarHandler(element);
  mouseWheelHandler(element);
  nativeScrollHandler(element);

  if (i.settings.useSelectionScroll) {
    selectionHandler(element);
  }

  if (h.env.supportsTouch || h.env.supportsIePointer) {
    touchHandler(element, h.env.supportsTouch, h.env.supportsIePointer);
  }
  if (i.settings.useKeyboard) {
    keyboardHandler(element);
  }

  updateGeometry(element);
};

},{"../lib/class":4,"../lib/helper":8,"./handler/click-rail":12,"./handler/drag-scrollbar":13,"./handler/keyboard":14,"./handler/mouse-wheel":15,"./handler/native-scroll":16,"./handler/selection":17,"./handler/touch":18,"./instances":20,"./update-geometry":21}],20:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , defaultSettings = require('./default-setting')
  , EventManager = require('../lib/event-manager')
  , guid = require('../lib/guid')
  , h = require('../lib/helper');

var instances = {};

function Instance(element) {
  var i = this;

  i.settings = h.clone(defaultSettings);
  i.containerWidth = null;
  i.containerHeight = null;
  i.contentWidth = null;
  i.contentHeight = null;

  i.isRtl = d.css(element, 'direction') === "rtl";
  i.isNegativeScroll = (function () {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  })();
  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  i.event = new EventManager();
  i.ownerDocument = element.ownerDocument || document;

  i.scrollbarXRail = d.appendTo(d.e('div', 'ps-scrollbar-x-rail'), element);
  i.scrollbarX = d.appendTo(d.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
  i.scrollbarXActive = null;
  i.scrollbarXWidth = null;
  i.scrollbarXLeft = null;
  i.scrollbarXBottom = h.toInt(d.css(i.scrollbarXRail, 'bottom'));
  i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
  i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : h.toInt(d.css(i.scrollbarXRail, 'top'));
  i.railBorderXWidth = h.toInt(d.css(i.scrollbarXRail, 'borderLeftWidth')) + h.toInt(d.css(i.scrollbarXRail, 'borderRightWidth'));
  // Set rail to display:block to calculate margins
  d.css(i.scrollbarXRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  d.css(i.scrollbarXRail, 'display', '');
  i.railXWidth = null;
  i.railXRatio = null;

  i.scrollbarYRail = d.appendTo(d.e('div', 'ps-scrollbar-y-rail'), element);
  i.scrollbarY = d.appendTo(d.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
  i.scrollbarYActive = null;
  i.scrollbarYHeight = null;
  i.scrollbarYTop = null;
  i.scrollbarYRight = h.toInt(d.css(i.scrollbarYRail, 'right'));
  i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
  i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : h.toInt(d.css(i.scrollbarYRail, 'left'));
  i.scrollbarYOuterWidth = i.isRtl ? h.outerWidth(i.scrollbarY) : null;
  i.railBorderYWidth = h.toInt(d.css(i.scrollbarYRail, 'borderTopWidth')) + h.toInt(d.css(i.scrollbarYRail, 'borderBottomWidth'));
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));
  d.css(i.scrollbarYRail, 'display', '');
  i.railYHeight = null;
  i.railYRatio = null;
}

function getId(element) {
  if (typeof element.dataset === 'undefined') {
    return element.getAttribute('data-ps-id');
  } else {
    return element.dataset.psId;
  }
}

function setId(element, id) {
  if (typeof element.dataset === 'undefined') {
    element.setAttribute('data-ps-id', id);
  } else {
    element.dataset.psId = id;
  }
}

function removeId(element) {
  if (typeof element.dataset === 'undefined') {
    element.removeAttribute('data-ps-id');
  } else {
    delete element.dataset.psId;
  }
}

exports.add = function (element) {
  var newId = guid();
  setId(element, newId);
  instances[newId] = new Instance(element);
  return instances[newId];
};

exports.remove = function (element) {
  delete instances[getId(element)];
  removeId(element);
};

exports.get = function (element) {
  return instances[getId(element)];
};

},{"../lib/dom":5,"../lib/event-manager":6,"../lib/guid":7,"../lib/helper":8,"./default-setting":10}],21:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('../lib/class')
  , d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateScroll = require('./update-scroll');

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = {width: i.railXWidth};
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + element.scrollTop;
  }
  d.css(i.scrollbarXRail, xRailOffset);

  var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  d.css(i.scrollbarYRail, yRailOffset);

  d.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
  d.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
}

module.exports = function (element) {
  var i = instances.get(element);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  var existingRails;
  if (!element.contains(i.scrollbarXRail)) {
    existingRails = d.queryChildren(element, '.ps-scrollbar-x-rail');
    if (existingRails.length > 0) {
      existingRails.forEach(function (rail) {
        d.remove(rail);
      });
    }
    d.appendTo(i.scrollbarXRail, element);
  }
  if (!element.contains(i.scrollbarYRail)) {
    existingRails = d.queryChildren(element, '.ps-scrollbar-y-rail');
    if (existingRails.length > 0) {
      existingRails.forEach(function (rail) {
        d.remove(rail);
      });
    }
    d.appendTo(i.scrollbarYRail, element);
  }

  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(i, h.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
    i.scrollbarXLeft = h.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
  } else {
    i.scrollbarXActive = false;
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }

  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(i, h.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
    i.scrollbarYTop = h.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
  } else {
    i.scrollbarYActive = false;
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    updateScroll(element, 'top', 0);
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  cls[i.scrollbarXActive ? 'add' : 'remove'](element, 'ps-active-x');
  cls[i.scrollbarYActive ? 'add' : 'remove'](element, 'ps-active-y');
};

},{"../lib/class":4,"../lib/dom":5,"../lib/helper":8,"./instances":20,"./update-scroll":22}],22:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('./instances');

var upEvent = document.createEvent('Event')
  , downEvent = document.createEvent('Event')
  , leftEvent = document.createEvent('Event')
  , rightEvent = document.createEvent('Event')
  , yEvent = document.createEvent('Event')
  , xEvent = document.createEvent('Event')
  , xStartEvent = document.createEvent('Event')
  , xEndEvent = document.createEvent('Event')
  , yStartEvent = document.createEvent('Event')
  , yEndEvent = document.createEvent('Event')
  , lastTop
  , lastLeft;

upEvent.initEvent('ps-scroll-up', true, true);
downEvent.initEvent('ps-scroll-down', true, true);
leftEvent.initEvent('ps-scroll-left', true, true);
rightEvent.initEvent('ps-scroll-right', true, true);
yEvent.initEvent('ps-scroll-y', true, true);
xEvent.initEvent('ps-scroll-x', true, true);
xStartEvent.initEvent('ps-x-reach-start', true, true);
xEndEvent.initEvent('ps-x-reach-end', true, true);
yStartEvent.initEvent('ps-y-reach-start', true, true);
yEndEvent.initEvent('ps-y-reach-end', true, true);

module.exports = function (element, axis, value) {
  if (typeof element === 'undefined') {
    throw 'You must provide an element to the update-scroll function';
  }

  if (typeof axis === 'undefined') {
    throw 'You must provide an axis to the update-scroll function';
  }

  if (typeof value === 'undefined') {
    throw 'You must provide a value to the update-scroll function';
  }

  if (axis === 'top' && value <= 0) {
    element.scrollTop = 0;
    element.dispatchEvent(yStartEvent);
    return; // don't allow negative scroll
  }

  if (axis === 'left' && value <= 0) {
    element.scrollLeft = 0;
    element.dispatchEvent(xStartEvent);
    return; // don't allow negative scroll
  }

  var i = instances.get(element);

  if (axis === 'top' && value > i.contentHeight - i.containerHeight) {
    element.scrollTop = i.contentHeight - i.containerHeight;
    element.dispatchEvent(yEndEvent);
    return; // don't allow scroll past container
  }

  if (axis === 'left' && value > i.contentWidth - i.containerWidth) {
    element.scrollLeft = i.contentWidth - i.containerWidth;
    element.dispatchEvent(xEndEvent);
    return; // don't allow scroll past container
  }

  if (!lastTop) {
    lastTop = element.scrollTop;
  }

  if (!lastLeft) {
    lastLeft = element.scrollLeft;
  }

  if (axis === 'top' && value < lastTop) {
    element.dispatchEvent(upEvent);
  }

  if (axis === 'top' && value > lastTop) {
    element.dispatchEvent(downEvent);
  }

  if (axis === 'left' && value < lastLeft) {
    element.dispatchEvent(leftEvent);
  }

  if (axis === 'left' && value > lastLeft) {
    element.dispatchEvent(rightEvent);
  }

  if (axis === 'top') {
    element.scrollTop = lastTop = value;
    element.dispatchEvent(yEvent);
  }

  if (axis === 'left') {
    element.scrollLeft = lastLeft = value;
    element.dispatchEvent(xEvent);
  }

};

},{"./instances":20}],23:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateGeometry = require('./update-geometry');

module.exports = function (element) {
  var i = instances.get(element);

  if (!i) {
    return;
  }

  // Recalcuate negative scrollLeft adjustment
  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;

  // Recalculate rail margins
  d.css(i.scrollbarXRail, 'display', 'block');
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  d.css(i.scrollbarXRail, 'display', 'none');
  d.css(i.scrollbarYRail, 'display', 'none');

  updateGeometry(element);

  d.css(i.scrollbarXRail, 'display', '');
  d.css(i.scrollbarYRail, 'display', '');
};

},{"../lib/dom":5,"../lib/helper":8,"./instances":20,"./update-geometry":21}],24:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],25:[function(require,module,exports){
var _ = cdb._;
var Model = cdb.core.Model;
var DashboardView = require('./dashboard-view');
var WidgetsCollection = require('./widgets/widgets-collection');
var WidgetModelFactory = require('./widgets/widget-model-factory');
var ListModel = require('./widgets/list/model');
var HistogramModel = require('./widgets/histogram/model');
var CategoryModel = require('./widgets/category/model');
var FormulaModel = require('./widgets/formula/model');
var RangeFilter = require('./windshaft/filters/range');
var CategoryFilter = require('./windshaft/filters/category');
var WindshaftConfig = require('./windshaft/config');
var WindshaftClient = require('./windshaft/client');
var WindshaftDashboard = require('./windshaft/dashboard');
var WindshaftPrivateDashboardConfig = require('./windshaft/private-dashboard-config');
var WindshaftPublicDashboardConfig = require('./windshaft/public-dashboard-config');

module.exports = function(selector, diJSON, visOpts) {
  var widgetModelFactory = new WidgetModelFactory({
    list: function(attrs, opts) {
      return new ListModel(attrs, opts);
    },
    formula: function(attrs, opts) {
      return new FormulaModel(attrs, opts);
    },
    histogram: function(attrs, opts, layerIndex) {
      opts.filter = new RangeFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      return new HistogramModel(attrs, opts);
    },
    'time-series': function(attrs, opts, layerIndex) {
      // change type because time-series because it's really a histogram (for the tiler at least)
      attrs.type = 'histogram';
      opts.filter = new RangeFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      var model = new HistogramModel(attrs, opts);

      // since we changed the type of we need some way to identify that it's intended for a time-series view later
      model.isForTimeSeries = true;

      return model;
    },
    aggregation: function(attrs, opts, layerIndex) {
      opts.filter = new CategoryFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      return new CategoryModel(attrs, opts);
    }
  });

  // TODO keep this collection in sync with layers individual widgets collections
  var widgets = new WidgetsCollection();

  var dashboardInfoModel = new Model({
    title: diJSON.title,
    description: diJSON.description,
    updatedAt: diJSON.updated_at,
    userName: diJSON.user.fullname,
    userAvatarURL: diJSON.user.avatar_url
  });
  var dashboardView = new DashboardView({
    el: document.querySelector(selector),
    widgets: widgets,
    dashboardInfoModel: dashboardInfoModel
  });

  var vis = cdb.createVis(dashboardView.$('#map'), diJSON.vizJSON, visOpts);

  var cartoDBLayerGroup;
  var interactiveLayers = [];
  vis.map.layers.each(function(layer) {
    var layerType = layer.get('type');
    var isLayerGroup = layerType === 'layergroup';

    if (isLayerGroup) {
      cartoDBLayerGroup = layer;
    }

    if (isLayerGroup || layerType === 'namedmap') {
      layer.layers.each(function(subLayer) {
        interactiveLayers.push(subLayer);
      });
    } else {
       if (layerType === 'torque') {
        interactiveLayers.push(layer);
       }
    }
  });

  // TODO: We can probably move this logic somewhere else
  var widgetModels = [];
  for (var id in diJSON.widgets) {
    var d = diJSON.widgets[id];
    var layer = _.find(interactiveLayers, function(l) {
      return d.layerId === l.get('id');
    });
    var layerIndex = interactiveLayers.indexOf(layer);
    if (layer) {
      var attrs = _.extend({
        id: id
      }, d);
      var widgetModel = widgetModelFactory.createModel(layer, layerIndex, attrs);
      widgetModels.push(widgetModel);
    } else {
      // TODO layers in a namedmap doesn't have layerId, need some other way to find the corresponding layer for a given widget
      throw Error('no layer found for defined widget');
    }
  }
  // _.each(interactiveLayers, function(layer, layerIndex) {
  //   var widgetsAttrs = layer.get('widgets') || {};
  //   for (var id in widgetsAttrs) {
  //     var attrs = _.extend({
  //       id: id
  //     }, widgetsAttrs[id]);
  //     var widgetModel = widgetModelFactory.createModel(layer, layerIndex, attrs);
  //     widgetModels.push(widgetModel);
  //   }
  // });

  widgets.reset(widgetModels);

  dashboardView.render();

  // TODO: Perhaps this "endpoint" could be part of the "datasource"?
  var endpoint = WindshaftConfig.MAPS_API_BASE_URL;
  var configGenerator = WindshaftPublicDashboardConfig;
  var datasource = diJSON.datasource;
  // TODO: We can use something else to differentiate types of "datasource"s
  if (datasource.template_name) {
    endpoint = [WindshaftConfig.MAPS_API_BASE_URL, 'named', datasource.template_name].join('/');
    configGenerator = WindshaftPrivateDashboardConfig;
  }

  var windshaftClient = new WindshaftClient({
    endpoint: endpoint,
    urlTemplate: datasource.maps_api_template,
    userName: datasource.user_name,
    statTag: datasource.stat_tag,
    forceCors: datasource.force_cors
  });

  var dashboard = new WindshaftDashboard({
    client: windshaftClient,
    configGenerator: configGenerator,
    statTag: datasource.stat_tag,
    //TODO: assuming here all viz.json has a layergroup and that may not be true
    layerGroup: cartoDBLayerGroup,
    layers: interactiveLayers,
    widgets: widgets,
    map: vis.map
  });

  // TODO: rethink this
  if (widgets.size() > 0) {
    setTimeout(function() {
      vis.mapView.invalidateSize();
    }, 0);
  }

  return dashboardView;
};

},{"./dashboard-view":31,"./widgets/category/model":45,"./widgets/formula/model":65,"./widgets/histogram/model":73,"./widgets/list/model":81,"./widgets/widget-model-factory":101,"./widgets/widgets-collection":107,"./windshaft/client":108,"./windshaft/config":109,"./windshaft/dashboard":111,"./windshaft/filters/category":114,"./windshaft/filters/range":116,"./windshaft/private-dashboard-config":117,"./windshaft/public-dashboard-config":118}],26:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var WidgetViewFactory = require('./widgets/widget-view-factory');
var TimeSeriesContentView = require('./widgets/time-series/content-view');
var TorqueTimeSeriesContentView = require('./widgets/time-series/torque-content-view');

module.exports = View.extend({

  className: 'CDB-Dashboard-belowMap',

  initialize: function(options) {
    this._widgetViewFactory = new WidgetViewFactory([
      {
        match: function(m) {
          // isForTimeSeries is set to true to distinguish from default type 'histogram'
          // This match needs to be done before the default time-series widget's match below to have presedence
          return m.isForTimeSeries && m.layer.get('type') === 'torque';
        },
        createContentView: function(m) {
          return new TorqueTimeSeriesContentView({
            model: m,
            rangeFilter: m.filter,
            torqueLayerModel: m.layer
          });
        },
        customizeWidgetAttrs: function(attrs) {
          attrs.className += ' CDB-Widget--timeSeries';
          return attrs;
        }
      }, {
        match: function(m) {
          // isForTimeSeries is set to true to distinguish from default type 'histogram'
          return m.isForTimeSeries;
        },
        createContentView: function(m) {
          return new TimeSeriesContentView({
            model: m,
            filter: m.filter
          });
        },
        customizeWidgetAttrs: function(attrs) {
          attrs.className += ' CDB-Widget--timeSeries';
          return attrs;
        }
      }
    ]);

    this._widgets = options.widgets;
    this._widgets.bind('add', this._maybeRenderWidgetView, this);
    this._widgets.bind('reset', this.render, this);
    this.add_related_model(this._widgets);
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    this._widgets.each(this._maybeRenderWidgetView, this);
    this.$el.toggle(!_.isEmpty(this._subviews));
    return this;
  },

  _maybeRenderWidgetView: function(widgetModel) {
    var view = this._widgetViewFactory.createWidgetView(widgetModel);
    if (view) {
      this.addView(view);
      this.$el.append(view.render().el);
    }
  }

});

},{"./widgets/time-series/content-view":90,"./widgets/time-series/torque-content-view":93,"./widgets/widget-view-factory":103}],27:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./dashboard-info-view.tpl');
var moment = require('moment');

var DashboardInfoView = View.extend({

  className: 'CDB-Dashboard-info',

  events: {
    'click .js-toggle-view-link': "_toggleView"
  },

  render: function() {
    this.$el.html(
      template({
        title: this.model.get('title'),
        description: this.model.get('description'),
        updatedAt: moment(this.model.get('updatedAt')).fromNow(),
        userName: this.model.get('userName'),
        userAvatarURL: this.model.get('userAvatarURL')
      })
    );

    return this;
  },

  _toggleView: function() {
    this.$el.toggleClass('is-active');
  }
});

module.exports = DashboardInfoView;

},{"./dashboard-info-view.tpl":28,"moment":2}],28:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Dashboard-infoHeader"> <div class="CDB-Dashboard-infoLogo"> <i class="CDB-Icon CDB-Icon-cartofante"></i> </div> <div class="CDB-Dashboard-infoActions"> <button class="CDB-Dashboard-infoActionsLink js-toggle-view-link"></button> </div> <div class="CDB-Dashboard-infoTexts"> <p class="CDB-Dashboard-infoUpdate">UPDATED '+
((__t=( updatedAt ))==null?'':_.escape(__t))+
'</p> <h1 class="CDB-Dashboard-infoTitle">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h1> <h2 class="CDB-Dashboard-infoDescription">'+
((__t=( description ))==null?'':_.escape(__t))+
'</h2> </div> </div> <div class="CDB-Dashboard-infoFooter"> <ul>  <li class="CDB-Dashboard-infoFooterItem"> <div class="CDB-Dashboard-infoMedia CDB-Dashboard-infoAvatar"> <img src="'+
((__t=( userAvatarURL ))==null?'':_.escape(__t))+
'" alt="avatar" class="inline-block"> </div> <p class="CDB-Dashboard-infoFooterTxt">'+
((__t=( userName ))==null?'':_.escape(__t))+
'</p> </li> </ul> </div>';
}
return __p;
};

},{"underscore":24}],29:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var Ps = require('perfect-scrollbar');
var View = cdb.core.View;
var Model = cdb.core.Model;
var CategoryContentView = require('./widgets/category/content_view');
var FormulaContentView = require('./widgets/formula/content_view');
var HistogramContentView = require('./widgets/histogram/content-view');
var ListContentView = require('./widgets/list/content_view');
var WidgetViewFactory = require('./widgets/widget-view-factory');
var template = require('./dashboard-sidebar.tpl');

module.exports = View.extend({

  className: 'CDB-Widget-canvas',

  initialize: function(options) {
    this._widgetViewFactory = new WidgetViewFactory([
      {
        type: 'formula',
        createContentView: function(m) {
          return new FormulaContentView({
            model: m
          });
        }
      }, {
        type: 'list',
        createContentView: function(m) {
          return new ListContentView({
            model: m
          });
        }
      }, {
        match: function(m) {
          return m.get('type') === 'histogram' && m.layer.get('type') !== 'torque';
        },
        createContentView: function(m) {
          return new HistogramContentView({
            dataModel: m,
            viewModel: new Model(),
            filter: m.filter
          });
        }
      }, {
        type: 'aggregation',
        createContentView: function(m) {
          return new CategoryContentView({
            model: m,
            filter: m.filter
          });
        }
      }
    ]);

    this._widgets = options.widgets;

    this._widgets.bind('add', this._maybeRenderWidgetView, this);
    this._widgets.bind('reset', this.render, this);
    this._widgets.bind('change:collapsed', this._onWidgetCollapsed, this);
    this.add_related_model(this._widgets);
  },

  render: function() {
    this._cleanScrollEvent();
    this.clearSubViews();

    this.$el.html(template());
    this._widgets.each(this._maybeRenderWidgetView, this);
    this.$el.toggle(!_.isEmpty(this._subviews));

    this._renderScroll();
    this._renderShadows();
    this._bindScroll();

    return this;
  },

  _$container: function() {
    return $(this._container());
  },

  _container: function() {
    return this.el.querySelector('.js-container');
  },

  _maybeRenderWidgetView: function(widgetModel) {
    var view = this._widgetViewFactory.createWidgetView(widgetModel);
    if (view) {
      this.addView(view);
      this._$container().append(view.render().el);
    }
  },

  _bindScroll: function() {
    this._$container()
      .on('ps-y-reach-start', _.bind(this._onScrollTop, this))
      .on('ps-y-reach-end', _.bind(this._onScrollBottom, this))
      .on('ps-scroll-y', _.bind(this._onScroll, this));
  },

  _renderScroll: function() {
    Ps.initialize(this._container(), {
      wheelSpeed: 2,
      wheelPropagation: true,
      minScrollbarLength: 20
    });
  },

  _onWidgetCollapsed: function() {
    Ps.update(this._container());
  },

  _renderShadows: function() {
    var self = this;
    this.$shadowTop = $('<div>').addClass("CDB-Widget-canvasShadow CDB-Widget-canvasShadow--top");
    this.$shadowBottom = $('<div>').addClass("CDB-Widget-canvasShadow CDB-Widget-canvasShadow--bottom is-visible");
    this.$el.append(this.$shadowTop);
    this.$el.append(this.$shadowBottom);
  },

  _onScrollTop: function() {
    this.$shadowTop.removeClass('is-visible');
  },

  _onScroll: function() {
    var $el = this._$container();
    var currentPos = $el.scrollTop();
    var max = $el.get(0).scrollHeight;
    var height = $el.outerHeight();
    var maxPos = max - height;
    this.$shadowTop.toggleClass('is-visible', currentPos > 0);
    this.$shadowBottom.toggleClass('is-visible', currentPos < maxPos);
  },

  _onScrollBottom: function() {
    this.$shadowBottom.removeClass('is-visible');
  },

  _cleanScrollEvent: function() {
    if (this._$container()) {
      this._$container().off('ps-scroll-y');
    }
  },

  clean: function() {
    this._cleanScrollEvent();
    View.prototype.clean.call(this);
  }

});

},{"./dashboard-sidebar.tpl":30,"./widgets/category/content_view":35,"./widgets/formula/content_view":64,"./widgets/histogram/content-view":69,"./widgets/list/content_view":76,"./widgets/widget-view-factory":103,"perfect-scrollbar":3}],30:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-canvasInner js-container"></div>';
}
return __p;
};

},{"underscore":24}],31:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./dashboard.tpl');
var DashboardBelowMapView = require('./dashboard-below-map-view');
var DashboardInfoView = require('./dashboard-info-view');
var DashboardSidebarView = require('./dashboard-sidebar-view');

/**
 * Dashboard is a wrapper around the map canvas, which contains widget views for the map contdxt
 * Widgets may be rendered in two areas, in the "sidebar" or "below-map".
 */
module.exports = View.extend({

  className: 'CDB-Dashboard-canvas',

  initialize: function(options) {
    this._widgets = options.widgets;
    this._dashboardInfoModel = options.dashboardInfoModel;

    // TODO parent context requires some markup to be present already, but NOT the other views
    this.el.classList.add(this.className);
    this.$el.html(template());
  },

  render: function() {
    this.clearSubViews();

    var view;
    view = new DashboardInfoView({
      model: this._dashboardInfoModel
    });
    this.addView(view);
    this.$el.append(view.render().el);

    view = new DashboardBelowMapView({
      widgets: this._widgets
    });
    this.addView(view);
    this.$('.js-map-wrapper').append(view.render().el);

    view = new DashboardSidebarView({
      widgets: this._widgets
    });
    this.addView(view);
    this.$el.append(view.render().el);

    return this;
  }
});

},{"./dashboard-below-map-view":26,"./dashboard-info-view":27,"./dashboard-sidebar-view":29,"./dashboard.tpl":32}],32:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Dashboard-mapWrapper CDB-Dashboard-mapWrapper--margin js-map-wrapper"> <div class="CDB-Map-canvas"> <div class="CDB-Map" id="map"></div> </div> </div>';
}
return __p;
};

},{"underscore":24}],33:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var d3 = cdb.d3;
var log = cdb.log;
var View = cdb.core.View;

/**
 * Animate between two values
 */
module.exports = View.extend({

  animateFromValues: function(from, to, className, template, opts) {
    var $el = this.$(className);
    var options = opts || {};
    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};
    var debounceWait = options.debounceWait || 500;

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  },

  animateFromCurrentValue: function(value, className, template, opts) {
    var $el = this.$(className);

    var options = opts || {};
    var debounceWait = options.debounceWait || 500;

    var to   = value;
    var from = +this.$(className).text();

    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  },

  animateValue: function(model, what, className, template, opts) {
    var $el = this.$(className);

    var options = opts || {};
    var debounceWait = options.debounceWait || 500;

    var to   = model.get(what);
    var from = model.previous(what) || 0;

    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  }
});

},{}],34:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header js-header"></div> <div class="CDB-Widget-content CDB-Widget-content--noSidesMargin"> <div class="CDB-Widget-listWrapper js-content"></div> </div> <div class="CDB-Widget-footer js-footer"></div>';
}
return __p;
};

},{"underscore":24}],35:[function(require,module,exports){
var _ = cdb._;
var WidgetContent = require('../standard/widget_content_view');
var SearchTitleView = require('./title/search_title_view');
var CategoryOptionsView = require('./options/options_view');
var CategoryItemsView = require('./list/items_view');
var WidgetViewModel = require('../widget_content_model');
var CategoryStatsView = require('./stats/stats_view');
var CategoryPaginatorView = require('./paginator/paginator_view');
var SearchCategoryItemsView = require('./list/search_items_view');
var SearchCategoryPaginatorView = require('./paginator/search_paginator_view');
var template = require('./content_template.tpl');

/**
 * Content view for category widget
 *
 */

module.exports = WidgetContent.extend({

  _ITEMS_PER_PAGE: 6,

  initialize: function(opts) {
    this.viewModel = new WidgetViewModel();
    WidgetContent.prototype.initialize.call(this, arguments);
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(template());
    this._initViews();
    return this;
  },

  _initBinds: function() {
    this.model.bind('change:collapsed', function(mdl, isCollapsed) {
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
    }, this);
  },

  _initViews: function() {
    var searchTitle = new SearchTitleView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-header').append(searchTitle.render().el);
    this.addView(searchTitle);

    var stats = new CategoryStatsView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-header').append(stats.render().el);
    this.addView(stats);

    var options = new CategoryOptionsView({
      dataModel: this.model,
      viewModel: this.viewModel
    });
    this.$('.js-content').html(options.render().el);
    this.addView(options);

    var dataList = new CategoryItemsView({
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE
    });
    this.$('.js-content').append(dataList.render().el);
    this.addView(dataList);

    var pagination = new CategoryPaginatorView({
      $target: dataList.$el,
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE
    });
    this.$('.js-footer').append(pagination.render().el);
    this.addView(pagination);

    var searchList = new SearchCategoryItemsView({
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE,
      paginator: true
    });
    this.$('.js-content').append(searchList.render().el);
    this.addView(searchList);

    var searchPagination = new SearchCategoryPaginatorView({
      $target: searchList.$el,
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE,
      paginator: true
    });
    this.$('.js-footer').append(searchPagination.render().el);
    this.addView(searchPagination);
  }

});

},{"../standard/widget_content_view":85,"../widget_content_model":105,"./content_template.tpl":34,"./list/items_view":42,"./list/search_items_view":44,"./options/options_view":53,"./paginator/paginator_view":55,"./paginator/search_paginator_view":57,"./stats/stats_view":60,"./title/search_title_view":62}],36:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button type="button" class="CDB-Widget-listItemInner CDB-Widget-listButton js-button '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( formattedValue ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState '+
((__t=( isAggregated ? 'CDB-Widget-progressState--pattern' : '' ))==null?'':_.escape(__t))+
'" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%; background-color: '+
((__t=( customColor ? color : '' ))==null?'':_.escape(__t))+
'"></div> </div> </button>';
}
return __p;
};

},{"underscore":24}],37:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-listItemInner '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( formattedValue ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState CDB-Widget-progressState--pattern '+
((__t=( isAggregated ? 'CDB-Widget-progressState--inactive' : '' ))==null?'':_.escape(__t))+
'" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%; background-color: '+
((__t=( customColor ? color : '' ))==null?'':_.escape(__t))+
'"></div> </div> </div>';
}
return __p;
};

},{"underscore":24}],38:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var formatter = cdb.core.format;
var clickableTemplate = require('./item_clickable_template.tpl');
var unclickableTemplate = require('./item_unclickable_template.tpl');

/**
 * Category list item view
 */
module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function(options) {
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    var value = this.model.get('value');
    var template = this.model.get('agg') ||this.dataModel.isLocked() ?
      unclickableTemplate : clickableTemplate;

    this.$el.html(
      template({
        customColor: this.dataModel.isColorApplied(),
        isAggregated: this.model.get('agg'),
        name: this.model.get('name'),
        value: value,
        formattedValue: formatter.formatNumber(value),
        percentage: ((value / this.dataModel.get('max')) * 100),
        color: this.model.get('color'),
        isDisabled: !this.model.get('selected') ? 'is-disabled' : '',
        prefix: this.dataModel.get('prefix'),
        suffix: this.dataModel.get('suffix')
      })
    );

    return this;
  },

  _initBinds: function() {
    this.model.bind('change', this.render, this);
    this.dataModel.bind('change:search change:categoryColors', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _onItemClick: function() {
    this.trigger('itemClicked', this.model, this);
  }

});

},{"./item_clickable_template.tpl":36,"./item_unclickable_template.tpl":37}],39:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button type="button" class="CDB-Widget-listItemInner CDB-Widget-listItemInner--fullSpace CDB-Widget-listButton js-button '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Widget-checkbox '+
((__t=( isDisabled ? '' : 'is-checked' ))==null?'':_.escape(__t))+
'"></span> <div class="u-lSpace--xl"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%"></div> </div> </div> </button>';
}
return __p;
};

},{"underscore":24}],40:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var formatter = cdb.core.format;
var template = require('./search_item_clickable_template.tpl');

/**
 * Category search list view
 */
module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function(options) {
    // This data model comes from the original data in order to get
    // the max value and set properly the progress bar and add the
    // necessary suffix and prefix for the item.
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    var value = this.model.get('value');

    this.$el.html(
      template({
        name: this.model.get('name'),
        value: value,
        formattedValue: formatter.formatNumber(value),
        percentage: ((value / this.dataModel.get('max')) * 100),
        isDisabled: !this.model.get('selected'),
        prefix: this.dataModel.get('prefix'),
        suffix: this.dataModel.get('suffix')
      })
    );

    return this;
  },

  _initBinds: function() {
    this.model.bind('change:selected', this.render, this);
  },

  _onItemClick: function() {
    this.model.set('selected', !this.model.get('selected'));
  }

});

},{"./search_item_clickable_template.tpl":39}],41:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li>';
}
return __p;
};

},{"underscore":24}],42:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var CategoryItemView = require('./item/item_view');
var placeholder = require('./items_placeholder_template.tpl');

/**
 * Category list view
 */
module.exports = View.extend({

  options: {
    paginator: false,
    itemsPerPage: 6
  },

  className: 'CDB-Widget-list CDB-Widget-list--wrapped js-list',
  tagName: 'ul',

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var data = this.dataModel.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;

    if (isDataEmpty) {
      this._renderPlaceholder();
    } else {
      this._renderList();
    }
    return this;
  },

  _initBinds: function() {
    this.viewModel.bind('change:search', this.toggle, this);
    this.dataModel.bind('change:data change:searchData', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _renderPlaceholder: function() {
    // Change view classes
    this.$el
      .addClass('CDB-Widget-list--withBorders')
      .removeClass('CDB-Widget-list--wrapped');
    this.$el.append(placeholder());
  },

  _renderList: function() {
    // Change view classes
    this.$el.removeClass('CDB-Widget-list--withBorders');
    this.$el[ this.options.paginator ? 'addClass' : 'removeClass']('CDB-Widget-list--wrapped');

    var groupItem;
    var data = this.dataModel.getData();

    data.each(function(mdl, i) {
      if (i % this.options.itemsPerPage === 0) {
        groupItem = $('<div>').addClass('CDB-Widget-listGroup');
        this.$el.append(groupItem);
      }
      this._addItem(mdl, groupItem);
    }, this);
  },

  _addItem: function(mdl, $parent) {
    var v = new CategoryItemView({
      model: mdl,
      dataModel: this.dataModel
    });
    v.bind('itemClicked', this._setFilters, this);
    this.addView(v);
    $parent.append(v.render().el);
  },

  _setFilters: function(mdl) {
    var isSelected = mdl.get('selected');

    if (isSelected) {
      if (!this.dataModel.getRejectedCount() && !this.dataModel.getAcceptedCount() && this.dataModel.getCount() > 1) {
        var data = this.dataModel.getData();
        var rejects = [];
        // Make elements "unselected"
        data.map(function(m) {
          var name = m.get('name');
          if (name !== mdl.get('name')) {
            m.set('selected', false);
          }
        });
        this.dataModel.acceptFilters(mdl.get('name'));
      } else {
        mdl.set('selected', false);
        this.dataModel.rejectFilters(mdl.get('name'));
      }
    } else {
      mdl.set('selected', true);
      this.dataModel.acceptFilters(mdl.get('name'));
    }
  },

  toggle: function() {
    this[ !this.viewModel.isSearchEnabled() ? 'show' : 'hide']();
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  }

});

},{"./item/item_view":38,"./items_placeholder_template.tpl":41}],43:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="CDB-Widget-listItem"> <h4 class="CDB-Widget-textBig CDB-Widget-textBig--bold">No results</h4> <p class="CDB-Widget-textSmall u-tSpace-xl">Your search "'+
((__t=( q ))==null?'':_.escape(__t))+
'" didn\'t match<br>with any value.</p> <p class="CDB-Widget-textSmall u-tSpace-xl">Try searching again.</p> </li>';
}
return __p;
};

},{"underscore":24}],44:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var CategoryItemsView = require('./items_view');
var WidgetSearchCategoryItemView = require('./item/search_item_view');
var placeholder = require('./search_items_no_results_template.tpl');

/**
 * Category list view
 */
module.exports = CategoryItemsView.extend({

  className: 'CDB-Widget-list is-hidden CDB-Widget-list--wrapped js-list',

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var data = this.dataModel.getSearchResult();
    var isDataEmpty = data.isEmpty() || data.size() === 0;

    if (isDataEmpty) {
      this._renderPlaceholder();
    } else {
      this._renderList();
    }
    return this;
  },

  _renderList: function() {
    this.$el.removeClass('CDB-Widget-list--withBorders CDB-Widget-list--noresults');
    this.$el.addClass('CDB-Widget-list--wrapped');

    var groupItem;
    var data = this.dataModel.getSearchResult();

    data.each(function(mdl, i) {
      if (i % this.options.itemsPerPage === 0) {
        groupItem = $('<div>').addClass('CDB-Widget-listGroup');
        this.$el.append(groupItem);
      }
      this._addItem(mdl, groupItem);
    }, this);
  },

  _renderPlaceholder: function() {
    // Change view classes
    this.$el
      .addClass('CDB-Widget-list--noresults')
      .removeClass('CDB-Widget-list--wrapped');

    this.$el.html(
      placeholder({
        q: this.dataModel.getSearchQuery()
      })
    );
  },

  _addItem: function(mdl, $parent) {
    var v = new WidgetSearchCategoryItemView({
      model: mdl,
      dataModel: this.dataModel
    });
    this.addView(v);
    $parent.append(v.render().el);
  },

  toggle: function() {
    this[ this.viewModel.isSearchEnabled() ? 'show' : 'hide']();
  }

});

},{"./item/search_item_view":40,"./items_view":42,"./search_items_no_results_template.tpl":43}],45:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;
var d3 = cdb.d3;
var CategoryColors = require('./models/category_colors');
var WidgetModel = require('../widget_model');
var WidgetSearchModel = require('./models/search_model');
var CategoryModelRange = require('./models/category_model_range');
var CategoriesCollection = require('./models/categories_collection');
var LockedCatsCollection = require('./models/locked_categories_collection');

/**
 *  Category widget model
 *
 *  - It has several internal models/collections
 *
 *   search model: it manages category search results.
 *   locked collection: it stores locked items.
 *   filter model: it knows which items are accepted or rejected.
 *
 */

module.exports = WidgetModel.extend({

  url: function() {
    return this.get('url') + '?bbox=' + this.get('boundingBox') + '&own_filter=' + (this.get('locked') ? 1 : 0);
  },

  initialize: function(attrs, opts) {
    this._data = new CategoriesCollection();

    WidgetModel.prototype.initialize.call(this, attrs, opts);

    // Locked categories collection
    this.locked = new LockedCatsCollection();

    // Internal model for calculating total amount of values in the category
    this.rangeModel = new CategoryModelRange();

    // Colors class
    this.colors = new CategoryColors();

    // Search model
    this.search = new WidgetSearchModel({}, {
      locked: this.locked
    });
  },

  // Set any needed parameter when they have changed in this model
  _setInternalModels: function() {
    var url = this.get('url');

    this.search.set({
      url: url,
      boundingBox: this.get('boundingBox')
    });

    this.rangeModel.setUrl(url);
  },

  _onChangeBinds: function() {
    this._setInternalModels();

    this.rangeModel.bind('change:totalCount', function(mdl, value) {
      this.set('totalCount', value);
    }, this);

    this.bind('change:url', function(){
      if (this.get('sync') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:boundingBox', function() {
      // If a search is applied and bounding bounds has changed,
      // don't fetch new raw data
      if (this.get('bbox') && !this.isSearchApplied() && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:url change:boundingBox', function() {
      this.search.set({
        url: this.get('url'),
        boundingBox: this.get('boundingBox')
      });
    }, this);

    this.bind('change:collapsed', function(mdl, isCollapsed) {
      if (!isCollapsed) {
        if (mdl.changedAttributes(this._previousAttrs)) {
          this._fetch();
        }
      } else {
        this._previousAttrs = {
          url: this.get('url'),
          boundingBox: this.get('boundingBox')
        };
      }
    }, this);

    this.locked.bind('change add remove', function() {
      this.trigger('change:lockCollection', this.locked, this);
    }, this);

    this.search.bind('loading', function() {
      this.trigger("loading", this);
    }, this);
    this.search.bind('sync', function() {
      this.trigger("sync", this);
    }, this);
    this.search.bind('error', function(e) {
      if (!e || (e && e.statusText !== "abort")) {
        this.trigger("error", this);
      }
    }, this);
    this.search.bind('change:data', function() {
      this.trigger('change:searchData', this.search, this);
    }, this);
  },

  /*
   *  Helper methods for internal models/collections
   *
   */

  applyCategoryColors: function() {
    this.set('categoryColors', true);
    var colorsData = this._data.map(function(m){
      return [ m.get('name'), m.get('color') ];
    });
    this.trigger('applyCategoryColors', colorsData, this);
  },

  cancelCategoryColors: function() {
    this.set('categoryColors', false);
    this.trigger('cancelCategoryColors', this);
  },

  isColorApplied: function() {
    return this.get('categoryColors');
  },

  // Locked collection helper methods //

  getLockedSize: function() {
    return this.locked.size();
  },

  isLocked: function() {
    return this.get('locked');
  },

  canBeLocked: function() {
    return this.isLocked() ||
      this.getAcceptedCount() > 0;
  },

  canApplyLocked: function() {
    var acceptedCollection = this.filter.getAccepted();
    if (this.filter.getAccepted().size() !== this.locked.size()) {
      return true;
    }

    return acceptedCollection.find(function(m) {
      return !this.locked.isItemLocked(m.get('name'));
    }, this);
  },

  applyLocked: function() {
    var currentLocked = this.locked.getItemsName();
    if (!currentLocked.length) {
      this.unlockCategories();
      return false;
    }
    this.set('locked', true);
    this.filter.cleanFilter(false);
    this.filter.accept(currentLocked);
    this.filter.applyFilter();
    this.cleanSearch();
  },

  lockCategories: function() {
    this.set('locked', true);
    this._fetch();
  },

  unlockCategories: function() {
    this.set('locked', false);
    this.acceptAll();
  },

  // Search model helper methods //

  getSearchQuery: function() {
    return this.search.getSearchQuery();
  },

  setSearchQuery: function(q) {
    this.search.set('q', q);
  },

  isSearchValid: function() {
    return this.search.isValid();
  },

  getSearchResult: function() {
    return this.search.getData();
  },

  getSearchCount: function() {
    return this.search.getCount();
  },

  applySearch: function() {
    this.search.fetch();
  },

  isSearchApplied: function() {
    return this.search.isSearchApplied();
  },

  cleanSearch: function() {
    this.locked.resetItems([]);
    this.search.resetData();
  },

  setupSearch: function() {
    if (!this.isSearchApplied()) {
      var acceptedCats = this.filter.getAccepted().toJSON();
      this.locked.addItems(acceptedCats);
      this.search.setData(
        this._data.toJSON()
      );
    }
  },

  // Filter model helper methods //

  getRejectedCount: function() {
    return this.filter.rejectedCategories.size();
  },

  getAcceptedCount: function() {
    return this.filter.acceptedCategories.size();
  },

  acceptFilters: function(values) {
    this.filter.accept(values);
  },

  rejectFilters: function(values) {
    this.filter.reject(values);
  },

  rejectAll: function() {
    this.filter.rejectAll();
  },

  acceptAll: function() {
    this.filter.acceptAll();
  },

  isAllFiltersRejected: function() {
    return this.filter.get('rejectAll');
  },

  // Proper model helper methods //

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  getCount: function() {
    return this.get('categoriesCount');
  },

  refresh: function() {
    if (this.isSearchApplied()) {
      this.search.fetch();
    } else {
      this._fetch();
    }
  },

  // Data parser methods //

  _parseData: function(categories) {
    var newData = [];
    var _tmpArray = {};
    var acceptedCats = this.filter.getAccepted();

    // Update colors by data categories
    this.colors.updateData(
      _.uniq(
        _.union(
          _.pluck(categories, 'category'),
          _.pluck(acceptedCats, 'name')
        )
      )
    );

    _.each(categories, function(datum, i) {
      var category = datum.category;
      var isRejected = this.filter.isRejected(category);
      _tmpArray[category] = true;

      newData.push({
        selected: !isRejected,
        name: category,
        agg: datum.agg,
        value: datum.value,
        color: this.colors.getColorByCategory(category)
      });
    }, this);

    if (this.isLocked()) {
      // Add accepted items that are not present in the categories data
      acceptedCats.each(function(mdl, i) {
        var category = mdl.get('name').toString();
        if (!_tmpArray[category]) {
          newData.push({
            selected: true,
            color: this.colors.getColorByCategory(category),
            name: category,
            agg: false,
            value: 0
          });
        }
      }, this);
    }

    return {
      data: newData
    }
  },

  setCategories: function(d) {
    var attrs = this._parseData(d);
    this._data.reset(attrs.data);
    this.set(attrs);
    if (this.isColorApplied()) {
      this.applyCategoryColors();
    }
  },

  parse: function(d) {
    var categories = d.categories;
    var attrs = this._parseData(categories);

    _.extend(attrs, {
        nulls: d.nulls,
        min: d.min,
        max: d.max,
        count: d.count,
        categoriesCount: d.categoriesCount
      }
    );
    this._data.reset(attrs.data);
    if (this.isColorApplied()) {
      this.applyCategoryColors();
    }
    return attrs;
  },

  // Backbone toJson function override

  toJSON: function() {
    return {
      type: "aggregation",
      options: {
        column: this.get('column'),
        aggregation: this.get('aggregation'),
        aggregationColumn: this.get('aggregationColumn')
      }
    };
  }

});

},{"../widget_model":106,"./models/categories_collection":46,"./models/category_colors":47,"./models/category_model_range":49,"./models/locked_categories_collection":50,"./models/search_model":51}],46:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var CategoryItemModel = require('./category_item_model');

/**
 *  Data categories collection
 *
 *  - It basically sorts by (value, selected and "Other").
 */

module.exports = Backbone.Collection.extend({

  model: CategoryItemModel,

  comparator: function(a,b) {
    if (a.get('name') === 'Other') {
      return 1;
    } else if (b.get('name') === 'Other') {
      return -1;
    } else if (a.get('value') === b.get('value')) {
      return (a.get('selected') < b.get('selected')) ? 1 : -1;
    } else {
      return (a.get('value') < b.get('value')) ? 1 : -1;
    }
  }

});

},{"./category_item_model":48}],47:[function(require,module,exports){
var _ = cdb._;
// var colorbrewer = require('colorbrewer');
// var categoryColors = _.initial(colorbrewer.Accent[8]); // Color brewer colors
var categoryColors = ['#2CA095','#E5811B','#4A4DBA','#AD2BAD','#559030','#E1C221']; // Demo colors
var defaultColor = '#CCC';

/**
 *  Class to set categories to each color
 *  - Right now, there is a relation 1 color to 1 category.
 *  - If that category is not available in the new data, that
 *    color will be freed.
 *
 */

function CategoryColors() {
  this.colors = {};
  _.each(categoryColors, function(c) {
    this.colors[c] = null;
  }, this);
}

CategoryColors.prototype.updateData = function(d) {
  // Remove categories from colors where they are not present anymore
  _.each(this.colors, function(value, key) {
    if (!_.contains(d, value)) {
      this.colors[key] = null;
    } else {
      d = _.without(d, value);
    }
  }, this);

  // Set colors by new categories
  _.each(d, function(category) {
    var nextFreeColor = this.getNextAvailableColor();
    if (nextFreeColor) {
      this.colors[nextFreeColor] = category;
    }
  }, this);
};

CategoryColors.prototype.getNextAvailableColor = function() {
  for (var i in this.colors) {
    if (this.colors[i] === null) {
      return i;
    }
  }
  return null;
};

CategoryColors.prototype.getColorByCategory = function (category) {
  for (var i in this.colors) {
    if (this.colors[i] === category) {
      return i;
    }
  }
  return defaultColor;
};

CategoryColors.prototype.getCategoryByColor = function (color) {
  return this.colors[color];
};

module.exports = CategoryColors;

},{}],48:[function(require,module,exports){

var Model = cdb.core.Model;

/**
 *
 */

module.exports = Model.extend({

  defaults: {
    name: '',
    agg: false,
    value: 0
  }

});

},{}],49:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;

/**
 *  This model is used for getting the total amount of values
 *  from the category.
 *
 */

module.exports = Model.extend({

  defaults: {
    url: '',
    totalCount: 0
  },

  url: function() {
    return this.get('url');
  },

  initialize: function() {
    this.bind('change:url', function() {
      this.fetch();
    }, this);
  },

  setUrl: function(url) {
    this.set('url', url);
  },

  parse: function(d) {
    // Calculating the total amount of all categories with the sum of all
    // values from this model included the aggregated (Other)

    return {
      totalCount: _.reduce(
        _.pluck(d.categories, 'value'),
        function(memo, value) {
          return memo + value;
        },
        0
      )
    };
  }
});

},{}],50:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var CategoryItemModel = require('./category_item_model');

/**
 *  Locked categories collection
 *
 */

module.exports = Backbone.Collection.extend({

  model: CategoryItemModel,

  addItem: function(mdl) {
    if (!this.isItemLocked(mdl.get('name'))) {
      this.add(mdl);
    }
  },

  addItems: function(mdls) {
    _.each(mdls, function(m) {
      if (!this.isItemLocked(m.name)) {
        this.add(m);
      }
    }, this);
  },

  resetItems: function(mdls) {
    this.reset(mdls);
  },

  removeItem: function(mdl) {
    var lockedItem = this.isItemLocked(mdl.get('name'));
    if (lockedItem) {
      this.remove(lockedItem);
    }
  },

  removeItems: function() {
    this.reset([]);
  },

  isItemLocked: function(name) {
    return this.find(function(d) {
      return d.get('name') === name;
    });
  },

  getItemsName: function() {
    return this.pluck('name');
  }

});

},{"./category_item_model":48}],51:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;
var CategoriesCollection = require('./categories_collection');

/**
 * Category search model
 */
module.exports = Model.extend({

  defaults: {
    q: '',
    data: [],
    url: ''
  },

  url: function() {
    return this.get('url') + '/search?q=' + encodeURIComponent(this.get('q'));
  },

  initialize: function(attrs, opts) {
    // Locked collection will have the status
    // of the selected/locked items
    this.locked = opts.locked;
    this._data = new CategoriesCollection();
    this._initBinds();
  },

  _initBinds: function() {
    this._data.bind('change:selected', this._onChangeSelected, this);
    this.bind('change:boundingBox', function() {
      if (this.isSearchApplied()) {
        this.fetch();
      }
    }, this);
  },

  setData: function(data) {
    var categories = this._parseData(data);
    this._data.reset(categories);
    this.set('data', categories);
  },

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  getCount: function() {
    return this.getSize();
  },

  isValid: function() {
    var str = this.get('q');
    return !!(str||'');
  },

  isLocked: function() {},

  resetData: function() {
    this.setData([]);
    this.set('q', '');
  },

  getSearchQuery: function() {
    return this.get('q');
  },

  isSearchApplied: function() {
    return this.isValid() && this.getSize() > 0;
  },

  _onChangeSelected: function(mdl, isSelected) {
    this.locked[ isSelected ? 'addItem' : 'removeItem' ](mdl);
  },

  _parseData: function(categories) {
    var newData = [];
    _.each(categories, function(d) {
      if (!d.agg) {
        var category = (d.category || d.name).toString();
        var isLocked = this.locked.isItemLocked(category);
        newData.push({
          selected: isLocked,
          name: category,
          agg: d.agg,
          value: d.value
        });
      }
    }, this);

    return newData;
  },

  parse: function(r) {
    var categories = this._parseData(r.categories);
    this._data.reset(categories);
    return {
      data: categories
    };
  },

  fetch: function(opts) {
    this.trigger("loading", this);
    return Model.prototype.fetch.call(this, opts);
  },

  sync: function() {
    var self = arguments[1];
    if (this._xhr) {
      this._xhr.abort();
    }
    this._xhr = Model.prototype.sync.apply(this, arguments);
    this._xhr.always(function() {
      self._xhr = null;
    });
    return this._xhr;
  }

});

},{"./categories_collection":46}],52:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) { 
__p+=' <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark CDB-Widget-textSmaller--upper">'+
((__t=( totalLocked ))==null?'':_.escape(__t))+
' selected</p> ';
 } else { 
__p+=' <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark CDB-Widget-textSmaller--upper"> ';
 if (isLocked) { 
__p+=' '+
((__t=( totalCats ))==null?'':_.escape(__t))+
' blocked <button class="CDB-Widget-link u-lSpace js-unlock">unlock</button> ';
 } else { 
__p+=' '+
((__t=( rejectedCats === 0 && acceptedCats === 0 || acceptedCats >= totalCats ? "All selected" : acceptedCats + " selected" ))==null?'':_.escape(__t))+
' ';
 if (canBeLocked) { 
__p+=' <button class="CDB-Widget-link u-lSpace js-lock">lock</button> ';
 }
__p+=' ';
 }
__p+=' </p> ';
 if (!isLocked) { 
__p+=' <div class="CDB-Widget-filterButtons"> ';
 if (rejectedCats > 0 ||acceptedCats > 0 ||isAllRejected) { 
__p+=' <button class="CDB-Widget-link CDB-Widget-filterButton js-all">all</button> ';
 } 
__p+=' ';
 if (totalCats > rejectedCats && !isAllRejected) { 
__p+=' <button class="CDB-Widget-link CDB-Widget-filterButton js-none">none</button> ';
 } 
__p+=' </div> ';
 } 
__p+=' ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],53:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var template = require('./options_template.tpl');

/**
 * Category filter view
 *
 */
module.exports = View.extend({

  className: 'CDB-Widget-filter CDB-Widget-contentSpaced CDB-Widget-contentSpaced--sideMargins',

  events: {
    'click .js-all': '_onSelectAll',
    'click .js-none': '_onUnselectAll',
    'click .js-lock': '_lockCategories',
    'click .js-unlock': '_unlockCategories'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this.viewModel = this.options.viewModel;
    this._initBinds();
  },

  render: function() {
    var totalCats = this.dataModel.getData().size();
    var rejectedCats = this.dataModel.getRejectedCount();
    var acceptedCats = this.dataModel.getAcceptedCount();

    this.$el.html(
      template({
        isLocked: this.dataModel.isLocked(),
        canBeLocked: this.dataModel.canBeLocked(),
        totalLocked: this.dataModel.getLockedSize(),
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        isSearchApplied: this.dataModel.isSearchApplied(),
        isAllRejected: this.dataModel.isAllFiltersRejected(),
        totalCats: totalCats,
        rejectedCats: rejectedCats,
        acceptedCats: acceptedCats
      })
    );
    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:data change:filter change:locked change:lockCollection', this.render, this);
    this.viewModel.bind('change:search', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _lockCategories: function() {
    this.dataModel.lockCategories();
  },

  _unlockCategories: function() {
    this.dataModel.unlockCategories();
  },

  _onUnselectAll: function() {
    this.dataModel.rejectAll();
  },

  _onSelectAll: function() {
    this.dataModel.acceptAll();
  }

});

},{"./options_template.tpl":52}],54:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-contentFlex"> <button class="u-rSpace--m CDB-Widget-buttonIcon CDB-Widget-textSmaller CDB-Widget-textSmaller--upper js-searchToggle"> <i class="CDB-Icon CDB-Icon--center CDB-Icon-lens u-rSpace"></i> <span class="u-iBlock"> search </span> </button> </div> ';
 if (showPaginator) { 
__p+=' <div class="CDB-Widget-navDots js-dots"> ';
 for (var i = 0, l = pages; i < l; i++) { 
__p+='<button class="CDB-Shape-dot CDB-Widget-dot--navigation js-page ';
 if (currentPage === i) { 
__p+='is-selected';
 } 
__p+='" data-page="'+
((__t=( i ))==null?'':_.escape(__t))+
'"></button>';
 } 
__p+=' </div> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],55:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var Model = cdb.core.Model;
var defaultTemplate = require('./paginator_template.tpl');

module.exports = View.extend({

  options: {
    itemsPerPage: 6,
    template: defaultTemplate,
    paginator: false
  },

  className: 'CDB-Widget-nav CDB-Widget-contentSpaced',

  events: {
    'click .js-searchToggle': '_onSearchClicked',
    'click .js-page': '_onDotClick'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this.viewModel = this.options.viewModel;
    this._$target = this.options.$target;
    this.model = new Model({
      page: 0
    });
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var pages = Math.ceil(this.dataModel.getSize() / this.options.itemsPerPage);
    var template = this.options.template;
    this.$el.html(
      template({
        showPaginator: this.options.paginator,
        currentPage: this.model.get('page'),
        pages: pages
      })
    );
    this._scrollToPage();

    return this;
  },

  _initBinds: function() {
    $(window).bind('resize.' + this.cid, _.bind(this._scrollToPage, this));
    this.model.bind('change:page', this.render, this);
    this.dataModel.bind('change:data change:searchData', function() {
      this._setPage();
      this.render();
    }, this);
    this.viewModel.bind('change:search', this.toggle, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  // If current page doesn't exist due to a data change, we should reset it
  _setPage: function() {
    var count = this.dataModel.getSize();
    var pages = Math.ceil(count / this._ITEMS_PER_PAGE);
    if (this.model.get('page') > (pages - 1)) {
      this.model.set({ page: 0 }, { silent :true });
    }
  },

  _onSearchClicked: function() {
    this.dataModel.setupSearch();
    this.viewModel.toggleSearch();
  },

  _scrollToPage: function() {
    var page = this.model.get('page');
    var pageWidth = this._$target.find('.CDB-Widget-listGroup:eq(0)').outerWidth();
    this._$target.css('margin-left', - (page * pageWidth));
  },

  _onDotClick: function(ev) {
    var page = $(ev.target).data('page');
    this.model.set('page', page);
  },

  toggle: function() {
    this[ this.viewModel.isSearchEnabled() ? 'hide' : 'show' ]();
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  clean: function() {
    $(window).unbind('resize.' + this.cid);
    View.prototype.clean.call(this);
  }

});

},{"./paginator_template.tpl":54}],56:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-contentFlex"> <button class="u-rSpace--m CDB-Widget-link js-searchToggle">cancel</button> </div> ';
 if (showPaginator) { 
__p+=' <div class="CDB-Widget-navDots js-dots"> ';
 for (var i = 0, l = pages; i < l; i++) { 
__p+='<button class="CDB-Shape-dot CDB-Widget-dot--navigation js-page ';
 if (currentPage === i) { 
__p+='is-selected';
 } 
__p+='" data-page="'+
((__t=( i ))==null?'':_.escape(__t))+
'"></button>';
 } 
__p+=' </div> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],57:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var Model = cdb.core.Model;
var PaginatorView = require('./paginator_view');
var searchTemplate = require('./search_paginator_template.tpl');

module.exports = PaginatorView.extend({

  className: 'CDB-Widget-nav is-hidden CDB-Widget-contentSpaced',

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var pages = Math.ceil(this.dataModel.getSearchCount() / this.options.itemsPerPage);
    this.$el.html(
      searchTemplate({
        showPaginator: true,
        currentPage: this.model.get('page'),
        pages: pages
      })
    );
    this._scrollToPage();

    return this;
  },

  _setPage: function() {
    var count = this.dataModel.getSearchCount();
    var pages = Math.ceil(count / this._ITEMS_PER_PAGE);
    if (this.model.get('page') > (pages - 1)) {
      this.model.set({ page: 0 }, { silent :true });
    }
  },

  toggle: function() {
    this[ !this.viewModel.isSearchEnabled() ? 'hide' : 'show' ]();
  },

  _onSearchClicked: function() {
    this.dataModel.cleanSearch();
    this.viewModel.toggleSearch();
  }

});

},{"./paginator_view":55,"./search_paginator_template.tpl":56}],58:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( value ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],59:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) { 
__p+=' <dt class="CDB-Widget-infoItem"> ';
 if (isSearchApplied) { 
__p+=' '+
((__t=( resultsCount ))==null?'':_.escape(__t))+
' found ';
 } else { 
__p+=' &nbsp; ';
 } 
__p+=' </dt> ';
 } else { 
__p+=' <dt class="CDB-Widget-infoItem">'+
((__t=( nullsPer ))==null?'':_.escape(__t))+
'% null rows</dt> <dt class="CDB-Widget-infoItem"><span class="js-cats">'+
((__t=( catsPer ))==null?'':_.escape(__t))+
'</span>% in '+
((__t=( totalCats ))==null?'':_.escape(__t))+
' categor'+
((__t=( totalCats !== 1 ? 'ies' : 'y' ))==null?'':_.escape(__t))+
'</dt> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],60:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var d3 = cdb.d3;
var formatter = cdb.core.format;
var template = require('./stats_template.tpl');
var animationTemplate = require('./cats_template.tpl');
var AnimateValues = require('../../animate_values');

/**
 * Category stats info view
 *
 */

module.exports = View.extend({

  className: 'CDB-Widget-info CDB-Widget-textSmaller CDB-Widget-textSmaller--upper',
  tagName: 'dl',

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.$el.html(
      template({
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        isSearchApplied: this.dataModel.isSearchApplied(),
        resultsCount: this.dataModel.getSearchCount(),
        totalCats: this._getCategoriesSize(),
        nullsPer: this._getNullPercentage(),
        catsPer: this._getCurrentCategoriesPercentage()
      })
    );

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateFromValues(this._getPreviousCategoriesPercentage(), this._getCurrentCategoriesPercentage(), '.js-cats',
      animationTemplate, { defaultValue: '-', animationSpeed: 700, formatter: formatter.formatValue }
    );

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:data change:locked change:search change:totalCount', this.render, this);
    this.viewModel.bind('change:search', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _getNullPercentage: function() {
    var nulls = this.dataModel.get('nulls');
    var total = this.dataModel.get('totalCount') || 0;
    return !nulls ? 0 : ((nulls/total) * 100).toFixed(2);
  },

  _getPreviousCategoriesPercentage: function() {
    var total = this.dataModel.previous('totalCount') || 0;
    var data = this.dataModel.getPreviousData();
    return this._getCategoriesPercentage(data, total);
  },

  _getCurrentCategoriesPercentage: function() {
    var total = this.dataModel.get('totalCount') || 0;
    var data = this.dataModel.getData().toJSON();
    return this._getCategoriesPercentage(data, total);
  },

  _getCategoriesPercentage: function(data, total) {
    if (!total) {
      return 0;
    }

    var currentTotal = data.reduce(function(memo, mdl) {
      return !mdl.agg ? ( memo + parseFloat(mdl.value)) : memo;
    }, 0);

    if (!currentTotal) {
      return 0;
    }

    return ((currentTotal / total) * 100).toFixed(2);
  },

  _getCategoriesSize: function() {
    return _.pluck(
      this.dataModel.getData().reject(function(mdl) {
        return mdl.get('agg');
      }), 'name').length;
  }
});

},{"../../animate_values":33,"./cats_template.tpl":58,"./stats_template.tpl":59}],61:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) { 
__p+=' <form class="CDB-Widget-search js-form"> <i class="CDB-Icon CDB-Icon-lens CDB-Widget-searchLens"></i> <input type="text" class="CDB-Widget-textInput CDB-Widget-searchTextInput js-textInput" value="'+
((__t=( q ))==null?'':_.escape(__t))+
'" placeholder="Search by '+
((__t=( columnName ))==null?'':_.escape(__t))+
'"> ';
 if (canShowApply) { 
__p+=' <button type="button" class="CDB-Widget-link CDB-Widget-searchApply js-applyLocked">apply</button> ';
 } 
__p+=' </form> ';
 } else { 
__p+=' <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-options CDB-Widget-contentSpaced"> <button class="CDB-Widget-buttonIcon CDB-Widget-buttonIcon--circle js-colors '+
((__t=( isColorApplied ? 'is-selected' : '' ))==null?'':_.escape(__t))+
' '+
((__t=( isColorApplied ? 'js-cancelColors' : 'js-applyColors' ))==null?'':_.escape(__t))+
'" data-tooltip="\n          '+
((__t=( isColorApplied ? 'Remove colors' : 'Apply colors' ))==null?'':_.escape(__t))+
'\n        "> <i class="CDB-Icon CDB-Icon-syringe CDB-Icon--top"></i> </button> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div> </div> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],62:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var View = cdb.core.View;
var TooltipView = require('../../widget-tooltip-view');
var template = require('./search_title_template.tpl');

/**
 *  Show category title or search any category
 *  + another options for this widget, as in,
 *  colorize categories, lock defined categories...
 *
 */

module.exports = View.extend({

  events: {
    'keyup .js-textInput': '_onKeyupInput',
    'submit .js-form': '_onSubmitForm',
    'click .js-applyLocked': '_applyLocked',
    'click .js-applyColors': '_applyColors',
    'click .js-cancelColors': '_cancelColors',
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(
      template({
        isCollapsed: this.dataModel.isCollapsed(),
        isColorApplied: this.dataModel.isColorApplied(),
        title: this.dataModel.get('title'),
        columnName: this.dataModel.get('column'),
        q: this.dataModel.getSearchQuery(),
        isLocked: this.dataModel.isLocked(),
        canBeLocked: this.dataModel.canBeLocked(),
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        canShowApply: this.dataModel.canApplyLocked()
      })
    );
    this._initViews();
    return this;
  },

  _initBinds: function() {
    this.viewModel.bind('change:search', this._onSearchToggled, this);
    this.dataModel.bind('change:filter change:lockCollection change:categoryColors change:collapsed', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _initViews: function() {
    var collapseTooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(collapseTooltip.render().el);
    this.addView(collapseTooltip);

    var colorsTooltip = new TooltipView({
      target: this.$('.js-colors')
    });
    $('body').append(colorsTooltip.render().el);
    this.addView(colorsTooltip);
  },

  _onSearchToggled: function() {
    var isSearchEnabled = this.viewModel.isSearchEnabled();
    this[isSearchEnabled ? '_bindESC' : '_unbindESC']();
    this.render();
    if (isSearchEnabled) {
      this._focusOnInput();
    }
  },

  _onSubmitForm: function(ev) {
    if (ev) {
      ev.preventDefault();
    }
    var q = this.$('.js-textInput').val();
    if (this.dataModel.getSearchQuery() !== q) {
      this.dataModel.setSearchQuery(q);
      if (this.dataModel.isSearchValid()) {
        this.dataModel.applySearch();
      }
    }
  },

  _focusOnInput: function() {
    var self = this;
    setTimeout(function() {
      self.$('.js-textInput').focus();
    }, 0);
  },

  _onKeyupInput: _.debounce(
    function(ev) {
      var q = this.$('.js-textInput').val();
      if (ev.keyCode !== 13 && ev.keyCode !== 27 && q !== "") {
        this._onSubmitForm();
      }
    }, 250
  ),

  _bindESC: function() {
    $(document).bind("keyup." + this.cid, _.bind(this._onKeyUp, this));
  },

  _unbindESC: function() {
    $(document).unbind("keyup." + this.cid);
  },

  _onKeyUp: function(ev) {
    if (ev.keyCode === 27) {
      this._cancelSearch();
      return false;
    }
  },

  _applyLocked: function() {
    this.viewModel.toggleSearch();
    this.dataModel.applyLocked();
  },

  _applyColors: function() {
    this.dataModel.applyCategoryColors();
  },

  _cancelColors: function() {
    this.dataModel.cancelCategoryColors();
  },

  _cancelSearch: function() {
    this.dataModel.cleanSearch();
    this.viewModel.disableSearch();
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  },

  clean: function() {
    this._unbindESC();
    View.prototype.clean.call(this);
  }

});

},{"../../widget-tooltip-view":102,"./search_title_template.tpl":61}],63:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],64:[function(require,module,exports){
var _ = cdb._;
var formatter = cdb.core.format;
var d3 = cdb.d3;
var $ = cdb.$;
var WidgetContent = require('../standard/widget_content_view');
var WidgetViewModel = require('../widget_content_model');
var template = require('./template.tpl');
var TooltipView = require('../widget-tooltip-view');
var animationTemplate = require('./animation_template.tpl');
var AnimateValues = require('../animate_values.js');

/**
 * Default widget content view:
 */
module.exports = WidgetContent.extend({

  events: {
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.dataModel = this.model;
    this.viewModel = new WidgetViewModel();
    WidgetContent.prototype.initialize.call(this);
  },

  render: function() {
    this.clearSubViews();
    var value = this.dataModel.get('data');

    var format = function(value) {
      var formatter = d3.format('0,000');

      if (_.isNumber(value)) {
        return formatter(value.toFixed(2));
      }
      return 0;
    };

    var nulls = !_.isUndefined(this.dataModel.get('nulls')) && formatter.formatNumber(this.dataModel.get('nulls')) ||'-';
    var isCollapsed = this.dataModel.isCollapsed();

    var prefix = this.dataModel.get('prefix');
    var suffix = this.dataModel.get('suffix');

    this.$el.html(
      template({
        title: this.dataModel.get('title'),
        operation: this.dataModel.get('operation'),
        value: value,
        nulls: nulls,
        prefix: prefix,
        suffix: suffix,
        isCollapsed: isCollapsed
      })
    );

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateValue(this.dataModel, 'data', '.js-value', animationTemplate, { animationSpeed: 700, formatter: format, templateData: { prefix: prefix, suffix: suffix }});

    this.$el.toggleClass('is-collapsed', !!isCollapsed);

    this._initViews();

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:collapsed', this.render, this);
    WidgetContent.prototype._initBinds.call(this);
  },

  _initViews: function() {
    var tooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(tooltip.render().el);
    this.addView(tooltip);
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  }

});

},{"../animate_values.js":33,"../standard/widget_content_view":85,"../widget-tooltip-view":102,"../widget_content_model":105,"./animation_template.tpl":63,"./template.tpl":66}],65:[function(require,module,exports){
var _ = cdb._;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  defaults: _.extend(
    {},
    WidgetModel.prototype.defaults,
    {
      data: '',
      suffix: '',
      prefix: ''
    }
  ),

  // TODO: The response format has probably changed
  parse: function(r) {
    return {
      data: r.result,
      nulls: r.nulls
    };
  },

  toJSON: function(d) {
    return {
      type: "formula",
      options: {
        column: this.get('column'),
        operation: this.get('operation')
      }
    };
  }

});

},{"../widget_model":106}],66:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <div class="CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-tag CDB-Widget-tag--'+
((__t=( operation ))==null?'':_.escape(__t))+
'"> <span class="CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( operation ))==null?'':_.escape(__t))+
'</span> </div> </div> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( nulls ))==null?'':_.escape(__t))+
' null rows</dt> </dl> </div> <div class="CDB-Widget-content"> ';
 if (value) { 
__p+=' <h4 class="CDB-Widget-textBigger CDB-Widget-textBigger--maxWidth js-value" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'"> '+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
' </h4> ';
 } else { 
__p+=' <div class="CDB-Widget-listItem--fake"></div> ';
 } 
__p+=' </div>';
}
return __p;
};

},{"underscore":24}],67:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],68:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var d3 = cdb.d3;
var formatter = cdb.core.format;
var Model = cdb.core.Model;
var View = cdb.core.View;

module.exports = View.extend({

  defaults: {
     // render the chart once the width is set as default, provide false value for this prop to disable this behavior
     // e.g. for "mini" histogram behavior
    showOnWidthChange: true,

    labelsMargin: 16, // px
    hasAxisTip: false,
    minimumBarHeight: 2,
    animationSpeed: 750,
    handleWidth: 6,
    handleHeight: 23,
    handleRadius: 3,
    divisionWidth: 80,
    animationBarDelay: function(d, i) {
      return Math.random() * (100 + (i * 10));
    },
    transitionType: 'elastic'
  },

  initialize: function() {
    if (!_.isNumber(this.options.height)) throw new Error('height is required');

    this.options = _.extend({}, this.defaults, this.options);

    _.bindAll(this, '_selectBars', '_adjustBrushHandles', '_onBrushMove', '_onBrushStart', '_onMouseMove', '_onMouseOut');

    // Use this special setup for each view instance ot have its own debounced listener
    // TODO in theory there's the possiblity that the callback is called before the view is rendered in the DOM,
    //  which would lead to the view not being visible until an explicit window resize.
    //  a wasAddedToDOM event would've been nice to have
    this._onWindowResize = _.debounce(this._resizeToParentElement.bind(this), 50);
    $(window).bind('resize', this._onWindowResize);

    // using tagName: 'svg' doesn't work,
    // and w/o class="" d3 won't instantiate properly
    this.setElement($('<svg class=""></svg>')[0]);

    this.canvas = d3.select(this.el)
    .attr('width', 0)
    .attr('height', this.options.height);

    this.canvas
    .append('g')
    .attr('class', 'CDB-WidgetCanvas');

    this._setupModel();
    this._setupBindings();
    this._setupDimensions();
    this._setupD3Bindings();

    this.hide(); // will be toggled on width change
  },

  render: function() {
    this._generateChart();
    this._generateChartContent();
    return this;
  },

  clean: function() {
    $(window).unbind('resize', this._onWindowResize);
    View.prototype.clean.call(this);
  },

  replaceData: function(data) {
    this.model.set({ data: data });
  },

  toggleLabels: function(show) {
    this.model.set('showLabels', show);
  },

  chartWidth: function() {
    var m = this.model.get('margin');

    // Get max because width might be negative initially
    return Math.max(0, this.model.get('width') - m.left - m.right);
  },

  chartHeight: function() {
    var m = this.model.get('margin');
    var labelsMargin = this.model.get('showLabels')
      ? this.defaults.labelsMargin
      : 0;
    return this.model.get('height') - m.top - m.bottom - labelsMargin;
  },

  _resizeToParentElement: function() {

    if (this.$el.parent()) {
      // Hide this view temporarily to get actual size of the parent container
      var wasHidden = this.isHidden();

      this.hide();

      var width = this.$el.parent().width() || 0;

      if (wasHidden) {
        this.hide();
      } else {
        this.show();
      }

      this.model.set('width', width);
    }
  },

  _onChangeLeftAxisTip: function() {
    this._updateAxisTip('left');
  },

  _onChangeRightAxisTip: function() {
    this._updateAxisTip('right');
  },

  _updateAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip  = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);
    var handle    = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);

    textLabel.data([this.model.get(className + '_axis_tip')]).text(function(d) {
      return formatter.formatNumber(d);
    });

    var width = textLabel.node().getBBox().width;
    rectLabel.attr('width', width + 4);

    var parts = /translate\(\s*([^\s,)]+), ([^\s,)]+)/.exec(handle.attr('transform'));
    var xPos = +parts[1] + 3;

    if ((xPos - width/2) < 0) {
      axisTip.attr('transform', 'translate(0, 52)');
      textLabel.attr('dx', -xPos);
      rectLabel.attr('x',  -xPos);
    } else if ((xPos + width/2 + 2) >= this.chartWidth()) {
      axisTip.attr('transform', 'translate(0, 52)');
      textLabel.attr('dx', this.chartWidth() - (xPos + width - 2));
      rectLabel.attr('x', this.chartWidth() - (xPos + width));
    } else {
      axisTip.attr('transform', 'translate(-' + (width/2) + ', 52)');
      rectLabel.attr('x', 0);
      textLabel.attr('dx', +2);
    }
  },

  _onChangeData: function() {
    if (this.model.previous('data').length != this.model.get('data').length) {
      this.reset();
    } else {
      this.refresh();
    }
  },

  _onChangeRange: function() {
    if (this.model.get('lo_index') === 0 && this.model.get('hi_index') === 0) {
      return;
    }
    this.trigger('range_updated', this.model.get('lo_index'), this.model.get('hi_index'));
  },

  _onChangeWidth: function() {
    var width = this.model.get('width');
    this.$el.width(width);
    this.chart.attr('width', width);
    if (this.options.showOnWidthChange && width > 0) {
      this.show();
    }
    this.reset();

    var loBarIndex = this.model.get('lo_index');
    var hiBarIndex = this.model.get('hi_index');
    this.selectRange(loBarIndex, hiBarIndex);
  },

  _onChangeHeight: function() {
    var height = this.model.get('height');

    this.$el.height(height);
    this.chart.attr('height', height);
    this.leftHandle.attr('height', height);
    this.rightHandle.attr('height', height);

    this.reset();
  },

  _onChangShowLabels: function() {
    this._axis.style('opacity', this.model.get('showLabels') ? 1 : 0);
  },

  _onChangePos: function() {
    var pos = this.model.get('pos');
    var margin = this.model.get('margin');

    var x = +pos.x;
    var y = +pos.y;

    this.chart
    .transition()
    .duration(150)
    .attr('transform', 'translate(' + (margin.left + x) + ', ' + (margin.top + y) + ')');
  },

  _onBrushStart: function() {
    var extent = this.brush.extent();
    var hiExtent = extent[1];
    var rightX = this.xScale(hiExtent) - this.options.handleWidth / 2;

    this.chart.classed('is-selectable', true);
  },

  _onChangeDragging: function() {
    this.chart.classed('is-dragging', this.model.get('dragging'));
    this._updateAxisTipOpacity('right');
    this._updateAxisTipOpacity('left');
  },

  _showAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip   = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);

    if (textLabel) {
      textLabel.transition().duration(200).attr('opacity',  1);
    }
    if (rectLabel) {
      rectLabel.transition().duration(200).attr('opacity',  1);
    }
  },

  _hideAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip   = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);

    if (textLabel) {
      textLabel.transition().duration(200).attr('opacity',  0);
    }
    if (rectLabel) {
      rectLabel.transition().duration(200).attr('opacity',  0);
    }
  },

  _updateAxisTipOpacity: function(className) {
    if (this.model.get('dragging')) {
      this._showAxisTip(className);
    } else {
      this._hideAxisTip(className);
    }
  },

  _onBrushMove: function() {
    this.model.set({ dragging: true });
    this._selectBars();
    this._adjustBrushHandles();
  },

  _onMouseOut: function() {
    var bars = this.chart.selectAll('.CDB-Chart-bar');
    bars.classed('is-highlighted', false);
    this.trigger('hover', { value: null });
  },

  _onMouseMove: function() {
    var x = d3.event.offsetX;
    var y = d3.event.offsetY;

    var barIndex = Math.floor(x / this.barWidth);
    var data = this.model.get('data');

    if (data[barIndex] === undefined || data[barIndex] === null) {
      return;
    }

    var freq = data[barIndex].freq;
    var hoverProperties = {};

    var bar = this.chart.select('.CDB-Chart-bar:nth-child(' + (barIndex + 1) + ')');

    if (bar && bar.node() && !bar.classed('is-selected')) {

      var left = (barIndex * this.barWidth) + (this.barWidth/2);

      var top = this.yScale(freq);

      var h = this.chartHeight() - this.yScale(freq);

      if (h < this.options.minimumBarHeight && h > 0) {
        top = this.chartHeight() - this.options.minimumBarHeight;
      }

      if (!this._isDragging() && freq > 0) {
        var d = formatter.formatNumber(freq);
        hoverProperties = { top: top, left: left, data: d };
      } else {
        hoverProperties = null;
      }

    } else {
      hoverProperties = null;
    }

    this.trigger('hover', hoverProperties);

    this.chart.selectAll('.CDB-Chart-bar')
    .classed('is-highlighted', false);

    if (bar && bar.node()) {
      bar.classed('is-highlighted', true);
    }
  },

  reset: function() {
    this._removeChartContent();
    this._setupDimensions();
    this._calcBarWidth();
    this._generateChartContent();
    this._removeShadowBars();
    this._generateShadowBars();
  },

  refresh: function() {
    this._setupDimensions();
    this._removeAxis();
    this._generateAxis();
    this._updateChart();

    this._generateShadowBars();
    this.chart.select('.CDB-Chart-handles').moveToFront();
    this.chart.select('.Brush').moveToFront();
  },

  resetIndexes: function() {
    this.model.set({ lo_index: null, hi_index: null });
  },

  removeShadowBars: function() {
    this.model.set('show_shadow_bars', false);
  },

  _removeShadowBars: function() {
    this.chart.selectAll('.CDB-Chart-shadowBars').remove();
  },

  _removeBars: function() {
    this.chart.selectAll('.CDB-Chart-bars').remove();
  },

  _removeBrush: function() {
    this.chart.selectAll('.Brush').remove();
    this.chart.classed('is-selectable', false);
  },

  _removeLines: function() {
    this.chart.select('.CDB-Chart-lines').remove();
  },

  _removeChartContent: function() {
    this._removeBrush();
    this._removeHandles();
    this._removeBars();
    this._removeAxis();
    this._removeLines();
  },

  _generateChartContent: function() {
    this._generateAxis();
    this._generateLines();

    this._generateBars();
    this._generateHandles();
    this._setupBrush();
  },

  _generateLines: function() {
    this._generateHorizontalLines();

    if (this.options.type !== 'time') {
      this._generateVerticalLines();
    }
  },

  _generateVerticalLines: function() {
    var lines = this.chart.select('.CDB-Chart-lines');

    lines.append('g')
    .selectAll('.CDB-Chart-line')
    .data(this.verticalRange.slice(1, this.verticalRange.length - 1))
    .enter().append('svg:line')
    .attr('class', 'CDB-Chart-line')
    .attr('y1', 0)
    .attr('x1', function(d) { return d; })
    .attr('y2', this.chartHeight())
    .attr('x2', function(d) { return d; });
  },

  _generateHorizontalLines: function() {
    var lines = this.chart.append('g')
    .attr('class', 'CDB-Chart-lines');

    lines.append('g')
    .attr('class', 'y')
    .selectAll('.CDB-Chart-line')
    .data(this.horizontalRange)
    .enter().append('svg:line')
    .attr('class', 'CDB-Chart-line')
    .attr('x1', 0)
    .attr('y1', function(d) { return d; })
    .attr('x2', this.chartWidth())
    .attr('y2', function(d) { return d; });

    this.bottomLine = lines
    .append('line')
    .attr('class', 'CDB-Chart-line CDB-Chart-line--bottom')
    .attr('x1', 0)
    .attr('y1', this.chartHeight())
    .attr('x2', this.chartWidth() - 1)
    .attr('y2', this.chartHeight());
  },

   _setupD3Bindings: function() { // TODO: move to a helper

    d3.selection.prototype.moveToBack = function() {
      return this.each(function() {
        var firstChild = this.parentNode.firstChild;
        if (firstChild) {
          this.parentNode.insertBefore(this, firstChild);
        }
      });
    };

    d3.selection.prototype.moveToFront = function() {
      return this.each(function(){
        this.parentNode.appendChild(this);
      });
    };
  },

  _setupModel: function() {
    this.model = new Model({
      showLabels: true,
      data: this.options.data,
      height: this.options.height,
      display: true,
      show_shadow_bars: this.options.shadowData,
      margin: _.clone(this.options.margin),
      width: 0, // will be set on resize listener
      pos: { x: 0, y: 0 }
    });
  },

  _setupBindings: function() {
    this.model.bind('change:data', this._onChangeData, this);
    this.model.bind('change:display', this._onChangeDisplay, this);
    this.model.bind('change:dragging', this._onChangeDragging, this);
    this.model.bind('change:height', this._onChangeHeight, this);
    this.model.bind('change:left_axis_tip', this._onChangeLeftAxisTip, this);
    this.model.bind('change:lo_index change:hi_index', this._onChangeRange, this);
    this.model.bind('change:pos', this._onChangePos, this);
    this.model.bind('change:right_axis_tip', this._onChangeRightAxisTip, this);
    this.model.bind('change:showLabels', this._onChangShowLabels, this);
    this.model.bind('change:show_shadow_bars', this._onChangeShowShadowBars, this);
    this.model.bind('change:width', this._onChangeWidth, this);
  },

  _setupDimensions: function() {
    this._setupScales();
    this._setupRanges();
    this._onWindowResize();
  },

  _setupScales: function() {
    var data = this.model.get('data');

    this.xScale = d3.scale.linear().domain([0, 100]).range([0, this.chartWidth()]);
    this.yScale = d3.scale.linear().domain([0, d3.max(data, function(d) { return _.isEmpty(d) ? 0 : d.freq; } )]).range([this.chartHeight(), 0]);

    if (!data || !data.length) {
      return;
    }

    if (this.options.type === 'time') {
      this.xAxisScale = d3.time.scale().domain([data[0].start * 1000, data[data.length - 1].end * 1000]).nice().range([0, this.chartWidth()]);
    } else {
      this.xAxisScale = d3.scale.linear().range([data[0].start, data[data.length - 1].end]).domain([0, this.chartWidth()]);
    }
  },

  _setupRanges: function() {
    var n = Math.round(this.chartWidth() / this.options.divisionWidth);
    this.verticalRange = d3.range(0, this.chartWidth() + this.chartWidth() / n, this.chartWidth() / n);
    this.horizontalRange = d3.range(0, this.chartHeight() + this.chartHeight() / 2, this.chartHeight() / 2);
  },

  _calcBarWidth: function() {
    this.barWidth = this.chartWidth() / this.model.get('data').length;
  },

  _generateChart: function() {
    var margin = this.model.get('margin');

    this.chart = d3.select(this.el)
    .selectAll('.CDB-WidgetCanvas')
    .append('g')
    .attr('class', 'CDB-Chart')
    .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');

    this.chart.classed(this.options.className || '', true);
  },

  _onChangeShowShadowBars: function() {
    if (this.model.get('show_shadow_bars')) {
      this._generateShadowBars();
    } else {
      this._removeShadowBars();
    }
  },

  _onChangeDisplay: function() {
    if (this.model.get('display')) {
      this._show();
    } else {
      this._hide();
    }
  },

  hide: function() {
    this.model.set('display', false);
  },

  show: function() {
    this.model.set('display', true);
  },

  _hide: function() {
    this.$el.hide();
  },

  _show: function() {
    this.$el.show();
  },

  isHidden: function() {
    return !this.model.get('display');
  },

  _selectBars: function() {
    var self = this;
    var extent = this.brush.extent();
    var lo = extent[0];
    var hi = extent[1];


    this.model.set({ lo_index: this._getLoBarIndex(), hi_index: this._getHiBarIndex() });

    this.chart.selectAll('.CDB-Chart-bar').classed('is-selected', function(d, i) {
      var a = Math.floor(i * self.barWidth);
      var b = Math.floor(a + self.barWidth);
      var LO = Math.floor(self.xScale(lo));
      var HI = Math.floor(self.xScale(hi));
      var isIn = (a > LO && a < HI) || (b > LO && b < HI) || (a <= LO && b >= HI);
      return !isIn;
    });
  },

  _isDragging: function() {
    return this.model.get('dragging');
  },

  _move: function(pos) {
    this.model.set({ pos: pos });
  },

  expand: function(height) {
    this.canvas.attr('height', this.model.get('height') + height);
    this._move({ x: 0, y: height });
  },

  contract: function(height) {
    this.canvas.attr('height', height);
    this._move({ x: 0, y: 0 });
  },

  resizeHeight: function(height) {
    this.model.set('height', height);
  },

  removeSelection: function() {
    this.resetIndexes();
    this.chart.selectAll('.CDB-Chart-bar').classed('is-selected', false);
    this._removeBrush();
    this._setupBrush();
  },

  selectRange: function(loBarIndex, hiBarIndex) {
    if (!loBarIndex && !hiBarIndex) {
      return;
    }

    var loPosition = this._getBarPosition(loBarIndex);
    var hiPosition = this._getBarPosition(hiBarIndex);

    this._selectRange(loPosition, hiPosition);
  },

  _selectRange: function(loPosition, hiPosition) {
    this.chart.select('.Brush').transition()
    .duration(this.brush.empty() ? 0 : 150)
    .call(this.brush.extent([loPosition, hiPosition]))
    .call(this.brush.event);
  },

  _getLoBarIndex: function() {
    var extent = this.brush.extent();
    return Math.round(this.xScale(extent[0]) / this.barWidth);
  },

  _getHiBarIndex: function() {
    var extent = this.brush.extent();
    return Math.round(this.xScale(extent[1]) / this.barWidth);
  },

  _getBarIndex: function() {
    var x = d3.event.sourceEvent.offsetX;
    return Math.floor(x / this.barWidth);
  },

  _getBarPosition: function(index) {
    var data = this.model.get('data');
    return index * (100 / data.length);
  },

  _setupBrush: function() {
    var self = this;

    var xScale = this.xScale;
    var brush = this.brush = d3.svg.brush().x(this.xScale);

    function onBrushEnd() {
      var data = self.model.get('data');
      var loPosition, hiPosition;

      self.model.set({ dragging: false });

      if (brush.empty()) {
        self.chart.selectAll('.CDB-Chart-bar').classed('is-selected', false);
        d3.select(this).call(brush.extent([0, 0]));
      } else {

        var loBarIndex = self._getLoBarIndex();
        var hiBarIndex = self._getHiBarIndex();

        loPosition = self._getBarPosition(loBarIndex);
        hiPosition = self._getBarPosition(hiBarIndex);

        if (!d3.event.sourceEvent) {
          return;
        }

        if (loBarIndex === hiBarIndex) {
          if (hiBarIndex >= data.length) {
            loPosition = self._getBarPosition(loBarIndex - 1);
          } else {
            hiPosition = self._getBarPosition(hiBarIndex + 1);
          }
        }

        self._selectRange(loPosition, hiPosition);
        self.model.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
        self._adjustBrushHandles();
        self._selectBars();

        self.trigger('on_brush_end', self.model.get('lo_index'), self.model.get('hi_index'));
      }

      if (d3.event.sourceEvent && loPosition === undefined && hiPosition === undefined) {
        var barIndex = self._getBarIndex();

        loPosition = self._getBarPosition(barIndex);
        hiPosition = self._getBarPosition(barIndex + 1);

        self.model.set({ lo_index: barIndex, hi_index: barIndex + 1 });
        self._selectRange(loPosition, hiPosition);
        self.trigger('on_brush_end', self.model.get('lo_index'), self.model.get('hi_index'));
      }
    }

    var data = this.model.get('data');

    this.brush
    .on('brushstart', this._onBrushStart)
    .on('brush', this._onBrushMove)
    .on('brushend', onBrushEnd);

    this.chart.append('g')
    .attr('class', 'Brush')
    .call(this.brush)
    .selectAll('rect')
    .attr('y', 0)
    .attr('height', this.chartHeight())
    .on('mouseout', this._onMouseOut)
    .on('mousemove', this._onMouseMove);
  },

  _adjustBrushHandles: function() {
    var extent = this.brush.extent();

    var loExtent = extent[0];
    var hiExtent = extent[1];

    var leftX  = this.xScale(loExtent) - this.options.handleWidth / 2;
    var rightX = this.xScale(hiExtent) - this.options.handleWidth / 2;

    this.chart.select('.CDB-Chart-handle-left')
    .attr('transform', 'translate(' + leftX + ', 0)');

    this.chart.select('.CDB-Chart-handle-right')
    .attr('transform', 'translate(' + rightX + ', 0)');

    if (this.options.hasAxisTip) {
      this.model.set({
        left_axis_tip: this.xAxisScale(leftX + 3),
        right_axis_tip: this.xAxisScale(rightX + 3)
      });
    }
  },

  _generateAxisTip: function(className) {

    var handle = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);

    var axisTip = handle.selectAll("g")
    .data([''])
    .enter().append("g")
    .attr('class', 'CDB-Chart-axisTip CDB-Chart-axisTip-' + className)
    .attr("transform", function(d, i) { return "translate(0,52)"; });

    this.rectLabel = axisTip.append("rect")
    .attr('class', 'CDB-Chart-axisTipRect CDB-Chart-axisTip-' + className)
    .attr("height", 12)
    .attr("width", 10);

    this.textLabel = axisTip.append("text")
    .attr('class', 'CDB-Chart-axisTipText CDB-Chart-axisTip-' + className)
    .attr("dy", "11")
    .attr("dx", "0")
    .text(function(d) { return d; });
  },

  _generateHandle: function(className) {
    var opts = { width: this.options.handleWidth, height: this.options.handleHeight, radius: this.options.handleRadius };
    var yPos = (this.chartHeight() / 2) - (this.options.handleHeight / 2);

    var handle = this.chart.select('.CDB-Chart-handles')
    .append('g')
    .attr('class', 'CDB-Chart-handle CDB-Chart-handle-' + className);

    if (this.options.hasAxisTip) {
      this._generateAxisTip(className);
    }

    handle
    .append('line')
    .attr('class', 'CDB-Chart-handleLine')
    .attr('x1', 3)
    .attr('y1', -4)
    .attr('x2', 3)
    .attr('y2', this.chartHeight() + 4);

    if (this.options.hasHandles) {
      handle
      .append('rect')
      .attr('class', 'CDB-Chart-handleRect')
      .attr('transform', 'translate(0, ' + yPos + ')')
      .attr('width', opts.width)
      .attr('height', opts.height)
      .attr('rx', opts.radius)
      .attr('ry', opts.radius);

      var y = 21; // initial position of the first grip

      for (var i = 0; i < 3; i++) {
        handle
        .append('line')
        .attr('class', 'CDB-Chart-handleGrip')
        .attr('x1', 2)
        .attr('y1', y + i*3)
        .attr('x2', 4)
        .attr('y2', y + i*3);
      }
    }

    return handle;
  },

  _generateHandles: function() {
    this.chart.append('g').attr('class', 'CDB-Chart-handles');
    this.leftHandle  = this._generateHandle('left');
    this.rightHandle = this._generateHandle('right');
  },

  _generateHandleLine: function() {
    return this.chart.select('.CDB-Chart-handles').append('line')
    .attr('class', 'CDB-Chart-handleLine')
    .attr('x1', 0)
    .attr('y1', 0)
    .attr('x2', 0)
    .attr('y2', this.chartHeight());
  },

  _removeHandles: function() {
    this.chart.select('.CDB-Chart-handles').remove();
  },

  _removeAxis: function() {
    this.canvas.select('.CDB-Chart-axis').remove();
  },

  _generateAdjustAnchorMethod: function(ticks) {

    return function(d, i) {
      if (i === 0) {
        return 'start';
      } else if (i === (ticks.length - 1)) {
        return 'end';
      } else {
        return 'middle';
      }
    };
  },

  _generateAxis: function() {
    this._axis = this.options.type === 'time'
      ? this._generateTimeAxis()
      : this._generateNumericAxis();

    this._onChangShowLabels();
  },

  _generateNumericAxis: function() {
    var self = this;
    var adjustTextAnchor = this._generateAdjustAnchorMethod(this.verticalRange);

    var axis = this.chart.append('g')
    .attr('class', 'CDB-Chart-axis');

    axis
    .append('g')
    .selectAll('.Label')
    .data(this.verticalRange)
    .enter().append("text")
    .attr("x", function(d) { return d; })
    .attr("y", function(d) { return self.chartHeight() + 15; })
    .attr("text-anchor", adjustTextAnchor)
    .text(function(d) {
      return formatter.formatNumber(self.xAxisScale(d));
    });

    return axis;
  },

  _generateTimeAxis: function() {
    var adjustTextAnchor = this._generateAdjustAnchorMethod(this.xAxisScale.ticks());

    var xAxis = d3.svg.axis()
    .orient("bottom")
    .tickPadding(5)
    .innerTickSize(-this.chartHeight())
    .scale(this.xAxisScale)
    .orient('bottom');

    var axis = this.canvas.append('g')
    .attr("class", 'CDB-Chart-axis')
    .attr("transform", "translate(0," + (this.chartHeight() + 5) + ")")
    .call(xAxis);

    axis.selectAll('text').style('text-anchor', adjustTextAnchor);
    axis.moveToBack();

    return axis;
  },

  _updateChart: function() {
    var self = this;
    var data = this.model.get('data');

    var bars = this.chart.selectAll('.CDB-Chart-bar')
    .data(data);

    bars
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-bar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * self.barWidth) + ', 0 )';
    })
    .attr('y', self.chartHeight())
    .attr('height', 0)
    .attr('width', Math.max(0, this.barWidth - 1));

    bars
    .transition()
    .duration(200)
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return self.yScale(d.freq);
      }
    });

    bars
    .exit()
    .transition()
    .duration(200)
    .attr('height', function(d) {
      return 0;
    })
    .attr('y', function(d) {
      return self.chartHeight();
    });
  },

  _generateBars: function() {
    var self = this;
    var data = this.model.get('data');

    this._calcBarWidth();

    var bars = this.chart.append('g')
    .attr('transform', 'translate(0, 0)')
    .attr('class', 'CDB-Chart-bars')
    .selectAll('.CDB-Chart-bar')
    .data(data);

    bars
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-bar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * self.barWidth) + ', 0 )';
    })
    .attr('y', self.chartHeight())
    .attr('height', 0)
    .attr('width', Math.max(0, this.barWidth - 1));

    bars
    .transition()
    .ease(this.options.transitionType)
    .duration(this.options.animationSpeed)
    .delay(this.options.animationBarDelay)
    .transition()
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return self.yScale(d.freq);
      }
    });
  },

  showShadowBars: function() {
    this.model.set('show_shadow_bars', true);
  },

  _generateShadowBars: function() {
    var data = this.options.shadowData;

    if (!data || !data.length || !this.model.get('show_shadow_bars')) {
      this._removeShadowBars();
      return;
    }

    this._removeShadowBars();

    var self = this;

    var yScale = d3.scale.linear().domain([0, d3.max(data, function(d) { return _.isEmpty(d) ? 0 : d.freq; } )]).range([this.chartHeight(), 0]);
    var barWidth = this.chartWidth() / data.length;

    var bars = this.chart.append('g')
    .attr('transform', 'translate(0, 0)')
    .attr('class', 'CDB-Chart-shadowBars')
    .selectAll('.CDB-Chart-shadowBar')
    .data(data)
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-shadowBar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * barWidth) + ', 0 )';
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return yScale(d.freq);
      }
    })
    .attr('width', Math.max(0, barWidth - 1))
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    });

    // We need to explicitly move the lines of the grid behind the shadow bars
    this.chart.selectAll('.CDB-Chart-shadowBars').moveToBack();
    this.chart.selectAll('.CDB-Chart-lines').moveToBack();
  }
});

},{}],69:[function(require,module,exports){
var _ = cdb._;
var formatter = cdb.core.format;
var HistogramTitleView = require('./histogram_title_view');
var WidgetContent = require('../standard/widget_content_view');
var WidgetViewModel = require('../widget_content_model');
var HistogramChartView = require('./chart');
var placeholder = require('./placeholder.tpl');
var template = require('./content.tpl');
var AnimateValues = require('../animate_values.js');
var animationTemplate = require('./animation_template.tpl');

/**
 * Widget content view for a histogram
 */
module.exports = WidgetContent.extend({

  defaults: {
    chartHeight: 48 + 20 + 4
  },

  events: {
    'click .js-clear': '_clear',
    'click .js-zoom': '_zoom'
  },

  initialize: function() {
    this.model = this.options.dataModel;
    this.viewModel = new WidgetViewModel();
    this.lockedByUser = false;
    WidgetContent.prototype.initialize.call(this);
  },

  _initViews: function() {
    var titleView = new HistogramTitleView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-title').html(titleView.render().el);
    this.addView(titleView);

    this._renderMiniChart();
    this._renderMainChart();
  },

  _initBinds: function() {
    this.model.once('change:data', this._onFirstLoad, this);
    this.model.bind('change:collapsed', function(mdl, isCollapsed) {
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
    }, this);
  },

  _onFirstLoad: function() {
    this.render();
    this._storeBounds();

    this.model.bind('change', this._onChangeModel, this);
    this.model._fetch();
  },

  _storeBounds: function() {
    var data = this.model.getData();
    if (data && data.length > 0) {
      this.start = data[0].start;
      this.end = data[data.length - 1].end;
      this.binsCount = data.length;
      this.model.set({ start: this.start, end: this.end, bins: this.binsCount });
    }
  },

  _isZoomed: function() {
    return this.viewModel.get('zoomed');
  },

  _onChangeModel: function() {

    // When the histogram is zoomed, we don't need to rely
    // on the change url to update the histogram
    if (this.model.changed.url && this._isZoomed()) {
      return;
    }

    // if the action was initiated by the user
    // don't replace the stored data
    if (this.lockedByUser) {
      this.lockedByUser = false;
    } else {
      if (this._isZoomed()) {
        this.zoomedData = this.model.getData();
      } else {
        this.histogramChartView.showShadowBars();
        this.originalData = this.model.getData();
      }
        this.histogramChartView.replaceData(this.model.getData());
    }

    if (this.unsettingRange) {
      this._unsetRange();
    } else {
      if (this._isZoomed() && !this.lockZoomedData) {
        this.lockZoomedData = true;
        this.zoomedData = this.model.getData();
      }
    }

    this._updateStats();
  },

  render: function() {
    this.clearSubViews();

    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;

    this.$el.html(
      template({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? data.length : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    } else {
      this.originalData = this.model.getData();
      this._setupBindings();
      this._initViews();
    }

    return this;
  },

  _unsetRange: function() {
    this.unsettingRange = false;
    this.histogramChartView.replaceData(this.originalData);
    this.viewModel.set({ lo_index: null, hi_index: null });

    if (!this._isZoomed()) {
      this.histogramChartView.showShadowBars();
    }
  },

  _addPlaceholder: function() {
    this.$('.js-content').append(placeholder());
  },

  _renderMainChart: function() {
    this.histogramChartView = new HistogramChartView(({
      margin: { top: 4, right: 4, bottom: 4, left: 4 },
      hasShadowBards: true,
      hasHandles: true,
      hasAxisTip: true,
      width: this.canvasWidth,
      height: this.defaults.chartHeight,
      data: this.model.getData(),
      shadowData: this.model.getData()
    }));

    this.$('.js-content').append(this.histogramChartView.el);
    this.addView(this.histogramChartView);

    this.histogramChartView.bind('range_updated', this._onRangeUpdated, this);
    this.histogramChartView.bind('on_brush_end', this._onBrushEnd, this);
    this.histogramChartView.bind('hover', this._onValueHover, this);
    this.histogramChartView.render().show();

    this._updateStats();
  },

  _renderMiniChart: function() {
    this.miniHistogramChartView = new HistogramChartView(({
      className: 'CDB-Chart--mini',
      margin: { top: 0, right: 0, bottom: 4, left: 4 },
      height: 40,
      showOnWidthChange: false,
      data: this.model.getData()
    }));

    this.addView(this.miniHistogramChartView);
    this.$('.js-content').append(this.miniHistogramChartView.el);
    this.miniHistogramChartView.bind('on_brush_end', this._onMiniRangeUpdated, this);
    this.miniHistogramChartView.render();
  },

  _setupBindings: function() {
    this.viewModel.bind('change:zoomed', this._onChangeZoomed, this);
    this.viewModel.bind('change:zoom_enabled', this._onChangeZoomEnabled, this);
    this.viewModel.bind('change:filter_enabled', this._onChangeFilterEnabled, this);
    this.viewModel.bind('change:total', this._onChangeTotal, this);
    this.viewModel.bind('change:nulls', this._onChangeNulls, this);
    this.viewModel.bind('change:max',   this._onChangeMax, this);
    this.viewModel.bind('change:min',   this._onChangeMin, this);
    this.viewModel.bind('change:avg',   this._onChangeAvg, this);
  },

  _clearTooltip: function() {
    this.$(".js-tooltip").stop().hide();
  },

  _onValueHover: function(info) {
    var $tooltip = this.$(".js-tooltip");

    if (info && info.data) {
      var bottom = this.defaults.chartHeight + 3 - info.top;

      $tooltip.css({ bottom: bottom, left: info.left });
      $tooltip.text(info.data);
      $tooltip.css({ left: info.left - $tooltip.width()/2 });
      $tooltip.fadeIn(70);
    } else {
      this._clearTooltip();
    }
  },

  _onMiniRangeUpdated: function(loBarIndex, hiBarIndex) {
    this.lockedByUser = false;
    this.lockZoomedData = false;

    this._clearTooltip();
    this.histogramChartView.removeSelection();

    var data = this.originalData;

    if (loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
      this.filter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._updateStats();
    } else {
      console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this._getData();
    
    if (!data || !data.length) {
      return;
    }

    if (this._isZoomed()) {
      this.lockedByUser = true;
    }

    var properties = { filter_enabled: true, lo_index: loBarIndex, hi_index: hiBarIndex };

    if (!this.viewModel.get('zoomed')) {
      properties.zoom_enabled = true;
    }

    this.viewModel.set(properties);

    if (loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
      this.filter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._updateStats();
    } else {
      console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
    }
  },

  _onRangeUpdated: function(loBarIndex, hiBarIndex) {

    var self = this;
    if (this.viewModel.get('zoomed')) {
      this.viewModel.set({ zoom_enabled: false, lo_index: loBarIndex, hi_index: hiBarIndex });
    } else {
      this.viewModel.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
    }

    var updateStats = _.debounce(function() { self._updateStats(); }, 400);
    updateStats();
  },

  _getData: function() {
    var data = this.model.getData();

    if (this._isZoomed()) {
      data = this.zoomedData;
    }
    return data;
  },

  _onChangeFilterEnabled: function() {
    this.$(".js-filter").toggleClass('is-hidden', !this.viewModel.get('filter_enabled'));
  },

  _onChangeZoomEnabled: function() {
    this.$(".js-zoom").toggleClass('is-hidden', !this.viewModel.get('zoom_enabled'));
  },

  _changeHeaderValue: function(className, what, suffix) {
    if (this.viewModel.get(what) === undefined) {
      this.$(className).text('0 ' + suffix);
      return;
    }

    this._addTitleForValue(className, what, suffix);

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateValue(this.viewModel, what, className, animationTemplate, {
      formatter: formatter.formatNumber,
      templateData: { suffix: " " + suffix }
    });
  },

  _onChangeNulls: function() {
    this._changeHeaderValue('.js-nulls', 'nulls', 'NULL ROWS');
  },

  _onChangeTotal: function() {
    this._changeHeaderValue('.js-val', 'total', 'SELECTED');
  },

  _onChangeMax: function() {
    this._changeHeaderValue('.js-max', 'max', 'MAX');
  },

  _onChangeMin: function() {
    this._changeHeaderValue('.js-min', 'min', 'MIN');
  },

  _onChangeAvg: function() {
    this._changeHeaderValue('.js-avg', 'avg', 'AVG');
  },

  _addTitleForValue: function(className, what, unit) {
    this.$(className).attr('title', this._formatNumberWithCommas(this.viewModel.get(what).toFixed(2)) + ' ' + unit);
  },

  _formatNumberWithCommas: function(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  },

  _updateStats: function() {
    var data = this.originalData;

    if (this._isZoomed()) {
      data = this.zoomedData;
    }

    var nulls = this.model.get('nulls');

    var min, max;

    if (data && data.length) {

      var loBarIndex = this.viewModel.get('lo_index') || 0;
      var hiBarIndex = this.viewModel.get('hi_index') || data.length;

      var sum = this._calcSum(data, loBarIndex, hiBarIndex);
      var avg = this._calcAvg(data, loBarIndex, hiBarIndex);

      if (loBarIndex >= 0 && loBarIndex < data.length) {
        min = data[loBarIndex].start;
      }

      if (hiBarIndex >= 0 && hiBarIndex - 1 < data.length) {
        max = data[hiBarIndex - 1].end;
      }

      this.viewModel.set({ total: sum, nulls: nulls, min: min, max: max, avg: avg });
    }
  },

  _calcAvg: function(data, start, end) {

    var selectedData = data.slice(start, end);

    var total = this._calcSum(data, start, end, total);

    if (!total) {
      return 0;
    }

    var area = _.reduce(selectedData, function(memo, d) {
      return (d.avg && d.freq) ? (d.avg * d.freq) + memo : memo;
    }, 0);

    return area / total;
  },

  _calcSum: function(data, start, end) {
    return _.reduce(data.slice(start, end), function(memo, d) {
      return d.freq + memo;
    }, 0);
  },

  _onChangeZoomed: function() {
    if (this.viewModel.get('zoomed')) {
      this._onZoomIn();
    } else {
      this._onZoomOut();
    }
  },

  _onZoomIn: function() {
    this._showMiniRange();
    this.histogramChartView.expand(20);

    this.histogramChartView.removeShadowBars();

    this.model.set({ start: null, end: null, bins: null, own_filter: 1 });
    this.model._fetch();
    this.lockedByUser = false;
  },

  _zoom: function() {
    this.lockedByUser = true;
    this.viewModel.set({ zoomed: true, zoom_enabled: false });
    this.histogramChartView.removeSelection();
  },

  _onZoomOut: function() {
    this.lockedByUser   = true;
    this.lockZoomedData = false;
    this.unsettingRange = true;

    this.model.set({ start: this.start, end: this.end, bins: this.binsCount, own_filter: null });

    this.viewModel.set({ zoom_enabled: false, filter_enabled: false, lo_index: null, hi_index: null });

    this.filter.unsetRange();

    this.histogramChartView.contract(this.defaults.chartHeight);
    this.histogramChartView.resetIndexes();

    this.miniHistogramChartView.hide();
  },

  _showMiniRange: function() {
    var data = this.model.getData();

    var loBarIndex = this.viewModel.get('lo_index');
    var hiBarIndex = this.viewModel.get('hi_index');

    this.miniHistogramChartView.selectRange(loBarIndex, hiBarIndex);
    this.miniHistogramChartView.show();
  },

  _clear: function() {
    this.histogramChartView.removeSelection();
    this.viewModel.set({ zoomed: false, zoom_enabled: false });
    this.viewModel.trigger('change:zoomed');
  }
});

},{"../animate_values.js":33,"../standard/widget_content_view":85,"../widget_content_model":105,"./animation_template.tpl":67,"./chart":68,"./content.tpl":70,"./histogram_title_view":72,"./placeholder.tpl":74}],70:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="js-title"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> </div> <dl class="CDB-Widget-info CDB-Widget-textSmaller CDB-Widget-textSmaller--upper"> <dt class="CDB-Widget-infoItem js-nulls">0 NULL ROWS</dt> <dt class="CDB-Widget-infoItem js-min">0 MIN</dt> <dt class="CDB-Widget-infoItem js-avg">0 AVG</dt> <dt class="CDB-Widget-infoItem js-max">0 MAX</dt> </dl> </div> <div class="CDB-Widget-content js-content"> <div class="CDB-Widget-tooltip js-tooltip"></div> <div class="CDB-Widget-filter CDB-Widget-contentSpaced js-filter is-hidden"> <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--upper js-val"></p> <div class="CDB-Widget-filterButtons"> <button class="CDB-Widget-link CDB-Widget-filterButton js-zoom">zoom</button> <button class="CDB-Widget-link CDB-Widget-filterButton js-clear">clear</button> </div> </div> </div>';
}
return __p;
};

},{"underscore":24}],71:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-options CDB-Widget-contentSpaced"> <button class="CDB-Widget-buttonIcon CDB-Widget-buttonIcon--circle js-sizes '+
((__t=( isSizesApplied ? 'is-selected' : '' ))==null?'':_.escape(__t))+
' '+
((__t=( isSizesApplied ? 'js-cancelSizes' : 'js-applySizes' ))==null?'':_.escape(__t))+
'" data-tooltip="'+
((__t=( isSizesApplied ? 'Remove sizes' : 'Apply sizes' ))==null?'':_.escape(__t))+
'"> <i class="CDB-Icon CDB-Icon-syringe CDB-Icon--top"></i> </button> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div>';
}
return __p;
};

},{"underscore":24}],72:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var View = cdb.core.View;
var TooltipView = require('../widget-tooltip-view');
var template = require('./histogram_title_template.tpl');

/**
 *  Show title + show if histogram sizes are applied or not
 *
 */

module.exports = View.extend({

  className: 'CDB-Widget-title CDB-Widget-contentSpaced',

  events: {
    'click .js-applySizes': '_applySizes',
    'click .js-cancelSizes': '_cancelSizes',
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.$el.html(
      template({
        title: this.dataModel.get('title'),
        isSizesApplied: this.dataModel.get('histogramSizes'),
        isCollapsed: this.dataModel.isCollapsed()
      })
    );
    this._initViews();

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:histogramSizes change:collapsed', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _initViews: function() {
    var sizesTooltip = new TooltipView({
      target: this.$('.js-sizes')
    });
    $('body').append(sizesTooltip.render().el);
    this.addView(sizesTooltip);

    var collapseTooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(collapseTooltip.render().el);
    this.addView(collapseTooltip);
  },

  _applySizes: function() {
    this.dataModel.set('histogramSizes', true);
  },

  _cancelSizes: function() {
    this.dataModel.set('histogramSizes', false);
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  }

});

},{"../widget-tooltip-view":102,"./histogram_title_template.tpl":71}],73:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  url: function() {
    var params = [];

    if (this.get('columnType')) {
      params.push('column_type=' + this.get('columnType'));
    }
    if (_.isNumber(this.get('start'))) {
      params.push('start=' + this.get('start'));
    }
    if (_.isNumber(this.get('end'))) {
      params.push('end=' + this.get('end'));
    }
    if (_.isNumber(this.get('bins'))) {
      params.push('bins=' + this.get('bins'));
    }
    if (_.isNumber(this.get('own_filter'))) {
      params.push('own_filter=' + this.get('own_filter'));
    }
    if (this.get('boundingBox') && this.get('submitBBox')) {
      params.push('bbox=' + this.get('boundingBox'));
    }

    var url = this.get('url');
    if (params.length > 0) {
        url += '?' + params.join('&');
    }
    return url;
  },

  initialize: function(attrs, opts) {
    WidgetModel.prototype.initialize.apply(this, arguments);
    this._data = new Backbone.Collection(this.get('data'));

    // BBox should only be included until after the first fetch, since we want to get the range of the full dataset
    this.once('change:data', function() {
      this.set('submitBBox', true);
    }, this);

    this.layer.bind('change:meta', this._onChangeLayerMeta, this);
  },

  getData: function() {
    return this._data.toJSON();
  },

  getSize: function() {
    return this._data.size();
  },

  parse: function(data) {
    var numberOfBins = data.bins_count;
    var width = data.bin_width;
    var nulls = data.nulls_count;
    var start = data.bins_start;

    var buckets = new Array(numberOfBins);

    _.each(data.bins, function(b) {
      buckets[b.bin] = b;
    });

    for (var i = 0; i < numberOfBins; i++) {
      buckets[i] = _.extend({
        bin: i,
        start: start + (i * width),
        end: start + ((i + 1) * width),
        freq: 0
      }, buckets[i]);
    }

    this._data.reset(buckets);

    return {
      data: buckets,
      nulls: data.nulls
    };
  },

  // set bins for the histograms
  // @bins should be an array with the format [{ start: ..., end: ..., freq: ..., min: ..., max:   }, ...]
  //    - start, end: are the bucket bounds
  //    - min, max: the min and the max value for all the points in that bucket
  //    - freq: count
  setBins: function(bins, options) {
    this._data.reset(bins, options);
    this.set('data', { bins: bins }, options);
    return this;
  },

  toJSON: function(d) {
    return {
      type: "histogram",
      options: {
        column: this.get('column'),
        bins: this.get('bins')
      }
    };
  },

  _onChangeLayerMeta: function() {
    this.filter.set('columnType', this.layer.get('meta').column_type);
  },

  _onChangeBinds: function() {
    WidgetModel.prototype._onChangeBinds.call(this);
    this.bind('change:histogramSizes', function(mdl, isSizesApplied, d) {
      if (isSizesApplied) {
        this.trigger('histogramSizes', this);
      }
    }, this);
  }
});

},{"../widget_model":106}],74:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-chart CDB-Widget-chart--fake"> ';
 for (var i = 0; i < 15; i++) { 
__p+=' <li class="CDB-Widget-chartItem CDB-Widget-chartItem--'+
((__t=( _.sample(['small', 'medium', 'big'], 1)[0] ))==null?'':_.escape(__t))+
' Widget-chartItem--fake"></li> ';
 } 
__p+=' </ul>';
}
return __p;
};

},{"underscore":24}],75:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( itemsCount ))==null?'':_.escape(__t))+
' rows</dt> </dl> </div> <div class="CDB-Widget-content CDB-Widget-content--noSidesMargin"> <div class="CDB-Widget-listWrapper js-content"></div> </div> <div class="CDB-Widget-footer js-footer"></div>';
}
return __p;
};

},{"underscore":24}],76:[function(require,module,exports){
var _ = cdb._;
var format = cdb.core.format;
var WidgetContentView = require('../standard/widget_content_view');
var WidgetListItemsView = require('./items_view');
var WidgetListPaginatorView = require('./paginator_view');
var WidgetListEdgesView = require('./edges_view');
var template = require('./content_template.tpl');
var templatePlaceholder = require('./placeholder_template.tpl');

/**
 * Default widget content view:
 */
module.exports = WidgetContentView.extend({

  options: {
    showScroll: false
  },

  render: function() {
    this.clearSubViews();
    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
    this.$el.html(
      template({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? format.formatValue(data.length) : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    } else {
      this._initViews();
    }

    return this;
  },

  _initViews: function() {
    var count = this.model.getSize();

    // List view -> items view
    this._list = new WidgetListItemsView({
      model: this.model
    });
    this.$('.js-content').html(this._list.render().el);
    this.addView(this._list);

    var isScrollList = (this._list.$el.get(0).scrollHeight - this._list.$el.outerHeight()) > 0;

    if (isScrollList ||this.options.showScroll) {
      // Paginator
      this._pagination = new WidgetListPaginatorView({
        $target: this._list.$el
      });
      this.$('.js-footer').append(this._pagination.render().el);
      this.addView(this._pagination);

      // Edges
      this._edges = new WidgetListEdgesView({
        $target: this._list.$el
      });
      this.$('.js-content').append(this._edges.render().el);
      this.addView(this._edges);
    }
  }

});

},{"../standard/widget_content_view":85,"./content_template.tpl":75,"./edges_view":77,"./items_view":80,"./paginator_view":82,"./placeholder_template.tpl":83}],77:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;

/**
 *  List edges view:
 *
 *  - It shows the borders and the shadows, if needed.
 */
module.exports = View.extend({

  _TEMPLATE: ' ' +
    '<div class="CDB-Widget-listEdge CDB-Widget-listEdge--top">'+
      '<div class="CDB-Widget-listEdgeShadow js-topShadow"></div>'+
      '<div class="CDB-Widget-listEdgeBorder"></div>'+
    '</div>'+
    '<div class="CDB-Widget-listEdge CDB-Widget-listEdge--bottom">'+
      '<div class="CDB-Widget-listEdgeShadow js-bottomShadow"></div>'+
      '<div class="CDB-Widget-listEdgeBorder"></div>'+
    '</div>',

  initialize: function() {
    this._$target = this.options.$target;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    var template = _.template(this._TEMPLATE);
    this.$el.html(template());
    this._checkScroll();
    return this;
  },

  _initBinds: function() {
    var self = this;
    this._$target.bind('scroll', function() {
      self._checkScroll();
    });
  },

  _unbindScroll: function() {
    this._$target.unbind('scroll');
  },

  _checkScroll: function() {
    var currentScroll = this._$target.scrollTop();
    var maxScroll = this._$target.get(0).scrollHeight - this._$target.outerHeight();
    this.$('.js-topShadow').toggle(currentScroll !== 0);
    this.$('.js-bottomShadow').toggle(currentScroll !== maxScroll);
  },

  clean: function() {
    this._unbindScroll();
    View.prototype.clean.call(this);
  }

});

},{}],78:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isClickable) { 
__p+=' <button type="button" class="CDB-Widget-listItemInner CDB-Widget-listButton CDB-Widget-listButton--withBorder js-button"> ';
 } else { 
__p+=' <div class="CDB-Widget-listItemInner CDB-Widget-listItemInner--withBorders"> ';
 } 
__p+=' <div class="CDB-Widget-contentSpaced CDB-Widget-contentSpaced--topAligned CDB-Widget-contentSpaced--start"> <em class="CDB-Shape-dot CDB-Widget-listDot"></em> ';
 if (itemsCount > 0) { 
__p+=' <div class="CDB-Widget-contentFull"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--upper CDB-Widget-textSmall--bold" title="'+
((__t=( items[0][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[0][1] ))==null?'':_.escape(__t))+
'</p> ';
 if (itemsCount > 2) { 
__p+=' <dl class="CDB-Widget-inlineList"> ';
 for (var i = 1, l = itemsCount; i < l; i++) { 
__p+=' <div class="CDB-Widget-inlineListItem CDB-Widget-textSmaller CDB-Widget-textSmaller--noEllip"> <dd class="CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark u-rSpace" title="'+
((__t=( items[i][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[i][1] ))==null?'':_.escape(__t))+
'</dd> <dt title="'+
((__t=( items[i][0] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[i][0] ))==null?'':_.escape(__t))+
'</dt> </div> ';
 } 
__p+=' </dl> ';
 } else if (itemsCount === 2) { 
__p+=' <dl class="CDB-Widget-textSmaller CDB-Widget-textSmaller--noEllip u-tSpace"> <dd class="CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark u-rSpace" title="'+
((__t=( items[1][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[1][1] ))==null?'':_.escape(__t))+
'</dd> <dt title="'+
((__t=( items[1][0] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[1][0] ))==null?'':_.escape(__t))+
'</dt> </dl> ';
 } 
__p+=' </div> ';
 } 
__p+=' </div> ';
 if (isClickable) { 
__p+=' </div></button> ';
 } else { 
__p+='  ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],79:[function(require,module,exports){
var _ = cdb._;
var format = cdb.core.format;
var View = cdb.core.View;
var template = require('./item_template.tpl');

module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function() {
    this.viewModel = this.options.viewModel;
  },

  render: function() {
    var data = this.model.toJSON();
    var hasInteractivity = this._hasInteractivity(data);
    var items = this._sanitizeData(data);

    this.$el.html(
      template({
        items: items,
        isClickable: hasInteractivity,
        itemsCount: _.size(items)
      })
    );

    // If there is no cartodb_id defined, click event should
    // be disabled
    this[ hasInteractivity ? 'delegateEvents' : 'undelegateEvents' ]();
    return this;
  },

  // Remove cartodb_id, if exists
  // Replace titles if there are alternatives
  // Convert data object to array items
  _sanitizeData: function(data) {
    var hasInteractivity = this._hasInteractivity(data);
    var data = _.omit(data, function(value, key, object) {
      return key === 'cartodb_id';
    });

    var columnTitles = this.viewModel.get('columns_title');
    if (hasInteractivity && !_.isEmpty(columnTitles)) {
      columnTitles = _.rest(columnTitles, 1);
    }

    // Convert to pair items and check if there is a column title
    var arr = [];
    var i = 0;

    _.each(data, function(value, key) {
      var title = columnTitles && columnTitles[i] || key;
      arr.push([ title, format.formatValue(value) ]);
      ++i;
    });

    return arr;
  },

  _hasInteractivity: function(data) {
    return !_.isEmpty(
      _.filter(data, function(value, key){
        return key === 'cartodb_id'
      })
    )
  },

  _onItemClick: function() {
    this.trigger('itemClicked', this.model, this);
  }

});

},{"./item_template.tpl":78}],80:[function(require,module,exports){
var View = cdb.core.View;
var WidgetListItemView = require('./item_view');

module.exports = View.extend({

  className: 'CDB-Widget-list js-list',
  tagName: 'ul',

  events: {
    'scroll': '_checkScroll'
  },

  render: function() {
    this.clearSubViews();
    this._renderList();
    return this;
  },

  _renderList: function() {
    this.model.getData().each(this._addItem, this);
  },

  _addItem: function(mdl) {
    var v = new WidgetListItemView({
      model: mdl,
      viewModel: this.model
    });
    v.bind('itemClicked', function(){
      this.trigger('itemClicked', mdl, this);
    }, this);
    this.addView(v);
    this.$el.append(v.render().el);
  }

});

},{"./item_view":79}],81:[function(require,module,exports){
var Backbone = cdb.Backbone;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  options: {
    page: 0,
    per_page: 100
  },

  initialize: function(attrs, opts) {
    this._data = new Backbone.Collection(this.get('data'));
    WidgetModel.prototype.initialize.call(this, attrs, opts);
  },

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  parse: function(data) {
    var rows = data.rows;
    this._data.reset(rows);
    return {
      data: rows
    };
  },

  toJSON: function() {
    return {
      type: "list",
      options: {
        columns: this.get('columns')
      }
    };
  }
});

},{"../widget_model":106}],82:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;

module.exports = View.extend({

  className: 'CDB-Widget-nav CDB-Widget-contentSpaced',

  _TEMPLATE: ' ' +
    '<span></span>' +
    '<div class="CDB-Widget-navArrows CDB-Widget-contentSpaced">'+
      '<button class="CDB-Shape-arrow CDB-Shape-arrow--up js-up"></button>'+
      '<button class="CDB-Shape-arrow CDB-Shape-arrow--down js-down"></button>'+
    '</div>',

  events: {
    'click .js-up': '_scrollUp',
    'click .js-down': '_scrollDown'
  },

  initialize: function() {
    if (!this.options.$target) {
      throw new Error('target should be defined in order to be able to paginate');
    }
    this._$target = this.options.$target;
    this._scrollHeight = this._$target.get(0).scrollHeight - this._$target.outerHeight();
    this._initBinds();
  },

  render: function() {
    var template = _.template(this._TEMPLATE);
    this.$el.html(template());
    this._checkScroll();
    return this;
  },

  _initBinds: function() {
    var self = this;
    this._$target.bind('scroll', function() {
      self._checkScroll();
    });
  },

  _unbindScroll: function() {
    this._$target.unbind('scroll');
  },

  _checkScroll: function() {
    var currentScroll = this._$target.scrollTop();
    this.$('.js-up').toggleClass('is-disabled', currentScroll === 0);
    this.$('.js-down').toggleClass('is-disabled', currentScroll >= this._scrollHeight);
  },

  _getEdgeVisibleItems: function() {
    var areaHeight = this._$target.outerHeight();
    var firstEl = null;
    var lastEl = null;
    var items = this._$target.children('.CDB-Widget-listItem');

    items.each(function(index, value) {
      var top = $(this).position().top;
      var height = $(this).outerHeight();

      if (top > -1 && firstEl === null){ //first entirely visible element
        firstEl = this;
      } else if ((top + height) > areaHeight && lastEl === null){
        lastEl = items[index-1];//the last entirely visible was the element before
      }
    });

    return [firstEl,lastEl];
  },

  _scrollDown: function() {
    var lastVisibleItem = this._getEdgeVisibleItems()[1];
    var currentScroll = this._$target.scrollTop();
    var $next = $(lastVisibleItem).next();
    if ($next.length) {
      var top = $next.position().top;
      var height = $next.outerHeight();
      var scrollPos = top + height - this._$target.outerHeight() + currentScroll;
      if (scrollPos > 0) {
        this._$target.scrollTop(scrollPos);
      }
    }
  },

  _scrollUp: function() {
    var firstVisibleItem = this._getEdgeVisibleItems()[0];
    var currentScroll = this._$target.scrollTop();
    var $prev = $(firstVisibleItem).prev();
    if ($prev.length) {
      var top = $prev.position().top;
      var scrollPos = currentScroll + top;
      this._$target.scrollTop(scrollPos);
    }
  },

  clean: function() {
    this._unbindScroll();
    View.prototype.clean.call(this);
  }

});

},{}],83:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-list CDB-Widget-list--withBorders"> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> </ul>';
}
return __p;
};

},{"underscore":24}],84:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( itemsCount ))==null?'':_.escape(__t))+
' items</dt> </dl> </div> <div class="CDB-Widget-content js-content"></div>';
}
return __p;
};

},{"underscore":24}],85:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var log = cdb.log;
var View = cdb.core.View;
var d3 = cdb.d3;
var contentTemplate = require('./widget_content_template.tpl');
var placeholderTemplate = require('./widget_placeholder_template.tpl');

/**
 * Default widget content view:
 */
module.exports = View.extend({

  className: 'CDB-Widget-body',

  initialize: function() {
    this.filter = this.options.filter;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
    this.$el.html(
      contentTemplate({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? data.length : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    }

    return this;
  },

  _initBinds: function() {
    this.model.bind('change:data', this.render, this);
  },

  _addPlaceholder: function() {
    if (placeholderTemplate) {
      this.$('.js-content').append(placeholderTemplate());
    } else {
      log.info('Placeholder template doesn\'t exist');
    }
  }
});

},{"./widget_content_template.tpl":84,"./widget_placeholder_template.tpl":89}],86:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button class="CDB-Widget-button CDB-Widget-errorButton js-refresh"> <span class="CDB-Widget-textSmall CDB-Widget-textSmall--bold">REFRESH</span> </button>';
}
return __p;
};

},{"underscore":24}],87:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var template = require('./widget_error_template.tpl');

/**
 *  Default widget error view:
 *
 *  It will listen or not to dataModel changes when
 *  first load is done.
 */
module.exports = View.extend({

  className: 'CDB-Widget-error is-hidden',

  events: {
    'click .js-refresh': '_onRefreshClick'
  },

  initialize: function() {
    this._initBinds();
  },

  render: function() {
    this.$el.html(template());
    return this;
  },

  _initBinds: function() {
    this.model.bind('error', this.show, this);
    this.model.bind('loading', this.hide, this);
  },

  _onRefreshClick: function() {
    this.model.refresh();
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  }

});

},{"./widget_error_template.tpl":86}],88:[function(require,module,exports){
var View = cdb.core.View;

/**
 *  Default widget loader view:
 *
 *  It will listen or not to dataModel changes when
 *  first load is done.
 */
module.exports = View.extend({

  className: 'CDB-Widget-loader',

  initialize: function() {
    this._initBinds();
  },

  _initBinds: function() {
    this.model.bind('loading', this.show, this);
    this.model.bind('sync error', this.hide, this);
  },

  show: function() {
    this.$el.addClass('is-visible');
  },

  hide: function() {
    var self = this;
    setTimeout(function() {
      self.$el.removeClass('is-visible');
    }, 500);
  }

});

},{}],89:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-list CDB-Widget-list--withBorders"> <li class="CDB-Widget-listItem CDB-Widget-listItem--withBorders CDB-Widget-listItem--fake"></li> </ul>';
}
return __p;
};

},{"underscore":24}],90:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var placeholderTemplate = require('./placeholder.tpl');
var HistogramView = require('./histogram-view');

/**
 * Widget content view for a time-series
 */
module.exports = View.extend({

  className: 'CDB-Widget-body CDB-Widget-body--timeSeries',

  initialize: function() {
    this.model.once('change:data', this._onFirstLoad, this);
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(''); // to remove placeholder if there is any

    if (this._isDataEmpty()) {
      this.$el.append(placeholderTemplate({
        hasTorqueLayer: false
      }));
    } else {
      this._appendView(new HistogramView(this.options));
    }

    return this;
  },

  _onFirstLoad: function() {
    this._storeBounds();
    this.model.once('change:data', this.render, this);
    this.model._fetch();
  },

  _storeBounds: function() {
    var data = this.model.getData();
    if (data && data.length > 0) {
      var start = data[0].start;
      var end = data[data.length - 1].end;
      this.model.set({ start: start, end: end, bins: data.length });
    }
  },

  _appendView: function(view) {
    this.addView(view);
    this.$el.append(view.render().el);
  },

  _isDataEmpty: function() {
    var data = this.model.getData();
    return _.isEmpty(data) || _.size(data) === 0;
  }
});

},{"./histogram-view":91,"./placeholder.tpl":92}],91:[function(require,module,exports){
var $ = cdb.$;
var View = cdb.core.View;
var HistogramChartView = require('../histogram/chart');

/**
 * Time-series histogram view.
 */
module.exports = View.extend({

  className: 'CDB-Widget-content CDB-Widget-content--timeSeries',

  defaults: {
    mobileThreshold: 960, // px; should match CSS media-query
    histogramChartHeight:
      48 + // inline bars height
      4 + // bottom margin
      16 + // labels
      4, // margins
    histogramChartMobileHeight:
      20 + // inline bars height (no bottom labels)
      4 // margins
  },

  initialize: function() {
    this.filter = this.options.filter;

    this.model.bind('change:data', this._onChangeData, this);
  },

  render: function() {
    this.clearSubViews();
    this._createHistogramView();
    return this;
  },

  _createHistogramView: function() {
    this._chartView = new HistogramChartView({
      type: 'time',
      animationSpeed: 100,
      margin: {
        top: 4,
        right: 4,
        bottom: 4,
        left: 4
      },
      hasHandles: true,
      animationBarDelay: function(d, i) {
        return (i * 3);
      },
      height: this.defaults.histogramChartHeight,
      data: this.model.getData()
    });
    this.addView(this._chartView);
    this.$el.append(this._chartView.render().el);
    this._chartView.show();

    this._chartView.bind('on_brush_end', this._onBrushEnd, this);
    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this.add_related_model(this._chartView.model);
  },

  _onChangeData: function() {
    if (this._chartView) {
      this._chartView.replaceData(this.model.getData());
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this.model.getData();
    this.filter.setRange(
      data[loBarIndex].start,
      data[hiBarIndex - 1].end
    );
  },

  _onChangeChartWidth: function() {
    var isMobileSize = $(window).width() < this.defaults.mobileThreshold;

    this._chartView.toggleLabels(!isMobileSize);

    var height = isMobileSize
      ? this.defaults.histogramChartMobileHeight
      : this.defaults.histogramChartHeight;
    this._chartView.model.set('height', height);
  }

});

},{"../histogram/chart":68}],92:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header CDB-Widget-header--timeSeries"> ';
 if (hasTorqueLayer) { 
__p+=' <div class="CDB-Widget-timeSeriesFakeControl"></div> <div class="CDB-Widget-timeSeriesTimeInfo CDB-Widget-timeSeriesTimeInfo--fake"></div> ';
 } 
__p+=' </div> <div class="CDB-Widget-content CDB-Widget-content--timeSeries"> <div class="CDB-Widget-timeSeriesFakeChart ';
 if (hasTorqueLayer) { 
__p+='CDB-Widget-timeSeriesFakeChart--torque';
 } 
__p+='"> ';
 for (var i = 0; i < 50; i++) { 
__p+=' <div class="CDB-Widget-timeSeriesFakeChartItem" style="height: '+
((__t=( Math.floor(Math.random() * 100) ))==null?'':_.escape(__t))+
'%"></div> ';
 } 
__p+=' </div> </div>';
}
return __p;
};

},{"underscore":24}],93:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var torqueTemplate = require('./torque-template.tpl');
var placeholderTemplate = require('./placeholder.tpl');
var TorqueControlsView = require('./torque-controls-view');
var TorqueTimeInfoView = require('./torque-time-info-view');
var TorqueHistogramView = require('./torque-histogram-view');

/**
 * Widget content view for a Torque time-series
 */
module.exports = View.extend({

  className: 'CDB-Widget-body CDB-Widget-body--timeSeries',

  initialize: function() {
    this.model.once('change:data', this.render, this);
  },

  render: function() {
    this.clearSubViews();

    if (this._isDataEmpty()) {
      this.$el.html(placeholderTemplate({
        hasTorqueLayer: true
      }));
    } else {
      this._renderContent();
    }

    return this;
  },

  _renderContent: function() {
    this.$el.html(torqueTemplate());
    this._appendView(
      new TorqueControlsView({ model: this.options.torqueLayerModel }),
      '.js-header'
    );
    this._appendView(
      new TorqueTimeInfoView({ model: this.options.torqueLayerModel }),
      '.js-header'
    );
    this._appendView(new TorqueHistogramView(this.options));
  },

  _appendView: function(view, selector) {
    this.addView(view);
    if (selector) {
      this.$(selector).append(view.el);
    } else {
      this.$el.append(view.el);
    }
    view.render();
  },

  _isDataEmpty: function() {
    var data = this.model.getData();
    return _.isEmpty(data) || _.size(data) === 0;
  }
});

},{"./placeholder.tpl":92,"./torque-controls-view":94,"./torque-histogram-view":96,"./torque-template.tpl":97,"./torque-time-info-view":98}],94:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./torque-controls.tpl');

/**
 * Torque animation controls, to manage run state
 */
module.exports = View.extend({

  tagName: 'button',
  className: 'CDB-Widget-controlButton',

  events: {
    'click': '_onClick'
  },

  initialize: function() {
    this.model.bind('change:isRunning', this.render, this);
  },

  render: function() {
    this.$el.html(
      template({
        iconClass: 'CDB-Widget-controlButton-icon CDB-Widget-controlButton-icon--' + (
          this.model.get('isRunning')
            ? 'pause'
            : 'play')
      })
    );

    return this;
  },

  _onClick: function() {
    if (this.model.get('isRunning')) {
      this.model.pause();
    } else {
      this.model.play();
    }
  }
});

},{"./torque-controls.tpl":95}],95:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-controlButton-content"> <i class="'+
((__t=( iconClass ))==null?'':_.escape(__t))+
'"></i> </div>';
}
return __p;
};

},{"underscore":24}],96:[function(require,module,exports){
var $ = cdb.$;
var View = cdb.core.View;
var HistogramChartView = require('../histogram/chart');
var TorqueTimeSliderView = require('./torque-time-slider-view');

/**
 * Torque time-series histogram view.
 * Extends the common histogram chart view with time-control
 * this.model is a histogram model
 */
module.exports = View.extend({

  className: 'CDB-Widget-content CDB-Widget-content--timeSeries',

  // TODO could be calculated from element styles instead of duplicated numbers here?
  defaults: {
    mobileThreshold: 960, // px; should match CSS media-query
    histogramChartHeight:
      48 + // inline bars height
      4 + // bottom margin
      16 + // bottom labels
      4, // margins
    histogramChartMobileHeight:
      20 + // inline bars height (no bottom labels)
      4 // margins
  },

  initialize: function() {
    if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');
    if (!this.options.rangeFilter) throw new Error('rangeFilter is required');

    this._rangeFilter = this.options.rangeFilter;
    this._torqueLayerModel = this.options.torqueLayerModel;

    this.model.bind('change:data', this._onChangeData, this);
  },

  render: function() {
    this.clearSubViews();
    this._createHistogramView();
    return this;
  },

  _createHistogramView: function() {
    this._chartView = new HistogramChartView({
      type: 'time',
      animationSpeed: 100,
      animationBarDelay: function(d, i) {
        return (i * 3);
      },
      margin: {
        top: 4,
        right: 4,
        bottom: 4,
        left: 4
      },
      hasHandles: true,
      height: this.defaults.histogramChartHeight,
      data: this.model.getData(),
      shadowData: this.model.getData()
    });

    this.addView(this._chartView);
    this.$el.append(this._chartView.render().el);
    this._chartView.show();

    this._chartView.bind('on_brush_end', this._onBrushEnd, this);
    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this.add_related_model(this._chartView.model);

    var timeSliderView = new TorqueTimeSliderView({
      model: this.model, // a histogram model
      chartView: this._chartView,
      torqueLayerModel: this._torqueLayerModel
    });
    this.addView(timeSliderView);
    timeSliderView.render();
  },

  _onChangeData: function() {
    if (this._chartView) {
      this._chartView.replaceData(this.model.getData());
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this.model.getData();
    this._rangeFilter.setRange(
      data[loBarIndex].start,
      data[hiBarIndex - 1].end
    );
    this._torqueLayerModel.setStepsRange(loBarIndex, hiBarIndex);
  },

  _onChangeChartWidth: function() {
    var isMobileSize = $(window).width() < this.defaults.mobileThreshold;

    this._chartView.toggleLabels(!isMobileSize);

    var height = isMobileSize
      ? this.defaults.histogramChartMobileHeight
      : this.defaults.histogramChartHeight;
    this._chartView.model.set('height', height);
  }

});

},{"../histogram/chart":68,"./torque-time-slider-view":100}],97:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header CDB-Widget-header--timeSeries js-header"></div>';
}
return __p;
};

},{"underscore":24}],98:[function(require,module,exports){
var _ = cdb._;
var d3 = cdb.d3;
var View = cdb.core.View;
var template = require('./torque-time-info.tpl');

/**
 * View rendering the current step time
 *
 * Model is expected to be a torque layer model
 */
module.exports = View.extend({

  className: 'CDB-Widget-timeSeriesTimeInfo',

  initialize: function() {
    this.model.bind('change:step', this.render, this);

    // for format rules see https://github.com/mbostock/d3/wiki/Time-Formatting
    this._timeFormatter = d3.time.format('%H:%M');
    this._dateFormatter = d3.time.format('%x');
  },

  render: function() {
    var date = this.model.get('time');

    this.$el.html(
      isNaN(date && date.getTime())
        ? ''
        : template({
            time: this._timeFormatter(date),
            date: this._dateFormatter(date)
          })
    );

    return this;
  }
});

},{"./torque-time-info.tpl":99}],99:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<p class="CDB-Widget-textBig"> '+
((__t=( time ))==null?'':_.escape(__t))+
' </p> <p class="CDB-Widget-textBig CDB-Widget-text--secondary"> '+
((__t=( date ))==null?'':_.escape(__t))+
' </p>';
}
return __p;
};

},{"underscore":24}],100:[function(require,module,exports){
var d3 = cdb.d3;
var Model = cdb.core.Model;
var View = cdb.core.View;

/**
 * Time-slider, expected to be used in a histogram view
 */
module.exports = View.extend({

  defaults: {
    width: 4,
    height: 8
  },

  initialize: function() {
    if (!this.options.model) throw new Error('model is required');
    if (!this.options.chartView) throw new Error('chartView is required');
    if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');

    this._chartView = this.options.chartView;
    this._torqueLayerModel = this.options.torqueLayerModel;
    this.viewModel = new Model();

    this._torqueLayerModel.bind('change:step', this._onChangeStep, this);
    this._torqueLayerModel.bind('change:steps', this._onChangeSteps, this);
    this._torqueLayerModel.bind('change:stepsRange', this._onStepsRange, this);
    this.add_related_model(this._torqueLayerModel);

    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this._chartView.model.bind('change:height', this._onChangeChartHeight, this);
    this.add_related_model(this._chartView.model);

    this._updateXScale();
  },

  render: function() {
    // Make the render call idempotent; only create time slider once
    if (!this.timeSlider) {
      var dragBehavior = d3.behavior.drag()
        .on('dragstart', this._onDragStart.bind(this))
        .on('drag', this._onDrag.bind(this))
        .on('dragend', this._onDragEnd.bind(this));

      this.timeSlider = this._chartView.canvas.append('rect')
        .attr('class', 'CDB-TimeSlider')
        .attr('width', this.defaults.width)
        .attr('height', this._calcHeight())
        .attr('rx', 3)
        .attr('ry', 3)
        .data([{ x: 0, y: 0 }])
        .attr('transform', this._translateXY)
        .call(dragBehavior);
    }

    return this;
  },

  clean: function() {
    if (this.timeSlider) {
      this.timeSlider.remove();
    }
    View.prototype.clean.call(this);
  },

  _onDragStart: function() {
    var isRunning = this._torqueLayerModel.get('isRunning');
    if (isRunning) {
      this._torqueLayerModel.pause();
    }
    this.viewModel.set({
      isDragging: true,
      wasRunning: isRunning
    });
  },

  _onDrag: function(d, i) {
    var nextX = d.x + d3.event.dx;
    if (this._isWithinRange(nextX)) {
      d.x = nextX;
      this.timeSlider.attr('transform', this._translateXY);

      var step = Math.round(this._xScale.invert(d.x));
      this._torqueLayerModel.setStep(step);
    }
  },

  _onDragEnd: function() {
    this.viewModel.set('isDragging', false);
    if (this.viewModel.get('wasRunning')) {
      this._torqueLayerModel.play();
    }
  },

  _translateXY: function(d) {
    return 'translate(' + [d.x, d.y] + ')';
  },

  _isWithinRange: function(x) {
    return x >= 0 && x <= this._width();
  },

  _onChangeStep: function() {
    // Time slider might not be created when this method is first called
    if (this.timeSlider && !this.viewModel.get('isDragging')) {
      var data = this.timeSlider.data();
      var newX = this._xScale(this._torqueLayerModel.get('step'));
      if (!isNaN(newX)) {
        data[0].x = newX;
        this.timeSlider
          .data(data)
          .transition()
          .ease('linear')
          .attr('transform', this._translateXY);
      }
    }
  },

  _onChangeSteps: function() {
    this._updateXScale();
  },

  _onStepsRange: function() {
    var r = this._torqueLayerModel.get('stepsRange');
    if (r.start === 0 && r.end === this.model.get('bins')) {
      this._chartView.removeSelection();
    } else {
      this._chartView.selectRange(r.start, r.end);
    }
  },

  _onChangeChartWidth: function() {
    this._updateXScale();
    this._onChangeStep();
  },

  _onChangeChartHeight: function() {
    this.timeSlider.attr('height', this._calcHeight());
  },

  _calcHeight: function() {
    return this._chartView.chartHeight() + this.defaults.height;
  },

  _updateXScale: function() {
    this._xScale = d3.scale.linear()
      .domain([0, this._torqueLayerModel.get('steps')])
      .range([0, this._width()]);
  },

  _width: function() {
    return this._chartView.model.get('width');
  }
});

},{}],101:[function(require,module,exports){
var _ = cdb._;

var WidgetModelFactory = function (types) {
  types = types || {};
  this.types = {};
  for (var type in types) {
    var createModel = types[type];
    this.addType(type, createModel);
  }
};

WidgetModelFactory.prototype.addType = function (type, createModel) {
  if (!_.isString(type)) new Error('type must be a string or a function');
  if (!_.isFunction(createModel)) new Error('createModel must be a function');
  this.types[type] = createModel;
};

WidgetModelFactory.prototype.createModel = function (layer, layerIndex, attrs) {
  if (!attrs.id) throw new Error('attrs.id is required');

  var createModel = this.types[attrs.type];
  if (createModel) {
    var opts = {
      layer: layer
    };
    return createModel(attrs, opts, layerIndex);
  } else {
    throw new Error('no model found for arguments ' + arguments);
  }
};

module.exports = WidgetModelFactory;

},{}],102:[function(require,module,exports){
var View = cdb.core.View;
var _ = cdb._;

/**
 * Standard widget tooltip view
 *
 */
module.exports = View.extend({

  className: 'CDB-Widget-tooltip',

  options: {
    attribute: 'data-tooltip',
    offsetX: 10,
    offsetY: -28
  },

  initialize: function(opts) {
    if (!opts.target) {
      throw new Error('target is not defined');
    }
    this._$target = this.options.target;
    this._initBinds();
  },

  render: function() {
    var value = this._$target.attr(this.options.attribute);
    this.$el.html(value);
    return this;
  },

  _initBinds: function() {
    this._$target.hover(
      _.bind(this.show, this),
      _.bind(this.hide, this)
    );
  },

  _setPosition: function() {
    var pos = this._$target.offset();
    var width = this.$el.outerWidth();

    this.$el.css({
      top: pos.top + this.options.offsetY,
      left: pos.left - (width/2) + this.options.offsetX
    });
  },

  show: function() {
    this.render();
    this._setPosition();
    View.prototype.show.call(this);
  },

  clean: function() {
    this._$target.off('mouseenter mouseleave');
    View.prototype.clean.call(this);
  }

});

},{}],103:[function(require,module,exports){
var _ = cdb._;
var WidgetView = require('./widget-view');

var WidgetViewFactory = function(defs) {
  this.defs = [];
  _.each(defs, function(def) {
    this.addType(def);
  }, this);
};

WidgetViewFactory.prototype.DEFAULT_CLASS_NAMES = 'CDB-Widget CDB-Widget--light';

WidgetViewFactory.prototype.addType = function(def) {
  if (!def.match) {
    if (def.type) {
      def.match = function(widget) {
        return widget.get('type') === this.type;
      };
    } else {
      new Error('def.type or def.match must be provided for createContentView to work');
    }
  }
  if (!_.isFunction(def.createContentView)) new Error('def.createContentView must be a function');
  this.defs.push(def);
};

/**
 * @returns {Object, undefined} Returns nothing if there is not matching view for the given model
 */
WidgetViewFactory.prototype.createWidgetView = function(widget) {
  var def = _.find(this.defs, function(def) {
    return def.match(widget);
  });

  if (def) {
    var attrs = {
      className: this.DEFAULT_CLASS_NAMES,
      model: widget,
      contentView: def.createContentView(widget)
    };

    return new WidgetView(
      _.isFunction(def.customizeWidgetAttrs)
        ? def.customizeWidgetAttrs(attrs)
        : attrs
    );
  }
};

module.exports = WidgetViewFactory;

},{"./widget-view":104}],104:[function(require,module,exports){
var View = cdb.core.View;
var WidgetLoaderView = require('./standard/widget_loader_view');
var WidgetErrorView = require('./standard/widget_error_view');

/**
 * Default widget view
 * The model is a expected to be widget model
 */
module.exports = View.extend({

  className: 'CDB-Widget CDB-Widget--light',

  options: {
    columns_title: [],
    sync: true
  },

  initialize: function() {
    this.model.layer.bind('change:visible', this._onChangeLayerVisible, this);
  },

  render: function() {
    this._loader = new WidgetLoaderView({
      model: this.model
    });
    this.$el.append(this._loader.render().el);
    this.addView(this._loader);

    this._error = new WidgetErrorView({
      model: this.model
    });
    this.$el.append(this._error.render().el);
    this.addView(this._error);

    var contentView = this.options.contentView;
    this.$el.append(contentView.render().el);
    this.addView(contentView);

    return this;
  },

  _onChangeLayerVisible: function(layer) {
    // !! to force a boolean value, so only a true value actually shows the view
    this.$el.toggle(!!layer.get('visible'));
  }
});

},{"./standard/widget_error_view":87,"./standard/widget_loader_view":88}],105:[function(require,module,exports){
var Model = cdb.core.Model;

/**
 *  View model, special for widgets with search and collapse
 *  functionalities
 *
 */

module.exports = Model.extend({

  defaults: {
    search: false
  },

  toggleSearch: function() {
    this.set('search', !this.get('search'));
  },

  enableSearch: function() {
    this.set('search', true);
  },

  disableSearch: function() {
    this.set('search', false);
  },

  isSearchEnabled: function() {
    return this.get('search');
  }

});

},{}],106:[function(require,module,exports){
var Model = cdb.core.Model;

/**
 * Default widget model
 */
module.exports = Model.extend({

  defaults: {
    url: '',
    data: [],
    columns: [],
    sync: true,
    bbox: true,
    collapsed: false
  },

  url: function() {
    return this.get('url') + '?bbox=' + this.get('boundingBox');
  },

  initialize: function(attrs, opts) {
    opts = opts || {};

    this.layer = opts.layer;
    this.filter = opts.filter; // optional/might be undefined

    this._initBinds();
  },

  _initBinds: function() {
    this.once('change:url', function() {
      var self = this;
      this._fetch(function() {
        self._onChangeBinds();
      });
    }, this);

    // Retrigger an event when the filter changes
    if (this.filter) {
      this.filter.bind('change', this._onFilterChanged, this);
    }
  },

  _onChangeBinds: function() {
    this.bind('change:url', function(){
      if (this.get('sync') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);
    this.bind('change:boundingBox', function() {
      if (this.get('bbox') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:collapsed', function(mdl, isCollapsed) {
      if (!isCollapsed) {
        if (mdl.changedAttributes(this._previousAttrs)) {
          this._fetch();
        }
      } else {
        this._previousAttrs = {
          url: this.get('url'),
          boundingBox: this.get('boundingBox')
        };
      }
    }, this);
  },

  _fetch: function(callback) {
    var self = this;
    this.fetch({
      success: callback,
      error: function() {
        self.trigger('error');
      }
    });
  },

  refresh: function() {
    this._fetch();
  },

  isCollapsed: function() {
    return this.get('collapsed');
  },

  toggleCollapsed: function() {
    this.set('collapsed', !this.get('collapsed'));
  },

  _onFilterChanged: function(filter) {
    this.trigger('change:filter', this, filter);
  },

  getData: function() {
    return this.get('data');
  },

  getPreviousData: function() {
    return this.previous('data');
  },

  fetch: function(opts) {
    this.trigger("loading", this);
    return Model.prototype.fetch.call(this,opts);
  },

  toJSON: function() {
    throw new Error('toJSON should be defined for each widget');
  }
});

},{}],107:[function(require,module,exports){
var Backbone = cdb.Backbone;
var _ = cdb._;

/**
 *  Collection that controls widget models per layer
 *
 */
module.exports = Backbone.Collection.extend({

  initialize: function() {
    this._initBinds();
  },

  _initBinds: function() {
    // If a category model applies the category colors, rest should remove/disable
    // the category colors applied before.
    this.bind('change:categoryColors', function(m, isColorCategorized) {
      if (isColorCategorized) {
        this.each(function(mdl) {
          if (mdl !== m && mdl.get('categoryColors')) {
            mdl.set('categoryColors', false);
          }
        })
      }
    }, this);

    // If a histogram model applies the histogram sizes, rest should remove/disable
    // the sizes applied before.
    this.bind('change:histogramSizes', function(m, isSizesApplied) {
      if (isSizesApplied) {
        this.each(function(mdl) {
          if (mdl !== m && mdl.get('histogramSizes')) {
            mdl.set('histogramSizes', false);
          }
        })
      }
    }, this);
  }

});

},{}],108:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var LZMA = cdb.LZMA;
var util = cdb.core.util;
var WindshaftDashboardInstance = require('./dashboard-instance');

var validatePresenceOfOptions = function(options, requiredOptions) {
  var missingOptions = _.filter(requiredOptions, function(option) {
    return !options[option];
  });
  if (missingOptions.length) {
    throw 'The following options are required: ' + missingOptions.join(', ');
  }
};

/**
 * Windshaft client. It provides a method to create instances of dashboards.
 * @param {object} options Options to set up the client
 */
WindshaftClient = function(options) {
  validatePresenceOfOptions(options, ['urlTemplate', 'userName', 'endpoint', 'statTag']);

  this.urlTemplate = options.urlTemplate;
  this.userName = options.userName;
  this.endpoint = options.endpoint;
  this.statTag = options.statTag;
  this.forceCors = options.forceCors || false;

  this.url = this.urlTemplate.replace('{user}', this.userName);
};

WindshaftClient.DEFAULT_COMPRESSION_LEVEL = 3;
WindshaftClient.MAX_GET_SIZE = 2033;

/**
 * Creates an instance of a map in Windshaft
 * @param {object} mapDefinition An object that responds to .toJSON with the definition of the map
 * @param  {function} callback A callback that will get the public or private map
 * @return {cdb.windshaft.DashboardInstance} The instance of the dashboard
 */
WindshaftClient.prototype.instantiateMap = function(options) {
  var mapDefinition = options.mapDefinition;
  var filters = options.filters;
  var successCallback = options.success;
  var errorCallback = options.error;
  var payload = JSON.stringify(mapDefinition);

  var options = {
    success: function(data) {
      if (data.errors) {
        errorCallback(data.errors[0]);
      } else {
        data.urlTemplate = this.urlTemplate;
        data.userName = this.userName;
        successCallback(new WindshaftDashboardInstance(data));
      }
    }.bind(this),
    error: function(xhr) {
      var err = { errors: ['Unknown error'] };
      try {
        err = JSON.parse(xhr.responseText);
      } catch(e) {}
      errorCallback(err.errors[0]);
    }
  };

  // TODO: Move this
  var params = [
    ["stat_tag", this.statTag].join("=")
  ];

  var filters = filters || {};
  if (Object.keys(filters).length) {
    params.push(["filters", encodeURIComponent(JSON.stringify(filters))].join('='));
  }

  if (this._usePOST(payload, params)) {
    this._post(payload, params, options);
  } else {
    this._get(payload, params, options);
  }
}

WindshaftClient.prototype._usePOST = function(payload, params) {
  if (util.isCORSSupported() && this.forceCors) {
    return true;
  }
  return payload.length >= this.constructor.MAX_GET_SIZE;
}

WindshaftClient.prototype._post = function(payload, params, options) {
  $.ajax({
    crossOrigin: true,
    method: 'POST',
    dataType: 'json',
    contentType: 'application/json',
    url: this._getURL(params),
    data: payload,
    success: options.success,
    error: options.error
  });
}

WindshaftClient.prototype._get = function(payload, params, options) {
  var compressFunction = this._getCompressor(payload);
  compressFunction(payload, this.constructor.DEFAULT_COMPRESSION_LEVEL, function(dataParameter) {
    params.push(dataParameter);
    $.ajax({
      url: this._getURL(params),
      method: 'GET',
      dataType: 'jsonp',
      jsonpCallback: this._jsonpCallbackName(payload),
      cache: true,
      success: options.success,
      error: options.error
    });
  }.bind(this));
}

WindshaftClient.prototype._getCompressor = function(payload) {
  if (payload.length < this.constructor.MAX_GET_SIZE) {
    return function(data, level, callback) {
      callback("config=" + encodeURIComponent(data));
    };
  }

  return function(data, level, callback) {
    data = JSON.stringify({ config: data });
    LZMA.compress(data, level, function(encoded) {
      callback("lzma=" + encodeURIComponent(util.array2hex(encoded)));
    });
  };
}


WindshaftClient.prototype._getURL = function(params) {
  return [this.url, this.endpoint].join('/') + '?' + params.join('&');
}

WindshaftClient.prototype._jsonpCallbackName = function(payload) {
  return '_cdbc_' + util.uniqueCallbackName(payload);
}

module.exports = WindshaftClient;

},{"./dashboard-instance":110}],109:[function(require,module,exports){
var config = {};
config.MAPS_API_BASE_URL = 'api/v1/map'

module.exports = config;

},{}],110:[function(require,module,exports){
var _ = cdb._;
var Model = cdb.core.Model;
var WindshaftConfig = require('./config');
var EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";

module.exports = Model.extend({

  TILE_EXTENSIONS_BY_LAYER_TYPE: {
    'mapnik': '.png',
    'torque': '.json.torque'
  },

  initialize: function() {

    // TODO: What params are really used?
    this.pngParams = ['map_key', 'api_key', 'cache_policy', 'updated_at'];
    this.gridParams = ['map_key', 'api_key', 'cache_policy', 'updated_at'];
  },

  isLoaded: function() {
    return !!this.get('layergroupid');
  },

  getBaseURL: function(subhost) {
    return [
      this._getHost(subhost),
      WindshaftConfig.MAPS_API_BASE_URL,
      this._getMapId(),
    ].join('/');
  },

  _getMapId: function() {
    return this.get('layergroupid');
  },

  _getHost: function(subhost) {
    var userName = this.get('userName');
    var protocol = this._useHTTPS() ? 'https' : 'http';
    var subhost = subhost ? subhost + '.' : '';
    var host = this.get('urlTemplate').replace('{user}', userName);
    var cdnHost = this.get('cdn_url') && this.get('cdn_url')[protocol];
    if (cdnHost) {
      host = [protocol, '://', subhost, cdnHost, '/', userName].join('');
    }

    return host;
  },

  _useHTTPS: function() {
    return this.get('urlTemplate').indexOf('https') === 0;
  },

  getTiles: function(layerType, params) {
    var grids = [];
    var tiles = [];

    var pngParams = this._encodeParams(params, this.pngParams);
    var gridParams = this._encodeParams(params, this.gridParams);
    var subdomains = ['0', '1', '2', '3'];

    if(this._useHTTPS()) {
      subdomains = [''];
    }

    layerType = layerType || 'mapnik';

    var layerIndexes = this._getLayerIndexesByType(layerType);
    if (layerIndexes.length) {
      var gridTemplate = '/{z}/{x}/{y}';

      for(var i = 0; i < subdomains.length; ++i) {
        var subdomain = subdomains[i];
        var tileURLTemplate = [
          this.getBaseURL(subdomain),
          '/',
          layerIndexes.join(','),
          '/{z}/{x}/{y}',
          this.TILE_EXTENSIONS_BY_LAYER_TYPE[layerType],
          (pngParams ? "?" + pngParams: '')
        ].join('');

        tiles.push(tileURLTemplate);

        // for mapnik layers add grid json too
        if (layerType === 'mapnik') {
          for(var layer = 0; layer < this.get('metadata').layers.length; ++layer) {
            var index = this._getLayerIndexByType(layer, "mapnik");
            if (index >= 0) {
              var gridURLTemplate = [
                this.getBaseURL(subdomain),
                "/",
                index,
                gridTemplate,
                ".grid.json",
                (gridParams ? "?" + gridParams: '')
              ].join("");
              grids[layer] = grids[layer] || [];
              grids[layer].push(gridURLTemplate);
            }
          }
        }
      }
    } else {
      // TODO: Clients of this method should decide what to render if no layers are present
      tiles = [EMPTY_GIF];
    }

    this.urls = {
      tiles: tiles,
      grids: grids
    };
    return this.urls;
  },

  getLayerMeta: function(layerIndex) {
    var layerMeta = {};
    var layers = this.get('metadata') && this.get('metadata').layers;
    if (layers && layers[layerIndex]) {
        layerMeta = layers[layerIndex].meta || {};
    }
    return layerMeta;
  },

  _encodeParams: function(params, included) {
    if(!params) return '';
    var url_params = [];
    included = included || _.keys(params);
    for(var i in included) {
      var k = included[i];
      var p = params[k];
      if(p) {
        if (_.isArray(p)) {
          for (var j = 0, len = p.length; j < len; j++) {
            url_params.push(k + "[]=" + encodeURIComponent(p[j]));
          }
        } else {
          var q = encodeURIComponent(p);
          q = q.replace(/%7Bx%7D/g,"{x}").replace(/%7By%7D/g,"{y}").replace(/%7Bz%7D/g,"{z}");
          url_params.push(k + "=" + q);
        }
      }
    }
    return url_params.join('&');
  },

  /**
   * Returns the index of a layer of a given type, as the tiler kwows it.
   *
   * @param {string|array} types - Type or types of layers
   */
  _getLayerIndexesByType: function(types) {
    var layers = this.get('metadata') && this.get('metadata').layers;

    if (!layers) {
      return;
    }
    var layerIndexes = [];
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var isValidType = false;
      if (types && types.length > 0) {
        isValidType = types.indexOf(layer.type) != -1;
      }
      if (isValidType) {
        layerIndexes.push(i);
      }
    }
    return layerIndexes;
  },

  /**
   * Returns the index of a layer of a given type, as the tiler kwows it.
   *
   * @param {integer} index - number of layer of the specified type
   * @param {string} layerType - type of the layers
   */
  _getLayerIndexByType: function(index, layerType) {
    var layers = this.get('metadata') && this.get('metadata').layers;

    if (!layers) {
      return index;
    }

    var tilerLayerIndex = {};
    var j = 0;
    for (var i = 0; i < layers.length; i++) {
      if (layers[i].type == layerType) {
        tilerLayerIndex[j] = i;
        j++;
      }
    }
    if (tilerLayerIndex[index] === undefined) {
      return -1;
    }
    return tilerLayerIndex[index];
  },

  getWidgetURL: function(options) {
    var widgetId = options.widgetId;
    var protocol = options.protocol;
    var url;
    var layers = this.get('metadata') && this.get('metadata').layers;

    _.each(layers, function(layer) {
      var widgets = layer.widgets;
      for (var id in widgets) {
        if (widgetId === id) {
          url = widgets[id].url[protocol];
          return;
        }
      }
    });

    return url;
  }
});

},{"./config":109}],111:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WindshaftFiltersCollection = require('./filters/collection');
var WindshaftFiltersBoundingBoxFilter = require('./filters/bounding_box');
var WindshaftDashboardInstance = require('./dashboard-instance');

var WindshaftDashboard = function(options) {
  BOUNDING_BOX_FILTER_WAIT = 500;

  this.layerGroup = options.layerGroup;
  this.layers = new Backbone.Collection(options.layers);
  this.widgets = options.widgets;
  this.map = options.map;
  this.client = options.client;
  this.statTag = options.statTag;
  this.configGenerator = options.configGenerator;

  this.instance = new WindshaftDashboardInstance();

  this.map.bind('change:center change:zoom', _.debounce(this._boundingBoxChanged, BOUNDING_BOX_FILTER_WAIT), this);

  this.layers.bind('change', this._layerChanged, this);
  this.widgets.bind('change:filter', this._filterChanged, this);

  this._createInstance();
};

WindshaftDashboard.prototype._createInstance = function(options) {
  var options = options || {};

  var dashboardConfig = this.configGenerator.generate({
    layers: this.layers.models,
    widgets: this.widgets
  });


  var filtersFromVisibleLayers = this.widgets.chain()
    .filter(function(w) { return w.layer.isVisible() })
    .map(function(w) { return w.filter })
    .compact() // not all widgets have filters
    .value();

  var filters = new WindshaftFiltersCollection(filtersFromVisibleLayers);

  this.client.instantiateMap({
    mapDefinition: dashboardConfig,
    filters: filters.toJSON(),
    success: function(dashboardInstance) {

      // Update the dashboard instance with the attributes of the new one
      this.instance.set(dashboardInstance.toJSON());

      // TODO: Set the URL of the attributes service once it's available
      this.layerGroup && this.layerGroup.set({
        baseURL: dashboardInstance.getBaseURL(),
        urls: dashboardInstance.getTiles('mapnik')
      });

      // update other kind of layers too
      this.layers.each(function(layer, layerIndex) {
        if (layer.get('type') === 'torque') {
          layer.set('meta', dashboardInstance.getLayerMeta(layerIndex));
          layer.set('urls', dashboardInstance.getTiles('torque'));
        }
      });

      this._updateWidgetURLs({
        layerId: options.layerId
      });

    }.bind(this),
    error: function(error) {
      console.log('Error creating dashboard instance: ' + error);
    }
  });

  return this.instance;
};

WindshaftDashboard.prototype._boundingBoxChanged = function() {
  if (this.instance.isLoaded()) {
    this._updateWidgetURLs();
  }
};

WindshaftDashboard.prototype._updateWidgetURLs = function(options) {
  options = options || {};
  var boundingBoxFilter = new WindshaftFiltersBoundingBoxFilter(this.map.getViewBounds());
  var boundingBox = boundingBoxFilter.toString();
  var layerId = options.layerId;

  this.widgets.each(function(widget) {
    var url = this.instance.getWidgetURL({
      widgetId: widget.get('id'),
      protocol: 'http'
    });

    var layerMeta = widget.layer.get('meta') || {};
    var extraAttrs = {};
    if (layerMeta.steps && layerMeta.column_type && _.isNumber(layerMeta.start) && _.isNumber(layerMeta.end)) {
      extraAttrs = {
        bins: layerMeta.steps,
        columnType: layerMeta.column_type,
        start: layerMeta.start  / 1000,
        end:  layerMeta.end / 1000
      };
    }

    widget.set(_.extend({
      'url': url,
      'boundingBox': boundingBox
    }, extraAttrs), {
      silent: layerId && layerId !== widget.layer.get('id')
    });
  }, this);
};

WindshaftDashboard.prototype._filterChanged = function(w) {
  this._createInstance({
    layerId: w.layer.get('id')
  });
};

WindshaftDashboard.prototype._layerChanged = function(layer) {
  var layerId = layer.get('id');
  this._createInstance({
    layerId: layerId
  });
};

module.exports = WindshaftDashboard;

},{"./dashboard-instance":110,"./filters/bounding_box":113,"./filters/collection":115}],112:[function(require,module,exports){
var Model = cdb.core.Model;

module.exports = Model.extend({

  isEmpty: function() {
    throw "Filters must implement the .isEmpty method";
  },

  toJSON: function() {
    throw "Filters must implement the .toJSON method";
  }
});

},{}],113:[function(require,module,exports){
var Model = cdb.core.Model;

module.exports = Model.extend({

  initialize: function(bounds) {
    this.setBounds(bounds);
  },

  setBounds: function(bounds) {
    this.set({
      west: bounds[0][1],
      south: bounds[0][0],
      east: bounds[1][1],
      north: bounds[1][0]
    });
  },

  toString: function() {
    return [
      this.get('west'),
      this.get('south'),
      this.get('east'),
      this.get('north')
    ].join(',');
  }
});

},{}],114:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WindshaftFilterBase = require('./base');

/**
 *  Filter used by the category widget
 *
 */
module.exports = WindshaftFilterBase.extend({

  defaults: {
    rejectAll: false
  },

  initialize: function() {
    this.rejectedCategories = new Backbone.Collection();
    this.acceptedCategories = new Backbone.Collection();
    this._initBinds();
  },

  _initBinds: function() {
    this.rejectedCategories.bind('add remove', function() {
      this.set('rejectAll', false);
    }, this);
    this.acceptedCategories.bind('add remove', function() {
      this.set('rejectAll', false);
    }, this);
  },

  isEmpty: function() {
    return this.rejectedCategories.size() === 0 && this.acceptedCategories.size() === 0 && !this.get('rejectAll');
  },

  accept: function(values, applyFilter) {
    values = !_.isArray(values) ? [values] : values;
    var acceptedCount = this.acceptedCategories.size();

    _.each(values, function(value) {
      var d = { name: value };
      var rejectedMdls = this.rejectedCategories.where(d);
      var acceptedMdls = this.acceptedCategories.where(d);
      if (rejectedMdls.length > 0) {
        this.rejectedCategories.remove(rejectedMdls);
      }
      if (!acceptedMdls.length) {
        this.acceptedCategories.add(d);
      }
    }, this);

    if (applyFilter !== false) {
      this.applyFilter();
    }
  },

  acceptAll: function() {
    this.set('rejectAll', false);
    this.cleanFilter();
  },

  isAccepted: function(name) {
    return this.acceptedCategories.where({ name: name }).length > 0;
  },

  getAccepted: function() {
    return this.acceptedCategories;
  },

  reject: function(values, applyFilter) {
    values = !_.isArray(values) ? [values] : values;

    _.each(values, function(value) {
      var d = { name: value };
      var acceptedMdls = this.acceptedCategories.where(d);
      var rejectedMdls = this.rejectedCategories.where(d);
      if (acceptedMdls.length > 0) {
        this.acceptedCategories.remove(acceptedMdls);
      } else {
        if (!rejectedMdls.length) {
          this.rejectedCategories.add(d);
        }
      }
    }, this);

    if (applyFilter !== false) {
      this.applyFilter();
    }
  },

  isRejected: function(name) {
    var rejectCount = this.rejectedCategories.size();
    var acceptCount = this.acceptedCategories.size();
    if (this.rejectedCategories.where({ name: name }).length > 0) {
      return true;
    } else if (acceptCount > 0 && this.acceptedCategories.where({ name: name }).length === 0) {
      return true;
    } else if (this.get('rejectAll')) {
      return true;
    } else {
      return false;
    }
  },

  getRejected: function() {
    return this.rejectedCategories;
  },

  rejectAll: function() {
    this.set('rejectAll', true);
    this.cleanFilter();
  },

  cleanFilter: function(triggerChange) {
    this.acceptedCategories.reset();
    this.rejectedCategories.reset();
    if (triggerChange !== false) {
      this.applyFilter();
    }
  },

  applyFilter: function() {
    this.trigger('change', this);
  },

  toJSON: function() {
    var filter = {};
    var rejectCount = this.rejectedCategories.size();
    var acceptCount = this.acceptedCategories.size();
    var acceptedCats = {accept: _.pluck(this.acceptedCategories.toJSON(), 'name') };
    var rejectedCats = { reject: _.pluck(this.rejectedCategories.toJSON(), 'name') };

    if (this.get('rejectAll')) {
      filter = { accept: [] };
    } else if (acceptCount > 0) {
      filter = acceptedCats;
    } else if (rejectCount > 0 && acceptCount === 0) {
      filter = rejectedCats;
    }

    var json = {};
    json[this.get('widgetId')] = filter;

    return json;
  }
});

},{"./base":112}],115:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;

module.exports = Backbone.Collection.extend({

  toJSON: function() {
    var json = {};
    var activeFilters = this.getActiveFilters();
    if (activeFilters.length) {
      json.layers = [];
      _.each(activeFilters, function(filter) {
        if (!filter.isEmpty()) {
          var index = filter.get('layerIndex');
          if (json.layers[index]) {
            _.extend(json.layers[index],filter.toJSON());
          } else {
            json.layers[index] = filter.toJSON();
          }
        }
      });
      // fill the holes
      for (var i = 0; i < json.layers.length; ++i) {
        json.layers[i] = json.layers[i] || {};
      }
    }

    return json;
  },

  getActiveFilters: function() {
    return this.filter(function(filter) {
      return !filter.isEmpty();
    });
  }
});

},{}],116:[function(require,module,exports){
var _ = cdb._;
var WindshaftFilterBase = require('./base');

module.exports = WindshaftFilterBase.extend({

  isEmpty: function() {
    return _.isUndefined(this.get('min')) && _.isUndefined(this.get('max'));
  },

  setRange: function(min, max) {
    this.set({
      min: min,
      max: max
    });
  },

  unsetRange: function() {
    this.setRange(undefined, undefined);
  },

  toJSON: function() {
    var json = {};
    json[this.get('widgetId')] = {
      min: this.get('min'),
      max: this.get('max'),
      column_type: this.get('columnType')
    };

    return json;
  }
});

},{"./base":112}],117:[function(require,module,exports){
var _ = cdb._;
var WindshaftPrivateDashboardConfig = {};

WindshaftPrivateDashboardConfig.generate = function(options) {
  var layers = options.layers;
  var config = {};

  _.each(layers, function(layer, index){
    config['layer' + index] = layer.isVisible() ? 1 : 0;
  });

  // TODO: We should add the params
  // TODO: We should add the auth_token
  return config;
};

module.exports = WindshaftPrivateDashboardConfig;

},{}],118:[function(require,module,exports){
var _ = cdb._;
var WindshaftPublicDashboardConfig = {};

WindshaftPublicDashboardConfig.generate = function(options) {
  var layers = options.layers;
  var widgets = options.widgets;
  var config = { layers: [] };
  _.each(layers, function(layer) {
    if (layer.isVisible()) {
      var layerConfig = {
        type: layer.get('type').toLowerCase(),
        options: {
          sql: layer.get('sql'),
          cartocss: layer.get('cartocss'),
          cartocss_version: layer.get('cartocss_version'),
          interactivity: layer.getInteractiveColumnNames()
        }
      };
      if (layer.getInfowindowFieldNames().length) {
        layerConfig.options.attributes = {
          id: "cartodb_id",
          columns: layer.getInfowindowFieldNames()
        };
      }

      layerConfig.options.widgets = {};
      var layerId = layer.get('id');
      widgets.each(function(widget) {
        if (layerId === widget.layer.get('id')) {
          layerConfig.options.widgets[widget.get('id')] = widget.toJSON();
        }
      });
      config.layers.push(layerConfig);
    }
  });

  return config;
};

module.exports = WindshaftPublicDashboardConfig;

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvY2xhc3MuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9kb20uanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9ldmVudC1tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvZ3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2hlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2RlZmF1bHQtc2V0dGluZy5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL2NsaWNrLXJhaWwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL2RyYWctc2Nyb2xsYmFyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9rZXlib2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvbW91c2Utd2hlZWwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL25hdGl2ZS1zY3JvbGwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL3NlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvdG91Y2guanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9pbml0aWFsaXplLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaW5zdGFuY2VzLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vdXBkYXRlLWdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vdXBkYXRlLXNjcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL3VwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJzcmMvY3JlYXRlLWRhc2hib2FyZC5qcyIsInNyYy9kYXNoYm9hcmQtYmVsb3ctbWFwLXZpZXcuanMiLCJzcmMvZGFzaGJvYXJkLWluZm8tdmlldy5qcyIsInNyYy9kYXNoYm9hcmQtaW5mby12aWV3LnRwbCIsInNyYy9kYXNoYm9hcmQtc2lkZWJhci12aWV3LmpzIiwic3JjL2Rhc2hib2FyZC1zaWRlYmFyLnRwbCIsInNyYy9kYXNoYm9hcmQtdmlldy5qcyIsInNyYy9kYXNoYm9hcmQudHBsIiwic3JjL3dpZGdldHMvYW5pbWF0ZV92YWx1ZXMuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9jb250ZW50X3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2NvbnRlbnRfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3QvaXRlbS9pdGVtX2NsaWNrYWJsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vaXRlbV91bmNsaWNrYWJsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vaXRlbV92aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtL3NlYXJjaF9pdGVtX2NsaWNrYWJsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vc2VhcmNoX2l0ZW1fdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3QvaXRlbXNfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtc192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9zZWFyY2hfaXRlbXNfbm9fcmVzdWx0c190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L3NlYXJjaF9pdGVtc192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWwuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9tb2RlbHMvY2F0ZWdvcmllc19jb2xsZWN0aW9uLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2NhdGVnb3J5X2NvbG9ycy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L21vZGVscy9jYXRlZ29yeV9pdGVtX21vZGVsLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2NhdGVnb3J5X21vZGVsX3JhbmdlLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2xvY2tlZF9jYXRlZ29yaWVzX2NvbGxlY3Rpb24uanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9tb2RlbHMvc2VhcmNoX21vZGVsLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvb3B0aW9ucy9vcHRpb25zX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L29wdGlvbnMvb3B0aW9uc192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvcGFnaW5hdG9yL3BhZ2luYXRvcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9wYWdpbmF0b3IvcGFnaW5hdG9yX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9wYWdpbmF0b3Ivc2VhcmNoX3BhZ2luYXRvcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9wYWdpbmF0b3Ivc2VhcmNoX3BhZ2luYXRvcl92aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvc3RhdHMvY2F0c190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9zdGF0cy9zdGF0c190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9zdGF0cy9zdGF0c192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvdGl0bGUvc2VhcmNoX3RpdGxlX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L3RpdGxlL3NlYXJjaF90aXRsZV92aWV3LmpzIiwic3JjL3dpZGdldHMvZm9ybXVsYS9hbmltYXRpb25fdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvZm9ybXVsYS9jb250ZW50X3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9mb3JtdWxhL21vZGVsLmpzIiwic3JjL3dpZGdldHMvZm9ybXVsYS90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9jaGFydC5qcyIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9jb250ZW50LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vY29udGVudC50cGwiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vaGlzdG9ncmFtX3RpdGxlX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9oaXN0b2dyYW1fdGl0bGVfdmlldy5qcyIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9tb2RlbC5qcyIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9wbGFjZWhvbGRlci50cGwiLCJzcmMvd2lkZ2V0cy9saXN0L2NvbnRlbnRfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvbGlzdC9jb250ZW50X3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L2VkZ2VzX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L2l0ZW1fdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvbGlzdC9pdGVtX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L2l0ZW1zX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L21vZGVsLmpzIiwic3JjL3dpZGdldHMvbGlzdC9wYWdpbmF0b3Jfdmlldy5qcyIsInNyYy93aWRnZXRzL2xpc3QvcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvc3RhbmRhcmQvd2lkZ2V0X2NvbnRlbnRfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvc3RhbmRhcmQvd2lkZ2V0X2NvbnRlbnRfdmlldy5qcyIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9lcnJvcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9zdGFuZGFyZC93aWRnZXRfZXJyb3Jfdmlldy5qcyIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9sb2FkZXJfdmlldy5qcyIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9wbGFjZWhvbGRlcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy9jb250ZW50LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy9oaXN0b2dyYW0tdmlldy5qcyIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3BsYWNlaG9sZGVyLnRwbCIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS1jb250ZW50LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtY29udHJvbHMtdmlldy5qcyIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS1jb250cm9scy50cGwiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtaGlzdG9ncmFtLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXRpbWUtaW5mby12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXRpbWUtaW5mby50cGwiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtdGltZS1zbGlkZXItdmlldy5qcyIsInNyYy93aWRnZXRzL3dpZGdldC1tb2RlbC1mYWN0b3J5LmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0LXRvb2x0aXAtdmlldy5qcyIsInNyYy93aWRnZXRzL3dpZGdldC12aWV3LWZhY3RvcnkuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXQtdmlldy5qcyIsInNyYy93aWRnZXRzL3dpZGdldF9jb250ZW50X21vZGVsLmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0X21vZGVsLmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0cy1jb2xsZWN0aW9uLmpzIiwic3JjL3dpbmRzaGFmdC9jbGllbnQuanMiLCJzcmMvd2luZHNoYWZ0L2NvbmZpZy5qcyIsInNyYy93aW5kc2hhZnQvZGFzaGJvYXJkLWluc3RhbmNlLmpzIiwic3JjL3dpbmRzaGFmdC9kYXNoYm9hcmQuanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvYmFzZS5qcyIsInNyYy93aW5kc2hhZnQvZmlsdGVycy9ib3VuZGluZ19ib3guanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvY2F0ZWdvcnkuanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvY29sbGVjdGlvbi5qcyIsInNyYy93aW5kc2hhZnQvZmlsdGVycy9yYW5nZS5qcyIsInNyYy93aW5kc2hhZnQvcHJpdmF0ZS1kYXNoYm9hcmQtY29uZmlnLmpzIiwic3JjL3dpbmRzaGFmdC9wdWJsaWMtZGFzaGJvYXJkLWNvbmZpZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVEYXNoYm9hcmQ6IHJlcXVpcmUoJy4vc3JjL2NyZWF0ZS1kYXNoYm9hcmQnKVxufTtcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xMC42XG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIHV0aWxzX2hvb2tzX19ob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faXNBTW9tZW50T2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2kgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9mICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3N0cmljdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl90em0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faXNVVEMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX29mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9wZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2xvY2FsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZSgpIHtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXSB8fCBuZXcgTG9jYWxlKCk7XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHVuaXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHVuaXQgaW4gdW5pdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCh1bml0LCB1bml0c1t1bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1t1bml0c10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UXxZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKHN0aCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjMyNVxuICAgICAgICByZXR1cm4gdHlwZW9mIHN0aCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0aCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KS5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNbbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgaGVyZSFcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuXG4gICAgdmFyIGZyb21fc3RyaW5nX19pc29SZWdleCA9IC9eXFxzKig/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyhbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGR7Mn0tXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZHsyfS9dLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvKFR8IClcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvKFR8IClcXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGZyb21fc3RyaW5nX19pc29SZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzZdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mICs9IChtYXRjaFs2XSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2gobWF0Y2hPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9mICs9ICdaJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDA3IGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIGRvZXNuJ3QgYWNjZXB0IHllYXJzIDwgMTk3MFxuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gZmlyc3REYXlPZldlZWsgICAgICAgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBkYXkgb2YgdGhlIHdlZWsgdGhhdCBzdGFydHMgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAodXN1YWxseSBzdW5kYXkgb3IgbW9uZGF5KVxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3Qgd2VlayBpcyB0aGUgd2VlayB0aGF0IGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgZGF5IG9mIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKGVnLiBJU08gd2Vla3MgdXNlIHRodXJzZGF5ICg0KSlcbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZmlyc3REYXlPZldlZWssIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyKSB7XG4gICAgICAgIHZhciBlbmQgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBtb20uZGF5KCksXG4gICAgICAgICAgICBhZGp1c3RlZE1vbWVudDtcblxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPiBlbmQpIHtcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayAtPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA8IGVuZCAtIDcpIHtcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0ZWRNb21lbnQgPSBsb2NhbF9fY3JlYXRlTG9jYWwobW9tKS5hZGQoZGF5c1RvRGF5T2ZXZWVrLCAnZCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogTWF0aC5jZWlsKGFkanVzdGVkTW9tZW50LmRheU9mWWVhcigpIC8gNyksXG4gICAgICAgICAgICB5ZWFyOiBhZGp1c3RlZE1vbWVudC55ZWFyKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZmlyc3REYXlPZldlZWtPZlllYXIsIGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICAgIHZhciB3ZWVrMUphbiA9IDYgKyBmaXJzdERheU9mV2VlayAtIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBqYW5YID0gY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCAxICsgd2VlazFKYW4pLCBkID0gamFuWC5nZXRVVENEYXkoKSwgZGF5T2ZZZWFyO1xuICAgICAgICBpZiAoZCA8IGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICAgICAgICBkICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICB3ZWVrZGF5ID0gd2Vla2RheSAhPSBudWxsID8gMSAqIHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcblxuICAgICAgICBkYXlPZlllYXIgPSAxICsgd2VlazFKYW4gKyA3ICogKHdlZWsgLSAxKSAtIGQgKyB3ZWVrZGF5O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiBkYXlPZlllYXIgPiAwID8geWVhciA6IHllYXIgLSAxLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiBkYXlPZlllYXIgPiAwID8gIGRheU9mWWVhciA6IGRheXNJblllYXIoeWVhciAtIDEpICsgZGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3cuZ2V0VVRDRnVsbFllYXIoKSwgbm93LmdldFVUQ01vbnRoKCksIG5vdy5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcDtcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCBkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgKyt3ZWVrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRveSwgZG93KTtcblxuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gdXRpbHNfaG9va3NfX2hvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF07XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbF9fY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICB9XG4gICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDM2ZTU7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICgoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaE9mZnNldCkgfHwgW10pO1xuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkpIC0gKCtyZXMpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUoK3Jlcy5fZCArIGRpZmYpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQob2Zmc2V0RnJvbVN0cmluZyh0aGlzLl9pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pc0RTVFNoaWZ0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faXNVVEM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwO1xuICAgIH1cblxuICAgIHZhciBhc3BOZXRSZWdleCA9IC8oXFwtKT8oPzooXFxkKilcXC4pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKVxcLj8oXFxkezN9KT8pPy87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICB2YXIgY3JlYXRlX19pc29SZWdleCA9IC9eKC0pP1AoPzooPzooWzAtOSwuXSopWSk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilEKT8oPzpUKD86KFswLTksLl0qKUgpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopUyk/KT98KFswLTksLl0qKVcpJC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBjcmVhdGVfX2lzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGR1cmF0aW9uLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gZHVyYXRpb24uX21vbnRocztcbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKCttb20uX2QgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIGdldF9zZXRfX3NldChtb20sICdEYXRlJywgZ2V0X3NldF9fZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXRfc2V0X19nZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBsb2NhbF9fY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZihzb2QsICdkYXlzJywgdHJ1ZSksXG4gICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZm9ybWF0cyAmJiBmb3JtYXRzW2Zvcm1hdF0gfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBsb2NhbF9fY3JlYXRlTG9jYWwobm93KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzID4gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0TXMgPCArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA8ICtpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBpc01vbWVudChpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSA8IGlucHV0TXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSAmJiB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPT09ICtpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArKHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9ICsodGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpLFxuICAgICAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNCxcbiAgICAgICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KTtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nIHx8IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gK3RoaXMuX2QgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoW3llYXIsIDExLCAzMSArIGRvdyAtIGRveV0pLCBkb3csIGRveSkud2VlaztcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KS55ZWFyO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsIDAsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIG1hdGNoV29yZCk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IHRoaXMuX3dlZWtkYXlzUGFyc2UgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICBtb20gPSBsb2NhbF9fY3JlYXRlTG9jYWwoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gdGhpcy5kYXkoKSB8fCA3IDogdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyBpbnB1dCA6IGlucHV0IC0gNyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgID0gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNsb25lICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICA9IGVuZE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZm9ybWF0ICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICA9IGZyb21Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50byAgICAgICAgICAgPSB0bztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICA9IHRvTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgID0gZ2V0U2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaW52YWxpZEF0ICAgID0gaW52YWxpZEF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgID0gaXNBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICA9IGlzQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZXR3ZWVuICAgID0gaXNCZXR3ZWVuO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgID0gaXNTYW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgID0gbGFuZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICA9IGxvY2FsZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICA9IGxvY2FsZURhdGE7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW4gICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdGFydE9mICAgICAgPSBzdGFydE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICA9IHRvQXJyYXk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b09iamVjdCAgICAgPSB0b09iamVjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgPSB0b190eXBlX192YWx1ZU9mO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuICAgIC8vIFRpbWV6b25lXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNzc5JywgZ2V0U2V0Wm9uZSk7XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlID0gbW9tZW50UHJvdG90eXBlX19wcm90bztcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9zZXRfX3NldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZV9fcHJvdG8gPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG90eXBlX19wcm90by5fY2FsZW5kYXIgICAgICAgPSBkZWZhdWx0Q2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgPSBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2xvbmdEYXRlRm9ybWF0ID0gZGVmYXVsdExvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5faW52YWxpZERhdGUgICAgPSBkZWZhdWx0SW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsICAgICAgICA9IGRlZmF1bHRPcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsUGFyc2UgICA9IGRlZmF1bHRPcmRpbmFsUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fcmVsYXRpdmVUaW1lICAgPSBkZWZhdWx0UmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHMgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydCAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnQgPSBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrID0gZGVmYXVsdExvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5cyAgICAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNNaW4gICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIC8vIEhvdXJzXG4gICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tZXJpZGllbVBhcnNlID0gZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIGNvdW50LCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRocycsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzID09PSAxICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA9PT0gMSAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPT09IDEgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgID09PSAxICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA9PT0gMSAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBpc29fc3RyaW5nX19hYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgdmFyIHNlY29uZHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoWSA/IFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb25fcHJvdG90eXBlX19wcm90byA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWJzICAgICAgICAgICAgPSBkdXJhdGlvbl9hYnNfX2FicztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICA9IGR1cmF0aW9uX2FzX192YWx1ZU9mO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICA9IGR1cmF0aW9uX2dldF9fZ2V0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgaXNvX3N0cmluZ19fdG9JU09TdHJpbmcpO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICB1dGlsc19ob29rc19faG9va3MudmVyc2lvbiA9ICcyLjEwLjYnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGxvY2FsX19jcmVhdGVMb2NhbCk7XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICB1dGlsc19ob29rc19faG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVJblpvbmU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICB1dGlsc19ob29rc19faG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcblxuICAgIHZhciBfbW9tZW50ID0gdXRpbHNfaG9va3NfX2hvb2tzO1xuXG4gICAgcmV0dXJuIF9tb21lbnQ7XG5cbn0pKTsiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvanMvbWFpbicpO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvbGRBZGQoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICB9XG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIG9sZFJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgdmFyIGNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICB2YXIgaWR4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIGNsYXNzZXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cbiAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbn1cblxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIG9sZEFkZChlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9XG59O1xuXG5leHBvcnRzLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgb2xkUmVtb3ZlKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gIH1cbn07XG5cbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWxlbWVudC5jbGFzc0xpc3QpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICB9XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NID0ge307XG5cbkRPTS5lID0gZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSkge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbkRPTS5hcHBlbmRUbyA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG4gIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIHJldHVybiBjaGlsZDtcbn07XG5cbmZ1bmN0aW9uIGNzc0dldChlbGVtZW50LCBzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3N0eWxlTmFtZV07XG59XG5cbmZ1bmN0aW9uIGNzc1NldChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHN0eWxlVmFsdWUgPSBzdHlsZVZhbHVlLnRvU3RyaW5nKCkgKyAncHgnO1xuICB9XG4gIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjc3NNdWx0aVNldChlbGVtZW50LCBvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbC50b1N0cmluZygpICsgJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtrZXldID0gdmFsO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5ET00uY3NzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0LCBzdHlsZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGVOYW1lT3JPYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gbXVsdGlwbGUgc2V0IHdpdGggb2JqZWN0XG4gICAgcmV0dXJuIGNzc011bHRpU2V0KGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY3NzR2V0KGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNzc1NldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCwgc3R5bGVWYWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5ET00ubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBxdWVyeSkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQubWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHF1ZXJ5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvcihxdWVyeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcihxdWVyeSk7XG4gICAgfVxuICB9XG59O1xuXG5ET00ucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LnJlbW92ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbkRPTS5xdWVyeUNoaWxkcmVuID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gRE9NLm1hdGNoZXMoY2hpbGQsIHNlbGVjdG9yKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuZXZlbnRzID0ge307XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gIH1cbiAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RWxlbWVudC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICB2YXIgaXNIYW5kbGVyUHJvdmlkZWQgPSAodHlwZW9mIGhhbmRsZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChoZGxyKSB7XG4gICAgaWYgKGlzSGFuZGxlclByb3ZpZGVkICYmIGhkbHIgIT09IGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhkbHIsIGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIHRoaXMpO1xufTtcblxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcbiAgICB0aGlzLnVuYmluZChuYW1lKTtcbiAgfVxufTtcblxudmFyIEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLmV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBlZSA9IHRoaXMuZXZlbnRFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50RWxlbWVudCkge1xuICAgIHJldHVybiBldmVudEVsZW1lbnQuZWxlbWVudCA9PT0gZWxlbWVudDtcbiAgfSlbMF07XG4gIGlmICh0eXBlb2YgZWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWUgPSBuZXcgRXZlbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgIHRoaXMuZXZlbnRFbGVtZW50cy5wdXNoKGVlKTtcbiAgfVxuICByZXR1cm4gZWU7XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpLmJpbmQoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICB0aGlzLmV2ZW50RWxlbWVudChlbGVtZW50KS51bmJpbmQoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuZXZlbnRFbGVtZW50c1tpXS51bmJpbmRBbGwoKTtcbiAgfVxufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICB2YXIgZWUgPSB0aGlzLmV2ZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIG9uY2VIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlZS51bmJpbmQoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XG4gICAgaGFuZGxlcihlKTtcbiAgfTtcbiAgZWUuYmluZChldmVudE5hbWUsIG9uY2VIYW5kbGVyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRNYW5hZ2VyO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHM0KCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKVxuICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcbiAgICAgICAgICAgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcbiAgfTtcbn0pKCk7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbHMgPSByZXF1aXJlKCcuL2NsYXNzJylcbiAgLCBkID0gcmVxdWlyZSgnLi9kb20nKTtcblxuZXhwb3J0cy50b0ludCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBwYXJzZUludCh4LCAxMCkgfHwgMDtcbn07XG5cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHRoaXMuY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBzb3VyY2UpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUob3JpZ2luYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgcmVzdWx0W2tleV0gPSB0aGlzLmNsb25lKHNvdXJjZVtrZXldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5pc0VkaXRhYmxlID0gZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBkLm1hdGNoZXMoZWwsIFwiaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHxcbiAgICAgICAgIGQubWF0Y2hlcyhlbCwgXCJzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHxcbiAgICAgICAgIGQubWF0Y2hlcyhlbCwgXCJ0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXVwiKSB8fFxuICAgICAgICAgZC5tYXRjaGVzKGVsLCBcImJ1dHRvbixbY29udGVudGVkaXRhYmxlXVwiKTtcbn07XG5cbmV4cG9ydHMucmVtb3ZlUHNDbGFzc2VzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGNsc0xpc3QgPSBjbHMubGlzdChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGNsc0xpc3RbaV07XG4gICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKCdwcy0nKSA9PT0gMCkge1xuICAgICAgY2xzLnJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5vdXRlcldpZHRoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ3dpZHRoJykpICtcbiAgICAgICAgIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ3BhZGRpbmdMZWZ0JykpICtcbiAgICAgICAgIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ3BhZGRpbmdSaWdodCcpKSArXG4gICAgICAgICB0aGlzLnRvSW50KGQuY3NzKGVsZW1lbnQsICdib3JkZXJMZWZ0V2lkdGgnKSkgK1xuICAgICAgICAgdGhpcy50b0ludChkLmNzcyhlbGVtZW50LCAnYm9yZGVyUmlnaHRXaWR0aCcpKTtcbn07XG5cbmV4cG9ydHMuc3RhcnRTY3JvbGxpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcykge1xuICBjbHMuYWRkKGVsZW1lbnQsICdwcy1pbi1zY3JvbGxpbmcnKTtcbiAgaWYgKHR5cGVvZiBheGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLScgKyBheGlzKTtcbiAgfSBlbHNlIHtcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy14Jyk7XG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMteScpO1xuICB9XG59O1xuXG5leHBvcnRzLnN0b3BTY3JvbGxpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcykge1xuICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy1pbi1zY3JvbGxpbmcnKTtcbiAgaWYgKHR5cGVvZiBheGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLScgKyBheGlzKTtcbiAgfSBlbHNlIHtcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy14Jyk7XG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMteScpO1xuICB9XG59O1xuXG5leHBvcnRzLmVudiA9IHtcbiAgaXNXZWJLaXQ6ICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gIHN1cHBvcnRzVG91Y2g6ICgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6IHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyAhPT0gbnVsbFxufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlc3Ryb3kgPSByZXF1aXJlKCcuL3BsdWdpbi9kZXN0cm95JylcbiAgLCBpbml0aWFsaXplID0gcmVxdWlyZSgnLi9wbHVnaW4vaW5pdGlhbGl6ZScpXG4gICwgdXBkYXRlID0gcmVxdWlyZSgnLi9wbHVnaW4vdXBkYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0aWFsaXplOiBpbml0aWFsaXplLFxuICB1cGRhdGU6IHVwZGF0ZSxcbiAgZGVzdHJveTogZGVzdHJveVxufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heFNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiAwLFxuICBzdG9wUHJvcGFnYXRpb25PbkNsaWNrOiB0cnVlLFxuICBzdXBwcmVzc1Njcm9sbFg6IGZhbHNlLFxuICBzdXBwcmVzc1Njcm9sbFk6IGZhbHNlLFxuICBzd2lwZVByb3BhZ2F0aW9uOiB0cnVlLFxuICB1c2VCb3RoV2hlZWxBeGVzOiBmYWxzZSxcbiAgdXNlS2V5Ym9hcmQ6IHRydWUsXG4gIHVzZVNlbGVjdGlvblNjcm9sbDogZmFsc2UsXG4gIHdoZWVsUHJvcGFnYXRpb246IGZhbHNlLFxuICB3aGVlbFNwZWVkOiAxXG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcblxuICBpZiAoIWkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpLmV2ZW50LnVuYmluZEFsbCgpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhclgpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhclkpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhclhSYWlsKTtcbiAgZC5yZW1vdmUoaS5zY3JvbGxiYXJZUmFpbCk7XG4gIGgucmVtb3ZlUHNDbGFzc2VzKGVsZW1lbnQpO1xuXG4gIGluc3RhbmNlcy5yZW1vdmUoZWxlbWVudCk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gYmluZENsaWNrUmFpbEhhbmRsZXIoZWxlbWVudCwgaSkge1xuICBmdW5jdGlvbiBwYWdlT2Zmc2V0KGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIHZhciBzdG9wUHJvcGFnYXRpb24gPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5iaW5kO1xuXG4gIGlmIChpLnNldHRpbmdzLnN0b3BQcm9wYWdhdGlvbk9uQ2xpY2spIHtcbiAgICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZLCAnY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xuICB9XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhcllSYWlsLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBoYWxmT2ZTY3JvbGxiYXJMZW5ndGggPSBoLnRvSW50KGkuc2Nyb2xsYmFyWUhlaWdodCAvIDIpO1xuICAgIHZhciBwb3NpdGlvblRvcCA9IGkucmFpbFlSYXRpbyAqIChlLnBhZ2VZIC0gd2luZG93LnNjcm9sbFkgLSBwYWdlT2Zmc2V0KGkuc2Nyb2xsYmFyWVJhaWwpLnRvcCAtIGhhbGZPZlNjcm9sbGJhckxlbmd0aCk7XG4gICAgdmFyIG1heFBvc2l0aW9uVG9wID0gaS5yYWlsWVJhdGlvICogKGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpO1xuICAgIHZhciBwb3NpdGlvblJhdGlvID0gcG9zaXRpb25Ub3AgLyBtYXhQb3NpdGlvblRvcDtcblxuICAgIGlmIChwb3NpdGlvblJhdGlvIDwgMCkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDA7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblJhdGlvID4gMSkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDE7XG4gICAgfVxuXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCAoaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpICogcG9zaXRpb25SYXRpbyk7XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcblxuICBpZiAoaS5zZXR0aW5ncy5zdG9wUHJvcGFnYXRpb25PbkNsaWNrKSB7XG4gICAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWCwgJ2NsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcbiAgfVxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYUmFpbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoID0gaC50b0ludChpLnNjcm9sbGJhclhXaWR0aCAvIDIpO1xuICAgIHZhciBwb3NpdGlvbkxlZnQgPSBpLnJhaWxYUmF0aW8gKiAoZS5wYWdlWCAtIHdpbmRvdy5zY3JvbGxYIC0gcGFnZU9mZnNldChpLnNjcm9sbGJhclhSYWlsKS5sZWZ0IC0gaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoKTtcbiAgICB2YXIgbWF4UG9zaXRpb25MZWZ0ID0gaS5yYWlsWFJhdGlvICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKTtcbiAgICB2YXIgcG9zaXRpb25SYXRpbyA9IHBvc2l0aW9uTGVmdCAvIG1heFBvc2l0aW9uTGVmdDtcblxuICAgIGlmIChwb3NpdGlvblJhdGlvIDwgMCkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDA7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblJhdGlvID4gMSkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDE7XG4gICAgfVxuXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgKChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpICogcG9zaXRpb25SYXRpbykgLSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCk7XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmRDbGlja1JhaWxIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSByZXF1aXJlKCcuLi8uLi9saWIvZG9tJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBiaW5kTW91c2VTY3JvbGxYSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIHZhciBjdXJyZW50TGVmdCA9IG51bGw7XG4gIHZhciBjdXJyZW50UGFnZVggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbExlZnQoZGVsdGFYKSB7XG4gICAgdmFyIG5ld0xlZnQgPSBjdXJyZW50TGVmdCArIChkZWx0YVggKiBpLnJhaWxYUmF0aW8pO1xuICAgIHZhciBtYXhMZWZ0ID0gaS5zY3JvbGxiYXJYUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgKGkucmFpbFhSYXRpbyAqIChpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCkpO1xuXG4gICAgaWYgKG5ld0xlZnQgPCAwKSB7XG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gMDtcbiAgICB9IGVsc2UgaWYgKG5ld0xlZnQgPiBtYXhMZWZ0KSB7XG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gbWF4TGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaS5zY3JvbGxiYXJYTGVmdCA9IG5ld0xlZnQ7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbExlZnQgPSBoLnRvSW50KGkuc2Nyb2xsYmFyWExlZnQgKiAoaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSAvIChpLmNvbnRhaW5lcldpZHRoIC0gKGkucmFpbFhSYXRpbyAqIGkuc2Nyb2xsYmFyWFdpZHRoKSkpIC0gaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQ7XG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jywgc2Nyb2xsTGVmdCk7XG4gIH1cblxuICB2YXIgbW91c2VNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdXBkYXRlU2Nyb2xsTGVmdChlLnBhZ2VYIC0gY3VycmVudFBhZ2VYKTtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaC5zdG9wU2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gIH07XG5cbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgY3VycmVudFBhZ2VYID0gZS5wYWdlWDtcbiAgICBjdXJyZW50TGVmdCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYLCAnbGVmdCcpKSAqIGkucmFpbFhSYXRpbztcbiAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XG5cbiAgICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gICAgaS5ldmVudC5vbmNlKGkub3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJpbmRNb3VzZVNjcm9sbFlIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgdmFyIGN1cnJlbnRUb3AgPSBudWxsO1xuICB2YXIgY3VycmVudFBhZ2VZID0gbnVsbDtcblxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxUb3AoZGVsdGFZKSB7XG4gICAgdmFyIG5ld1RvcCA9IGN1cnJlbnRUb3AgKyAoZGVsdGFZICogaS5yYWlsWVJhdGlvKTtcbiAgICB2YXIgbWF4VG9wID0gaS5zY3JvbGxiYXJZUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyAoaS5yYWlsWVJhdGlvICogKGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpKTtcblxuICAgIGlmIChuZXdUb3AgPCAwKSB7XG4gICAgICBpLnNjcm9sbGJhcllUb3AgPSAwO1xuICAgIH0gZWxzZSBpZiAobmV3VG9wID4gbWF4VG9wKSB7XG4gICAgICBpLnNjcm9sbGJhcllUb3AgPSBtYXhUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkuc2Nyb2xsYmFyWVRvcCA9IG5ld1RvcDtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsVG9wID0gaC50b0ludChpLnNjcm9sbGJhcllUb3AgKiAoaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpIC8gKGkuY29udGFpbmVySGVpZ2h0IC0gKGkucmFpbFlSYXRpbyAqIGkuc2Nyb2xsYmFyWUhlaWdodCkpKTtcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIHNjcm9sbFRvcCk7XG4gIH1cblxuICB2YXIgbW91c2VNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdXBkYXRlU2Nyb2xsVG9wKGUucGFnZVkgLSBjdXJyZW50UGFnZVkpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBoLnN0b3BTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcbiAgICBpLmV2ZW50LnVuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgfTtcblxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBjdXJyZW50UGFnZVkgPSBlLnBhZ2VZO1xuICAgIGN1cnJlbnRUb3AgPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWSwgJ3RvcCcpKSAqIGkucmFpbFlSYXRpbztcbiAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XG5cbiAgICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gICAgaS5ldmVudC5vbmNlKGkub3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kTW91c2VTY3JvbGxYSGFuZGxlcihlbGVtZW50LCBpKTtcbiAgYmluZE1vdXNlU2Nyb2xsWUhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gYmluZEtleWJvYXJkSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIHZhciBob3ZlcmVkID0gZmFsc2U7XG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBob3ZlcmVkID0gdHJ1ZTtcbiAgfSk7XG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBob3ZlcmVkID0gZmFsc2U7XG4gIH0pO1xuXG4gIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGlmIChkZWx0YVggPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJZQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApIHx8IChzY3JvbGxUb3AgPj0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQgJiYgZGVsdGFZIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgaWYgKGRlbHRhWSA9PT0gMCkge1xuICAgICAgaWYgKCFpLnNjcm9sbGJhclhBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChzY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApIHx8IChzY3JvbGxMZWZ0ID49IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCAmJiBkZWx0YVggPiAwKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkICYmIGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhvdmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogaS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIC8vIGdvIGRlZXBlciBpZiBlbGVtZW50IGlzIGEgd2ViY29tcG9uZW50XG4gICAgICB3aGlsZSAoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGlmIChoLmlzRWRpdGFibGUoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWx0YVggPSAwO1xuICAgIHZhciBkZWx0YVkgPSAwO1xuXG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgY2FzZSAzNzogLy8gbGVmdFxuICAgICAgZGVsdGFYID0gLTMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzODogLy8gdXBcbiAgICAgIGRlbHRhWSA9IDMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOTogLy8gcmlnaHRcbiAgICAgIGRlbHRhWCA9IDMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0MDogLy8gZG93blxuICAgICAgZGVsdGFZID0gLTMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzMzogLy8gcGFnZSB1cFxuICAgICAgZGVsdGFZID0gOTA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDMyOiAvLyBzcGFjZSBiYXJcbiAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIGRlbHRhWSA9IDkwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGFZID0gLTkwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzNDogLy8gcGFnZSBkb3duXG4gICAgICBkZWx0YVkgPSAtOTA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM1OiAvLyBlbmRcbiAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgZGVsdGFZID0gLWkuY29udGVudEhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhWSA9IC1pLmNvbnRhaW5lckhlaWdodDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzY6IC8vIGhvbWVcbiAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgZGVsdGFZID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YVkgPSBpLmNvbnRhaW5lckhlaWdodDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCAtIGRlbHRhWSk7XG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0ICsgZGVsdGFYKTtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcblxuICAgIHNob3VsZFByZXZlbnQgPSBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZEtleWJvYXJkSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBiaW5kTW91c2VXaGVlbEhhbmRsZXIoZWxlbWVudCwgaSkge1xuICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGlmIChkZWx0YVggPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJZQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApIHx8IChzY3JvbGxUb3AgPj0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQgJiYgZGVsdGFZIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgaWYgKGRlbHRhWSA9PT0gMCkge1xuICAgICAgaWYgKCFpLnNjcm9sbGJhclhBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChzY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApIHx8IChzY3JvbGxMZWZ0ID49IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCAmJiBkZWx0YVggPiAwKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWx0YUZyb21FdmVudChlKSB7XG4gICAgdmFyIGRlbHRhWCA9IGUuZGVsdGFYO1xuICAgIHZhciBkZWx0YVkgPSAtMSAqIGUuZGVsdGFZO1xuXG4gICAgaWYgKHR5cGVvZiBkZWx0YVggPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGRlbHRhWSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gT1MgWCBTYWZhcmlcbiAgICAgIGRlbHRhWCA9IC0xICogZS53aGVlbERlbHRhWCAvIDY7XG4gICAgICBkZWx0YVkgPSBlLndoZWVsRGVsdGFZIC8gNjtcbiAgICB9XG5cbiAgICBpZiAoZS5kZWx0YU1vZGUgJiYgZS5kZWx0YU1vZGUgPT09IDEpIHtcbiAgICAgIC8vIEZpcmVmb3ggaW4gZGVsdGFNb2RlIDE6IExpbmUgc2Nyb2xsaW5nXG4gICAgICBkZWx0YVggKj0gMTA7XG4gICAgICBkZWx0YVkgKj0gMTA7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhWCAhPT0gZGVsdGFYICYmIGRlbHRhWSAhPT0gZGVsdGFZLyogTmFOIGNoZWNrcyAqLykge1xuICAgICAgLy8gSUUgaW4gc29tZSBtb3VzZSBkcml2ZXJzXG4gICAgICBkZWx0YVggPSAwO1xuICAgICAgZGVsdGFZID0gZS53aGVlbERlbHRhO1xuICAgIH1cblxuICAgIHJldHVybiBbZGVsdGFYLCBkZWx0YVldO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQmVDb25zdW1lZEJ5VGV4dGFyZWEoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgaG92ZXJlZFRleHRhcmVhID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYTpob3ZlcicpO1xuICAgIGlmIChob3ZlcmVkVGV4dGFyZWEpIHtcbiAgICAgIHZhciBtYXhTY3JvbGxUb3AgPSBob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsSGVpZ2h0IC0gaG92ZXJlZFRleHRhcmVhLmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChtYXhTY3JvbGxUb3AgPiAwKSB7XG4gICAgICAgIGlmICghKGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgJiZcbiAgICAgICAgICAgICEoaG92ZXJlZFRleHRhcmVhLnNjcm9sbFRvcCA9PT0gbWF4U2Nyb2xsVG9wICYmIGRlbHRhWSA8IDApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtYXhTY3JvbGxMZWZ0ID0gaG92ZXJlZFRleHRhcmVhLnNjcm9sbExlZnQgLSBob3ZlcmVkVGV4dGFyZWEuY2xpZW50V2lkdGg7XG4gICAgICBpZiAobWF4U2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgaWYgKCEoaG92ZXJlZFRleHRhcmVhLnNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgJiZcbiAgICAgICAgICAgICEoaG92ZXJlZFRleHRhcmVhLnNjcm9sbExlZnQgPT09IG1heFNjcm9sbExlZnQgJiYgZGVsdGFYID4gMCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZXdoZWVsSGFuZGxlcihlKSB7XG4gICAgLy8gRklYTUU6IHRoaXMgaXMgYSBxdWljayBmaXggZm9yIHRoZSBzZWxlY3QgcHJvYmxlbSBpbiBGRiBhbmQgSUUuXG4gICAgLy8gSWYgdGhlcmUgY29tZXMgYW4gZWZmZWN0aXZlIHdheSB0byBkZWFsIHdpdGggdGhlIHByb2JsZW0sXG4gICAgLy8gdGhpcyBsaW5lcyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICBpZiAoIWguZW52LmlzV2ViS2l0ICYmIGVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2VsZWN0OmZvY3VzJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSBnZXREZWx0YUZyb21FdmVudChlKTtcblxuICAgIHZhciBkZWx0YVggPSBkZWx0YVswXTtcbiAgICB2YXIgZGVsdGFZID0gZGVsdGFbMV07XG5cbiAgICBpZiAoc2hvdWxkQmVDb25zdW1lZEJ5VGV4dGFyZWEoZGVsdGFYLCBkZWx0YVkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuICAgIGlmICghaS5zZXR0aW5ncy51c2VCb3RoV2hlZWxBeGVzKSB7XG4gICAgICAvLyBkZWx0YVggd2lsbCBvbmx5IGJlIHVzZWQgZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nIGFuZCBkZWx0YVkgd2lsbFxuICAgICAgLy8gb25seSBiZSB1c2VkIGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcgLSB0aGlzIGlzIHRoZSBkZWZhdWx0XG4gICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gKGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xuICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0ICsgKGRlbHRhWCAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xuICAgIH0gZWxzZSBpZiAoaS5zY3JvbGxiYXJZQWN0aXZlICYmICFpLnNjcm9sbGJhclhBY3RpdmUpIHtcbiAgICAgIC8vIG9ubHkgdmVydGljYWwgc2Nyb2xsYmFyIGlzIGFjdGl2ZSBhbmQgdXNlQm90aFdoZWVsQXhlcyBvcHRpb24gaXNcbiAgICAgIC8vIGFjdGl2ZSwgc28gbGV0J3Mgc2Nyb2xsIHZlcnRpY2FsIGJhciB1c2luZyBib3RoIG1vdXNlIHdoZWVsIGF4ZXNcbiAgICAgIGlmIChkZWx0YVkpIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgKyAoZGVsdGFYICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XG4gICAgICB9XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGkuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhaS5zY3JvbGxiYXJZQWN0aXZlKSB7XG4gICAgICAvLyB1c2VCb3RoV2hlZWxBeGVzIGFuZCBvbmx5IGhvcml6b250YWwgYmFyIGlzIGFjdGl2ZSwgc28gdXNlIGJvdGhcbiAgICAgIC8vIHdoZWVsIGF4ZXMgZm9yIGhvcml6b250YWwgYmFyXG4gICAgICBpZiAoZGVsdGFYKSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFByZXZlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gICAgc2hvdWxkUHJldmVudCA9IChzaG91bGRQcmV2ZW50IHx8IHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cub253aGVlbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnd2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5vbm1vdXNld2hlZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmRNb3VzZVdoZWVsSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbmZ1bmN0aW9uIGJpbmROYXRpdmVTY3JvbGxIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZE5hdGl2ZVNjcm9sbEhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gYmluZFNlbGVjdGlvbkhhbmRsZXIoZWxlbWVudCwgaSkge1xuICBmdW5jdGlvbiBnZXRSYW5nZU5vZGUoKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkgOlxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRTZWxlY3Rpb24gPyBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSA6ICcnO1xuICAgIGlmIChzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNjcm9sbGluZ0xvb3AgPSBudWxsO1xuICB2YXIgc2Nyb2xsRGlmZiA9IHt0b3A6IDAsIGxlZnQ6IDB9O1xuICBmdW5jdGlvbiBzdGFydFNjcm9sbGluZygpIHtcbiAgICBpZiAoIXNjcm9sbGluZ0xvb3ApIHtcbiAgICAgIHNjcm9sbGluZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VzLmdldChlbGVtZW50KSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc2Nyb2xsaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCArIHNjcm9sbERpZmYudG9wKTtcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0ICsgc2Nyb2xsRGlmZi5sZWZ0KTtcbiAgICAgICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG4gICAgICB9LCA1MCk7IC8vIGV2ZXJ5IC4xIHNlY1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wU2Nyb2xsaW5nKCkge1xuICAgIGlmIChzY3JvbGxpbmdMb29wKSB7XG4gICAgICBjbGVhckludGVydmFsKHNjcm9sbGluZ0xvb3ApO1xuICAgICAgc2Nyb2xsaW5nTG9vcCA9IG51bGw7XG4gICAgfVxuICAgIGguc3RvcFNjcm9sbGluZyhlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBpc1NlbGVjdGVkID0gZmFsc2U7XG4gIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZ2V0UmFuZ2VOb2RlKCkpKSB7XG4gICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgc3RvcFNjcm9sbGluZygpO1xuICAgIH1cbiAgfSk7XG4gIGkuZXZlbnQuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICBzdG9wU2Nyb2xsaW5nKCk7XG4gICAgfVxuICB9KTtcblxuICBpLmV2ZW50LmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSB7eDogZS5wYWdlWCwgeTogZS5wYWdlWX07XG4gICAgICB2YXIgY29udGFpbmVyR2VvbWV0cnkgPSB7XG4gICAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICAgICAgcmlnaHQ6IGVsZW1lbnQub2Zmc2V0TGVmdCArIGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgIHRvcDogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICAgIGJvdHRvbTogZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgfTtcblxuICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueCA8IGNvbnRhaW5lckdlb21ldHJ5LmxlZnQgKyAzKSB7XG4gICAgICAgIHNjcm9sbERpZmYubGVmdCA9IC01O1xuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlUG9zaXRpb24ueCA+IGNvbnRhaW5lckdlb21ldHJ5LnJpZ2h0IC0gMykge1xuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSA1O1xuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobW91c2VQb3NpdGlvbi55IDwgY29udGFpbmVyR2VvbWV0cnkudG9wICsgMykge1xuICAgICAgICBpZiAoY29udGFpbmVyR2VvbWV0cnkudG9wICsgMyAtIG1vdXNlUG9zaXRpb24ueSA8IDUpIHtcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IC01O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gLTIwO1xuICAgICAgICB9XG4gICAgICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcbiAgICAgIH0gZWxzZSBpZiAobW91c2VQb3NpdGlvbi55ID4gY29udGFpbmVyR2VvbWV0cnkuYm90dG9tIC0gMykge1xuICAgICAgICBpZiAobW91c2VQb3NpdGlvbi55IC0gY29udGFpbmVyR2VvbWV0cnkuYm90dG9tICsgMyA8IDUpIHtcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAyMDtcbiAgICAgICAgfVxuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxEaWZmLnRvcCA9PT0gMCAmJiBzY3JvbGxEaWZmLmxlZnQgPT09IDApIHtcbiAgICAgICAgc3RvcFNjcm9sbGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZFNlbGVjdGlvbkhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBiaW5kVG91Y2hIYW5kbGVyKGVsZW1lbnQsIGksIHN1cHBvcnRzVG91Y2gsIHN1cHBvcnRzSWVQb2ludGVyKSB7XG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIHZhciBtYWduaXR1ZGVYID0gTWF0aC5hYnMoZGVsdGFYKTtcbiAgICB2YXIgbWFnbml0dWRlWSA9IE1hdGguYWJzKGRlbHRhWSk7XG5cbiAgICBpZiAobWFnbml0dWRlWSA+IG1hZ25pdHVkZVgpIHtcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgdXAvZG93biB0aGUgcGFnZVxuXG4gICAgICBpZiAoKChkZWx0YVkgPCAwKSAmJiAoc2Nyb2xsVG9wID09PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkpIHx8XG4gICAgICAgICAgKChkZWx0YVkgPiAwKSAmJiAoc2Nyb2xsVG9wID09PSAwKSkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLnN3aXBlUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYWduaXR1ZGVYID4gbWFnbml0dWRlWSkge1xuICAgICAgLy8gdXNlciBpcyBwZXJoYXBzIHRyeWluZyB0byBzd2lwZSBsZWZ0L3JpZ2h0IGFjcm9zcyB0aGUgcGFnZVxuXG4gICAgICBpZiAoKChkZWx0YVggPCAwKSAmJiAoc2Nyb2xsTGVmdCA9PT0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSkgfHxcbiAgICAgICAgICAoKGRlbHRhWCA+IDApICYmIChzY3JvbGxMZWZ0ID09PSAwKSkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLnN3aXBlUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpIHtcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gZGlmZmVyZW5jZVkpO1xuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCAtIGRpZmZlcmVuY2VYKTtcblxuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0ge307XG4gIHZhciBzdGFydFRpbWUgPSAwO1xuICB2YXIgc3BlZWQgPSB7fTtcbiAgdmFyIGVhc2luZ0xvb3AgPSBudWxsO1xuICB2YXIgaW5HbG9iYWxUb3VjaCA9IGZhbHNlO1xuICB2YXIgaW5Mb2NhbFRvdWNoID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZ2xvYmFsVG91Y2hTdGFydCgpIHtcbiAgICBpbkdsb2JhbFRvdWNoID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBnbG9iYWxUb3VjaEVuZCgpIHtcbiAgICBpbkdsb2JhbFRvdWNoID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUb3VjaChlKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcykge1xuICAgICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWF5YmUgSUUgcG9pbnRlclxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEhhbmRsZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGUucG9pbnRlclR5cGUgJiYgZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHRvdWNoU3RhcnQoZSkge1xuICAgIGlmIChzaG91bGRIYW5kbGUoZSkpIHtcbiAgICAgIGluTG9jYWxUb3VjaCA9IHRydWU7XG5cbiAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoKGUpO1xuXG4gICAgICBzdGFydE9mZnNldC5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgc3RhcnRPZmZzZXQucGFnZVkgPSB0b3VjaC5wYWdlWTtcblxuICAgICAgc3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgaWYgKGVhc2luZ0xvb3AgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgIH1cblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoIWluR2xvYmFsVG91Y2ggJiYgaW5Mb2NhbFRvdWNoICYmIHNob3VsZEhhbmRsZShlKSkge1xuICAgICAgdmFyIHRvdWNoID0gZ2V0VG91Y2goZSk7XG5cbiAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0ge3BhZ2VYOiB0b3VjaC5wYWdlWCwgcGFnZVk6IHRvdWNoLnBhZ2VZfTtcblxuICAgICAgdmFyIGRpZmZlcmVuY2VYID0gY3VycmVudE9mZnNldC5wYWdlWCAtIHN0YXJ0T2Zmc2V0LnBhZ2VYO1xuICAgICAgdmFyIGRpZmZlcmVuY2VZID0gY3VycmVudE9mZnNldC5wYWdlWSAtIHN0YXJ0T2Zmc2V0LnBhZ2VZO1xuXG4gICAgICBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpO1xuICAgICAgc3RhcnRPZmZzZXQgPSBjdXJyZW50T2Zmc2V0O1xuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICB2YXIgdGltZUdhcCA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKHRpbWVHYXAgPiAwKSB7XG4gICAgICAgIHNwZWVkLnggPSBkaWZmZXJlbmNlWCAvIHRpbWVHYXA7XG4gICAgICAgIHNwZWVkLnkgPSBkaWZmZXJlbmNlWSAvIHRpbWVHYXA7XG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUHJldmVudERlZmF1bHQoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvdWNoRW5kKCkge1xuICAgIGlmICghaW5HbG9iYWxUb3VjaCAmJiBpbkxvY2FsVG91Y2gpIHtcbiAgICAgIGluTG9jYWxUb3VjaCA9IGZhbHNlO1xuXG4gICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgICAgZWFzaW5nTG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWQueCkgPCAwLjAxICYmIE1hdGguYWJzKHNwZWVkLnkpIDwgMC4wMSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHlUb3VjaE1vdmUoc3BlZWQueCAqIDMwLCBzcGVlZC55ICogMzApO1xuXG4gICAgICAgIHNwZWVkLnggKj0gMC44O1xuICAgICAgICBzcGVlZC55ICo9IDAuODtcbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydHNUb3VjaCkge1xuICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICd0b3VjaHN0YXJ0JywgZ2xvYmFsVG91Y2hTdGFydCk7XG4gICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZ2xvYmFsVG91Y2hFbmQpO1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAndG91Y2hzdGFydCcsIHRvdWNoU3RhcnQpO1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAndG91Y2htb3ZlJywgdG91Y2hNb3ZlKTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzSWVQb2ludGVyKSB7XG4gICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICdwb2ludGVyZG93bicsIGdsb2JhbFRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3BvaW50ZXJ1cCcsIGdsb2JhbFRvdWNoRW5kKTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAncG9pbnRlcmRvd24nLCB0b3VjaFN0YXJ0KTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAncG9pbnRlcm1vdmUnLCB0b3VjaE1vdmUpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVydXAnLCB0b3VjaEVuZCk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICdNU1BvaW50ZXJEb3duJywgZ2xvYmFsVG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAnTVNQb2ludGVyVXAnLCBnbG9iYWxUb3VjaEVuZCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlckRvd24nLCB0b3VjaFN0YXJ0KTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnTVNQb2ludGVyTW92ZScsIHRvdWNoTW92ZSk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlclVwJywgdG91Y2hFbmQpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdXBwb3J0c1RvdWNoLCBzdXBwb3J0c0llUG9pbnRlcikge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmRUb3VjaEhhbmRsZXIoZWxlbWVudCwgaSwgc3VwcG9ydHNUb3VjaCwgc3VwcG9ydHNJZVBvaW50ZXIpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbi8vIEhhbmRsZXJzXG52YXIgY2xpY2tSYWlsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9jbGljay1yYWlsJylcbiAgLCBkcmFnU2Nyb2xsYmFySGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9kcmFnLXNjcm9sbGJhcicpXG4gICwga2V5Ym9hcmRIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL2tleWJvYXJkJylcbiAgLCBtb3VzZVdoZWVsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9tb3VzZS13aGVlbCcpXG4gICwgbmF0aXZlU2Nyb2xsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9uYXRpdmUtc2Nyb2xsJylcbiAgLCBzZWxlY3Rpb25IYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL3NlbGVjdGlvbicpXG4gICwgdG91Y2hIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL3RvdWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHVzZXJTZXR0aW5ncykge1xuICB1c2VyU2V0dGluZ3MgPSB0eXBlb2YgdXNlclNldHRpbmdzID09PSAnb2JqZWN0JyA/IHVzZXJTZXR0aW5ncyA6IHt9O1xuXG4gIGNscy5hZGQoZWxlbWVudCwgJ3BzLWNvbnRhaW5lcicpO1xuXG4gIC8vIENyZWF0ZSBhIHBsdWdpbiBpbnN0YW5jZS5cbiAgdmFyIGkgPSBpbnN0YW5jZXMuYWRkKGVsZW1lbnQpO1xuXG4gIGkuc2V0dGluZ3MgPSBoLmV4dGVuZChpLnNldHRpbmdzLCB1c2VyU2V0dGluZ3MpO1xuXG4gIGNsaWNrUmFpbEhhbmRsZXIoZWxlbWVudCk7XG4gIGRyYWdTY3JvbGxiYXJIYW5kbGVyKGVsZW1lbnQpO1xuICBtb3VzZVdoZWVsSGFuZGxlcihlbGVtZW50KTtcbiAgbmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50KTtcblxuICBpZiAoaS5zZXR0aW5ncy51c2VTZWxlY3Rpb25TY3JvbGwpIHtcbiAgICBzZWxlY3Rpb25IYW5kbGVyKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKGguZW52LnN1cHBvcnRzVG91Y2ggfHwgaC5lbnYuc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgICB0b3VjaEhhbmRsZXIoZWxlbWVudCwgaC5lbnYuc3VwcG9ydHNUb3VjaCwgaC5lbnYuc3VwcG9ydHNJZVBvaW50ZXIpO1xuICB9XG4gIGlmIChpLnNldHRpbmdzLnVzZUtleWJvYXJkKSB7XG4gICAga2V5Ym9hcmRIYW5kbGVyKGVsZW1lbnQpO1xuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKVxuICAsIGRlZmF1bHRTZXR0aW5ncyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1zZXR0aW5nJylcbiAgLCBFdmVudE1hbmFnZXIgPSByZXF1aXJlKCcuLi9saWIvZXZlbnQtbWFuYWdlcicpXG4gICwgZ3VpZCA9IHJlcXVpcmUoJy4uL2xpYi9ndWlkJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpO1xuXG52YXIgaW5zdGFuY2VzID0ge307XG5cbmZ1bmN0aW9uIEluc3RhbmNlKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSB0aGlzO1xuXG4gIGkuc2V0dGluZ3MgPSBoLmNsb25lKGRlZmF1bHRTZXR0aW5ncyk7XG4gIGkuY29udGFpbmVyV2lkdGggPSBudWxsO1xuICBpLmNvbnRhaW5lckhlaWdodCA9IG51bGw7XG4gIGkuY29udGVudFdpZHRoID0gbnVsbDtcbiAgaS5jb250ZW50SGVpZ2h0ID0gbnVsbDtcblxuICBpLmlzUnRsID0gZC5jc3MoZWxlbWVudCwgJ2RpcmVjdGlvbicpID09PSBcInJ0bFwiO1xuICBpLmlzTmVnYXRpdmVTY3JvbGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmlnaW5hbFNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gLTE7XG4gICAgcmVzdWx0ID0gZWxlbWVudC5zY3JvbGxMZWZ0IDwgMDtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBvcmlnaW5hbFNjcm9sbExlZnQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSkoKTtcbiAgaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSBpLmlzTmVnYXRpdmVTY3JvbGwgPyBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCA6IDA7XG4gIGkuZXZlbnQgPSBuZXcgRXZlbnRNYW5hZ2VyKCk7XG4gIGkub3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICBpLnNjcm9sbGJhclhSYWlsID0gZC5hcHBlbmRUbyhkLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteC1yYWlsJyksIGVsZW1lbnQpO1xuICBpLnNjcm9sbGJhclggPSBkLmFwcGVuZFRvKGQuZSgnZGl2JywgJ3BzLXNjcm9sbGJhci14JyksIGkuc2Nyb2xsYmFyWFJhaWwpO1xuICBpLnNjcm9sbGJhclhBY3RpdmUgPSBudWxsO1xuICBpLnNjcm9sbGJhclhXaWR0aCA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWExlZnQgPSBudWxsO1xuICBpLnNjcm9sbGJhclhCb3R0b20gPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdib3R0b20nKSk7XG4gIGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gPT09IGkuc2Nyb2xsYmFyWEJvdHRvbTsgLy8gIWlzTmFOXG4gIGkuc2Nyb2xsYmFyWFRvcCA9IGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPyBudWxsIDogaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAndG9wJykpO1xuICBpLnJhaWxCb3JkZXJYV2lkdGggPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdib3JkZXJMZWZ0V2lkdGgnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdib3JkZXJSaWdodFdpZHRoJykpO1xuICAvLyBTZXQgcmFpbCB0byBkaXNwbGF5OmJsb2NrIHRvIGNhbGN1bGF0ZSBtYXJnaW5zXG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIGkucmFpbFhNYXJnaW5XaWR0aCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ21hcmdpbkxlZnQnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5SaWdodCcpKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIGkucmFpbFhXaWR0aCA9IG51bGw7XG4gIGkucmFpbFhSYXRpbyA9IG51bGw7XG5cbiAgaS5zY3JvbGxiYXJZUmFpbCA9IGQuYXBwZW5kVG8oZC5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXktcmFpbCcpLCBlbGVtZW50KTtcbiAgaS5zY3JvbGxiYXJZID0gZC5hcHBlbmRUbyhkLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteScpLCBpLnNjcm9sbGJhcllSYWlsKTtcbiAgaS5zY3JvbGxiYXJZQWN0aXZlID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJZVG9wID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJZUmlnaHQgPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdyaWdodCcpKTtcbiAgaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID0gaS5zY3JvbGxiYXJZUmlnaHQgPT09IGkuc2Nyb2xsYmFyWVJpZ2h0OyAvLyAhaXNOYU5cbiAgaS5zY3JvbGxiYXJZTGVmdCA9IGkuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA/IG51bGwgOiBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdsZWZ0JykpO1xuICBpLnNjcm9sbGJhcllPdXRlcldpZHRoID0gaS5pc1J0bCA/IGgub3V0ZXJXaWR0aChpLnNjcm9sbGJhclkpIDogbnVsbDtcbiAgaS5yYWlsQm9yZGVyWVdpZHRoID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnYm9yZGVyVG9wV2lkdGgnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdib3JkZXJCb3R0b21XaWR0aCcpKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgaS5yYWlsWU1hcmdpbkhlaWdodCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpblRvcCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpbkJvdHRvbScpKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIGkucmFpbFlIZWlnaHQgPSBudWxsO1xuICBpLnJhaWxZUmF0aW8gPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRJZChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5kYXRhc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wcy1pZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LmRhdGFzZXQucHNJZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRJZChlbGVtZW50LCBpZCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQuZGF0YXNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1wcy1pZCcsIGlkKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmRhdGFzZXQucHNJZCA9IGlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUlkKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRhdGFzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcHMtaWQnKTtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LnBzSWQ7XG4gIH1cbn1cblxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgbmV3SWQgPSBndWlkKCk7XG4gIHNldElkKGVsZW1lbnQsIG5ld0lkKTtcbiAgaW5zdGFuY2VzW25ld0lkXSA9IG5ldyBJbnN0YW5jZShlbGVtZW50KTtcbiAgcmV0dXJuIGluc3RhbmNlc1tuZXdJZF07XG59O1xuXG5leHBvcnRzLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbZ2V0SWQoZWxlbWVudCldO1xuICByZW1vdmVJZChlbGVtZW50KTtcbn07XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGluc3RhbmNlc1tnZXRJZChlbGVtZW50KV07XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xzID0gcmVxdWlyZSgnLi4vbGliL2NsYXNzJylcbiAgLCBkID0gcmVxdWlyZSgnLi4vbGliL2RvbScpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gZ2V0VGh1bWJTaXplKGksIHRodW1iU2l6ZSkge1xuICBpZiAoaS5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGgpIHtcbiAgICB0aHVtYlNpemUgPSBNYXRoLm1heCh0aHVtYlNpemUsIGkuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKTtcbiAgfVxuICBpZiAoaS5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGgpIHtcbiAgICB0aHVtYlNpemUgPSBNYXRoLm1pbih0aHVtYlNpemUsIGkuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdGh1bWJTaXplO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDc3MoZWxlbWVudCwgaSkge1xuICB2YXIgeFJhaWxPZmZzZXQgPSB7d2lkdGg6IGkucmFpbFhXaWR0aH07XG4gIGlmIChpLmlzUnRsKSB7XG4gICAgeFJhaWxPZmZzZXQubGVmdCA9IGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0ICsgaS5jb250YWluZXJXaWR0aCAtIGkuY29udGVudFdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cbiAgaWYgKGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20pIHtcbiAgICB4UmFpbE9mZnNldC5ib3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gLSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfSBlbHNlIHtcbiAgICB4UmFpbE9mZnNldC50b3AgPSBpLnNjcm9sbGJhclhUb3AgKyBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCB4UmFpbE9mZnNldCk7XG5cbiAgdmFyIHlSYWlsT2Zmc2V0ID0ge3RvcDogZWxlbWVudC5zY3JvbGxUb3AsIGhlaWdodDogaS5yYWlsWUhlaWdodH07XG4gIGlmIChpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQpIHtcbiAgICBpZiAoaS5pc1J0bCkge1xuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPSBpLmNvbnRlbnRXaWR0aCAtIChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgLSBpLnNjcm9sbGJhcllSaWdodCAtIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LnJpZ2h0ID0gaS5zY3JvbGxiYXJZUmlnaHQgLSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpLmlzUnRsKSB7XG4gICAgICB5UmFpbE9mZnNldC5sZWZ0ID0gaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBlbGVtZW50LnNjcm9sbExlZnQgKyBpLmNvbnRhaW5lcldpZHRoICogMiAtIGkuY29udGVudFdpZHRoIC0gaS5zY3JvbGxiYXJZTGVmdCAtIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLnNjcm9sbGJhcllMZWZ0ICsgZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgfVxuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCB5UmFpbE9mZnNldCk7XG5cbiAgZC5jc3MoaS5zY3JvbGxiYXJYLCB7bGVmdDogaS5zY3JvbGxiYXJYTGVmdCwgd2lkdGg6IGkuc2Nyb2xsYmFyWFdpZHRoIC0gaS5yYWlsQm9yZGVyWFdpZHRofSk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWSwge3RvcDogaS5zY3JvbGxiYXJZVG9wLCBoZWlnaHQ6IGkuc2Nyb2xsYmFyWUhlaWdodCAtIGkucmFpbEJvcmRlcllXaWR0aH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcblxuICBpLmNvbnRhaW5lcldpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgaS5jb250YWluZXJIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgaS5jb250ZW50V2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuICBpLmNvbnRlbnRIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcblxuICB2YXIgZXhpc3RpbmdSYWlscztcbiAgaWYgKCFlbGVtZW50LmNvbnRhaW5zKGkuc2Nyb2xsYmFyWFJhaWwpKSB7XG4gICAgZXhpc3RpbmdSYWlscyA9IGQucXVlcnlDaGlsZHJlbihlbGVtZW50LCAnLnBzLXNjcm9sbGJhci14LXJhaWwnKTtcbiAgICBpZiAoZXhpc3RpbmdSYWlscy5sZW5ndGggPiAwKSB7XG4gICAgICBleGlzdGluZ1JhaWxzLmZvckVhY2goZnVuY3Rpb24gKHJhaWwpIHtcbiAgICAgICAgZC5yZW1vdmUocmFpbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZC5hcHBlbmRUbyhpLnNjcm9sbGJhclhSYWlsLCBlbGVtZW50KTtcbiAgfVxuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJZUmFpbCkpIHtcbiAgICBleGlzdGluZ1JhaWxzID0gZC5xdWVyeUNoaWxkcmVuKGVsZW1lbnQsICcucHMtc2Nyb2xsYmFyLXktcmFpbCcpO1xuICAgIGlmIChleGlzdGluZ1JhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4aXN0aW5nUmFpbHMuZm9yRWFjaChmdW5jdGlvbiAocmFpbCkge1xuICAgICAgICBkLnJlbW92ZShyYWlsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkLmFwcGVuZFRvKGkuc2Nyb2xsYmFyWVJhaWwsIGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKCFpLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBpLmNvbnRhaW5lcldpZHRoICsgaS5zZXR0aW5ncy5zY3JvbGxYTWFyZ2luT2Zmc2V0IDwgaS5jb250ZW50V2lkdGgpIHtcbiAgICBpLnNjcm9sbGJhclhBY3RpdmUgPSB0cnVlO1xuICAgIGkucmFpbFhXaWR0aCA9IGkuY29udGFpbmVyV2lkdGggLSBpLnJhaWxYTWFyZ2luV2lkdGg7XG4gICAgaS5yYWlsWFJhdGlvID0gaS5jb250YWluZXJXaWR0aCAvIGkucmFpbFhXaWR0aDtcbiAgICBpLnNjcm9sbGJhclhXaWR0aCA9IGdldFRodW1iU2l6ZShpLCBoLnRvSW50KGkucmFpbFhXaWR0aCAqIGkuY29udGFpbmVyV2lkdGggLyBpLmNvbnRlbnRXaWR0aCkpO1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBoLnRvSW50KChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgKiAoaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIC8gKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkpO1xuICB9IGVsc2Uge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IGZhbHNlO1xuICAgIGkuc2Nyb2xsYmFyWFdpZHRoID0gMDtcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gMDtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSAwO1xuICB9XG5cbiAgaWYgKCFpLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJiBpLmNvbnRhaW5lckhlaWdodCArIGkuc2V0dGluZ3Muc2Nyb2xsWU1hcmdpbk9mZnNldCA8IGkuY29udGVudEhlaWdodCkge1xuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWUhlaWdodCA9IGkuY29udGFpbmVySGVpZ2h0IC0gaS5yYWlsWU1hcmdpbkhlaWdodDtcbiAgICBpLnJhaWxZUmF0aW8gPSBpLmNvbnRhaW5lckhlaWdodCAvIGkucmFpbFlIZWlnaHQ7XG4gICAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gZ2V0VGh1bWJTaXplKGksIGgudG9JbnQoaS5yYWlsWUhlaWdodCAqIGkuY29udGFpbmVySGVpZ2h0IC8gaS5jb250ZW50SGVpZ2h0KSk7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gaC50b0ludChlbGVtZW50LnNjcm9sbFRvcCAqIChpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSAvIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkpO1xuICB9IGVsc2Uge1xuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IGZhbHNlO1xuICAgIGkuc2Nyb2xsYmFyWUhlaWdodCA9IDA7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gMDtcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIDApO1xuICB9XG5cbiAgaWYgKGkuc2Nyb2xsYmFyWExlZnQgPj0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIHtcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGg7XG4gIH1cbiAgaWYgKGkuc2Nyb2xsYmFyWVRvcCA+PSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSB7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodDtcbiAgfVxuXG4gIHVwZGF0ZUNzcyhlbGVtZW50LCBpKTtcblxuICBjbHNbaS5zY3JvbGxiYXJYQWN0aXZlID8gJ2FkZCcgOiAncmVtb3ZlJ10oZWxlbWVudCwgJ3BzLWFjdGl2ZS14Jyk7XG4gIGNsc1tpLnNjcm9sbGJhcllBY3RpdmUgPyAnYWRkJyA6ICdyZW1vdmUnXShlbGVtZW50LCAncHMtYWN0aXZlLXknKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xuXG52YXIgdXBFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgZG93bkV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCBsZWZ0RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHJpZ2h0RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHlFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgeEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCB4U3RhcnRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgeEVuZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCB5U3RhcnRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgeUVuZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCBsYXN0VG9wXG4gICwgbGFzdExlZnQ7XG5cbnVwRXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtdXAnLCB0cnVlLCB0cnVlKTtcbmRvd25FdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC1kb3duJywgdHJ1ZSwgdHJ1ZSk7XG5sZWZ0RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtbGVmdCcsIHRydWUsIHRydWUpO1xucmlnaHRFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC1yaWdodCcsIHRydWUsIHRydWUpO1xueUV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLXknLCB0cnVlLCB0cnVlKTtcbnhFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC14JywgdHJ1ZSwgdHJ1ZSk7XG54U3RhcnRFdmVudC5pbml0RXZlbnQoJ3BzLXgtcmVhY2gtc3RhcnQnLCB0cnVlLCB0cnVlKTtcbnhFbmRFdmVudC5pbml0RXZlbnQoJ3BzLXgtcmVhY2gtZW5kJywgdHJ1ZSwgdHJ1ZSk7XG55U3RhcnRFdmVudC5pbml0RXZlbnQoJ3BzLXktcmVhY2gtc3RhcnQnLCB0cnVlLCB0cnVlKTtcbnlFbmRFdmVudC5pbml0RXZlbnQoJ3BzLXktcmVhY2gtZW5kJywgdHJ1ZSwgdHJ1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF4aXMsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhbiBlbGVtZW50IHRvIHRoZSB1cGRhdGUtc2Nyb2xsIGZ1bmN0aW9uJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXhpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhbiBheGlzIHRvIHRoZSB1cGRhdGUtc2Nyb2xsIGZ1bmN0aW9uJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYSB2YWx1ZSB0byB0aGUgdXBkYXRlLXNjcm9sbCBmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ3RvcCcgJiYgdmFsdWUgPD0gMCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeVN0YXJ0RXZlbnQpO1xuICAgIHJldHVybjsgLy8gZG9uJ3QgYWxsb3cgbmVnYXRpdmUgc2Nyb2xsXG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnICYmIHZhbHVlIDw9IDApIHtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSAwO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh4U3RhcnRFdmVudCk7XG4gICAgcmV0dXJuOyAvLyBkb24ndCBhbGxvdyBuZWdhdGl2ZSBzY3JvbGxcbiAgfVxuXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcblxuICBpZiAoYXhpcyA9PT0gJ3RvcCcgJiYgdmFsdWUgPiBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQ7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHlFbmRFdmVudCk7XG4gICAgcmV0dXJuOyAvLyBkb24ndCBhbGxvdyBzY3JvbGwgcGFzdCBjb250YWluZXJcbiAgfVxuXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPiBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpIHtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGg7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHhFbmRFdmVudCk7XG4gICAgcmV0dXJuOyAvLyBkb24ndCBhbGxvdyBzY3JvbGwgcGFzdCBjb250YWluZXJcbiAgfVxuXG4gIGlmICghbGFzdFRvcCkge1xuICAgIGxhc3RUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIGlmICghbGFzdExlZnQpIHtcbiAgICBsYXN0TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgfVxuXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA8IGxhc3RUb3ApIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQodXBFdmVudCk7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ3RvcCcgJiYgdmFsdWUgPiBsYXN0VG9wKSB7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGRvd25FdmVudCk7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnICYmIHZhbHVlIDwgbGFzdExlZnQpIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobGVmdEV2ZW50KTtcbiAgfVxuXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPiBsYXN0TGVmdCkge1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChyaWdodEV2ZW50KTtcbiAgfVxuXG4gIGlmIChheGlzID09PSAndG9wJykge1xuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gbGFzdFRvcCA9IHZhbHVlO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh5RXZlbnQpO1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICdsZWZ0Jykge1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGxhc3RMZWZ0ID0gdmFsdWU7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHhFdmVudCk7XG4gIH1cblxufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSByZXF1aXJlKCcuLi9saWIvZG9tJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi91cGRhdGUtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG5cbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVjYWxjdWF0ZSBuZWdhdGl2ZSBzY3JvbGxMZWZ0IGFkanVzdG1lbnRcbiAgaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSBpLmlzTmVnYXRpdmVTY3JvbGwgPyBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCA6IDA7XG5cbiAgLy8gUmVjYWxjdWxhdGUgcmFpbCBtYXJnaW5zXG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIGkucmFpbFhNYXJnaW5XaWR0aCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ21hcmdpbkxlZnQnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5SaWdodCcpKTtcbiAgaS5yYWlsWU1hcmdpbkhlaWdodCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpblRvcCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpbkJvdHRvbScpKTtcblxuICAvLyBIaWRlIHNjcm9sbGJhcnMgbm90IHRvIGFmZmVjdCBzY3JvbGxXaWR0aCBhbmQgc2Nyb2xsSGVpZ2h0XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJycpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICcnKTtcbn07XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4zJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBwcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBwcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXy5maW5kS2V5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyBmdW5jIDogZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgaSA9IGlkeCA+PSAwID8gaWR4IDogTWF0aC5tYXgoaWR4ICsgbGVuZ3RoLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBfID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHRzID0ge30sXG4gICAgICAgICAgY3VycmVudEtleTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBfLmNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIGlmIChwcm9wcykgXy5leHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IGZ1bmN0aW9uKCl7fSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBEYXNoYm9hcmRWaWV3ID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtdmlldycpO1xudmFyIFdpZGdldHNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi93aWRnZXRzL3dpZGdldHMtY29sbGVjdGlvbicpO1xudmFyIFdpZGdldE1vZGVsRmFjdG9yeSA9IHJlcXVpcmUoJy4vd2lkZ2V0cy93aWRnZXQtbW9kZWwtZmFjdG9yeScpO1xudmFyIExpc3RNb2RlbCA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9saXN0L21vZGVsJyk7XG52YXIgSGlzdG9ncmFtTW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvaGlzdG9ncmFtL21vZGVsJyk7XG52YXIgQ2F0ZWdvcnlNb2RlbCA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9jYXRlZ29yeS9tb2RlbCcpO1xudmFyIEZvcm11bGFNb2RlbCA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9mb3JtdWxhL21vZGVsJyk7XG52YXIgUmFuZ2VGaWx0ZXIgPSByZXF1aXJlKCcuL3dpbmRzaGFmdC9maWx0ZXJzL3JhbmdlJyk7XG52YXIgQ2F0ZWdvcnlGaWx0ZXIgPSByZXF1aXJlKCcuL3dpbmRzaGFmdC9maWx0ZXJzL2NhdGVnb3J5Jyk7XG52YXIgV2luZHNoYWZ0Q29uZmlnID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvY29uZmlnJyk7XG52YXIgV2luZHNoYWZ0Q2xpZW50ID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvY2xpZW50Jyk7XG52YXIgV2luZHNoYWZ0RGFzaGJvYXJkID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvZGFzaGJvYXJkJyk7XG52YXIgV2luZHNoYWZ0UHJpdmF0ZURhc2hib2FyZENvbmZpZyA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L3ByaXZhdGUtZGFzaGJvYXJkLWNvbmZpZycpO1xudmFyIFdpbmRzaGFmdFB1YmxpY0Rhc2hib2FyZENvbmZpZyA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L3B1YmxpYy1kYXNoYm9hcmQtY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIGRpSlNPTiwgdmlzT3B0cykge1xuICB2YXIgd2lkZ2V0TW9kZWxGYWN0b3J5ID0gbmV3IFdpZGdldE1vZGVsRmFjdG9yeSh7XG4gICAgbGlzdDogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICAgIHJldHVybiBuZXcgTGlzdE1vZGVsKGF0dHJzLCBvcHRzKTtcbiAgICB9LFxuICAgIGZvcm11bGE6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IEZvcm11bGFNb2RlbChhdHRycywgb3B0cyk7XG4gICAgfSxcbiAgICBoaXN0b2dyYW06IGZ1bmN0aW9uKGF0dHJzLCBvcHRzLCBsYXllckluZGV4KSB7XG4gICAgICBvcHRzLmZpbHRlciA9IG5ldyBSYW5nZUZpbHRlcih7XG4gICAgICAgIHdpZGdldElkOiBhdHRycy5pZCxcbiAgICAgICAgbGF5ZXJJbmRleDogbGF5ZXJJbmRleFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEhpc3RvZ3JhbU1vZGVsKGF0dHJzLCBvcHRzKTtcbiAgICB9LFxuICAgICd0aW1lLXNlcmllcyc6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzLCBsYXllckluZGV4KSB7XG4gICAgICAvLyBjaGFuZ2UgdHlwZSBiZWNhdXNlIHRpbWUtc2VyaWVzIGJlY2F1c2UgaXQncyByZWFsbHkgYSBoaXN0b2dyYW0gKGZvciB0aGUgdGlsZXIgYXQgbGVhc3QpXG4gICAgICBhdHRycy50eXBlID0gJ2hpc3RvZ3JhbSc7XG4gICAgICBvcHRzLmZpbHRlciA9IG5ldyBSYW5nZUZpbHRlcih7XG4gICAgICAgIHdpZGdldElkOiBhdHRycy5pZCxcbiAgICAgICAgbGF5ZXJJbmRleDogbGF5ZXJJbmRleFxuICAgICAgfSk7XG4gICAgICB2YXIgbW9kZWwgPSBuZXcgSGlzdG9ncmFtTW9kZWwoYXR0cnMsIG9wdHMpO1xuXG4gICAgICAvLyBzaW5jZSB3ZSBjaGFuZ2VkIHRoZSB0eXBlIG9mIHdlIG5lZWQgc29tZSB3YXkgdG8gaWRlbnRpZnkgdGhhdCBpdCdzIGludGVuZGVkIGZvciBhIHRpbWUtc2VyaWVzIHZpZXcgbGF0ZXJcbiAgICAgIG1vZGVsLmlzRm9yVGltZVNlcmllcyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuICAgIGFnZ3JlZ2F0aW9uOiBmdW5jdGlvbihhdHRycywgb3B0cywgbGF5ZXJJbmRleCkge1xuICAgICAgb3B0cy5maWx0ZXIgPSBuZXcgQ2F0ZWdvcnlGaWx0ZXIoe1xuICAgICAgICB3aWRnZXRJZDogYXR0cnMuaWQsXG4gICAgICAgIGxheWVySW5kZXg6IGxheWVySW5kZXhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeU1vZGVsKGF0dHJzLCBvcHRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRPRE8ga2VlcCB0aGlzIGNvbGxlY3Rpb24gaW4gc3luYyB3aXRoIGxheWVycyBpbmRpdmlkdWFsIHdpZGdldHMgY29sbGVjdGlvbnNcbiAgdmFyIHdpZGdldHMgPSBuZXcgV2lkZ2V0c0NvbGxlY3Rpb24oKTtcblxuICB2YXIgZGFzaGJvYXJkSW5mb01vZGVsID0gbmV3IE1vZGVsKHtcbiAgICB0aXRsZTogZGlKU09OLnRpdGxlLFxuICAgIGRlc2NyaXB0aW9uOiBkaUpTT04uZGVzY3JpcHRpb24sXG4gICAgdXBkYXRlZEF0OiBkaUpTT04udXBkYXRlZF9hdCxcbiAgICB1c2VyTmFtZTogZGlKU09OLnVzZXIuZnVsbG5hbWUsXG4gICAgdXNlckF2YXRhclVSTDogZGlKU09OLnVzZXIuYXZhdGFyX3VybFxuICB9KTtcbiAgdmFyIGRhc2hib2FyZFZpZXcgPSBuZXcgRGFzaGJvYXJkVmlldyh7XG4gICAgZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgIHdpZGdldHM6IHdpZGdldHMsXG4gICAgZGFzaGJvYXJkSW5mb01vZGVsOiBkYXNoYm9hcmRJbmZvTW9kZWxcbiAgfSk7XG5cbiAgdmFyIHZpcyA9IGNkYi5jcmVhdGVWaXMoZGFzaGJvYXJkVmlldy4kKCcjbWFwJyksIGRpSlNPTi52aXpKU09OLCB2aXNPcHRzKTtcblxuICB2YXIgY2FydG9EQkxheWVyR3JvdXA7XG4gIHZhciBpbnRlcmFjdGl2ZUxheWVycyA9IFtdO1xuICB2aXMubWFwLmxheWVycy5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIGxheWVyVHlwZSA9IGxheWVyLmdldCgndHlwZScpO1xuICAgIHZhciBpc0xheWVyR3JvdXAgPSBsYXllclR5cGUgPT09ICdsYXllcmdyb3VwJztcblxuICAgIGlmIChpc0xheWVyR3JvdXApIHtcbiAgICAgIGNhcnRvREJMYXllckdyb3VwID0gbGF5ZXI7XG4gICAgfVxuXG4gICAgaWYgKGlzTGF5ZXJHcm91cCB8fCBsYXllclR5cGUgPT09ICduYW1lZG1hcCcpIHtcbiAgICAgIGxheWVyLmxheWVycy5lYWNoKGZ1bmN0aW9uKHN1YkxheWVyKSB7XG4gICAgICAgIGludGVyYWN0aXZlTGF5ZXJzLnB1c2goc3ViTGF5ZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICBpZiAobGF5ZXJUeXBlID09PSAndG9ycXVlJykge1xuICAgICAgICBpbnRlcmFjdGl2ZUxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBXZSBjYW4gcHJvYmFibHkgbW92ZSB0aGlzIGxvZ2ljIHNvbWV3aGVyZSBlbHNlXG4gIHZhciB3aWRnZXRNb2RlbHMgPSBbXTtcbiAgZm9yICh2YXIgaWQgaW4gZGlKU09OLndpZGdldHMpIHtcbiAgICB2YXIgZCA9IGRpSlNPTi53aWRnZXRzW2lkXTtcbiAgICB2YXIgbGF5ZXIgPSBfLmZpbmQoaW50ZXJhY3RpdmVMYXllcnMsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiBkLmxheWVySWQgPT09IGwuZ2V0KCdpZCcpO1xuICAgIH0pO1xuICAgIHZhciBsYXllckluZGV4ID0gaW50ZXJhY3RpdmVMYXllcnMuaW5kZXhPZihsYXllcik7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7XG4gICAgICAgIGlkOiBpZFxuICAgICAgfSwgZCk7XG4gICAgICB2YXIgd2lkZ2V0TW9kZWwgPSB3aWRnZXRNb2RlbEZhY3RvcnkuY3JlYXRlTW9kZWwobGF5ZXIsIGxheWVySW5kZXgsIGF0dHJzKTtcbiAgICAgIHdpZGdldE1vZGVscy5wdXNoKHdpZGdldE1vZGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETyBsYXllcnMgaW4gYSBuYW1lZG1hcCBkb2Vzbid0IGhhdmUgbGF5ZXJJZCwgbmVlZCBzb21lIG90aGVyIHdheSB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIGxheWVyIGZvciBhIGdpdmVuIHdpZGdldFxuICAgICAgdGhyb3cgRXJyb3IoJ25vIGxheWVyIGZvdW5kIGZvciBkZWZpbmVkIHdpZGdldCcpO1xuICAgIH1cbiAgfVxuICAvLyBfLmVhY2goaW50ZXJhY3RpdmVMYXllcnMsIGZ1bmN0aW9uKGxheWVyLCBsYXllckluZGV4KSB7XG4gIC8vICAgdmFyIHdpZGdldHNBdHRycyA9IGxheWVyLmdldCgnd2lkZ2V0cycpIHx8IHt9O1xuICAvLyAgIGZvciAodmFyIGlkIGluIHdpZGdldHNBdHRycykge1xuICAvLyAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe1xuICAvLyAgICAgICBpZDogaWRcbiAgLy8gICAgIH0sIHdpZGdldHNBdHRyc1tpZF0pO1xuICAvLyAgICAgdmFyIHdpZGdldE1vZGVsID0gd2lkZ2V0TW9kZWxGYWN0b3J5LmNyZWF0ZU1vZGVsKGxheWVyLCBsYXllckluZGV4LCBhdHRycyk7XG4gIC8vICAgICB3aWRnZXRNb2RlbHMucHVzaCh3aWRnZXRNb2RlbCk7XG4gIC8vICAgfVxuICAvLyB9KTtcblxuICB3aWRnZXRzLnJlc2V0KHdpZGdldE1vZGVscyk7XG5cbiAgZGFzaGJvYXJkVmlldy5yZW5kZXIoKTtcblxuICAvLyBUT0RPOiBQZXJoYXBzIHRoaXMgXCJlbmRwb2ludFwiIGNvdWxkIGJlIHBhcnQgb2YgdGhlIFwiZGF0YXNvdXJjZVwiP1xuICB2YXIgZW5kcG9pbnQgPSBXaW5kc2hhZnRDb25maWcuTUFQU19BUElfQkFTRV9VUkw7XG4gIHZhciBjb25maWdHZW5lcmF0b3IgPSBXaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWc7XG4gIHZhciBkYXRhc291cmNlID0gZGlKU09OLmRhdGFzb3VyY2U7XG4gIC8vIFRPRE86IFdlIGNhbiB1c2Ugc29tZXRoaW5nIGVsc2UgdG8gZGlmZmVyZW50aWF0ZSB0eXBlcyBvZiBcImRhdGFzb3VyY2VcInNcbiAgaWYgKGRhdGFzb3VyY2UudGVtcGxhdGVfbmFtZSkge1xuICAgIGVuZHBvaW50ID0gW1dpbmRzaGFmdENvbmZpZy5NQVBTX0FQSV9CQVNFX1VSTCwgJ25hbWVkJywgZGF0YXNvdXJjZS50ZW1wbGF0ZV9uYW1lXS5qb2luKCcvJyk7XG4gICAgY29uZmlnR2VuZXJhdG9yID0gV2luZHNoYWZ0UHJpdmF0ZURhc2hib2FyZENvbmZpZztcbiAgfVxuXG4gIHZhciB3aW5kc2hhZnRDbGllbnQgPSBuZXcgV2luZHNoYWZ0Q2xpZW50KHtcbiAgICBlbmRwb2ludDogZW5kcG9pbnQsXG4gICAgdXJsVGVtcGxhdGU6IGRhdGFzb3VyY2UubWFwc19hcGlfdGVtcGxhdGUsXG4gICAgdXNlck5hbWU6IGRhdGFzb3VyY2UudXNlcl9uYW1lLFxuICAgIHN0YXRUYWc6IGRhdGFzb3VyY2Uuc3RhdF90YWcsXG4gICAgZm9yY2VDb3JzOiBkYXRhc291cmNlLmZvcmNlX2NvcnNcbiAgfSk7XG5cbiAgdmFyIGRhc2hib2FyZCA9IG5ldyBXaW5kc2hhZnREYXNoYm9hcmQoe1xuICAgIGNsaWVudDogd2luZHNoYWZ0Q2xpZW50LFxuICAgIGNvbmZpZ0dlbmVyYXRvcjogY29uZmlnR2VuZXJhdG9yLFxuICAgIHN0YXRUYWc6IGRhdGFzb3VyY2Uuc3RhdF90YWcsXG4gICAgLy9UT0RPOiBhc3N1bWluZyBoZXJlIGFsbCB2aXouanNvbiBoYXMgYSBsYXllcmdyb3VwIGFuZCB0aGF0IG1heSBub3QgYmUgdHJ1ZVxuICAgIGxheWVyR3JvdXA6IGNhcnRvREJMYXllckdyb3VwLFxuICAgIGxheWVyczogaW50ZXJhY3RpdmVMYXllcnMsXG4gICAgd2lkZ2V0czogd2lkZ2V0cyxcbiAgICBtYXA6IHZpcy5tYXBcbiAgfSk7XG5cbiAgLy8gVE9ETzogcmV0aGluayB0aGlzXG4gIGlmICh3aWRnZXRzLnNpemUoKSA+IDApIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdmlzLm1hcFZpZXcuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIHJldHVybiBkYXNoYm9hcmRWaWV3O1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgV2lkZ2V0Vmlld0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dpZGdldHMvd2lkZ2V0LXZpZXctZmFjdG9yeScpO1xudmFyIFRpbWVTZXJpZXNDb250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy90aW1lLXNlcmllcy9jb250ZW50LXZpZXcnKTtcbnZhciBUb3JxdWVUaW1lU2VyaWVzQ29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWNvbnRlbnQtdmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItRGFzaGJvYXJkLWJlbG93TWFwJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fd2lkZ2V0Vmlld0ZhY3RvcnkgPSBuZXcgV2lkZ2V0Vmlld0ZhY3RvcnkoW1xuICAgICAge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24obSkge1xuICAgICAgICAgIC8vIGlzRm9yVGltZVNlcmllcyBpcyBzZXQgdG8gdHJ1ZSB0byBkaXN0aW5ndWlzaCBmcm9tIGRlZmF1bHQgdHlwZSAnaGlzdG9ncmFtJ1xuICAgICAgICAgIC8vIFRoaXMgbWF0Y2ggbmVlZHMgdG8gYmUgZG9uZSBiZWZvcmUgdGhlIGRlZmF1bHQgdGltZS1zZXJpZXMgd2lkZ2V0J3MgbWF0Y2ggYmVsb3cgdG8gaGF2ZSBwcmVzZWRlbmNlXG4gICAgICAgICAgcmV0dXJuIG0uaXNGb3JUaW1lU2VyaWVzICYmIG0ubGF5ZXIuZ2V0KCd0eXBlJykgPT09ICd0b3JxdWUnO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVG9ycXVlVGltZVNlcmllc0NvbnRlbnRWaWV3KHtcbiAgICAgICAgICAgIG1vZGVsOiBtLFxuICAgICAgICAgICAgcmFuZ2VGaWx0ZXI6IG0uZmlsdGVyLFxuICAgICAgICAgICAgdG9ycXVlTGF5ZXJNb2RlbDogbS5sYXllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjdXN0b21pemVXaWRnZXRBdHRyczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICBhdHRycy5jbGFzc05hbWUgKz0gJyBDREItV2lkZ2V0LS10aW1lU2VyaWVzJztcbiAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAvLyBpc0ZvclRpbWVTZXJpZXMgaXMgc2V0IHRvIHRydWUgdG8gZGlzdGluZ3Vpc2ggZnJvbSBkZWZhdWx0IHR5cGUgJ2hpc3RvZ3JhbSdcbiAgICAgICAgICByZXR1cm4gbS5pc0ZvclRpbWVTZXJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNvbnRlbnRWaWV3OiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUaW1lU2VyaWVzQ29udGVudFZpZXcoe1xuICAgICAgICAgICAgbW9kZWw6IG0sXG4gICAgICAgICAgICBmaWx0ZXI6IG0uZmlsdGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbWl6ZVdpZGdldEF0dHJzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgIGF0dHJzLmNsYXNzTmFtZSArPSAnIENEQi1XaWRnZXQtLXRpbWVTZXJpZXMnO1xuICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0pO1xuXG4gICAgdGhpcy5fd2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcbiAgICB0aGlzLl93aWRnZXRzLmJpbmQoJ2FkZCcsIHRoaXMuX21heWJlUmVuZGVyV2lkZ2V0VmlldywgdGhpcyk7XG4gICAgdGhpcy5fd2lkZ2V0cy5iaW5kKCdyZXNldCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX3dpZGdldHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICB0aGlzLl93aWRnZXRzLmVhY2godGhpcy5fbWF5YmVSZW5kZXJXaWRnZXRWaWV3LCB0aGlzKTtcbiAgICB0aGlzLiRlbC50b2dnbGUoIV8uaXNFbXB0eSh0aGlzLl9zdWJ2aWV3cykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9tYXliZVJlbmRlcldpZGdldFZpZXc6IGZ1bmN0aW9uKHdpZGdldE1vZGVsKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLl93aWRnZXRWaWV3RmFjdG9yeS5jcmVhdGVXaWRnZXRWaWV3KHdpZGdldE1vZGVsKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLWluZm8tdmlldy50cGwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxudmFyIERhc2hib2FyZEluZm9WaWV3ID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1EYXNoYm9hcmQtaW5mbycsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy10b2dnbGUtdmlldy1saW5rJzogXCJfdG9nZ2xlVmlld1wiXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICB0aXRsZTogdGhpcy5tb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLm1vZGVsLmdldCgnZGVzY3JpcHRpb24nKSxcbiAgICAgICAgdXBkYXRlZEF0OiBtb21lbnQodGhpcy5tb2RlbC5nZXQoJ3VwZGF0ZWRBdCcpKS5mcm9tTm93KCksXG4gICAgICAgIHVzZXJOYW1lOiB0aGlzLm1vZGVsLmdldCgndXNlck5hbWUnKSxcbiAgICAgICAgdXNlckF2YXRhclVSTDogdGhpcy5tb2RlbC5nZXQoJ3VzZXJBdmF0YXJVUkwnKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3RvZ2dsZVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnRvZ2dsZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGFzaGJvYXJkSW5mb1ZpZXc7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9IZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0xvZ29cIj4gPGkgY2xhc3M9XCJDREItSWNvbiBDREItSWNvbi1jYXJ0b2ZhbnRlXCI+PC9pPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0FjdGlvbnNcIj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0FjdGlvbnNMaW5rIGpzLXRvZ2dsZS12aWV3LWxpbmtcIj48L2J1dHRvbj4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9UZXh0c1wiPiA8cCBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb1VwZGF0ZVwiPlVQREFURUQgJytcbigoX190PSggdXBkYXRlZEF0ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPGgxIGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvVGl0bGVcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gxPiA8aDIgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9EZXNjcmlwdGlvblwiPicrXG4oKF9fdD0oIGRlc2NyaXB0aW9uICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDI+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0Zvb3RlclwiPiA8dWw+ICA8bGkgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9Gb290ZXJJdGVtXCI+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9NZWRpYSBDREItRGFzaGJvYXJkLWluZm9BdmF0YXJcIj4gPGltZyBzcmM9XCInK1xuKChfX3Q9KCB1c2VyQXZhdGFyVVJMICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIGFsdD1cImF2YXRhclwiIGNsYXNzPVwiaW5saW5lLWJsb2NrXCI+IDwvZGl2PiA8cCBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0Zvb3RlclR4dFwiPicrXG4oKF9fdD0oIHVzZXJOYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPC9saT4gPC91bD4gPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciAkID0gY2RiLiQ7XG52YXIgUHMgPSByZXF1aXJlKCdwZXJmZWN0LXNjcm9sbGJhcicpO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgQ2F0ZWdvcnlDb250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9jYXRlZ29yeS9jb250ZW50X3ZpZXcnKTtcbnZhciBGb3JtdWxhQ29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvZm9ybXVsYS9jb250ZW50X3ZpZXcnKTtcbnZhciBIaXN0b2dyYW1Db250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9oaXN0b2dyYW0vY29udGVudC12aWV3Jyk7XG52YXIgTGlzdENvbnRlbnRWaWV3ID0gcmVxdWlyZSgnLi93aWRnZXRzL2xpc3QvY29udGVudF92aWV3Jyk7XG52YXIgV2lkZ2V0Vmlld0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dpZGdldHMvd2lkZ2V0LXZpZXctZmFjdG9yeScpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtc2lkZWJhci50cGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1jYW52YXMnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl93aWRnZXRWaWV3RmFjdG9yeSA9IG5ldyBXaWRnZXRWaWV3RmFjdG9yeShbXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZvcm11bGFDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExpc3RDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZ2V0KCd0eXBlJykgPT09ICdoaXN0b2dyYW0nICYmIG0ubGF5ZXIuZ2V0KCd0eXBlJykgIT09ICd0b3JxdWUnO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9ncmFtQ29udGVudFZpZXcoe1xuICAgICAgICAgICAgZGF0YU1vZGVsOiBtLFxuICAgICAgICAgICAgdmlld01vZGVsOiBuZXcgTW9kZWwoKSxcbiAgICAgICAgICAgIGZpbHRlcjogbS5maWx0ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnYWdncmVnYXRpb24nLFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbSxcbiAgICAgICAgICAgIGZpbHRlcjogbS5maWx0ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0pO1xuXG4gICAgdGhpcy5fd2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcblxuICAgIHRoaXMuX3dpZGdldHMuYmluZCgnYWRkJywgdGhpcy5fbWF5YmVSZW5kZXJXaWRnZXRWaWV3LCB0aGlzKTtcbiAgICB0aGlzLl93aWRnZXRzLmJpbmQoJ3Jlc2V0JywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuX3dpZGdldHMuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMuX29uV2lkZ2V0Q29sbGFwc2VkLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX3dpZGdldHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYW5TY3JvbGxFdmVudCgpO1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuXG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl93aWRnZXRzLmVhY2godGhpcy5fbWF5YmVSZW5kZXJXaWRnZXRWaWV3LCB0aGlzKTtcbiAgICB0aGlzLiRlbC50b2dnbGUoIV8uaXNFbXB0eSh0aGlzLl9zdWJ2aWV3cykpO1xuXG4gICAgdGhpcy5fcmVuZGVyU2Nyb2xsKCk7XG4gICAgdGhpcy5fcmVuZGVyU2hhZG93cygpO1xuICAgIHRoaXMuX2JpbmRTY3JvbGwoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF8kY29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJCh0aGlzLl9jb250YWluZXIoKSk7XG4gIH0sXG5cbiAgX2NvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmpzLWNvbnRhaW5lcicpO1xuICB9LFxuXG4gIF9tYXliZVJlbmRlcldpZGdldFZpZXc6IGZ1bmN0aW9uKHdpZGdldE1vZGVsKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLl93aWRnZXRWaWV3RmFjdG9yeS5jcmVhdGVXaWRnZXRWaWV3KHdpZGdldE1vZGVsKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgICAgdGhpcy5fJGNvbnRhaW5lcigpLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgX2JpbmRTY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuXyRjb250YWluZXIoKVxuICAgICAgLm9uKCdwcy15LXJlYWNoLXN0YXJ0JywgXy5iaW5kKHRoaXMuX29uU2Nyb2xsVG9wLCB0aGlzKSlcbiAgICAgIC5vbigncHMteS1yZWFjaC1lbmQnLCBfLmJpbmQodGhpcy5fb25TY3JvbGxCb3R0b20sIHRoaXMpKVxuICAgICAgLm9uKCdwcy1zY3JvbGwteScsIF8uYmluZCh0aGlzLl9vblNjcm9sbCwgdGhpcykpO1xuICB9LFxuXG4gIF9yZW5kZXJTY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgIFBzLmluaXRpYWxpemUodGhpcy5fY29udGFpbmVyKCksIHtcbiAgICAgIHdoZWVsU3BlZWQ6IDIsXG4gICAgICB3aGVlbFByb3BhZ2F0aW9uOiB0cnVlLFxuICAgICAgbWluU2Nyb2xsYmFyTGVuZ3RoOiAyMFxuICAgIH0pO1xuICB9LFxuXG4gIF9vbldpZGdldENvbGxhcHNlZDogZnVuY3Rpb24oKSB7XG4gICAgUHMudXBkYXRlKHRoaXMuX2NvbnRhaW5lcigpKTtcbiAgfSxcblxuICBfcmVuZGVyU2hhZG93czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuJHNoYWRvd1RvcCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoXCJDREItV2lkZ2V0LWNhbnZhc1NoYWRvdyBDREItV2lkZ2V0LWNhbnZhc1NoYWRvdy0tdG9wXCIpO1xuICAgIHRoaXMuJHNoYWRvd0JvdHRvbSA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoXCJDREItV2lkZ2V0LWNhbnZhc1NoYWRvdyBDREItV2lkZ2V0LWNhbnZhc1NoYWRvdy0tYm90dG9tIGlzLXZpc2libGVcIik7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuJHNoYWRvd1RvcCk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuJHNoYWRvd0JvdHRvbSk7XG4gIH0sXG5cbiAgX29uU2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRzaGFkb3dUb3AucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgfSxcblxuICBfb25TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgIHZhciAkZWwgPSB0aGlzLl8kY29udGFpbmVyKCk7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAkZWwuc2Nyb2xsVG9wKCk7XG4gICAgdmFyIG1heCA9ICRlbC5nZXQoMCkuc2Nyb2xsSGVpZ2h0O1xuICAgIHZhciBoZWlnaHQgPSAkZWwub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgbWF4UG9zID0gbWF4IC0gaGVpZ2h0O1xuICAgIHRoaXMuJHNoYWRvd1RvcC50b2dnbGVDbGFzcygnaXMtdmlzaWJsZScsIGN1cnJlbnRQb3MgPiAwKTtcbiAgICB0aGlzLiRzaGFkb3dCb3R0b20udG9nZ2xlQ2xhc3MoJ2lzLXZpc2libGUnLCBjdXJyZW50UG9zIDwgbWF4UG9zKTtcbiAgfSxcblxuICBfb25TY3JvbGxCb3R0b206IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJHNoYWRvd0JvdHRvbS5yZW1vdmVDbGFzcygnaXMtdmlzaWJsZScpO1xuICB9LFxuXG4gIF9jbGVhblNjcm9sbEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fJGNvbnRhaW5lcigpKSB7XG4gICAgICB0aGlzLl8kY29udGFpbmVyKCkub2ZmKCdwcy1zY3JvbGwteScpO1xuICAgIH1cbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYW5TY3JvbGxFdmVudCgpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNhbnZhc0lubmVyIGpzLWNvbnRhaW5lclwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLnRwbCcpO1xudmFyIERhc2hib2FyZEJlbG93TWFwVmlldyA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLWJlbG93LW1hcC12aWV3Jyk7XG52YXIgRGFzaGJvYXJkSW5mb1ZpZXcgPSByZXF1aXJlKCcuL2Rhc2hib2FyZC1pbmZvLXZpZXcnKTtcbnZhciBEYXNoYm9hcmRTaWRlYmFyVmlldyA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLXNpZGViYXItdmlldycpO1xuXG4vKipcbiAqIERhc2hib2FyZCBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBtYXAgY2FudmFzLCB3aGljaCBjb250YWlucyB3aWRnZXQgdmlld3MgZm9yIHRoZSBtYXAgY29udGR4dFxuICogV2lkZ2V0cyBtYXkgYmUgcmVuZGVyZWQgaW4gdHdvIGFyZWFzLCBpbiB0aGUgXCJzaWRlYmFyXCIgb3IgXCJiZWxvdy1tYXBcIi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLURhc2hib2FyZC1jYW52YXMnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl93aWRnZXRzID0gb3B0aW9ucy53aWRnZXRzO1xuICAgIHRoaXMuX2Rhc2hib2FyZEluZm9Nb2RlbCA9IG9wdGlvbnMuZGFzaGJvYXJkSW5mb01vZGVsO1xuXG4gICAgLy8gVE9ETyBwYXJlbnQgY29udGV4dCByZXF1aXJlcyBzb21lIG1hcmt1cCB0byBiZSBwcmVzZW50IGFscmVhZHksIGJ1dCBOT1QgdGhlIG90aGVyIHZpZXdzXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG5cbiAgICB2YXIgdmlldztcbiAgICB2aWV3ID0gbmV3IERhc2hib2FyZEluZm9WaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLl9kYXNoYm9hcmRJbmZvTW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuXG4gICAgdmlldyA9IG5ldyBEYXNoYm9hcmRCZWxvd01hcFZpZXcoe1xuICAgICAgd2lkZ2V0czogdGhpcy5fd2lkZ2V0c1xuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICB0aGlzLiQoJy5qcy1tYXAtd3JhcHBlcicpLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcblxuICAgIHZpZXcgPSBuZXcgRGFzaGJvYXJkU2lkZWJhclZpZXcoe1xuICAgICAgd2lkZ2V0czogdGhpcy5fd2lkZ2V0c1xuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLW1hcFdyYXBwZXIgQ0RCLURhc2hib2FyZC1tYXBXcmFwcGVyLS1tYXJnaW4ganMtbWFwLXdyYXBwZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1NYXAtY2FudmFzXCI+IDxkaXYgY2xhc3M9XCJDREItTWFwXCIgaWQ9XCJtYXBcIj48L2Rpdj4gPC9kaXY+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGxvZyA9IGNkYi5sb2c7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG5cbi8qKlxuICogQW5pbWF0ZSBiZXR3ZWVuIHR3byB2YWx1ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgYW5pbWF0ZUZyb21WYWx1ZXM6IGZ1bmN0aW9uKGZyb20sIHRvLCBjbGFzc05hbWUsIHRlbXBsYXRlLCBvcHRzKSB7XG4gICAgdmFyICRlbCA9IHRoaXMuJChjbGFzc05hbWUpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgZDMuZm9ybWF0KCcwLDAwMCcpO1xuICAgIHZhciB0ZW1wbGF0ZURhdGEgPSBvcHRpb25zLnRlbXBsYXRlRGF0YSB8fCB7fTtcbiAgICB2YXIgZGVib3VuY2VXYWl0ID0gb3B0aW9ucy5kZWJvdW5jZVdhaXQgfHwgNTAwO1xuXG4gICAgdmFyIHN0ZXBWYWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZSA9IChfLmlzTmFOKGkpIHx8IGkgPT09IHVuZGVmaW5lZCkgPyAob3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgMCkgOiBmb3JtYXR0ZXIoaSk7XG4gICAgICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHsgdmFsdWU6IHZhbHVlIH0sIHRlbXBsYXRlRGF0YSk7XG4gICAgICAkZWwudGV4dCh0ZW1wbGF0ZShkYXRhKSk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvblNwZWVkID09PSAwKSB7XG4gICAgICBzdGVwVmFsdWUodG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0ZXBWYWx1ZShmcm9tKTtcblxuICAgIHZhciBhbmltYXRlID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICRlbC5wcm9wKCdjb3VudGVyJywgZnJvbSkuc3RvcCgpLmFuaW1hdGUoeyBjb3VudGVyOiB0byB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblNwZWVkIHx8IDUwMCxcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZ01ldGhvZCB8fCAnc3dpbmcnLFxuICAgICAgICBzdGVwOiBzdGVwVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIGRlYm91bmNlV2FpdCk7XG5cbiAgICBhbmltYXRlKCk7XG4gIH0sXG5cbiAgYW5pbWF0ZUZyb21DdXJyZW50VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBjbGFzc05hbWUsIHRlbXBsYXRlLCBvcHRzKSB7XG4gICAgdmFyICRlbCA9IHRoaXMuJChjbGFzc05hbWUpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBkZWJvdW5jZVdhaXQgPSBvcHRpb25zLmRlYm91bmNlV2FpdCB8fCA1MDA7XG5cbiAgICB2YXIgdG8gICA9IHZhbHVlO1xuICAgIHZhciBmcm9tID0gK3RoaXMuJChjbGFzc05hbWUpLnRleHQoKTtcblxuICAgIHZhciBmb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBkMy5mb3JtYXQoJzAsMDAwJyk7XG4gICAgdmFyIHRlbXBsYXRlRGF0YSA9IG9wdGlvbnMudGVtcGxhdGVEYXRhIHx8IHt9O1xuXG4gICAgdmFyIHN0ZXBWYWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZSA9IChfLmlzTmFOKGkpIHx8IGkgPT09IHVuZGVmaW5lZCkgPyAob3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgMCkgOiBmb3JtYXR0ZXIoaSk7XG4gICAgICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHsgdmFsdWU6IHZhbHVlIH0sIHRlbXBsYXRlRGF0YSk7XG4gICAgICAkZWwudGV4dCh0ZW1wbGF0ZShkYXRhKSk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvblNwZWVkID09PSAwKSB7XG4gICAgICBzdGVwVmFsdWUodG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0ZXBWYWx1ZShmcm9tKTtcblxuICAgIHZhciBhbmltYXRlID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICRlbC5wcm9wKCdjb3VudGVyJywgZnJvbSkuc3RvcCgpLmFuaW1hdGUoeyBjb3VudGVyOiB0byB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblNwZWVkIHx8IDUwMCxcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZ01ldGhvZCB8fCAnc3dpbmcnLFxuICAgICAgICBzdGVwOiBzdGVwVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIGRlYm91bmNlV2FpdCk7XG5cbiAgICBhbmltYXRlKCk7XG4gIH0sXG5cbiAgYW5pbWF0ZVZhbHVlOiBmdW5jdGlvbihtb2RlbCwgd2hhdCwgY2xhc3NOYW1lLCB0ZW1wbGF0ZSwgb3B0cykge1xuICAgIHZhciAkZWwgPSB0aGlzLiQoY2xhc3NOYW1lKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZGVib3VuY2VXYWl0ID0gb3B0aW9ucy5kZWJvdW5jZVdhaXQgfHwgNTAwO1xuXG4gICAgdmFyIHRvICAgPSBtb2RlbC5nZXQod2hhdCk7XG4gICAgdmFyIGZyb20gPSBtb2RlbC5wcmV2aW91cyh3aGF0KSB8fCAwO1xuXG4gICAgdmFyIGZvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IGQzLmZvcm1hdCgnMCwwMDAnKTtcbiAgICB2YXIgdGVtcGxhdGVEYXRhID0gb3B0aW9ucy50ZW1wbGF0ZURhdGEgfHwge307XG5cbiAgICB2YXIgc3RlcFZhbHVlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhbHVlID0gKF8uaXNOYU4oaSkgfHwgaSA9PT0gdW5kZWZpbmVkKSA/IChvcHRpb25zLmRlZmF1bHRWYWx1ZSB8fCAwKSA6IGZvcm1hdHRlcihpKTtcbiAgICAgIHZhciBkYXRhID0gXy5leHRlbmQoeyB2YWx1ZTogdmFsdWUgfSwgdGVtcGxhdGVEYXRhKTtcbiAgICAgICRlbC50ZXh0KHRlbXBsYXRlKGRhdGEpKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uU3BlZWQgPT09IDApIHtcbiAgICAgIHN0ZXBWYWx1ZSh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RlcFZhbHVlKGZyb20pO1xuXG4gICAgdmFyIGFuaW1hdGUgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgJGVsLnByb3AoJ2NvdW50ZXInLCBmcm9tKS5zdG9wKCkuYW5pbWF0ZSh7IGNvdW50ZXI6IHRvIH0sIHtcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uU3BlZWQgfHwgNTAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nTWV0aG9kIHx8ICdzd2luZycsXG4gICAgICAgIHN0ZXA6IHN0ZXBWYWx1ZVxuICAgICAgfSk7XG4gICAgfSwgZGVib3VuY2VXYWl0KTtcblxuICAgIGFuaW1hdGUoKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWhlYWRlciBqcy1oZWFkZXJcIj48L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudCBDREItV2lkZ2V0LWNvbnRlbnQtLW5vU2lkZXNNYXJnaW5cIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdFdyYXBwZXIganMtY29udGVudFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtZm9vdGVyIGpzLWZvb3RlclwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgV2lkZ2V0Q29udGVudCA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBTZWFyY2hUaXRsZVZpZXcgPSByZXF1aXJlKCcuL3RpdGxlL3NlYXJjaF90aXRsZV92aWV3Jyk7XG52YXIgQ2F0ZWdvcnlPcHRpb25zVmlldyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9vcHRpb25zX3ZpZXcnKTtcbnZhciBDYXRlZ29yeUl0ZW1zVmlldyA9IHJlcXVpcmUoJy4vbGlzdC9pdGVtc192aWV3Jyk7XG52YXIgV2lkZ2V0Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vd2lkZ2V0X2NvbnRlbnRfbW9kZWwnKTtcbnZhciBDYXRlZ29yeVN0YXRzVmlldyA9IHJlcXVpcmUoJy4vc3RhdHMvc3RhdHNfdmlldycpO1xudmFyIENhdGVnb3J5UGFnaW5hdG9yVmlldyA9IHJlcXVpcmUoJy4vcGFnaW5hdG9yL3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgU2VhcmNoQ2F0ZWdvcnlJdGVtc1ZpZXcgPSByZXF1aXJlKCcuL2xpc3Qvc2VhcmNoX2l0ZW1zX3ZpZXcnKTtcbnZhciBTZWFyY2hDYXRlZ29yeVBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvci9zZWFyY2hfcGFnaW5hdG9yX3ZpZXcnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY29udGVudF90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDb250ZW50IHZpZXcgZm9yIGNhdGVnb3J5IHdpZGdldFxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldENvbnRlbnQuZXh0ZW5kKHtcblxuICBfSVRFTVNfUEVSX1BBR0U6IDYsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFdpZGdldFZpZXdNb2RlbCgpO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpjb2xsYXBzZWQnLCBmdW5jdGlvbihtZGwsIGlzQ29sbGFwc2VkKSB7XG4gICAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnaXMtY29sbGFwc2VkJywgISFpc0NvbGxhcHNlZCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlYXJjaFRpdGxlID0gbmV3IFNlYXJjaFRpdGxlVmlldyh7XG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtaGVhZGVyJykuYXBwZW5kKHNlYXJjaFRpdGxlLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2VhcmNoVGl0bGUpO1xuXG4gICAgdmFyIHN0YXRzID0gbmV3IENhdGVnb3J5U3RhdHNWaWV3KHtcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1oZWFkZXInKS5hcHBlbmQoc3RhdHMucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhzdGF0cyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG5ldyBDYXRlZ29yeU9wdGlvbnNWaWV3KHtcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuaHRtbChvcHRpb25zLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcob3B0aW9ucyk7XG5cbiAgICB2YXIgZGF0YUxpc3QgPSBuZXcgQ2F0ZWdvcnlJdGVtc1ZpZXcoe1xuICAgICAgdmlld01vZGVsOiB0aGlzLnZpZXdNb2RlbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIGl0ZW1zUGVyUGFnZTogdGhpcy5fSVRFTVNfUEVSX1BBR0VcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKGRhdGFMaXN0LnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoZGF0YUxpc3QpO1xuXG4gICAgdmFyIHBhZ2luYXRpb24gPSBuZXcgQ2F0ZWdvcnlQYWdpbmF0b3JWaWV3KHtcbiAgICAgICR0YXJnZXQ6IGRhdGFMaXN0LiRlbCxcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBpdGVtc1BlclBhZ2U6IHRoaXMuX0lURU1TX1BFUl9QQUdFXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtZm9vdGVyJykuYXBwZW5kKHBhZ2luYXRpb24ucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhwYWdpbmF0aW9uKTtcblxuICAgIHZhciBzZWFyY2hMaXN0ID0gbmV3IFNlYXJjaENhdGVnb3J5SXRlbXNWaWV3KHtcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBpdGVtc1BlclBhZ2U6IHRoaXMuX0lURU1TX1BFUl9QQUdFLFxuICAgICAgcGFnaW5hdG9yOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZChzZWFyY2hMaXN0LnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2VhcmNoTGlzdCk7XG5cbiAgICB2YXIgc2VhcmNoUGFnaW5hdGlvbiA9IG5ldyBTZWFyY2hDYXRlZ29yeVBhZ2luYXRvclZpZXcoe1xuICAgICAgJHRhcmdldDogc2VhcmNoTGlzdC4kZWwsXG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgaXRlbXNQZXJQYWdlOiB0aGlzLl9JVEVNU19QRVJfUEFHRSxcbiAgICAgIHBhZ2luYXRvcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLWZvb3RlcicpLmFwcGVuZChzZWFyY2hQYWdpbmF0aW9uLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2VhcmNoUGFnaW5hdGlvbik7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0SXRlbUlubmVyIENEQi1XaWRnZXQtbGlzdEJ1dHRvbiBqcy1idXR0b24gJytcbigoX190PSggaXNEaXNhYmxlZCA/ICdpcy1kaXNhYmxlZCcgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIENEQi1XaWRnZXQtdGV4dFNtYWxsLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsLS11cHBlclwiIHRpdGxlPVwiJytcbigoX190PSggbmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBuYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBwcmVmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggZm9ybWF0dGVkVmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggc3VmZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXByb2dyZXNzQmFyXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUgJytcbigoX190PSggaXNBZ2dyZWdhdGVkID8gJ0NEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZS0tcGF0dGVybicgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBzdHlsZT1cIndpZHRoOiAnK1xuKChfX3Q9KCBwZXJjZW50YWdlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyU7IGJhY2tncm91bmQtY29sb3I6ICcrXG4oKF9fdD0oIGN1c3RvbUNvbG9yID8gY29sb3IgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj48L2Rpdj4gPC9kaXY+IDwvYnV0dG9uPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciAnK1xuKChfX3Q9KCBpc0Rpc2FibGVkID8gJ2lzLWRpc2FibGVkJyA6ICcnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGwgQ0RCLVdpZGdldC10ZXh0U21hbGwtLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGwtLXVwcGVyXCIgdGl0bGU9XCInK1xuKChfX3Q9KCBuYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXJcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIHByZWZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBmb3JtYXR0ZWRWYWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBzdWZmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9wPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtcHJvZ3Jlc3NCYXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZSBDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUtLXBhdHRlcm4gJytcbigoX190PSggaXNBZ2dyZWdhdGVkID8gJ0NEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZS0taW5hY3RpdmUnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCIgc3R5bGU9XCJ3aWR0aDogJytcbigoX190PSggcGVyY2VudGFnZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclOyBiYWNrZ3JvdW5kLWNvbG9yOiAnK1xuKChfX3Q9KCBjdXN0b21Db2xvciA/IGNvbG9yIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBjbGlja2FibGVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaXRlbV9jbGlja2FibGVfdGVtcGxhdGUudHBsJyk7XG52YXIgdW5jbGlja2FibGVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaXRlbV91bmNsaWNrYWJsZV90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDYXRlZ29yeSBsaXN0IGl0ZW0gdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICB0YWdOYW1lOiAnbGknLFxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWxpc3RJdGVtJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLWJ1dHRvbic6ICdfb25JdGVtQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwuZ2V0KCd2YWx1ZScpO1xuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMubW9kZWwuZ2V0KCdhZ2cnKSB8fMKgdGhpcy5kYXRhTW9kZWwuaXNMb2NrZWQoKSA/XG4gICAgICB1bmNsaWNrYWJsZVRlbXBsYXRlIDogY2xpY2thYmxlVGVtcGxhdGU7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICBjdXN0b21Db2xvcjogdGhpcy5kYXRhTW9kZWwuaXNDb2xvckFwcGxpZWQoKSxcbiAgICAgICAgaXNBZ2dyZWdhdGVkOiB0aGlzLm1vZGVsLmdldCgnYWdnJyksXG4gICAgICAgIG5hbWU6IHRoaXMubW9kZWwuZ2V0KCduYW1lJyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlci5mb3JtYXROdW1iZXIodmFsdWUpLFxuICAgICAgICBwZXJjZW50YWdlOiAoKHZhbHVlIC8gdGhpcy5kYXRhTW9kZWwuZ2V0KCdtYXgnKSkgKiAxMDApLFxuICAgICAgICBjb2xvcjogdGhpcy5tb2RlbC5nZXQoJ2NvbG9yJyksXG4gICAgICAgIGlzRGlzYWJsZWQ6ICF0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWQnKSA/ICdpcy1kaXNhYmxlZCcgOiAnJyxcbiAgICAgICAgcHJlZml4OiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3ByZWZpeCcpLFxuICAgICAgICBzdWZmaXg6IHRoaXMuZGF0YU1vZGVsLmdldCgnc3VmZml4JylcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpzZWFyY2ggY2hhbmdlOmNhdGVnb3J5Q29sb3JzJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICB9LFxuXG4gIF9vbkl0ZW1DbGljazogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdpdGVtQ2xpY2tlZCcsIHRoaXMubW9kZWwsIHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciBDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXItLWZ1bGxTcGFjZSBDREItV2lkZ2V0LWxpc3RCdXR0b24ganMtYnV0dG9uICcrXG4oKF9fdD0oIGlzRGlzYWJsZWQgPyAnaXMtZGlzYWJsZWQnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVdpZGdldC1jaGVja2JveCAnK1xuKChfX3Q9KCBpc0Rpc2FibGVkID8gJycgOiAnaXMtY2hlY2tlZCcgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9zcGFuPiA8ZGl2IGNsYXNzPVwidS1sU3BhY2UtLXhsXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCBDREItV2lkZ2V0LXRleHRTbWFsbC0tYm9sZCBDREItV2lkZ2V0LXRleHRTbWFsbC0tdXBwZXJcIiB0aXRsZT1cIicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggbmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlclwiIHRpdGxlPVwiJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggcHJlZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHN1ZmZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1wcm9ncmVzc0JhclwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1wcm9ncmVzc1N0YXRlXCIgc3R5bGU9XCJ3aWR0aDogJytcbigoX190PSggcGVyY2VudGFnZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclXCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gPC9idXR0b24+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgZm9ybWF0dGVyID0gY2RiLmNvcmUuZm9ybWF0O1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9zZWFyY2hfaXRlbV9jbGlja2FibGVfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgc2VhcmNoIGxpc3Qgdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICB0YWdOYW1lOiAnbGknLFxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWxpc3RJdGVtJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLWJ1dHRvbic6ICdfb25JdGVtQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vIFRoaXMgZGF0YSBtb2RlbCBjb21lcyBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIGluIG9yZGVyIHRvIGdldFxuICAgIC8vIHRoZSBtYXggdmFsdWUgYW5kIHNldCBwcm9wZXJseSB0aGUgcHJvZ3Jlc3MgYmFyIGFuZCBhZGQgdGhlXG4gICAgLy8gbmVjZXNzYXJ5IHN1ZmZpeCBhbmQgcHJlZml4IGZvciB0aGUgaXRlbS5cbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmdldCgndmFsdWUnKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubW9kZWwuZ2V0KCduYW1lJyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlci5mb3JtYXROdW1iZXIodmFsdWUpLFxuICAgICAgICBwZXJjZW50YWdlOiAoKHZhbHVlIC8gdGhpcy5kYXRhTW9kZWwuZ2V0KCdtYXgnKSkgKiAxMDApLFxuICAgICAgICBpc0Rpc2FibGVkOiAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJyksXG4gICAgICAgIHByZWZpeDogdGhpcy5kYXRhTW9kZWwuZ2V0KCdwcmVmaXgnKSxcbiAgICAgICAgc3VmZml4OiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3N1ZmZpeCcpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpzZWxlY3RlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgfSxcblxuICBfb25JdGVtQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdzZWxlY3RlZCcsICF0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWQnKSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgQ2F0ZWdvcnlJdGVtVmlldyA9IHJlcXVpcmUoJy4vaXRlbS9pdGVtX3ZpZXcnKTtcbnZhciBwbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vaXRlbXNfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgbGlzdCB2aWV3XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBwYWdpbmF0b3I6IGZhbHNlLFxuICAgIGl0ZW1zUGVyUGFnZTogNlxuICB9LFxuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbGlzdCBDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQganMtbGlzdCcsXG4gIHRhZ05hbWU6ICd1bCcsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcblxuICAgIGlmIChpc0RhdGFFbXB0eSkge1xuICAgICAgdGhpcy5fcmVuZGVyUGxhY2Vob2xkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyTGlzdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy50b2dnbGUsIHRoaXMpO1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhIGNoYW5nZTpzZWFyY2hEYXRhJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICB9LFxuXG4gIF9yZW5kZXJQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhbmdlIHZpZXcgY2xhc3Nlc1xuICAgIHRoaXMuJGVsXG4gICAgICAuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdC0td2l0aEJvcmRlcnMnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcbiAgICB0aGlzLiRlbC5hcHBlbmQocGxhY2Vob2xkZXIoKSk7XG4gIH0sXG5cbiAgX3JlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIC8vIENoYW5nZSB2aWV3IGNsYXNzZXNcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnQ0RCLVdpZGdldC1saXN0LS13aXRoQm9yZGVycycpO1xuICAgIHRoaXMuJGVsWyB0aGlzLm9wdGlvbnMucGFnaW5hdG9yID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcblxuICAgIHZhciBncm91cEl0ZW07XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCk7XG5cbiAgICBkYXRhLmVhY2goZnVuY3Rpb24obWRsLCBpKSB7XG4gICAgICBpZiAoaSAlIHRoaXMub3B0aW9ucy5pdGVtc1BlclBhZ2UgPT09IDApIHtcbiAgICAgICAgZ3JvdXBJdGVtID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnQ0RCLVdpZGdldC1saXN0R3JvdXAnKTtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGdyb3VwSXRlbSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRJdGVtKG1kbCwgZ3JvdXBJdGVtKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfYWRkSXRlbTogZnVuY3Rpb24obWRsLCAkcGFyZW50KSB7XG4gICAgdmFyIHYgPSBuZXcgQ2F0ZWdvcnlJdGVtVmlldyh7XG4gICAgICBtb2RlbDogbWRsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLmRhdGFNb2RlbFxuICAgIH0pO1xuICAgIHYuYmluZCgnaXRlbUNsaWNrZWQnLCB0aGlzLl9zZXRGaWx0ZXJzLCB0aGlzKTtcbiAgICB0aGlzLmFkZFZpZXcodik7XG4gICAgJHBhcmVudC5hcHBlbmQodi5yZW5kZXIoKS5lbCk7XG4gIH0sXG5cbiAgX3NldEZpbHRlcnM6IGZ1bmN0aW9uKG1kbCkge1xuICAgIHZhciBpc1NlbGVjdGVkID0gbWRsLmdldCgnc2VsZWN0ZWQnKTtcblxuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YU1vZGVsLmdldFJlamVjdGVkQ291bnQoKSAmJiAhdGhpcy5kYXRhTW9kZWwuZ2V0QWNjZXB0ZWRDb3VudCgpICYmIHRoaXMuZGF0YU1vZGVsLmdldENvdW50KCkgPiAxKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgcmVqZWN0cyA9IFtdO1xuICAgICAgICAvLyBNYWtlIGVsZW1lbnRzIFwidW5zZWxlY3RlZFwiXG4gICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG0uZ2V0KCduYW1lJyk7XG4gICAgICAgICAgaWYgKG5hbWUgIT09IG1kbC5nZXQoJ25hbWUnKSkge1xuICAgICAgICAgICAgbS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmFjY2VwdEZpbHRlcnMobWRsLmdldCgnbmFtZScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1kbC5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZWplY3RGaWx0ZXJzKG1kbC5nZXQoJ25hbWUnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1kbC5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICB0aGlzLmRhdGFNb2RlbC5hY2NlcHRGaWx0ZXJzKG1kbC5nZXQoJ25hbWUnKSk7XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sgIXRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdpcy1oaWRkZW4nKTtcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5hZGRDbGFzcygnaXMtaGlkZGVuJyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1cIj4gPGg0IGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnIENEQi1XaWRnZXQtdGV4dEJpZy0tYm9sZFwiPk5vIHJlc3VsdHM8L2g0PiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIHUtdFNwYWNlLXhsXCI+WW91ciBzZWFyY2ggXCInK1xuKChfX3Q9KCBxICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIGRpZG5cXCd0IG1hdGNoPGJyPndpdGggYW55IHZhbHVlLjwvcD4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCB1LXRTcGFjZS14bFwiPlRyeSBzZWFyY2hpbmcgYWdhaW4uPC9wPiA8L2xpPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIENhdGVnb3J5SXRlbXNWaWV3ID0gcmVxdWlyZSgnLi9pdGVtc192aWV3Jyk7XG52YXIgV2lkZ2V0U2VhcmNoQ2F0ZWdvcnlJdGVtVmlldyA9IHJlcXVpcmUoJy4vaXRlbS9zZWFyY2hfaXRlbV92aWV3Jyk7XG52YXIgcGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL3NlYXJjaF9pdGVtc19ub19yZXN1bHRzX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIENhdGVnb3J5IGxpc3Qgdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5SXRlbXNWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0IGlzLWhpZGRlbiBDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQganMtbGlzdCcsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoUmVzdWx0KCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gZGF0YS5pc0VtcHR5KCkgfHwgZGF0YS5zaXplKCkgPT09IDA7XG5cbiAgICBpZiAoaXNEYXRhRW1wdHkpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBsYWNlaG9sZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckxpc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3JlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdpdGhCb3JkZXJzIENEQi1XaWRnZXQtbGlzdC0tbm9yZXN1bHRzJyk7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdC0td3JhcHBlZCcpO1xuXG4gICAgdmFyIGdyb3VwSXRlbTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaFJlc3VsdCgpO1xuXG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uKG1kbCwgaSkge1xuICAgICAgaWYgKGkgJSB0aGlzLm9wdGlvbnMuaXRlbXNQZXJQYWdlID09PSAwKSB7XG4gICAgICAgIGdyb3VwSXRlbSA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdEdyb3VwJyk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChncm91cEl0ZW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkSXRlbShtZGwsIGdyb3VwSXRlbSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX3JlbmRlclBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFuZ2UgdmlldyBjbGFzc2VzXG4gICAgdGhpcy4kZWxcbiAgICAgIC5hZGRDbGFzcygnQ0RCLVdpZGdldC1saXN0LS1ub3Jlc3VsdHMnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICBwbGFjZWhvbGRlcih7XG4gICAgICAgIHE6IHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaFF1ZXJ5KClcbiAgICAgIH0pXG4gICAgKTtcbiAgfSxcblxuICBfYWRkSXRlbTogZnVuY3Rpb24obWRsLCAkcGFyZW50KSB7XG4gICAgdmFyIHYgPSBuZXcgV2lkZ2V0U2VhcmNoQ2F0ZWdvcnlJdGVtVmlldyh7XG4gICAgICBtb2RlbDogbWRsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLmRhdGFNb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh2KTtcbiAgICAkcGFyZW50LmFwcGVuZCh2LnJlbmRlcigpLmVsKTtcbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbIHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIGQzID0gY2RiLmQzO1xudmFyIENhdGVnb3J5Q29sb3JzID0gcmVxdWlyZSgnLi9tb2RlbHMvY2F0ZWdvcnlfY29sb3JzJyk7XG52YXIgV2lkZ2V0TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfbW9kZWwnKTtcbnZhciBXaWRnZXRTZWFyY2hNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWxzL3NlYXJjaF9tb2RlbCcpO1xudmFyIENhdGVnb3J5TW9kZWxSYW5nZSA9IHJlcXVpcmUoJy4vbW9kZWxzL2NhdGVnb3J5X21vZGVsX3JhbmdlJyk7XG52YXIgQ2F0ZWdvcmllc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL21vZGVscy9jYXRlZ29yaWVzX2NvbGxlY3Rpb24nKTtcbnZhciBMb2NrZWRDYXRzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vbW9kZWxzL2xvY2tlZF9jYXRlZ29yaWVzX2NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiAgQ2F0ZWdvcnkgd2lkZ2V0IG1vZGVsXG4gKlxuICogIC0gSXQgaGFzIHNldmVyYWwgaW50ZXJuYWwgbW9kZWxzL2NvbGxlY3Rpb25zXG4gKlxuICogIMK3IHNlYXJjaCBtb2RlbDogaXQgbWFuYWdlcyBjYXRlZ29yeSBzZWFyY2ggcmVzdWx0cy5cbiAqICDCtyBsb2NrZWQgY29sbGVjdGlvbjogaXQgc3RvcmVzIGxvY2tlZCBpdGVtcy5cbiAqICDCtyBmaWx0ZXIgbW9kZWw6IGl0IGtub3dzIHdoaWNoIGl0ZW1zIGFyZSBhY2NlcHRlZCBvciByZWplY3RlZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRNb2RlbC5leHRlbmQoe1xuXG4gIHVybDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd1cmwnKSArICc/YmJveD0nICsgdGhpcy5nZXQoJ2JvdW5kaW5nQm94JykgKyAnJm93bl9maWx0ZXI9JyArICh0aGlzLmdldCgnbG9ja2VkJykgPyAxIDogMCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICB0aGlzLl9kYXRhID0gbmV3IENhdGVnb3JpZXNDb2xsZWN0aW9uKCk7XG5cbiAgICBXaWRnZXRNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRzKTtcblxuICAgIC8vIExvY2tlZCBjYXRlZ29yaWVzIGNvbGxlY3Rpb25cbiAgICB0aGlzLmxvY2tlZCA9IG5ldyBMb2NrZWRDYXRzQ29sbGVjdGlvbigpO1xuXG4gICAgLy8gSW50ZXJuYWwgbW9kZWwgZm9yIGNhbGN1bGF0aW5nIHRvdGFsIGFtb3VudCBvZiB2YWx1ZXMgaW4gdGhlIGNhdGVnb3J5XG4gICAgdGhpcy5yYW5nZU1vZGVsID0gbmV3IENhdGVnb3J5TW9kZWxSYW5nZSgpO1xuXG4gICAgLy8gQ29sb3JzIGNsYXNzXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgQ2F0ZWdvcnlDb2xvcnMoKTtcblxuICAgIC8vIFNlYXJjaCBtb2RlbFxuICAgIHRoaXMuc2VhcmNoID0gbmV3IFdpZGdldFNlYXJjaE1vZGVsKHt9LCB7XG4gICAgICBsb2NrZWQ6IHRoaXMubG9ja2VkXG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gU2V0IGFueSBuZWVkZWQgcGFyYW1ldGVyIHdoZW4gdGhleSBoYXZlIGNoYW5nZWQgaW4gdGhpcyBtb2RlbFxuICBfc2V0SW50ZXJuYWxNb2RlbHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cmwgPSB0aGlzLmdldCgndXJsJyk7XG5cbiAgICB0aGlzLnNlYXJjaC5zZXQoe1xuICAgICAgdXJsOiB1cmwsXG4gICAgICBib3VuZGluZ0JveDogdGhpcy5nZXQoJ2JvdW5kaW5nQm94JylcbiAgICB9KTtcblxuICAgIHRoaXMucmFuZ2VNb2RlbC5zZXRVcmwodXJsKTtcbiAgfSxcblxuICBfb25DaGFuZ2VCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0SW50ZXJuYWxNb2RlbHMoKTtcblxuICAgIHRoaXMucmFuZ2VNb2RlbC5iaW5kKCdjaGFuZ2U6dG90YWxDb3VudCcsIGZ1bmN0aW9uKG1kbCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0KCd0b3RhbENvdW50JywgdmFsdWUpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6dXJsJywgZnVuY3Rpb24oKXtcbiAgICAgIGlmICh0aGlzLmdldCgnc3luYycpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOmJvdW5kaW5nQm94JywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiBhIHNlYXJjaCBpcyBhcHBsaWVkIGFuZCBib3VuZGluZyBib3VuZHMgaGFzIGNoYW5nZWQsXG4gICAgICAvLyBkb24ndCBmZXRjaCBuZXcgcmF3IGRhdGFcbiAgICAgIGlmICh0aGlzLmdldCgnYmJveCcpICYmICF0aGlzLmlzU2VhcmNoQXBwbGllZCgpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOnVybCBjaGFuZ2U6Ym91bmRpbmdCb3gnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VhcmNoLnNldCh7XG4gICAgICAgIHVybDogdGhpcy5nZXQoJ3VybCcpLFxuICAgICAgICBib3VuZGluZ0JveDogdGhpcy5nZXQoJ2JvdW5kaW5nQm94JylcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6Y29sbGFwc2VkJywgZnVuY3Rpb24obWRsLCBpc0NvbGxhcHNlZCkge1xuICAgICAgaWYgKCFpc0NvbGxhcHNlZCkge1xuICAgICAgICBpZiAobWRsLmNoYW5nZWRBdHRyaWJ1dGVzKHRoaXMuX3ByZXZpb3VzQXR0cnMpKSB7XG4gICAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRycyA9IHtcbiAgICAgICAgICB1cmw6IHRoaXMuZ2V0KCd1cmwnKSxcbiAgICAgICAgICBib3VuZGluZ0JveDogdGhpcy5nZXQoJ2JvdW5kaW5nQm94JylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMubG9ja2VkLmJpbmQoJ2NoYW5nZSBhZGQgcmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpsb2NrQ29sbGVjdGlvbicsIHRoaXMubG9ja2VkLCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2VhcmNoLmJpbmQoJ2xvYWRpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIiwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5zZWFyY2guYmluZCgnc3luYycsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKFwic3luY1wiLCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLnNlYXJjaC5iaW5kKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZSB8fCAoZSAmJiBlLnN0YXR1c1RleHQgIT09IFwiYWJvcnRcIikpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZXJyb3JcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5zZWFyY2guYmluZCgnY2hhbmdlOmRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnNlYXJjaERhdGEnLCB0aGlzLnNlYXJjaCwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLypcbiAgICogIEhlbHBlciBtZXRob2RzIGZvciBpbnRlcm5hbCBtb2RlbHMvY29sbGVjdGlvbnNcbiAgICpcbiAgICovXG5cbiAgYXBwbHlDYXRlZ29yeUNvbG9yczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ2NhdGVnb3J5Q29sb3JzJywgdHJ1ZSk7XG4gICAgdmFyIGNvbG9yc0RhdGEgPSB0aGlzLl9kYXRhLm1hcChmdW5jdGlvbihtKXtcbiAgICAgIHJldHVybiBbIG0uZ2V0KCduYW1lJyksIG0uZ2V0KCdjb2xvcicpIF07XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKCdhcHBseUNhdGVnb3J5Q29sb3JzJywgY29sb3JzRGF0YSwgdGhpcyk7XG4gIH0sXG5cbiAgY2FuY2VsQ2F0ZWdvcnlDb2xvcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdjYXRlZ29yeUNvbG9ycycsIGZhbHNlKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbENhdGVnb3J5Q29sb3JzJywgdGhpcyk7XG4gIH0sXG5cbiAgaXNDb2xvckFwcGxpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnY2F0ZWdvcnlDb2xvcnMnKTtcbiAgfSxcblxuICAvLyBMb2NrZWQgY29sbGVjdGlvbiBoZWxwZXIgbWV0aG9kcyAvL1xuXG4gIGdldExvY2tlZFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2tlZC5zaXplKCk7XG4gIH0sXG5cbiAgaXNMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnbG9ja2VkJyk7XG4gIH0sXG5cbiAgY2FuQmVMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9ja2VkKCkgfHxcbiAgICAgIHRoaXMuZ2V0QWNjZXB0ZWRDb3VudCgpID4gMDtcbiAgfSxcblxuICBjYW5BcHBseUxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjY2VwdGVkQ29sbGVjdGlvbiA9IHRoaXMuZmlsdGVyLmdldEFjY2VwdGVkKCk7XG4gICAgaWYgKHRoaXMuZmlsdGVyLmdldEFjY2VwdGVkKCkuc2l6ZSgpICE9PSB0aGlzLmxvY2tlZC5zaXplKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZENvbGxlY3Rpb24uZmluZChmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gIXRoaXMubG9ja2VkLmlzSXRlbUxvY2tlZChtLmdldCgnbmFtZScpKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBhcHBseUxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRMb2NrZWQgPSB0aGlzLmxvY2tlZC5nZXRJdGVtc05hbWUoKTtcbiAgICBpZiAoIWN1cnJlbnRMb2NrZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVubG9ja0NhdGVnb3JpZXMoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zZXQoJ2xvY2tlZCcsIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyLmNsZWFuRmlsdGVyKGZhbHNlKTtcbiAgICB0aGlzLmZpbHRlci5hY2NlcHQoY3VycmVudExvY2tlZCk7XG4gICAgdGhpcy5maWx0ZXIuYXBwbHlGaWx0ZXIoKTtcbiAgICB0aGlzLmNsZWFuU2VhcmNoKCk7XG4gIH0sXG5cbiAgbG9ja0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdsb2NrZWQnLCB0cnVlKTtcbiAgICB0aGlzLl9mZXRjaCgpO1xuICB9LFxuXG4gIHVubG9ja0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdsb2NrZWQnLCBmYWxzZSk7XG4gICAgdGhpcy5hY2NlcHRBbGwoKTtcbiAgfSxcblxuICAvLyBTZWFyY2ggbW9kZWwgaGVscGVyIG1ldGhvZHMgLy9cblxuICBnZXRTZWFyY2hRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmdldFNlYXJjaFF1ZXJ5KCk7XG4gIH0sXG5cbiAgc2V0U2VhcmNoUXVlcnk6IGZ1bmN0aW9uKHEpIHtcbiAgICB0aGlzLnNlYXJjaC5zZXQoJ3EnLCBxKTtcbiAgfSxcblxuICBpc1NlYXJjaFZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2guaXNWYWxpZCgpO1xuICB9LFxuXG4gIGdldFNlYXJjaFJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmdldERhdGEoKTtcbiAgfSxcblxuICBnZXRTZWFyY2hDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmdldENvdW50KCk7XG4gIH0sXG5cbiAgYXBwbHlTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VhcmNoLmZldGNoKCk7XG4gIH0sXG5cbiAgaXNTZWFyY2hBcHBsaWVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2guaXNTZWFyY2hBcHBsaWVkKCk7XG4gIH0sXG5cbiAgY2xlYW5TZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubG9ja2VkLnJlc2V0SXRlbXMoW10pO1xuICAgIHRoaXMuc2VhcmNoLnJlc2V0RGF0YSgpO1xuICB9LFxuXG4gIHNldHVwU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWFyY2hBcHBsaWVkKCkpIHtcbiAgICAgIHZhciBhY2NlcHRlZENhdHMgPSB0aGlzLmZpbHRlci5nZXRBY2NlcHRlZCgpLnRvSlNPTigpO1xuICAgICAgdGhpcy5sb2NrZWQuYWRkSXRlbXMoYWNjZXB0ZWRDYXRzKTtcbiAgICAgIHRoaXMuc2VhcmNoLnNldERhdGEoXG4gICAgICAgIHRoaXMuX2RhdGEudG9KU09OKClcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEZpbHRlciBtb2RlbCBoZWxwZXIgbWV0aG9kcyAvL1xuXG4gIGdldFJlamVjdGVkQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci5yZWplY3RlZENhdGVnb3JpZXMuc2l6ZSgpO1xuICB9LFxuXG4gIGdldEFjY2VwdGVkQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci5hY2NlcHRlZENhdGVnb3JpZXMuc2l6ZSgpO1xuICB9LFxuXG4gIGFjY2VwdEZpbHRlcnM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHRoaXMuZmlsdGVyLmFjY2VwdCh2YWx1ZXMpO1xuICB9LFxuXG4gIHJlamVjdEZpbHRlcnM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHRoaXMuZmlsdGVyLnJlamVjdCh2YWx1ZXMpO1xuICB9LFxuXG4gIHJlamVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXIucmVqZWN0QWxsKCk7XG4gIH0sXG5cbiAgYWNjZXB0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlci5hY2NlcHRBbGwoKTtcbiAgfSxcblxuICBpc0FsbEZpbHRlcnNSZWplY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyLmdldCgncmVqZWN0QWxsJyk7XG4gIH0sXG5cbiAgLy8gUHJvcGVyIG1vZGVsIGhlbHBlciBtZXRob2RzIC8vXG5cbiAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH0sXG5cbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZSgpO1xuICB9LFxuXG4gIGdldENvdW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NhdGVnb3JpZXNDb3VudCcpO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzU2VhcmNoQXBwbGllZCgpKSB7XG4gICAgICB0aGlzLnNlYXJjaC5mZXRjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mZXRjaCgpO1xuICAgIH1cbiAgfSxcblxuICAvLyBEYXRhIHBhcnNlciBtZXRob2RzIC8vXG5cbiAgX3BhcnNlRGF0YTogZnVuY3Rpb24oY2F0ZWdvcmllcykge1xuICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgdmFyIF90bXBBcnJheSA9IHt9O1xuICAgIHZhciBhY2NlcHRlZENhdHMgPSB0aGlzLmZpbHRlci5nZXRBY2NlcHRlZCgpO1xuXG4gICAgLy8gVXBkYXRlIGNvbG9ycyBieSBkYXRhIGNhdGVnb3JpZXNcbiAgICB0aGlzLmNvbG9ycy51cGRhdGVEYXRhKFxuICAgICAgXy51bmlxKFxuICAgICAgICBfLnVuaW9uKFxuICAgICAgICAgIF8ucGx1Y2soY2F0ZWdvcmllcywgJ2NhdGVnb3J5JyksXG4gICAgICAgICAgXy5wbHVjayhhY2NlcHRlZENhdHMsICduYW1lJylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBfLmVhY2goY2F0ZWdvcmllcywgZnVuY3Rpb24oZGF0dW0sIGkpIHtcbiAgICAgIHZhciBjYXRlZ29yeSA9IGRhdHVtLmNhdGVnb3J5O1xuICAgICAgdmFyIGlzUmVqZWN0ZWQgPSB0aGlzLmZpbHRlci5pc1JlamVjdGVkKGNhdGVnb3J5KTtcbiAgICAgIF90bXBBcnJheVtjYXRlZ29yeV0gPSB0cnVlO1xuXG4gICAgICBuZXdEYXRhLnB1c2goe1xuICAgICAgICBzZWxlY3RlZDogIWlzUmVqZWN0ZWQsXG4gICAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgICBhZ2c6IGRhdHVtLmFnZyxcbiAgICAgICAgdmFsdWU6IGRhdHVtLnZhbHVlLFxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcnMuZ2V0Q29sb3JCeUNhdGVnb3J5KGNhdGVnb3J5KVxuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAvLyBBZGQgYWNjZXB0ZWQgaXRlbXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGNhdGVnb3JpZXMgZGF0YVxuICAgICAgYWNjZXB0ZWRDYXRzLmVhY2goZnVuY3Rpb24obWRsLCBpKSB7XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IG1kbC5nZXQoJ25hbWUnKS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIV90bXBBcnJheVtjYXRlZ29yeV0pIHtcbiAgICAgICAgICBuZXdEYXRhLnB1c2goe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcnMuZ2V0Q29sb3JCeUNhdGVnb3J5KGNhdGVnb3J5KSxcbiAgICAgICAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgICAgICAgYWdnOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXdEYXRhXG4gICAgfVxuICB9LFxuXG4gIHNldENhdGVnb3JpZXM6IGZ1bmN0aW9uKGQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9wYXJzZURhdGEoZCk7XG4gICAgdGhpcy5fZGF0YS5yZXNldChhdHRycy5kYXRhKTtcbiAgICB0aGlzLnNldChhdHRycyk7XG4gICAgaWYgKHRoaXMuaXNDb2xvckFwcGxpZWQoKSkge1xuICAgICAgdGhpcy5hcHBseUNhdGVnb3J5Q29sb3JzKCk7XG4gICAgfVxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkKSB7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSBkLmNhdGVnb3JpZXM7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fcGFyc2VEYXRhKGNhdGVnb3JpZXMpO1xuXG4gICAgXy5leHRlbmQoYXR0cnMsIHtcbiAgICAgICAgbnVsbHM6IGQubnVsbHMsXG4gICAgICAgIG1pbjogZC5taW4sXG4gICAgICAgIG1heDogZC5tYXgsXG4gICAgICAgIGNvdW50OiBkLmNvdW50LFxuICAgICAgICBjYXRlZ29yaWVzQ291bnQ6IGQuY2F0ZWdvcmllc0NvdW50XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLl9kYXRhLnJlc2V0KGF0dHJzLmRhdGEpO1xuICAgIGlmICh0aGlzLmlzQ29sb3JBcHBsaWVkKCkpIHtcbiAgICAgIHRoaXMuYXBwbHlDYXRlZ29yeUNvbG9ycygpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH0sXG5cbiAgLy8gQmFja2JvbmUgdG9Kc29uIGZ1bmN0aW9uIG92ZXJyaWRlXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhZ2dyZWdhdGlvblwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2x1bW46IHRoaXMuZ2V0KCdjb2x1bW4nKSxcbiAgICAgICAgYWdncmVnYXRpb246IHRoaXMuZ2V0KCdhZ2dyZWdhdGlvbicpLFxuICAgICAgICBhZ2dyZWdhdGlvbkNvbHVtbjogdGhpcy5nZXQoJ2FnZ3JlZ2F0aW9uQ29sdW1uJylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBDYXRlZ29yeUl0ZW1Nb2RlbCA9IHJlcXVpcmUoJy4vY2F0ZWdvcnlfaXRlbV9tb2RlbCcpO1xuXG4vKipcbiAqICBEYXRhIGNhdGVnb3JpZXMgY29sbGVjdGlvblxuICpcbiAqICAtIEl0IGJhc2ljYWxseSBzb3J0cyBieSAodmFsdWUsIHNlbGVjdGVkIGFuZCBcIk90aGVyXCIpLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIG1vZGVsOiBDYXRlZ29yeUl0ZW1Nb2RlbCxcblxuICBjb21wYXJhdG9yOiBmdW5jdGlvbihhLGIpIHtcbiAgICBpZiAoYS5nZXQoJ25hbWUnKSA9PT0gJ090aGVyJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChiLmdldCgnbmFtZScpID09PSAnT3RoZXInKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhLmdldCgndmFsdWUnKSA9PT0gYi5nZXQoJ3ZhbHVlJykpIHtcbiAgICAgIHJldHVybiAoYS5nZXQoJ3NlbGVjdGVkJykgPCBiLmdldCgnc2VsZWN0ZWQnKSkgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYS5nZXQoJ3ZhbHVlJykgPCBiLmdldCgndmFsdWUnKSkgPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbi8vIHZhciBjb2xvcmJyZXdlciA9IHJlcXVpcmUoJ2NvbG9yYnJld2VyJyk7XG4vLyB2YXIgY2F0ZWdvcnlDb2xvcnMgPSBfLmluaXRpYWwoY29sb3JicmV3ZXIuQWNjZW50WzhdKTsgLy8gQ29sb3IgYnJld2VyIGNvbG9yc1xudmFyIGNhdGVnb3J5Q29sb3JzID0gWycjMkNBMDk1JywnI0U1ODExQicsJyM0QTREQkEnLCcjQUQyQkFEJywnIzU1OTAzMCcsJyNFMUMyMjEnXTsgLy8gRGVtbyBjb2xvcnNcbnZhciBkZWZhdWx0Q29sb3IgPSAnI0NDQyc7XG5cbi8qKlxuICogIENsYXNzIHRvIHNldCBjYXRlZ29yaWVzIHRvIGVhY2ggY29sb3JcbiAqICAtIFJpZ2h0IG5vdywgdGhlcmUgaXMgYSByZWxhdGlvbiAxIGNvbG9yIHRvIDEgY2F0ZWdvcnkuXG4gKiAgLSBJZiB0aGF0IGNhdGVnb3J5IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIG5ldyBkYXRhLCB0aGF0XG4gKiAgICBjb2xvciB3aWxsIGJlIGZyZWVkLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBDYXRlZ29yeUNvbG9ycygpIHtcbiAgdGhpcy5jb2xvcnMgPSB7fTtcbiAgXy5lYWNoKGNhdGVnb3J5Q29sb3JzLCBmdW5jdGlvbihjKSB7XG4gICAgdGhpcy5jb2xvcnNbY10gPSBudWxsO1xuICB9LCB0aGlzKTtcbn1cblxuQ2F0ZWdvcnlDb2xvcnMucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbihkKSB7XG4gIC8vIFJlbW92ZSBjYXRlZ29yaWVzIGZyb20gY29sb3JzIHdoZXJlIHRoZXkgYXJlIG5vdCBwcmVzZW50IGFueW1vcmVcbiAgXy5lYWNoKHRoaXMuY29sb3JzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgaWYgKCFfLmNvbnRhaW5zKGQsIHZhbHVlKSkge1xuICAgICAgdGhpcy5jb2xvcnNba2V5XSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBfLndpdGhvdXQoZCwgdmFsdWUpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgLy8gU2V0IGNvbG9ycyBieSBuZXcgY2F0ZWdvcmllc1xuICBfLmVhY2goZCwgZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICB2YXIgbmV4dEZyZWVDb2xvciA9IHRoaXMuZ2V0TmV4dEF2YWlsYWJsZUNvbG9yKCk7XG4gICAgaWYgKG5leHRGcmVlQ29sb3IpIHtcbiAgICAgIHRoaXMuY29sb3JzW25leHRGcmVlQ29sb3JdID0gY2F0ZWdvcnk7XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbkNhdGVnb3J5Q29sb3JzLnByb3RvdHlwZS5nZXROZXh0QXZhaWxhYmxlQ29sb3IgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbG9ycykge1xuICAgIGlmICh0aGlzLmNvbG9yc1tpXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuQ2F0ZWdvcnlDb2xvcnMucHJvdG90eXBlLmdldENvbG9yQnlDYXRlZ29yeSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICBmb3IgKHZhciBpIGluIHRoaXMuY29sb3JzKSB7XG4gICAgaWYgKHRoaXMuY29sb3JzW2ldID09PSBjYXRlZ29yeSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0Q29sb3I7XG59O1xuXG5DYXRlZ29yeUNvbG9ycy5wcm90b3R5cGUuZ2V0Q2F0ZWdvcnlCeUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHJldHVybiB0aGlzLmNvbG9yc1tjb2xvcl07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5Q29sb3JzO1xuIiwiXG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIG5hbWU6ICcnLFxuICAgIGFnZzogZmFsc2UsXG4gICAgdmFsdWU6IDBcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKiAgVGhpcyBtb2RlbCBpcyB1c2VkIGZvciBnZXR0aW5nIHRoZSB0b3RhbCBhbW91bnQgb2YgdmFsdWVzXG4gKiAgZnJvbSB0aGUgY2F0ZWdvcnkuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHVybDogJycsXG4gICAgdG90YWxDb3VudDogMFxuICB9LFxuXG4gIHVybDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd1cmwnKTtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTp1cmwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmV0Y2goKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBzZXRVcmw6IGZ1bmN0aW9uKHVybCkge1xuICAgIHRoaXMuc2V0KCd1cmwnLCB1cmwpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkKSB7XG4gICAgLy8gQ2FsY3VsYXRpbmcgdGhlIHRvdGFsIGFtb3VudCBvZiBhbGwgY2F0ZWdvcmllcyB3aXRoIHRoZSBzdW0gb2YgYWxsXG4gICAgLy8gdmFsdWVzIGZyb20gdGhpcyBtb2RlbCBpbmNsdWRlZCB0aGUgYWdncmVnYXRlZCAoT3RoZXIpXG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxDb3VudDogXy5yZWR1Y2UoXG4gICAgICAgIF8ucGx1Y2soZC5jYXRlZ29yaWVzLCAndmFsdWUnKSxcbiAgICAgICAgZnVuY3Rpb24obWVtbywgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbWVtbyArIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAwXG4gICAgICApXG4gICAgfTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIENhdGVnb3J5SXRlbU1vZGVsID0gcmVxdWlyZSgnLi9jYXRlZ29yeV9pdGVtX21vZGVsJyk7XG5cbi8qKlxuICogIExvY2tlZCBjYXRlZ29yaWVzIGNvbGxlY3Rpb25cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgbW9kZWw6IENhdGVnb3J5SXRlbU1vZGVsLFxuXG4gIGFkZEl0ZW06IGZ1bmN0aW9uKG1kbCkge1xuICAgIGlmICghdGhpcy5pc0l0ZW1Mb2NrZWQobWRsLmdldCgnbmFtZScpKSkge1xuICAgICAgdGhpcy5hZGQobWRsKTtcbiAgICB9XG4gIH0sXG5cbiAgYWRkSXRlbXM6IGZ1bmN0aW9uKG1kbHMpIHtcbiAgICBfLmVhY2gobWRscywgZnVuY3Rpb24obSkge1xuICAgICAgaWYgKCF0aGlzLmlzSXRlbUxvY2tlZChtLm5hbWUpKSB7XG4gICAgICAgIHRoaXMuYWRkKG0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIHJlc2V0SXRlbXM6IGZ1bmN0aW9uKG1kbHMpIHtcbiAgICB0aGlzLnJlc2V0KG1kbHMpO1xuICB9LFxuXG4gIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKG1kbCkge1xuICAgIHZhciBsb2NrZWRJdGVtID0gdGhpcy5pc0l0ZW1Mb2NrZWQobWRsLmdldCgnbmFtZScpKTtcbiAgICBpZiAobG9ja2VkSXRlbSkge1xuICAgICAgdGhpcy5yZW1vdmUobG9ja2VkSXRlbSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0KFtdKTtcbiAgfSxcblxuICBpc0l0ZW1Mb2NrZWQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLmdldCgnbmFtZScpID09PSBuYW1lO1xuICAgIH0pO1xuICB9LFxuXG4gIGdldEl0ZW1zTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1Y2soJ25hbWUnKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBDYXRlZ29yaWVzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllc19jb2xsZWN0aW9uJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgc2VhcmNoIG1vZGVsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHE6ICcnLFxuICAgIGRhdGE6IFtdLFxuICAgIHVybDogJydcbiAgfSxcblxuICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndXJsJykgKyAnL3NlYXJjaD9xPScgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5nZXQoJ3EnKSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICAvLyBMb2NrZWQgY29sbGVjdGlvbiB3aWxsIGhhdmUgdGhlIHN0YXR1c1xuICAgIC8vIG9mIHRoZSBzZWxlY3RlZC9sb2NrZWQgaXRlbXNcbiAgICB0aGlzLmxvY2tlZCA9IG9wdHMubG9ja2VkO1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgQ2F0ZWdvcmllc0NvbGxlY3Rpb24oKTtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kYXRhLmJpbmQoJ2NoYW5nZTpzZWxlY3RlZCcsIHRoaXMuX29uQ2hhbmdlU2VsZWN0ZWQsIHRoaXMpO1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOmJvdW5kaW5nQm94JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1NlYXJjaEFwcGxpZWQoKSkge1xuICAgICAgICB0aGlzLmZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5fcGFyc2VEYXRhKGRhdGEpO1xuICAgIHRoaXMuX2RhdGEucmVzZXQoY2F0ZWdvcmllcyk7XG4gICAgdGhpcy5zZXQoJ2RhdGEnLCBjYXRlZ29yaWVzKTtcbiAgfSxcblxuICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICBnZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zaXplKCk7XG4gIH0sXG5cbiAgZ2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNpemUoKTtcbiAgfSxcblxuICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5nZXQoJ3EnKTtcbiAgICByZXR1cm4gISEoc3RyfHwnJyk7XG4gIH0sXG5cbiAgaXNMb2NrZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgcmVzZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldERhdGEoW10pO1xuICAgIHRoaXMuc2V0KCdxJywgJycpO1xuICB9LFxuXG4gIGdldFNlYXJjaFF1ZXJ5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3EnKTtcbiAgfSxcblxuICBpc1NlYXJjaEFwcGxpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSAmJiB0aGlzLmdldFNpemUoKSA+IDA7XG4gIH0sXG5cbiAgX29uQ2hhbmdlU2VsZWN0ZWQ6IGZ1bmN0aW9uKG1kbCwgaXNTZWxlY3RlZCkge1xuICAgIHRoaXMubG9ja2VkWyBpc1NlbGVjdGVkID8gJ2FkZEl0ZW0nIDogJ3JlbW92ZUl0ZW0nIF0obWRsKTtcbiAgfSxcblxuICBfcGFyc2VEYXRhOiBmdW5jdGlvbihjYXRlZ29yaWVzKSB7XG4gICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICBfLmVhY2goY2F0ZWdvcmllcywgZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKCFkLmFnZykge1xuICAgICAgICB2YXIgY2F0ZWdvcnkgPSAoZC5jYXRlZ29yeSB8fCBkLm5hbWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBpc0xvY2tlZCA9IHRoaXMubG9ja2VkLmlzSXRlbUxvY2tlZChjYXRlZ29yeSk7XG4gICAgICAgIG5ld0RhdGEucHVzaCh7XG4gICAgICAgICAgc2VsZWN0ZWQ6IGlzTG9ja2VkLFxuICAgICAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgICAgIGFnZzogZC5hZ2csXG4gICAgICAgICAgdmFsdWU6IGQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24ocikge1xuICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5fcGFyc2VEYXRhKHIuY2F0ZWdvcmllcyk7XG4gICAgdGhpcy5fZGF0YS5yZXNldChjYXRlZ29yaWVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY2F0ZWdvcmllc1xuICAgIH07XG4gIH0sXG5cbiAgZmV0Y2g6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB0aGlzLnRyaWdnZXIoXCJsb2FkaW5nXCIsIHRoaXMpO1xuICAgIHJldHVybiBNb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBvcHRzKTtcbiAgfSxcblxuICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5feGhyKSB7XG4gICAgICB0aGlzLl94aHIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5feGhyID0gTW9kZWwucHJvdG90eXBlLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLl94aHIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5feGhyID0gbnVsbDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5feGhyO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnO1xuIGlmIChpc1NlYXJjaEVuYWJsZWQpIHsgXG5fX3ArPScgPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tZGFyayBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIHRvdGFsTG9ja2VkICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBzZWxlY3RlZDwvcD4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tYm9sZCBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1kYXJrIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyXCI+ICc7XG4gaWYgKGlzTG9ja2VkKSB7IFxuX19wKz0nICcrXG4oKF9fdD0oIHRvdGFsQ2F0cyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgYmxvY2tlZCA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIHUtbFNwYWNlIGpzLXVubG9ja1wiPnVubG9jazwvYnV0dG9uPiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nICcrXG4oKF9fdD0oIHJlamVjdGVkQ2F0cyA9PT0gMCAmJiBhY2NlcHRlZENhdHMgPT09IDAgfHwgYWNjZXB0ZWRDYXRzID49IHRvdGFsQ2F0cyA/IFwiQWxsIHNlbGVjdGVkXCIgOiBhY2NlcHRlZENhdHMgKyBcIiBzZWxlY3RlZFwiICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyAnO1xuIGlmIChjYW5CZUxvY2tlZCkgeyBcbl9fcCs9JyA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIHUtbFNwYWNlIGpzLWxvY2tcIj5sb2NrPC9idXR0b24+ICc7XG4gfVxuX19wKz0nICc7XG4gfVxuX19wKz0nIDwvcD4gJztcbiBpZiAoIWlzTG9ja2VkKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWZpbHRlckJ1dHRvbnNcIj4gJztcbiBpZiAocmVqZWN0ZWRDYXRzID4gMCB8fMKgYWNjZXB0ZWRDYXRzID4gMCB8fMKgaXNBbGxSZWplY3RlZCkgeyBcbl9fcCs9JyA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIENEQi1XaWRnZXQtZmlsdGVyQnV0dG9uIGpzLWFsbFwiPmFsbDwvYnV0dG9uPiAnO1xuIH0gXG5fX3ArPScgJztcbiBpZiAodG90YWxDYXRzID4gcmVqZWN0ZWRDYXRzICYmICFpc0FsbFJlamVjdGVkKSB7IFxuX19wKz0nIDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWxpbmsgQ0RCLVdpZGdldC1maWx0ZXJCdXR0b24ganMtbm9uZVwiPm5vbmU8L2J1dHRvbj4gJztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScgJztcbiB9IFxuX19wKz0nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vb3B0aW9uc190ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDYXRlZ29yeSBmaWx0ZXIgdmlld1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1maWx0ZXIgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkIENEQi1XaWRnZXQtY29udGVudFNwYWNlZC0tc2lkZU1hcmdpbnMnLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtYWxsJzogJ19vblNlbGVjdEFsbCcsXG4gICAgJ2NsaWNrIC5qcy1ub25lJzogJ19vblVuc2VsZWN0QWxsJyxcbiAgICAnY2xpY2sgLmpzLWxvY2snOiAnX2xvY2tDYXRlZ29yaWVzJyxcbiAgICAnY2xpY2sgLmpzLXVubG9jayc6ICdfdW5sb2NrQ2F0ZWdvcmllcydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsQ2F0cyA9IHRoaXMuZGF0YU1vZGVsLmdldERhdGEoKS5zaXplKCk7XG4gICAgdmFyIHJlamVjdGVkQ2F0cyA9IHRoaXMuZGF0YU1vZGVsLmdldFJlamVjdGVkQ291bnQoKTtcbiAgICB2YXIgYWNjZXB0ZWRDYXRzID0gdGhpcy5kYXRhTW9kZWwuZ2V0QWNjZXB0ZWRDb3VudCgpO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaXNMb2NrZWQ6IHRoaXMuZGF0YU1vZGVsLmlzTG9ja2VkKCksXG4gICAgICAgIGNhbkJlTG9ja2VkOiB0aGlzLmRhdGFNb2RlbC5jYW5CZUxvY2tlZCgpLFxuICAgICAgICB0b3RhbExvY2tlZDogdGhpcy5kYXRhTW9kZWwuZ2V0TG9ja2VkU2l6ZSgpLFxuICAgICAgICBpc1NlYXJjaEVuYWJsZWQ6IHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpLFxuICAgICAgICBpc1NlYXJjaEFwcGxpZWQ6IHRoaXMuZGF0YU1vZGVsLmlzU2VhcmNoQXBwbGllZCgpLFxuICAgICAgICBpc0FsbFJlamVjdGVkOiB0aGlzLmRhdGFNb2RlbC5pc0FsbEZpbHRlcnNSZWplY3RlZCgpLFxuICAgICAgICB0b3RhbENhdHM6IHRvdGFsQ2F0cyxcbiAgICAgICAgcmVqZWN0ZWRDYXRzOiByZWplY3RlZENhdHMsXG4gICAgICAgIGFjY2VwdGVkQ2F0czogYWNjZXB0ZWRDYXRzXG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmRhdGEgY2hhbmdlOmZpbHRlciBjaGFuZ2U6bG9ja2VkIGNoYW5nZTpsb2NrQ29sbGVjdGlvbicsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy52aWV3TW9kZWwpO1xuICB9LFxuXG4gIF9sb2NrQ2F0ZWdvcmllczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwubG9ja0NhdGVnb3JpZXMoKTtcbiAgfSxcblxuICBfdW5sb2NrQ2F0ZWdvcmllczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwudW5sb2NrQ2F0ZWdvcmllcygpO1xuICB9LFxuXG4gIF9vblVuc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5yZWplY3RBbGwoKTtcbiAgfSxcblxuICBfb25TZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmFjY2VwdEFsbCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50RmxleFwiPiA8YnV0dG9uIGNsYXNzPVwidS1yU3BhY2UtLW0gQ0RCLVdpZGdldC1idXR0b25JY29uIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXIganMtc2VhcmNoVG9nZ2xlXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tLWNlbnRlciBDREItSWNvbi1sZW5zIHUtclNwYWNlXCI+PC9pPiA8c3BhbiBjbGFzcz1cInUtaUJsb2NrXCI+IHNlYXJjaCA8L3NwYW4+IDwvYnV0dG9uPiA8L2Rpdj4gJztcbiBpZiAoc2hvd1BhZ2luYXRvcikgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1uYXZEb3RzIGpzLWRvdHNcIj4gJztcbiBmb3IgKHZhciBpID0gMCwgbCA9IHBhZ2VzOyBpIDwgbDsgaSsrKSB7IFxuX19wKz0nPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS1kb3QgQ0RCLVdpZGdldC1kb3QtLW5hdmlnYXRpb24ganMtcGFnZSAnO1xuIGlmIChjdXJyZW50UGFnZSA9PT0gaSkgeyBcbl9fcCs9J2lzLXNlbGVjdGVkJztcbiB9IFxuX19wKz0nXCIgZGF0YS1wYWdlPVwiJytcbigoX190PSggaSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj48L2J1dHRvbj4nO1xuIH0gXG5fX3ArPScgPC9kaXY+ICc7XG4gfSBcbl9fcCs9Jyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgZGVmYXVsdFRlbXBsYXRlID0gcmVxdWlyZSgnLi9wYWdpbmF0b3JfdGVtcGxhdGUudHBsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBpdGVtc1BlclBhZ2U6IDYsXG4gICAgdGVtcGxhdGU6IGRlZmF1bHRUZW1wbGF0ZSxcbiAgICBwYWdpbmF0b3I6IGZhbHNlXG4gIH0sXG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1uYXYgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLXNlYXJjaFRvZ2dsZSc6ICdfb25TZWFyY2hDbGlja2VkJyxcbiAgICAnY2xpY2sgLmpzLXBhZ2UnOiAnX29uRG90Q2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm9wdGlvbnMuZGF0YU1vZGVsO1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgICB0aGlzLl8kdGFyZ2V0ID0gdGhpcy5vcHRpb25zLiR0YXJnZXQ7XG4gICAgdGhpcy5tb2RlbCA9IG5ldyBNb2RlbCh7XG4gICAgICBwYWdlOiAwXG4gICAgfSk7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgIHZhciBwYWdlcyA9IE1hdGguY2VpbCh0aGlzLmRhdGFNb2RlbC5nZXRTaXplKCkgLyB0aGlzLm9wdGlvbnMuaXRlbXNQZXJQYWdlKTtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGU7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgc2hvd1BhZ2luYXRvcjogdGhpcy5vcHRpb25zLnBhZ2luYXRvcixcbiAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMubW9kZWwuZ2V0KCdwYWdlJyksXG4gICAgICAgIHBhZ2VzOiBwYWdlc1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuX3Njcm9sbFRvUGFnZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZS4nICsgdGhpcy5jaWQsIF8uYmluZCh0aGlzLl9zY3JvbGxUb1BhZ2UsIHRoaXMpKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpwYWdlJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhIGNoYW5nZTpzZWFyY2hEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZXRQYWdlKCk7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTpzZWFyY2gnLCB0aGlzLnRvZ2dsZSwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLmRhdGFNb2RlbCk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLnZpZXdNb2RlbCk7XG4gIH0sXG5cbiAgLy8gSWYgY3VycmVudCBwYWdlIGRvZXNuJ3QgZXhpc3QgZHVlIHRvIGEgZGF0YSBjaGFuZ2UsIHdlIHNob3VsZCByZXNldCBpdFxuICBfc2V0UGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5kYXRhTW9kZWwuZ2V0U2l6ZSgpO1xuICAgIHZhciBwYWdlcyA9IE1hdGguY2VpbChjb3VudCAvIHRoaXMuX0lURU1TX1BFUl9QQUdFKTtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3BhZ2UnKSA+IChwYWdlcyAtIDEpKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCh7IHBhZ2U6IDAgfSwgeyBzaWxlbnQgOnRydWUgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9vblNlYXJjaENsaWNrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLnNldHVwU2VhcmNoKCk7XG4gICAgdGhpcy52aWV3TW9kZWwudG9nZ2xlU2VhcmNoKCk7XG4gIH0sXG5cbiAgX3Njcm9sbFRvUGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLm1vZGVsLmdldCgncGFnZScpO1xuICAgIHZhciBwYWdlV2lkdGggPSB0aGlzLl8kdGFyZ2V0LmZpbmQoJy5DREItV2lkZ2V0LWxpc3RHcm91cDplcSgwKScpLm91dGVyV2lkdGgoKTtcbiAgICB0aGlzLl8kdGFyZ2V0LmNzcygnbWFyZ2luLWxlZnQnLCAtIChwYWdlICogcGFnZVdpZHRoKSk7XG4gIH0sXG5cbiAgX29uRG90Q2xpY2s6IGZ1bmN0aW9uKGV2KSB7XG4gICAgdmFyIHBhZ2UgPSAkKGV2LnRhcmdldCkuZGF0YSgncGFnZScpO1xuICAgIHRoaXMubW9kZWwuc2V0KCdwYWdlJywgcGFnZSk7XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzWyB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSA/ICdoaWRlJyA6ICdzaG93JyBdKCk7XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdpcy1oaWRkZW4nKTtcbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgJCh3aW5kb3cpLnVuYmluZCgncmVzaXplLicgKyB0aGlzLmNpZCk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudEZsZXhcIj4gPGJ1dHRvbiBjbGFzcz1cInUtclNwYWNlLS1tIENEQi1XaWRnZXQtbGluayBqcy1zZWFyY2hUb2dnbGVcIj5jYW5jZWw8L2J1dHRvbj4gPC9kaXY+ICc7XG4gaWYgKHNob3dQYWdpbmF0b3IpIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbmF2RG90cyBqcy1kb3RzXCI+ICc7XG4gZm9yICh2YXIgaSA9IDAsIGwgPSBwYWdlczsgaSA8IGw7IGkrKykgeyBcbl9fcCs9JzxidXR0b24gY2xhc3M9XCJDREItU2hhcGUtZG90IENEQi1XaWRnZXQtZG90LS1uYXZpZ2F0aW9uIGpzLXBhZ2UgJztcbiBpZiAoY3VycmVudFBhZ2UgPT09IGkpIHsgXG5fX3ArPSdpcy1zZWxlY3RlZCc7XG4gfSBcbl9fcCs9J1wiIGRhdGEtcGFnZT1cIicrXG4oKF9fdD0oIGkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9idXR0b24+JztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIFBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgc2VhcmNoVGVtcGxhdGUgPSByZXF1aXJlKCcuL3NlYXJjaF9wYWdpbmF0b3JfdGVtcGxhdGUudHBsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnaW5hdG9yVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbmF2IGlzLWhpZGRlbiBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQnLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICB2YXIgcGFnZXMgPSBNYXRoLmNlaWwodGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoQ291bnQoKSAvIHRoaXMub3B0aW9ucy5pdGVtc1BlclBhZ2UpO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICBzZWFyY2hUZW1wbGF0ZSh7XG4gICAgICAgIHNob3dQYWdpbmF0b3I6IHRydWUsXG4gICAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLm1vZGVsLmdldCgncGFnZScpLFxuICAgICAgICBwYWdlczogcGFnZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl9zY3JvbGxUb1BhZ2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZXRQYWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSB0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hDb3VudCgpO1xuICAgIHZhciBwYWdlcyA9IE1hdGguY2VpbChjb3VudCAvIHRoaXMuX0lURU1TX1BFUl9QQUdFKTtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3BhZ2UnKSA+IChwYWdlcyAtIDEpKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCh7IHBhZ2U6IDAgfSwgeyBzaWxlbnQgOnRydWUgfSk7XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sgIXRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpID8gJ2hpZGUnIDogJ3Nob3cnIF0oKTtcbiAgfSxcblxuICBfb25TZWFyY2hDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5jbGVhblNlYXJjaCgpO1xuICAgIHRoaXMudmlld01vZGVsLnRvZ2dsZVNlYXJjaCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jyc7XG4gaWYgKGlzU2VhcmNoRW5hYmxlZCkgeyBcbl9fcCs9JyA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtXCI+ICc7XG4gaWYgKGlzU2VhcmNoQXBwbGllZCkgeyBcbl9fcCs9JyAnK1xuKChfX3Q9KCByZXN1bHRzQ291bnQgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIGZvdW5kICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgJm5ic3A7ICc7XG4gfSBcbl9fcCs9JyA8L2R0PiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nIDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW1cIj4nK1xuKChfX3Q9KCBudWxsc1BlciApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclIG51bGwgcm93czwvZHQ+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW1cIj48c3BhbiBjbGFzcz1cImpzLWNhdHNcIj4nK1xuKChfX3Q9KCBjYXRzUGVyICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvc3Bhbj4lIGluICcrXG4oKF9fdD0oIHRvdGFsQ2F0cyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgY2F0ZWdvcicrXG4oKF9fdD0oIHRvdGFsQ2F0cyAhPT0gMSA/ICdpZXMnIDogJ3knICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZHQ+ICc7XG4gfSBcbl9fcCs9Jyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vc3RhdHNfdGVtcGxhdGUudHBsJyk7XG52YXIgYW5pbWF0aW9uVGVtcGxhdGUgPSByZXF1aXJlKCcuL2NhdHNfdGVtcGxhdGUudHBsJyk7XG52YXIgQW5pbWF0ZVZhbHVlcyA9IHJlcXVpcmUoJy4uLy4uL2FuaW1hdGVfdmFsdWVzJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgc3RhdHMgaW5mbyB2aWV3XG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtaW5mbyBDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyJyxcbiAgdGFnTmFtZTogJ2RsJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMub3B0aW9ucy52aWV3TW9kZWw7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm9wdGlvbnMuZGF0YU1vZGVsO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaXNTZWFyY2hFbmFibGVkOiB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSxcbiAgICAgICAgaXNTZWFyY2hBcHBsaWVkOiB0aGlzLmRhdGFNb2RlbC5pc1NlYXJjaEFwcGxpZWQoKSxcbiAgICAgICAgcmVzdWx0c0NvdW50OiB0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hDb3VudCgpLFxuICAgICAgICB0b3RhbENhdHM6IHRoaXMuX2dldENhdGVnb3JpZXNTaXplKCksXG4gICAgICAgIG51bGxzUGVyOiB0aGlzLl9nZXROdWxsUGVyY2VudGFnZSgpLFxuICAgICAgICBjYXRzUGVyOiB0aGlzLl9nZXRDdXJyZW50Q2F0ZWdvcmllc1BlcmNlbnRhZ2UoKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdGVWYWx1ZXMoe1xuICAgICAgZWw6IHRoaXMuJGVsXG4gICAgfSk7XG5cbiAgICBhbmltYXRvci5hbmltYXRlRnJvbVZhbHVlcyh0aGlzLl9nZXRQcmV2aW91c0NhdGVnb3JpZXNQZXJjZW50YWdlKCksIHRoaXMuX2dldEN1cnJlbnRDYXRlZ29yaWVzUGVyY2VudGFnZSgpLCAnLmpzLWNhdHMnLFxuICAgICAgYW5pbWF0aW9uVGVtcGxhdGUsIHsgZGVmYXVsdFZhbHVlOiAnLScsIGFuaW1hdGlvblNwZWVkOiA3MDAsIGZvcm1hdHRlcjogZm9ybWF0dGVyLmZvcm1hdFZhbHVlIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmRhdGEgY2hhbmdlOmxvY2tlZCBjaGFuZ2U6c2VhcmNoIGNoYW5nZTp0b3RhbENvdW50JywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTpzZWFyY2gnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLmRhdGFNb2RlbCk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLnZpZXdNb2RlbCk7XG4gIH0sXG5cbiAgX2dldE51bGxQZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVsbHMgPSB0aGlzLmRhdGFNb2RlbC5nZXQoJ251bGxzJyk7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCd0b3RhbENvdW50JykgfHwgMDtcbiAgICByZXR1cm4gIW51bGxzID8gMCA6ICgobnVsbHMvdG90YWwpICogMTAwKS50b0ZpeGVkKDIpO1xuICB9LFxuXG4gIF9nZXRQcmV2aW91c0NhdGVnb3JpZXNQZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG90YWwgPSB0aGlzLmRhdGFNb2RlbC5wcmV2aW91cygndG90YWxDb3VudCcpIHx8IDA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXRQcmV2aW91c0RhdGEoKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2F0ZWdvcmllc1BlcmNlbnRhZ2UoZGF0YSwgdG90YWwpO1xuICB9LFxuXG4gIF9nZXRDdXJyZW50Q2F0ZWdvcmllc1BlcmNlbnRhZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbCA9IHRoaXMuZGF0YU1vZGVsLmdldCgndG90YWxDb3VudCcpIHx8IDA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCkudG9KU09OKCk7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhdGVnb3JpZXNQZXJjZW50YWdlKGRhdGEsIHRvdGFsKTtcbiAgfSxcblxuICBfZ2V0Q2F0ZWdvcmllc1BlcmNlbnRhZ2U6IGZ1bmN0aW9uKGRhdGEsIHRvdGFsKSB7XG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUb3RhbCA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIG1kbCkge1xuICAgICAgcmV0dXJuICFtZGwuYWdnID8gKCBtZW1vICsgcGFyc2VGbG9hdChtZGwudmFsdWUpKSA6IG1lbW87XG4gICAgfSwgMCk7XG5cbiAgICBpZiAoIWN1cnJlbnRUb3RhbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuICgoY3VycmVudFRvdGFsIC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpO1xuICB9LFxuXG4gIF9nZXRDYXRlZ29yaWVzU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8ucGx1Y2soXG4gICAgICB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCkucmVqZWN0KGZ1bmN0aW9uKG1kbCkge1xuICAgICAgICByZXR1cm4gbWRsLmdldCgnYWdnJyk7XG4gICAgICB9KSwgJ25hbWUnKS5sZW5ndGg7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnO1xuIGlmIChpc1NlYXJjaEVuYWJsZWQpIHsgXG5fX3ArPScgPGZvcm0gY2xhc3M9XCJDREItV2lkZ2V0LXNlYXJjaCBqcy1mb3JtXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tbGVucyBDREItV2lkZ2V0LXNlYXJjaExlbnNcIj48L2k+IDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0SW5wdXQgQ0RCLVdpZGdldC1zZWFyY2hUZXh0SW5wdXQganMtdGV4dElucHV0XCIgdmFsdWU9XCInK1xuKChfX3Q9KCBxICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIGJ5ICcrXG4oKF9fdD0oIGNvbHVtbk5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+ICc7XG4gaWYgKGNhblNob3dBcHBseSkgeyBcbl9fcCs9JyA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayBDREItV2lkZ2V0LXNlYXJjaEFwcGx5IGpzLWFwcGx5TG9ja2VkXCI+YXBwbHk8L2J1dHRvbj4gJztcbiB9IFxuX19wKz0nIDwvZm9ybT4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aXRsZSBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gzPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1vcHRpb25zIENEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1idXR0b25JY29uIENEQi1XaWRnZXQtYnV0dG9uSWNvbi0tY2lyY2xlIGpzLWNvbG9ycyAnK1xuKChfX3Q9KCBpc0NvbG9yQXBwbGllZCA/ICdpcy1zZWxlY3RlZCcgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgJytcbigoX190PSggaXNDb2xvckFwcGxpZWQgPyAnanMtY2FuY2VsQ29sb3JzJyA6ICdqcy1hcHBseUNvbG9ycycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCIgZGF0YS10b29sdGlwPVwiXFxuICAgICAgICAgICcrXG4oKF9fdD0oIGlzQ29sb3JBcHBsaWVkID8gJ1JlbW92ZSBjb2xvcnMnIDogJ0FwcGx5IGNvbG9ycycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXFxuICAgICAgICBcIj4gPGkgY2xhc3M9XCJDREItSWNvbiBDREItSWNvbi1zeXJpbmdlIENEQi1JY29uLS10b3BcIj48L2k+IDwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzIGpzLWNvbGxhcHNlXCIgZGF0YS10b29sdGlwPVwiJytcbigoX190PSggaXNDb2xsYXBzZWQgPyAnU2hvdycgOiAnSGlkZScgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzSXRlbVwiPjwvc3Bhbj4gPC9idXR0b24+IDwvZGl2PiA8L2Rpdj4gJztcbiB9IFxuX19wKz0nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciAkID0gY2RiLiQ7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgVG9vbHRpcFZpZXcgPSByZXF1aXJlKCcuLi8uLi93aWRnZXQtdG9vbHRpcC12aWV3Jyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3NlYXJjaF90aXRsZV90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiAgU2hvdyBjYXRlZ29yeSB0aXRsZSBvciBzZWFyY2ggYW55IGNhdGVnb3J5XG4gKiAgKyBhbm90aGVyIG9wdGlvbnMgZm9yIHRoaXMgd2lkZ2V0LCBhcyBpbixcbiAqICBjb2xvcml6ZSBjYXRlZ29yaWVzLCBsb2NrIGRlZmluZWQgY2F0ZWdvcmllcy4uLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAna2V5dXAgLmpzLXRleHRJbnB1dCc6ICdfb25LZXl1cElucHV0JyxcbiAgICAnc3VibWl0IC5qcy1mb3JtJzogJ19vblN1Ym1pdEZvcm0nLFxuICAgICdjbGljayAuanMtYXBwbHlMb2NrZWQnOiAnX2FwcGx5TG9ja2VkJyxcbiAgICAnY2xpY2sgLmpzLWFwcGx5Q29sb3JzJzogJ19hcHBseUNvbG9ycycsXG4gICAgJ2NsaWNrIC5qcy1jYW5jZWxDb2xvcnMnOiAnX2NhbmNlbENvbG9ycycsXG4gICAgJ2NsaWNrIC5qcy1jb2xsYXBzZSc6ICdfdG9nZ2xlQ29sbGFwc2UnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIGlzQ29sbGFwc2VkOiB0aGlzLmRhdGFNb2RlbC5pc0NvbGxhcHNlZCgpLFxuICAgICAgICBpc0NvbG9yQXBwbGllZDogdGhpcy5kYXRhTW9kZWwuaXNDb2xvckFwcGxpZWQoKSxcbiAgICAgICAgdGl0bGU6IHRoaXMuZGF0YU1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgY29sdW1uTmFtZTogdGhpcy5kYXRhTW9kZWwuZ2V0KCdjb2x1bW4nKSxcbiAgICAgICAgcTogdGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoUXVlcnkoKSxcbiAgICAgICAgaXNMb2NrZWQ6IHRoaXMuZGF0YU1vZGVsLmlzTG9ja2VkKCksXG4gICAgICAgIGNhbkJlTG9ja2VkOiB0aGlzLmRhdGFNb2RlbC5jYW5CZUxvY2tlZCgpLFxuICAgICAgICBpc1NlYXJjaEVuYWJsZWQ6IHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpLFxuICAgICAgICBjYW5TaG93QXBwbHk6IHRoaXMuZGF0YU1vZGVsLmNhbkFwcGx5TG9ja2VkKClcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy5fb25TZWFyY2hUb2dnbGVkLCB0aGlzKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6ZmlsdGVyIGNoYW5nZTpsb2NrQ29sbGVjdGlvbiBjaGFuZ2U6Y2F0ZWdvcnlDb2xvcnMgY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMudmlld01vZGVsKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29sbGFwc2VUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtY29sbGFwc2UnKVxuICAgIH0pO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoY29sbGFwc2VUb29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoY29sbGFwc2VUb29sdGlwKTtcblxuICAgIHZhciBjb2xvcnNUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtY29sb3JzJylcbiAgICB9KTtcbiAgICAkKCdib2R5JykuYXBwZW5kKGNvbG9yc1Rvb2x0aXAucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhjb2xvcnNUb29sdGlwKTtcbiAgfSxcblxuICBfb25TZWFyY2hUb2dnbGVkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNTZWFyY2hFbmFibGVkID0gdGhpcy52aWV3TW9kZWwuaXNTZWFyY2hFbmFibGVkKCk7XG4gICAgdGhpc1tpc1NlYXJjaEVuYWJsZWQgPyAnX2JpbmRFU0MnIDogJ191bmJpbmRFU0MnXSgpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgaWYgKGlzU2VhcmNoRW5hYmxlZCkge1xuICAgICAgdGhpcy5fZm9jdXNPbklucHV0KCk7XG4gICAgfVxuICB9LFxuXG4gIF9vblN1Ym1pdEZvcm06IGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB2YXIgcSA9IHRoaXMuJCgnLmpzLXRleHRJbnB1dCcpLnZhbCgpO1xuICAgIGlmICh0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hRdWVyeSgpICE9PSBxKSB7XG4gICAgICB0aGlzLmRhdGFNb2RlbC5zZXRTZWFyY2hRdWVyeShxKTtcbiAgICAgIGlmICh0aGlzLmRhdGFNb2RlbC5pc1NlYXJjaFZhbGlkKCkpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlTZWFyY2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2ZvY3VzT25JbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLiQoJy5qcy10ZXh0SW5wdXQnKS5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9LFxuXG4gIF9vbktleXVwSW5wdXQ6IF8uZGVib3VuY2UoXG4gICAgZnVuY3Rpb24oZXYpIHtcbiAgICAgIHZhciBxID0gdGhpcy4kKCcuanMtdGV4dElucHV0JykudmFsKCk7XG4gICAgICBpZiAoZXYua2V5Q29kZSAhPT0gMTMgJiYgZXYua2V5Q29kZSAhPT0gMjcgJiYgcSAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLl9vblN1Ym1pdEZvcm0oKTtcbiAgICAgIH1cbiAgICB9LCAyNTBcbiAgKSxcblxuICBfYmluZEVTQzogZnVuY3Rpb24oKSB7XG4gICAgJChkb2N1bWVudCkuYmluZChcImtleXVwLlwiICsgdGhpcy5jaWQsIF8uYmluZCh0aGlzLl9vbktleVVwLCB0aGlzKSk7XG4gIH0sXG5cbiAgX3VuYmluZEVTQzogZnVuY3Rpb24oKSB7XG4gICAgJChkb2N1bWVudCkudW5iaW5kKFwia2V5dXAuXCIgKyB0aGlzLmNpZCk7XG4gIH0sXG5cbiAgX29uS2V5VXA6IGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICB0aGlzLl9jYW5jZWxTZWFyY2goKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgX2FwcGx5TG9ja2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC50b2dnbGVTZWFyY2goKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5hcHBseUxvY2tlZCgpO1xuICB9LFxuXG4gIF9hcHBseUNvbG9yczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlDYXRlZ29yeUNvbG9ycygpO1xuICB9LFxuXG4gIF9jYW5jZWxDb2xvcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmNhbmNlbENhdGVnb3J5Q29sb3JzKCk7XG4gIH0sXG5cbiAgX2NhbmNlbFNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuY2xlYW5TZWFyY2goKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5kaXNhYmxlU2VhcmNoKCk7XG4gIH0sXG5cbiAgX3RvZ2dsZUNvbGxhcHNlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC50b2dnbGVDb2xsYXBzZWQoKTtcbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5iaW5kRVNDKCk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJytcbigoX190PSggcHJlZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHN1ZmZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBkMyA9IGNkYi5kMztcbnZhciAkID0gY2RiLiQ7XG52YXIgV2lkZ2V0Q29udGVudCA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBXaWRnZXRWaWV3TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfY29udGVudF9tb2RlbCcpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZS50cGwnKTtcbnZhciBUb29sdGlwVmlldyA9IHJlcXVpcmUoJy4uL3dpZGdldC10b29sdGlwLXZpZXcnKTtcbnZhciBhbmltYXRpb25UZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCcpO1xudmFyIEFuaW1hdGVWYWx1ZXMgPSByZXF1aXJlKCcuLi9hbmltYXRlX3ZhbHVlcy5qcycpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IGNvbnRlbnQgdmlldzpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRDb250ZW50LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1jb2xsYXBzZSc6ICdfdG9nZ2xlQ29sbGFwc2UnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFdpZGdldFZpZXdNb2RlbCgpO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZGF0YU1vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZDMuZm9ybWF0KCcwLDAwMCcpO1xuXG4gICAgICBpZiAoXy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcih2YWx1ZS50b0ZpeGVkKDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICB2YXIgbnVsbHMgPSAhXy5pc1VuZGVmaW5lZCh0aGlzLmRhdGFNb2RlbC5nZXQoJ251bGxzJykpICYmIGZvcm1hdHRlci5mb3JtYXROdW1iZXIodGhpcy5kYXRhTW9kZWwuZ2V0KCdudWxscycpKSB8fMKgJy0nO1xuICAgIHZhciBpc0NvbGxhcHNlZCA9IHRoaXMuZGF0YU1vZGVsLmlzQ29sbGFwc2VkKCk7XG5cbiAgICB2YXIgcHJlZml4ID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCdwcmVmaXgnKTtcbiAgICB2YXIgc3VmZml4ID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCdzdWZmaXgnKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIG9wZXJhdGlvbjogdGhpcy5kYXRhTW9kZWwuZ2V0KCdvcGVyYXRpb24nKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBudWxsczogbnVsbHMsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICAgICAgaXNDb2xsYXBzZWQ6IGlzQ29sbGFwc2VkXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0ZVZhbHVlcyh7XG4gICAgICBlbDogdGhpcy4kZWxcbiAgICB9KTtcblxuICAgIGFuaW1hdG9yLmFuaW1hdGVWYWx1ZSh0aGlzLmRhdGFNb2RlbCwgJ2RhdGEnLCAnLmpzLXZhbHVlJywgYW5pbWF0aW9uVGVtcGxhdGUsIHsgYW5pbWF0aW9uU3BlZWQ6IDcwMCwgZm9ybWF0dGVyOiBmb3JtYXQsIHRlbXBsYXRlRGF0YTogeyBwcmVmaXg6IHByZWZpeCwgc3VmZml4OiBzdWZmaXggfX0pO1xuXG4gICAgdGhpcy4kZWwudG9nZ2xlQ2xhc3MoJ2lzLWNvbGxhcHNlZCcsICEhaXNDb2xsYXBzZWQpO1xuXG4gICAgdGhpcy5faW5pdFZpZXdzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6Y29sbGFwc2VkJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLl9pbml0QmluZHMuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9vbHRpcCA9IG5ldyBUb29sdGlwVmlldyh7XG4gICAgICB0YXJnZXQ6IHRoaXMuJCgnLmpzLWNvbGxhcHNlJylcbiAgICB9KTtcbiAgICAkKCdib2R5JykuYXBwZW5kKHRvb2x0aXAucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0b29sdGlwKTtcbiAgfSxcblxuICBfdG9nZ2xlQ29sbGFwc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLnRvZ2dsZUNvbGxhcHNlZCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBXaWRnZXRNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9tb2RlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IF8uZXh0ZW5kKFxuICAgIHt9LFxuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5kZWZhdWx0cyxcbiAgICB7XG4gICAgICBkYXRhOiAnJyxcbiAgICAgIHN1ZmZpeDogJycsXG4gICAgICBwcmVmaXg6ICcnXG4gICAgfVxuICApLFxuXG4gIC8vIFRPRE86IFRoZSByZXNwb25zZSBmb3JtYXQgaGFzIHByb2JhYmx5IGNoYW5nZWRcbiAgcGFyc2U6IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogci5yZXN1bHQsXG4gICAgICBudWxsczogci5udWxsc1xuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9ybXVsYVwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2x1bW46IHRoaXMuZ2V0KCdjb2x1bW4nKSxcbiAgICAgICAgb3BlcmF0aW9uOiB0aGlzLmdldCgnb3BlcmF0aW9uJylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGFnIENEQi1XaWRnZXQtdGFnLS0nK1xuKChfX3Q9KCBvcGVyYXRpb24gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIG9wZXJhdGlvbiApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3NwYW4+IDwvZGl2PiA8L2Rpdj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50cyBqcy1jb2xsYXBzZVwiIGRhdGEtdG9vbHRpcD1cIicrXG4oKF9fdD0oIGlzQ29sbGFwc2VkID8gJ1Nob3cnIDogJ0hpZGUnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8c3BhbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50c0l0ZW1cIj48L3NwYW4+IDwvYnV0dG9uPiA8L2Rpdj4gPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvXCI+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIG51bGxzICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBudWxsIHJvd3M8L2R0PiA8L2RsPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudFwiPiAnO1xuIGlmICh2YWx1ZSkgeyBcbl9fcCs9JyA8aDQgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdnZXIgQ0RCLVdpZGdldC10ZXh0QmlnZ2VyLS1tYXhXaWR0aCBqcy12YWx1ZVwiIHRpdGxlPVwiJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+ICcrXG4oKF9fdD0oIHByZWZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBzdWZmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIDwvaDQ+ICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2Rpdj4gJztcbiB9IFxuX19wKz0nIDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggc3VmZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgICAvLyByZW5kZXIgdGhlIGNoYXJ0IG9uY2UgdGhlIHdpZHRoIGlzIHNldCBhcyBkZWZhdWx0LCBwcm92aWRlIGZhbHNlIHZhbHVlIGZvciB0aGlzIHByb3AgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW9yXG4gICAgIC8vIGUuZy4gZm9yIFwibWluaVwiIGhpc3RvZ3JhbSBiZWhhdmlvclxuICAgIHNob3dPbldpZHRoQ2hhbmdlOiB0cnVlLFxuXG4gICAgbGFiZWxzTWFyZ2luOiAxNiwgLy8gcHhcbiAgICBoYXNBeGlzVGlwOiBmYWxzZSxcbiAgICBtaW5pbXVtQmFySGVpZ2h0OiAyLFxuICAgIGFuaW1hdGlvblNwZWVkOiA3NTAsXG4gICAgaGFuZGxlV2lkdGg6IDYsXG4gICAgaGFuZGxlSGVpZ2h0OiAyMyxcbiAgICBoYW5kbGVSYWRpdXM6IDMsXG4gICAgZGl2aXNpb25XaWR0aDogODAsXG4gICAgYW5pbWF0aW9uQmFyRGVsYXk6IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKDEwMCArIChpICogMTApKTtcbiAgICB9LFxuICAgIHRyYW5zaXRpb25UeXBlOiAnZWxhc3RpYydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIodGhpcy5vcHRpb25zLmhlaWdodCkpIHRocm93IG5ldyBFcnJvcignaGVpZ2h0IGlzIHJlcXVpcmVkJyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgdGhpcy5vcHRpb25zKTtcblxuICAgIF8uYmluZEFsbCh0aGlzLCAnX3NlbGVjdEJhcnMnLCAnX2FkanVzdEJydXNoSGFuZGxlcycsICdfb25CcnVzaE1vdmUnLCAnX29uQnJ1c2hTdGFydCcsICdfb25Nb3VzZU1vdmUnLCAnX29uTW91c2VPdXQnKTtcblxuICAgIC8vIFVzZSB0aGlzIHNwZWNpYWwgc2V0dXAgZm9yIGVhY2ggdmlldyBpbnN0YW5jZSBvdCBoYXZlIGl0cyBvd24gZGVib3VuY2VkIGxpc3RlbmVyXG4gICAgLy8gVE9ETyBpbiB0aGVvcnkgdGhlcmUncyB0aGUgcG9zc2libGl0eSB0aGF0IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYmVmb3JlIHRoZSB2aWV3IGlzIHJlbmRlcmVkIGluIHRoZSBET00sXG4gICAgLy8gIHdoaWNoIHdvdWxkIGxlYWQgdG8gdGhlIHZpZXcgbm90IGJlaW5nIHZpc2libGUgdW50aWwgYW4gZXhwbGljaXQgd2luZG93IHJlc2l6ZS5cbiAgICAvLyAgYSB3YXNBZGRlZFRvRE9NIGV2ZW50IHdvdWxkJ3ZlIGJlZW4gbmljZSB0byBoYXZlXG4gICAgdGhpcy5fb25XaW5kb3dSZXNpemUgPSBfLmRlYm91bmNlKHRoaXMuX3Jlc2l6ZVRvUGFyZW50RWxlbWVudC5iaW5kKHRoaXMpLCA1MCk7XG4gICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKTtcblxuICAgIC8vIHVzaW5nIHRhZ05hbWU6ICdzdmcnIGRvZXNuJ3Qgd29yayxcbiAgICAvLyBhbmQgdy9vIGNsYXNzPVwiXCIgZDMgd29uJ3QgaW5zdGFudGlhdGUgcHJvcGVybHlcbiAgICB0aGlzLnNldEVsZW1lbnQoJCgnPHN2ZyBjbGFzcz1cIlwiPjwvc3ZnPicpWzBdKTtcblxuICAgIHRoaXMuY2FudmFzID0gZDMuc2VsZWN0KHRoaXMuZWwpXG4gICAgLmF0dHIoJ3dpZHRoJywgMClcbiAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5vcHRpb25zLmhlaWdodCk7XG5cbiAgICB0aGlzLmNhbnZhc1xuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItV2lkZ2V0Q2FudmFzJyk7XG5cbiAgICB0aGlzLl9zZXR1cE1vZGVsKCk7XG4gICAgdGhpcy5fc2V0dXBCaW5kaW5ncygpO1xuICAgIHRoaXMuX3NldHVwRGltZW5zaW9ucygpO1xuICAgIHRoaXMuX3NldHVwRDNCaW5kaW5ncygpO1xuXG4gICAgdGhpcy5oaWRlKCk7IC8vIHdpbGwgYmUgdG9nZ2xlZCBvbiB3aWR0aCBjaGFuZ2VcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dlbmVyYXRlQ2hhcnQoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUNoYXJ0Q29udGVudCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAkKHdpbmRvdykudW5iaW5kKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfSxcblxuICByZXBsYWNlRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMubW9kZWwuc2V0KHsgZGF0YTogZGF0YSB9KTtcbiAgfSxcblxuICB0b2dnbGVMYWJlbHM6IGZ1bmN0aW9uKHNob3cpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2hvd0xhYmVscycsIHNob3cpO1xuICB9LFxuXG4gIGNoYXJ0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdGhpcy5tb2RlbC5nZXQoJ21hcmdpbicpO1xuXG4gICAgLy8gR2V0IG1heCBiZWNhdXNlIHdpZHRoIG1pZ2h0IGJlIG5lZ2F0aXZlIGluaXRpYWxseVxuICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLm1vZGVsLmdldCgnd2lkdGgnKSAtIG0ubGVmdCAtIG0ucmlnaHQpO1xuICB9LFxuXG4gIGNoYXJ0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHRoaXMubW9kZWwuZ2V0KCdtYXJnaW4nKTtcbiAgICB2YXIgbGFiZWxzTWFyZ2luID0gdGhpcy5tb2RlbC5nZXQoJ3Nob3dMYWJlbHMnKVxuICAgICAgPyB0aGlzLmRlZmF1bHRzLmxhYmVsc01hcmdpblxuICAgICAgOiAwO1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldCgnaGVpZ2h0JykgLSBtLnRvcCAtIG0uYm90dG9tIC0gbGFiZWxzTWFyZ2luO1xuICB9LFxuXG4gIF9yZXNpemVUb1BhcmVudEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHRoaXMuJGVsLnBhcmVudCgpKSB7XG4gICAgICAvLyBIaWRlIHRoaXMgdmlldyB0ZW1wb3JhcmlseSB0byBnZXQgYWN0dWFsIHNpemUgb2YgdGhlIHBhcmVudCBjb250YWluZXJcbiAgICAgIHZhciB3YXNIaWRkZW4gPSB0aGlzLmlzSGlkZGVuKCk7XG5cbiAgICAgIHRoaXMuaGlkZSgpO1xuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbC5wYXJlbnQoKS53aWR0aCgpIHx8IDA7XG5cbiAgICAgIGlmICh3YXNIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlbC5zZXQoJ3dpZHRoJywgd2lkdGgpO1xuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VMZWZ0QXhpc1RpcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQXhpc1RpcCgnbGVmdCcpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVJpZ2h0QXhpc1RpcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQXhpc1RpcCgncmlnaHQnKTtcbiAgfSxcblxuICBfdXBkYXRlQXhpc1RpcDogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIHRleHRMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBUZXh0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBheGlzVGlwICA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXAuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG4gICAgdmFyIHJlY3RMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBSZWN0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBoYW5kbGUgICAgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGUuQ0RCLUNoYXJ0LWhhbmRsZS0nICsgY2xhc3NOYW1lKTtcblxuICAgIHRleHRMYWJlbC5kYXRhKFt0aGlzLm1vZGVsLmdldChjbGFzc05hbWUgKyAnX2F4aXNfdGlwJyldKS50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKGQpO1xuICAgIH0pO1xuXG4gICAgdmFyIHdpZHRoID0gdGV4dExhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgcmVjdExhYmVsLmF0dHIoJ3dpZHRoJywgd2lkdGggKyA0KTtcblxuICAgIHZhciBwYXJ0cyA9IC90cmFuc2xhdGVcXChcXHMqKFteXFxzLCldKyksIChbXlxccywpXSspLy5leGVjKGhhbmRsZS5hdHRyKCd0cmFuc2Zvcm0nKSk7XG4gICAgdmFyIHhQb3MgPSArcGFydHNbMV0gKyAzO1xuXG4gICAgaWYgKCh4UG9zIC0gd2lkdGgvMikgPCAwKSB7XG4gICAgICBheGlzVGlwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgNTIpJyk7XG4gICAgICB0ZXh0TGFiZWwuYXR0cignZHgnLCAteFBvcyk7XG4gICAgICByZWN0TGFiZWwuYXR0cigneCcsICAteFBvcyk7XG4gICAgfSBlbHNlIGlmICgoeFBvcyArIHdpZHRoLzIgKyAyKSA+PSB0aGlzLmNoYXJ0V2lkdGgoKSkge1xuICAgICAgYXhpc1RpcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDUyKScpO1xuICAgICAgdGV4dExhYmVsLmF0dHIoJ2R4JywgdGhpcy5jaGFydFdpZHRoKCkgLSAoeFBvcyArIHdpZHRoIC0gMikpO1xuICAgICAgcmVjdExhYmVsLmF0dHIoJ3gnLCB0aGlzLmNoYXJ0V2lkdGgoKSAtICh4UG9zICsgd2lkdGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1RpcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC0nICsgKHdpZHRoLzIpICsgJywgNTIpJyk7XG4gICAgICByZWN0TGFiZWwuYXR0cigneCcsIDApO1xuICAgICAgdGV4dExhYmVsLmF0dHIoJ2R4JywgKzIpO1xuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5wcmV2aW91cygnZGF0YScpLmxlbmd0aCAhPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbG9faW5kZXgnKSA9PT0gMCAmJiB0aGlzLm1vZGVsLmdldCgnaGlfaW5kZXgnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoJ3JhbmdlX3VwZGF0ZWQnLCB0aGlzLm1vZGVsLmdldCgnbG9faW5kZXgnKSwgdGhpcy5tb2RlbC5nZXQoJ2hpX2luZGV4JykpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLm1vZGVsLmdldCgnd2lkdGgnKTtcbiAgICB0aGlzLiRlbC53aWR0aCh3aWR0aCk7XG4gICAgdGhpcy5jaGFydC5hdHRyKCd3aWR0aCcsIHdpZHRoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dPbldpZHRoQ2hhbmdlICYmIHdpZHRoID4gMCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIHZhciBsb0JhckluZGV4ID0gdGhpcy5tb2RlbC5nZXQoJ2xvX2luZGV4Jyk7XG4gICAgdmFyIGhpQmFySW5kZXggPSB0aGlzLm1vZGVsLmdldCgnaGlfaW5kZXgnKTtcbiAgICB0aGlzLnNlbGVjdFJhbmdlKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMubW9kZWwuZ2V0KCdoZWlnaHQnKTtcblxuICAgIHRoaXMuJGVsLmhlaWdodChoZWlnaHQpO1xuICAgIHRoaXMuY2hhcnQuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB0aGlzLmxlZnRIYW5kbGUuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB0aGlzLnJpZ2h0SGFuZGxlLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH0sXG5cbiAgX29uQ2hhbmdTaG93TGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9heGlzLnN0eWxlKCdvcGFjaXR5JywgdGhpcy5tb2RlbC5nZXQoJ3Nob3dMYWJlbHMnKSA/IDEgOiAwKTtcbiAgfSxcblxuICBfb25DaGFuZ2VQb3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3MgPSB0aGlzLm1vZGVsLmdldCgncG9zJyk7XG4gICAgdmFyIG1hcmdpbiA9IHRoaXMubW9kZWwuZ2V0KCdtYXJnaW4nKTtcblxuICAgIHZhciB4ID0gK3Bvcy54O1xuICAgIHZhciB5ID0gK3Bvcy55O1xuXG4gICAgdGhpcy5jaGFydFxuICAgIC50cmFuc2l0aW9uKClcbiAgICAuZHVyYXRpb24oMTUwKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAobWFyZ2luLmxlZnQgKyB4KSArICcsICcgKyAobWFyZ2luLnRvcCArIHkpICsgJyknKTtcbiAgfSxcblxuICBfb25CcnVzaFN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcbiAgICB2YXIgaGlFeHRlbnQgPSBleHRlbnRbMV07XG4gICAgdmFyIHJpZ2h0WCA9IHRoaXMueFNjYWxlKGhpRXh0ZW50KSAtIHRoaXMub3B0aW9ucy5oYW5kbGVXaWR0aCAvIDI7XG5cbiAgICB0aGlzLmNoYXJ0LmNsYXNzZWQoJ2lzLXNlbGVjdGFibGUnLCB0cnVlKTtcbiAgfSxcblxuICBfb25DaGFuZ2VEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5jbGFzc2VkKCdpcy1kcmFnZ2luZycsIHRoaXMubW9kZWwuZ2V0KCdkcmFnZ2luZycpKTtcbiAgICB0aGlzLl91cGRhdGVBeGlzVGlwT3BhY2l0eSgncmlnaHQnKTtcbiAgICB0aGlzLl91cGRhdGVBeGlzVGlwT3BhY2l0eSgnbGVmdCcpO1xuICB9LFxuXG4gIF9zaG93QXhpc1RpcDogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIHRleHRMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBUZXh0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBheGlzVGlwICAgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwLkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciByZWN0TGFiZWwgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwUmVjdC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcblxuICAgIGlmICh0ZXh0TGFiZWwpIHtcbiAgICAgIHRleHRMYWJlbC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjAwKS5hdHRyKCdvcGFjaXR5JywgIDEpO1xuICAgIH1cbiAgICBpZiAocmVjdExhYmVsKSB7XG4gICAgICByZWN0TGFiZWwudHJhbnNpdGlvbigpLmR1cmF0aW9uKDIwMCkuYXR0cignb3BhY2l0eScsICAxKTtcbiAgICB9XG4gIH0sXG5cbiAgX2hpZGVBeGlzVGlwOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB2YXIgdGV4dExhYmVsID0gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtYXhpc1RpcFRleHQuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG4gICAgdmFyIGF4aXNUaXAgICA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXAuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG4gICAgdmFyIHJlY3RMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBSZWN0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuXG4gICAgaWYgKHRleHRMYWJlbCkge1xuICAgICAgdGV4dExhYmVsLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyMDApLmF0dHIoJ29wYWNpdHknLCAgMCk7XG4gICAgfVxuICAgIGlmIChyZWN0TGFiZWwpIHtcbiAgICAgIHJlY3RMYWJlbC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjAwKS5hdHRyKCdvcGFjaXR5JywgIDApO1xuICAgIH1cbiAgfSxcblxuICBfdXBkYXRlQXhpc1RpcE9wYWNpdHk6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnZHJhZ2dpbmcnKSkge1xuICAgICAgdGhpcy5fc2hvd0F4aXNUaXAoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGlkZUF4aXNUaXAoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQnJ1c2hNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCh7IGRyYWdnaW5nOiB0cnVlIH0pO1xuICAgIHRoaXMuX3NlbGVjdEJhcnMoKTtcbiAgICB0aGlzLl9hZGp1c3RCcnVzaEhhbmRsZXMoKTtcbiAgfSxcblxuICBfb25Nb3VzZU91dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhcnMgPSB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKTtcbiAgICBiYXJzLmNsYXNzZWQoJ2lzLWhpZ2hsaWdodGVkJywgZmFsc2UpO1xuICAgIHRoaXMudHJpZ2dlcignaG92ZXInLCB7IHZhbHVlOiBudWxsIH0pO1xuICB9LFxuXG4gIF9vbk1vdXNlTW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSBkMy5ldmVudC5vZmZzZXRYO1xuICAgIHZhciB5ID0gZDMuZXZlbnQub2Zmc2V0WTtcblxuICAgIHZhciBiYXJJbmRleCA9IE1hdGguZmxvb3IoeCAvIHRoaXMuYmFyV2lkdGgpO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgIGlmIChkYXRhW2JhckluZGV4XSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFbYmFySW5kZXhdID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyZXEgPSBkYXRhW2JhckluZGV4XS5mcmVxO1xuICAgIHZhciBob3ZlclByb3BlcnRpZXMgPSB7fTtcblxuICAgIHZhciBiYXIgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1iYXI6bnRoLWNoaWxkKCcgKyAoYmFySW5kZXggKyAxKSArICcpJyk7XG5cbiAgICBpZiAoYmFyICYmIGJhci5ub2RlKCkgJiYgIWJhci5jbGFzc2VkKCdpcy1zZWxlY3RlZCcpKSB7XG5cbiAgICAgIHZhciBsZWZ0ID0gKGJhckluZGV4ICogdGhpcy5iYXJXaWR0aCkgKyAodGhpcy5iYXJXaWR0aC8yKTtcblxuICAgICAgdmFyIHRvcCA9IHRoaXMueVNjYWxlKGZyZXEpO1xuXG4gICAgICB2YXIgaCA9IHRoaXMuY2hhcnRIZWlnaHQoKSAtIHRoaXMueVNjYWxlKGZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHRoaXMub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIHRvcCA9IHRoaXMuY2hhcnRIZWlnaHQoKSAtIHRoaXMub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzRHJhZ2dpbmcoKSAmJiBmcmVxID4gMCkge1xuICAgICAgICB2YXIgZCA9IGZvcm1hdHRlci5mb3JtYXROdW1iZXIoZnJlcSk7XG4gICAgICAgIGhvdmVyUHJvcGVydGllcyA9IHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIGRhdGE6IGQgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvdmVyUHJvcGVydGllcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaG92ZXJQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2hvdmVyJywgaG92ZXJQcm9wZXJ0aWVzKTtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpXG4gICAgLmNsYXNzZWQoJ2lzLWhpZ2hsaWdodGVkJywgZmFsc2UpO1xuXG4gICAgaWYgKGJhciAmJiBiYXIubm9kZSgpKSB7XG4gICAgICBiYXIuY2xhc3NlZCgnaXMtaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JlbW92ZUNoYXJ0Q29udGVudCgpO1xuICAgIHRoaXMuX3NldHVwRGltZW5zaW9ucygpO1xuICAgIHRoaXMuX2NhbGNCYXJXaWR0aCgpO1xuICAgIHRoaXMuX2dlbmVyYXRlQ2hhcnRDb250ZW50KCk7XG4gICAgdGhpcy5fcmVtb3ZlU2hhZG93QmFycygpO1xuICAgIHRoaXMuX2dlbmVyYXRlU2hhZG93QmFycygpO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldHVwRGltZW5zaW9ucygpO1xuICAgIHRoaXMuX3JlbW92ZUF4aXMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUF4aXMoKTtcbiAgICB0aGlzLl91cGRhdGVDaGFydCgpO1xuXG4gICAgdGhpcy5fZ2VuZXJhdGVTaGFkb3dCYXJzKCk7XG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtaGFuZGxlcycpLm1vdmVUb0Zyb250KCk7XG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5CcnVzaCcpLm1vdmVUb0Zyb250KCk7XG4gIH0sXG5cbiAgcmVzZXRJbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCh7IGxvX2luZGV4OiBudWxsLCBoaV9pbmRleDogbnVsbCB9KTtcbiAgfSxcblxuICByZW1vdmVTaGFkb3dCYXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2hvd19zaGFkb3dfYmFycycsIGZhbHNlKTtcbiAgfSxcblxuICBfcmVtb3ZlU2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtc2hhZG93QmFycycpLnJlbW92ZSgpO1xuICB9LFxuXG4gIF9yZW1vdmVCYXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXJzJykucmVtb3ZlKCk7XG4gIH0sXG5cbiAgX3JlbW92ZUJydXNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkJydXNoJykucmVtb3ZlKCk7XG4gICAgdGhpcy5jaGFydC5jbGFzc2VkKCdpcy1zZWxlY3RhYmxlJywgZmFsc2UpO1xuICB9LFxuXG4gIF9yZW1vdmVMaW5lczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtbGluZXMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfcmVtb3ZlQ2hhcnRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCgpO1xuICAgIHRoaXMuX3JlbW92ZUhhbmRsZXMoKTtcbiAgICB0aGlzLl9yZW1vdmVCYXJzKCk7XG4gICAgdGhpcy5fcmVtb3ZlQXhpcygpO1xuICAgIHRoaXMuX3JlbW92ZUxpbmVzKCk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQ2hhcnRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUF4aXMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUxpbmVzKCk7XG5cbiAgICB0aGlzLl9nZW5lcmF0ZUJhcnMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUhhbmRsZXMoKTtcbiAgICB0aGlzLl9zZXR1cEJydXNoKCk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dlbmVyYXRlSG9yaXpvbnRhbExpbmVzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVWZXJ0aWNhbExpbmVzKCk7XG4gICAgfVxuICB9LFxuXG4gIF9nZW5lcmF0ZVZlcnRpY2FsTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsaW5lcyA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWxpbmVzJyk7XG5cbiAgICBsaW5lcy5hcHBlbmQoJ2cnKVxuICAgIC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtbGluZScpXG4gICAgLmRhdGEodGhpcy52ZXJ0aWNhbFJhbmdlLnNsaWNlKDEsIHRoaXMudmVydGljYWxSYW5nZS5sZW5ndGggLSAxKSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWxpbmUnKVxuICAgIC5hdHRyKCd5MScsIDApXG4gICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAuYXR0cigneTInLCB0aGlzLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlSG9yaXpvbnRhbExpbmVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGluZXMgPSB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1saW5lcycpO1xuXG4gICAgbGluZXMuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAneScpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1DaGFydC1saW5lJylcbiAgICAuZGF0YSh0aGlzLmhvcml6b250YWxSYW5nZSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWxpbmUnKVxuICAgIC5hdHRyKCd4MScsIDApXG4gICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAuYXR0cigneDInLCB0aGlzLmNoYXJ0V2lkdGgoKSlcbiAgICAuYXR0cigneTInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTtcblxuICAgIHRoaXMuYm90dG9tTGluZSA9IGxpbmVzXG4gICAgLmFwcGVuZCgnbGluZScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1saW5lIENEQi1DaGFydC1saW5lLS1ib3R0b20nKVxuICAgIC5hdHRyKCd4MScsIDApXG4gICAgLmF0dHIoJ3kxJywgdGhpcy5jaGFydEhlaWdodCgpKVxuICAgIC5hdHRyKCd4MicsIHRoaXMuY2hhcnRXaWR0aCgpIC0gMSlcbiAgICAuYXR0cigneTInLCB0aGlzLmNoYXJ0SGVpZ2h0KCkpO1xuICB9LFxuXG4gICBfc2V0dXBEM0JpbmRpbmdzOiBmdW5jdGlvbigpIHsgLy8gVE9ETzogbW92ZSB0byBhIGhlbHBlclxuXG4gICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlVG9CYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVUb0Zyb250ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG5cbiAgX3NldHVwTW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe1xuICAgICAgc2hvd0xhYmVsczogdHJ1ZSxcbiAgICAgIGRhdGE6IHRoaXMub3B0aW9ucy5kYXRhLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuaGVpZ2h0LFxuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIHNob3dfc2hhZG93X2JhcnM6IHRoaXMub3B0aW9ucy5zaGFkb3dEYXRhLFxuICAgICAgbWFyZ2luOiBfLmNsb25lKHRoaXMub3B0aW9ucy5tYXJnaW4pLFxuICAgICAgd2lkdGg6IDAsIC8vIHdpbGwgYmUgc2V0IG9uIHJlc2l6ZSBsaXN0ZW5lclxuICAgICAgcG9zOiB7IHg6IDAsIHk6IDAgfVxuICAgIH0pO1xuICB9LFxuXG4gIF9zZXR1cEJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25DaGFuZ2VEYXRhLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkaXNwbGF5JywgdGhpcy5fb25DaGFuZ2VEaXNwbGF5LCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkcmFnZ2luZycsIHRoaXMuX29uQ2hhbmdlRHJhZ2dpbmcsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmhlaWdodCcsIHRoaXMuX29uQ2hhbmdlSGVpZ2h0LCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpsZWZ0X2F4aXNfdGlwJywgdGhpcy5fb25DaGFuZ2VMZWZ0QXhpc1RpcCwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6bG9faW5kZXggY2hhbmdlOmhpX2luZGV4JywgdGhpcy5fb25DaGFuZ2VSYW5nZSwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6cG9zJywgdGhpcy5fb25DaGFuZ2VQb3MsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnJpZ2h0X2F4aXNfdGlwJywgdGhpcy5fb25DaGFuZ2VSaWdodEF4aXNUaXAsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnNob3dMYWJlbHMnLCB0aGlzLl9vbkNoYW5nU2hvd0xhYmVscywgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6c2hvd19zaGFkb3dfYmFycycsIHRoaXMuX29uQ2hhbmdlU2hvd1NoYWRvd0JhcnMsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOndpZHRoJywgdGhpcy5fb25DaGFuZ2VXaWR0aCwgdGhpcyk7XG4gIH0sXG5cbiAgX3NldHVwRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0dXBTY2FsZXMoKTtcbiAgICB0aGlzLl9zZXR1cFJhbmdlcygpO1xuICAgIHRoaXMuX29uV2luZG93UmVzaXplKCk7XG4gIH0sXG5cbiAgX3NldHVwU2NhbGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICB0aGlzLnhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbMCwgMTAwXSkucmFuZ2UoWzAsIHRoaXMuY2hhcnRXaWR0aCgpXSk7XG4gICAgdGhpcy55U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzAsIGQzLm1heChkYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBfLmlzRW1wdHkoZCkgPyAwIDogZC5mcmVxOyB9ICldKS5yYW5nZShbdGhpcy5jaGFydEhlaWdodCgpLCAwXSk7XG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSAndGltZScpIHtcbiAgICAgIHRoaXMueEF4aXNTY2FsZSA9IGQzLnRpbWUuc2NhbGUoKS5kb21haW4oW2RhdGFbMF0uc3RhcnQgKiAxMDAwLCBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZW5kICogMTAwMF0pLm5pY2UoKS5yYW5nZShbMCwgdGhpcy5jaGFydFdpZHRoKCldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54QXhpc1NjYWxlID0gZDMuc2NhbGUubGluZWFyKCkucmFuZ2UoW2RhdGFbMF0uc3RhcnQsIGRhdGFbZGF0YS5sZW5ndGggLSAxXS5lbmRdKS5kb21haW4oWzAsIHRoaXMuY2hhcnRXaWR0aCgpXSk7XG4gICAgfVxuICB9LFxuXG4gIF9zZXR1cFJhbmdlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBNYXRoLnJvdW5kKHRoaXMuY2hhcnRXaWR0aCgpIC8gdGhpcy5vcHRpb25zLmRpdmlzaW9uV2lkdGgpO1xuICAgIHRoaXMudmVydGljYWxSYW5nZSA9IGQzLnJhbmdlKDAsIHRoaXMuY2hhcnRXaWR0aCgpICsgdGhpcy5jaGFydFdpZHRoKCkgLyBuLCB0aGlzLmNoYXJ0V2lkdGgoKSAvIG4pO1xuICAgIHRoaXMuaG9yaXpvbnRhbFJhbmdlID0gZDMucmFuZ2UoMCwgdGhpcy5jaGFydEhlaWdodCgpICsgdGhpcy5jaGFydEhlaWdodCgpIC8gMiwgdGhpcy5jaGFydEhlaWdodCgpIC8gMik7XG4gIH0sXG5cbiAgX2NhbGNCYXJXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYXJXaWR0aCA9IHRoaXMuY2hhcnRXaWR0aCgpIC8gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKS5sZW5ndGg7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJnaW4gPSB0aGlzLm1vZGVsLmdldCgnbWFyZ2luJyk7XG5cbiAgICB0aGlzLmNoYXJ0ID0gZDMuc2VsZWN0KHRoaXMuZWwpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1XaWRnZXRDYW52YXMnKVxuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsICcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgIHRoaXMuY2hhcnQuY2xhc3NlZCh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnLCB0cnVlKTtcbiAgfSxcblxuICBfb25DaGFuZ2VTaG93U2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdzaG93X3NoYWRvd19iYXJzJykpIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlU2hhZG93QmFycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3dCYXJzKCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNoYW5nZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnZGlzcGxheScpKSB7XG4gICAgICB0aGlzLl9zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ2Rpc3BsYXknLCBmYWxzZSk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ2Rpc3BsYXknLCB0cnVlKTtcbiAgfSxcblxuICBfaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaGlkZSgpO1xuICB9LFxuXG4gIF9zaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5zaG93KCk7XG4gIH0sXG5cbiAgaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5tb2RlbC5nZXQoJ2Rpc3BsYXknKTtcbiAgfSxcblxuICBfc2VsZWN0QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmJydXNoLmV4dGVudCgpO1xuICAgIHZhciBsbyA9IGV4dGVudFswXTtcbiAgICB2YXIgaGkgPSBleHRlbnRbMV07XG5cblxuICAgIHRoaXMubW9kZWwuc2V0KHsgbG9faW5kZXg6IHRoaXMuX2dldExvQmFySW5kZXgoKSwgaGlfaW5kZXg6IHRoaXMuX2dldEhpQmFySW5kZXgoKSB9KTtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpLmNsYXNzZWQoJ2lzLXNlbGVjdGVkJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgdmFyIGEgPSBNYXRoLmZsb29yKGkgKiBzZWxmLmJhcldpZHRoKTtcbiAgICAgIHZhciBiID0gTWF0aC5mbG9vcihhICsgc2VsZi5iYXJXaWR0aCk7XG4gICAgICB2YXIgTE8gPSBNYXRoLmZsb29yKHNlbGYueFNjYWxlKGxvKSk7XG4gICAgICB2YXIgSEkgPSBNYXRoLmZsb29yKHNlbGYueFNjYWxlKGhpKSk7XG4gICAgICB2YXIgaXNJbiA9IChhID4gTE8gJiYgYSA8IEhJKSB8fCAoYiA+IExPICYmIGIgPCBISSkgfHwgKGEgPD0gTE8gJiYgYiA+PSBISSk7XG4gICAgICByZXR1cm4gIWlzSW47XG4gICAgfSk7XG4gIH0sXG5cbiAgX2lzRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldCgnZHJhZ2dpbmcnKTtcbiAgfSxcblxuICBfbW92ZTogZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoeyBwb3M6IHBvcyB9KTtcbiAgfSxcblxuICBleHBhbmQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHRoaXMuY2FudmFzLmF0dHIoJ2hlaWdodCcsIHRoaXMubW9kZWwuZ2V0KCdoZWlnaHQnKSArIGhlaWdodCk7XG4gICAgdGhpcy5fbW92ZSh7IHg6IDAsIHk6IGhlaWdodCB9KTtcbiAgfSxcblxuICBjb250cmFjdDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgdGhpcy5jYW52YXMuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB0aGlzLl9tb3ZlKHsgeDogMCwgeTogMCB9KTtcbiAgfSxcblxuICByZXNpemVIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdoZWlnaHQnLCBoZWlnaHQpO1xuICB9LFxuXG4gIHJlbW92ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldEluZGV4ZXMoKTtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKS5jbGFzc2VkKCdpcy1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCgpO1xuICAgIHRoaXMuX3NldHVwQnJ1c2goKTtcbiAgfSxcblxuICBzZWxlY3RSYW5nZTogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIGlmICghbG9CYXJJbmRleCAmJiAhaGlCYXJJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsb1Bvc2l0aW9uID0gdGhpcy5fZ2V0QmFyUG9zaXRpb24obG9CYXJJbmRleCk7XG4gICAgdmFyIGhpUG9zaXRpb24gPSB0aGlzLl9nZXRCYXJQb3NpdGlvbihoaUJhckluZGV4KTtcblxuICAgIHRoaXMuX3NlbGVjdFJhbmdlKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pO1xuICB9LFxuXG4gIF9zZWxlY3RSYW5nZTogZnVuY3Rpb24obG9Qb3NpdGlvbiwgaGlQb3NpdGlvbikge1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQnJ1c2gnKS50cmFuc2l0aW9uKClcbiAgICAuZHVyYXRpb24odGhpcy5icnVzaC5lbXB0eSgpID8gMCA6IDE1MClcbiAgICAuY2FsbCh0aGlzLmJydXNoLmV4dGVudChbbG9Qb3NpdGlvbiwgaGlQb3NpdGlvbl0pKVxuICAgIC5jYWxsKHRoaXMuYnJ1c2guZXZlbnQpO1xuICB9LFxuXG4gIF9nZXRMb0JhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLnhTY2FsZShleHRlbnRbMF0pIC8gdGhpcy5iYXJXaWR0aCk7XG4gIH0sXG5cbiAgX2dldEhpQmFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmJydXNoLmV4dGVudCgpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMueFNjYWxlKGV4dGVudFsxXSkgLyB0aGlzLmJhcldpZHRoKTtcbiAgfSxcblxuICBfZ2V0QmFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gZDMuZXZlbnQuc291cmNlRXZlbnQub2Zmc2V0WDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gdGhpcy5iYXJXaWR0aCk7XG4gIH0sXG5cbiAgX2dldEJhclBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICByZXR1cm4gaW5kZXggKiAoMTAwIC8gZGF0YS5sZW5ndGgpO1xuICB9LFxuXG4gIF9zZXR1cEJydXNoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgeFNjYWxlID0gdGhpcy54U2NhbGU7XG4gICAgdmFyIGJydXNoID0gdGhpcy5icnVzaCA9IGQzLnN2Zy5icnVzaCgpLngodGhpcy54U2NhbGUpO1xuXG4gICAgZnVuY3Rpb24gb25CcnVzaEVuZCgpIHtcbiAgICAgIHZhciBkYXRhID0gc2VsZi5tb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICAgIHZhciBsb1Bvc2l0aW9uLCBoaVBvc2l0aW9uO1xuXG4gICAgICBzZWxmLm1vZGVsLnNldCh7IGRyYWdnaW5nOiBmYWxzZSB9KTtcblxuICAgICAgaWYgKGJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgc2VsZi5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtYmFyJykuY2xhc3NlZCgnaXMtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoLmV4dGVudChbMCwgMF0pKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIGxvQmFySW5kZXggPSBzZWxmLl9nZXRMb0JhckluZGV4KCk7XG4gICAgICAgIHZhciBoaUJhckluZGV4ID0gc2VsZi5fZ2V0SGlCYXJJbmRleCgpO1xuXG4gICAgICAgIGxvUG9zaXRpb24gPSBzZWxmLl9nZXRCYXJQb3NpdGlvbihsb0JhckluZGV4KTtcbiAgICAgICAgaGlQb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGhpQmFySW5kZXgpO1xuXG4gICAgICAgIGlmICghZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9CYXJJbmRleCA9PT0gaGlCYXJJbmRleCkge1xuICAgICAgICAgIGlmIChoaUJhckluZGV4ID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb1Bvc2l0aW9uID0gc2VsZi5fZ2V0QmFyUG9zaXRpb24obG9CYXJJbmRleCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaVBvc2l0aW9uID0gc2VsZi5fZ2V0QmFyUG9zaXRpb24oaGlCYXJJbmRleCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3NlbGVjdFJhbmdlKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pO1xuICAgICAgICBzZWxmLm1vZGVsLnNldCh7IGxvX2luZGV4OiBsb0JhckluZGV4LCBoaV9pbmRleDogaGlCYXJJbmRleCB9KTtcbiAgICAgICAgc2VsZi5fYWRqdXN0QnJ1c2hIYW5kbGVzKCk7XG4gICAgICAgIHNlbGYuX3NlbGVjdEJhcnMoKTtcblxuICAgICAgICBzZWxmLnRyaWdnZXIoJ29uX2JydXNoX2VuZCcsIHNlbGYubW9kZWwuZ2V0KCdsb19pbmRleCcpLCBzZWxmLm1vZGVsLmdldCgnaGlfaW5kZXgnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAmJiBsb1Bvc2l0aW9uID09PSB1bmRlZmluZWQgJiYgaGlQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBiYXJJbmRleCA9IHNlbGYuX2dldEJhckluZGV4KCk7XG5cbiAgICAgICAgbG9Qb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGJhckluZGV4KTtcbiAgICAgICAgaGlQb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGJhckluZGV4ICsgMSk7XG5cbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoeyBsb19pbmRleDogYmFySW5kZXgsIGhpX2luZGV4OiBiYXJJbmRleCArIDEgfSk7XG4gICAgICAgIHNlbGYuX3NlbGVjdFJhbmdlKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ29uX2JydXNoX2VuZCcsIHNlbGYubW9kZWwuZ2V0KCdsb19pbmRleCcpLCBzZWxmLm1vZGVsLmdldCgnaGlfaW5kZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgdGhpcy5icnVzaFxuICAgIC5vbignYnJ1c2hzdGFydCcsIHRoaXMuX29uQnJ1c2hTdGFydClcbiAgICAub24oJ2JydXNoJywgdGhpcy5fb25CcnVzaE1vdmUpXG4gICAgLm9uKCdicnVzaGVuZCcsIG9uQnJ1c2hFbmQpO1xuXG4gICAgdGhpcy5jaGFydC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdCcnVzaCcpXG4gICAgLmNhbGwodGhpcy5icnVzaClcbiAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAuYXR0cigneScsIDApXG4gICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuY2hhcnRIZWlnaHQoKSlcbiAgICAub24oJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dClcbiAgICAub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgfSxcblxuICBfYWRqdXN0QnJ1c2hIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcblxuICAgIHZhciBsb0V4dGVudCA9IGV4dGVudFswXTtcbiAgICB2YXIgaGlFeHRlbnQgPSBleHRlbnRbMV07XG5cbiAgICB2YXIgbGVmdFggID0gdGhpcy54U2NhbGUobG9FeHRlbnQpIC0gdGhpcy5vcHRpb25zLmhhbmRsZVdpZHRoIC8gMjtcbiAgICB2YXIgcmlnaHRYID0gdGhpcy54U2NhbGUoaGlFeHRlbnQpIC0gdGhpcy5vcHRpb25zLmhhbmRsZVdpZHRoIC8gMjtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZS1sZWZ0JylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbGVmdFggKyAnLCAwKScpO1xuXG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtaGFuZGxlLXJpZ2h0JylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgcmlnaHRYICsgJywgMCknKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFzQXhpc1RpcCkge1xuICAgICAgdGhpcy5tb2RlbC5zZXQoe1xuICAgICAgICBsZWZ0X2F4aXNfdGlwOiB0aGlzLnhBeGlzU2NhbGUobGVmdFggKyAzKSxcbiAgICAgICAgcmlnaHRfYXhpc190aXA6IHRoaXMueEF4aXNTY2FsZShyaWdodFggKyAzKVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9nZW5lcmF0ZUF4aXNUaXA6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZS5DREItQ2hhcnQtaGFuZGxlLScgKyBjbGFzc05hbWUpO1xuXG4gICAgdmFyIGF4aXNUaXAgPSBoYW5kbGUuc2VsZWN0QWxsKFwiZ1wiKVxuICAgIC5kYXRhKFsnJ10pXG4gICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYXhpc1RpcCBDREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKDAsNTIpXCI7IH0pO1xuXG4gICAgdGhpcy5yZWN0TGFiZWwgPSBheGlzVGlwLmFwcGVuZChcInJlY3RcIilcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWF4aXNUaXBSZWN0IENEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgMTIpXG4gICAgLmF0dHIoXCJ3aWR0aFwiLCAxMCk7XG5cbiAgICB0aGlzLnRleHRMYWJlbCA9IGF4aXNUaXAuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYXhpc1RpcFRleHQgQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSlcbiAgICAuYXR0cihcImR5XCIsIFwiMTFcIilcbiAgICAuYXR0cihcImR4XCIsIFwiMFwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUhhbmRsZTogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIG9wdHMgPSB7IHdpZHRoOiB0aGlzLm9wdGlvbnMuaGFuZGxlV2lkdGgsIGhlaWdodDogdGhpcy5vcHRpb25zLmhhbmRsZUhlaWdodCwgcmFkaXVzOiB0aGlzLm9wdGlvbnMuaGFuZGxlUmFkaXVzIH07XG4gICAgdmFyIHlQb3MgPSAodGhpcy5jaGFydEhlaWdodCgpIC8gMikgLSAodGhpcy5vcHRpb25zLmhhbmRsZUhlaWdodCAvIDIpO1xuXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZXMnKVxuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlIENEQi1DaGFydC1oYW5kbGUtJyArIGNsYXNzTmFtZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhc0F4aXNUaXApIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlQXhpc1RpcChjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGhhbmRsZVxuICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlTGluZScpXG4gICAgLmF0dHIoJ3gxJywgMylcbiAgICAuYXR0cigneTEnLCAtNClcbiAgICAuYXR0cigneDInLCAzKVxuICAgIC5hdHRyKCd5MicsIHRoaXMuY2hhcnRIZWlnaHQoKSArIDQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYXNIYW5kbGVzKSB7XG4gICAgICBoYW5kbGVcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVSZWN0JylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsICcgKyB5UG9zICsgJyknKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgb3B0cy53aWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBvcHRzLmhlaWdodClcbiAgICAgIC5hdHRyKCdyeCcsIG9wdHMucmFkaXVzKVxuICAgICAgLmF0dHIoJ3J5Jywgb3B0cy5yYWRpdXMpO1xuXG4gICAgICB2YXIgeSA9IDIxOyAvLyBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBncmlwXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGhhbmRsZVxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVHcmlwJylcbiAgICAgICAgLmF0dHIoJ3gxJywgMilcbiAgICAgICAgLmF0dHIoJ3kxJywgeSArIGkqMylcbiAgICAgICAgLmF0dHIoJ3gyJywgNClcbiAgICAgICAgLmF0dHIoJ3kyJywgeSArIGkqMyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVzJyk7XG4gICAgdGhpcy5sZWZ0SGFuZGxlICA9IHRoaXMuX2dlbmVyYXRlSGFuZGxlKCdsZWZ0Jyk7XG4gICAgdGhpcy5yaWdodEhhbmRsZSA9IHRoaXMuX2dlbmVyYXRlSGFuZGxlKCdyaWdodCcpO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUhhbmRsZUxpbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGVzJykuYXBwZW5kKCdsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWhhbmRsZUxpbmUnKVxuICAgIC5hdHRyKCd4MScsIDApXG4gICAgLmF0dHIoJ3kxJywgMClcbiAgICAuYXR0cigneDInLCAwKVxuICAgIC5hdHRyKCd5MicsIHRoaXMuY2hhcnRIZWlnaHQoKSk7XG4gIH0sXG5cbiAgX3JlbW92ZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZXMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfcmVtb3ZlQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW52YXMuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfZ2VuZXJhdGVBZGp1c3RBbmNob3JNZXRob2Q6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09ICh0aWNrcy5sZW5ndGggLSAxKSkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ21pZGRsZSc7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBfZ2VuZXJhdGVBeGlzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9heGlzID0gdGhpcy5vcHRpb25zLnR5cGUgPT09ICd0aW1lJ1xuICAgICAgPyB0aGlzLl9nZW5lcmF0ZVRpbWVBeGlzKClcbiAgICAgIDogdGhpcy5fZ2VuZXJhdGVOdW1lcmljQXhpcygpO1xuXG4gICAgdGhpcy5fb25DaGFuZ1Nob3dMYWJlbHMoKTtcbiAgfSxcblxuICBfZ2VuZXJhdGVOdW1lcmljQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhZGp1c3RUZXh0QW5jaG9yID0gdGhpcy5fZ2VuZXJhdGVBZGp1c3RBbmNob3JNZXRob2QodGhpcy52ZXJ0aWNhbFJhbmdlKTtcblxuICAgIHZhciBheGlzID0gdGhpcy5jaGFydC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYXhpcycpO1xuXG4gICAgYXhpc1xuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5zZWxlY3RBbGwoJy5MYWJlbCcpXG4gICAgLmRhdGEodGhpcy52ZXJ0aWNhbFJhbmdlKVxuICAgIC5lbnRlcigpLmFwcGVuZChcInRleHRcIilcbiAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpICsgMTU7IH0pXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBhZGp1c3RUZXh0QW5jaG9yKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKHNlbGYueEF4aXNTY2FsZShkKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXhpcztcbiAgfSxcblxuICBfZ2VuZXJhdGVUaW1lQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFkanVzdFRleHRBbmNob3IgPSB0aGlzLl9nZW5lcmF0ZUFkanVzdEFuY2hvck1ldGhvZCh0aGlzLnhBeGlzU2NhbGUudGlja3MoKSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgLm9yaWVudChcImJvdHRvbVwiKVxuICAgIC50aWNrUGFkZGluZyg1KVxuICAgIC5pbm5lclRpY2tTaXplKC10aGlzLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLnNjYWxlKHRoaXMueEF4aXNTY2FsZSlcbiAgICAub3JpZW50KCdib3R0b20nKTtcblxuICAgIHZhciBheGlzID0gdGhpcy5jYW52YXMuYXBwZW5kKCdnJylcbiAgICAuYXR0cihcImNsYXNzXCIsICdDREItQ2hhcnQtYXhpcycpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArICh0aGlzLmNoYXJ0SGVpZ2h0KCkgKyA1KSArIFwiKVwiKVxuICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIGF4aXMuc2VsZWN0QWxsKCd0ZXh0Jykuc3R5bGUoJ3RleHQtYW5jaG9yJywgYWRqdXN0VGV4dEFuY2hvcik7XG4gICAgYXhpcy5tb3ZlVG9CYWNrKCk7XG5cbiAgICByZXR1cm4gYXhpcztcbiAgfSxcblxuICBfdXBkYXRlQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICB2YXIgYmFycyA9IHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpXG4gICAgLmRhdGEoZGF0YSk7XG5cbiAgICBiYXJzXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWJhcicpXG4gICAgLmF0dHIoJ2RhdGEnLCBmdW5jdGlvbihkKSB7IHJldHVybiBfLmlzRW1wdHkoZCkgPyAwIDogIGQuZnJlcTsgfSlcbiAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChpICogc2VsZi5iYXJXaWR0aCkgKyAnLCAwICknO1xuICAgIH0pXG4gICAgLmF0dHIoJ3knLCBzZWxmLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLmF0dHIoJ2hlaWdodCcsIDApXG4gICAgLmF0dHIoJ3dpZHRoJywgTWF0aC5tYXgoMCwgdGhpcy5iYXJXaWR0aCAtIDEpKTtcblxuICAgIGJhcnNcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKDIwMClcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuXG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYueVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgaCA9IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfSlcbiAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoZCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLnlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLnlTY2FsZShkLmZyZXEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYmFyc1xuICAgIC5leGl0KClcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKDIwMClcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSlcbiAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQmFyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgIHRoaXMuX2NhbGNCYXJXaWR0aCgpO1xuXG4gICAgdmFyIGJhcnMgPSB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYmFycycpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKVxuICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgYmFyc1xuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1iYXInKVxuICAgIC5hdHRyKCdkYXRhJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gXy5pc0VtcHR5KGQpID8gMCA6ICBkLmZyZXE7IH0pXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoaSAqIHNlbGYuYmFyV2lkdGgpICsgJywgMCApJztcbiAgICB9KVxuICAgIC5hdHRyKCd5Jywgc2VsZi5jaGFydEhlaWdodCgpKVxuICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgIC5hdHRyKCd3aWR0aCcsIE1hdGgubWF4KDAsIHRoaXMuYmFyV2lkdGggLSAxKSk7XG5cbiAgICBiYXJzXG4gICAgLnRyYW5zaXRpb24oKVxuICAgIC5lYXNlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVHlwZSlcbiAgICAuZHVyYXRpb24odGhpcy5vcHRpb25zLmFuaW1hdGlvblNwZWVkKVxuICAgIC5kZWxheSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uQmFyRGVsYXkpXG4gICAgLnRyYW5zaXRpb24oKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkKSB7XG5cbiAgICAgIGlmIChfLmlzRW1wdHkoZCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gc2VsZi5jaGFydEhlaWdodCgpIC0gc2VsZi55U2NhbGUoZC5mcmVxKTtcblxuICAgICAgaWYgKGggPCBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodCAmJiBoID4gMCkge1xuICAgICAgICBoID0gc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICB9KVxuICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShkKSkge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYueVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYueVNjYWxlKGQuZnJlcSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgc2hvd1NoYWRvd0JhcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdzaG93X3NoYWRvd19iYXJzJywgdHJ1ZSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlU2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm9wdGlvbnMuc2hhZG93RGF0YTtcblxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIXRoaXMubW9kZWwuZ2V0KCdzaG93X3NoYWRvd19iYXJzJykpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvd0JhcnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVTaGFkb3dCYXJzKCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXy5pc0VtcHR5KGQpID8gMCA6IGQuZnJlcTsgfSApXSkucmFuZ2UoW3RoaXMuY2hhcnRIZWlnaHQoKSwgMF0pO1xuICAgIHZhciBiYXJXaWR0aCA9IHRoaXMuY2hhcnRXaWR0aCgpIC8gZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgYmFycyA9IHRoaXMuY2hhcnQuYXBwZW5kKCdnJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1zaGFkb3dCYXJzJylcbiAgICAuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LXNoYWRvd0JhcicpXG4gICAgLmRhdGEoZGF0YSlcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtc2hhZG93QmFyJylcbiAgICAuYXR0cignZGF0YScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIF8uaXNFbXB0eShkKSA/IDAgOiAgZC5mcmVxOyB9KVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKGkgKiBiYXJXaWR0aCkgKyAnLCAwICknO1xuICAgIH0pXG4gICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gc2VsZi5jaGFydEhlaWdodCgpIC0geVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLmZyZXEpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmF0dHIoJ3dpZHRoJywgTWF0aC5tYXgoMCwgYmFyV2lkdGggLSAxKSlcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuXG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIGggPSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBleHBsaWNpdGx5IG1vdmUgdGhlIGxpbmVzIG9mIHRoZSBncmlkIGJlaGluZCB0aGUgc2hhZG93IGJhcnNcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1zaGFkb3dCYXJzJykubW92ZVRvQmFjaygpO1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWxpbmVzJykubW92ZVRvQmFjaygpO1xuICB9XG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgZm9ybWF0dGVyID0gY2RiLmNvcmUuZm9ybWF0O1xudmFyIEhpc3RvZ3JhbVRpdGxlVmlldyA9IHJlcXVpcmUoJy4vaGlzdG9ncmFtX3RpdGxlX3ZpZXcnKTtcbnZhciBXaWRnZXRDb250ZW50ID0gcmVxdWlyZSgnLi4vc3RhbmRhcmQvd2lkZ2V0X2NvbnRlbnRfdmlldycpO1xudmFyIFdpZGdldFZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9jb250ZW50X21vZGVsJyk7XG52YXIgSGlzdG9ncmFtQ2hhcnRWaWV3ID0gcmVxdWlyZSgnLi9jaGFydCcpO1xudmFyIHBsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlci50cGwnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY29udGVudC50cGwnKTtcbnZhciBBbmltYXRlVmFsdWVzID0gcmVxdWlyZSgnLi4vYW5pbWF0ZV92YWx1ZXMuanMnKTtcbnZhciBhbmltYXRpb25UZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIFdpZGdldCBjb250ZW50IHZpZXcgZm9yIGEgaGlzdG9ncmFtXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0Q29udGVudC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgY2hhcnRIZWlnaHQ6IDQ4ICsgMjAgKyA0XG4gIH0sXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1jbGVhcic6ICdfY2xlYXInLFxuICAgICdjbGljayAuanMtem9vbSc6ICdfem9vbSdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBXaWRnZXRWaWV3TW9kZWwoKTtcbiAgICB0aGlzLmxvY2tlZEJ5VXNlciA9IGZhbHNlO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGl0bGVWaWV3ID0gbmV3IEhpc3RvZ3JhbVRpdGxlVmlldyh7XG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtdGl0bGUnKS5odG1sKHRpdGxlVmlldy5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHRpdGxlVmlldyk7XG5cbiAgICB0aGlzLl9yZW5kZXJNaW5pQ2hhcnQoKTtcbiAgICB0aGlzLl9yZW5kZXJNYWluQ2hhcnQoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25GaXJzdExvYWQsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIGZ1bmN0aW9uKG1kbCwgaXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuJGVsLnRvZ2dsZUNsYXNzKCdpcy1jb2xsYXBzZWQnLCAhIWlzQ29sbGFwc2VkKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfb25GaXJzdExvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgdGhpcy5fc3RvcmVCb3VuZHMoKTtcblxuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VNb2RlbCwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5fZmV0Y2goKTtcbiAgfSxcblxuICBfc3RvcmVCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gZGF0YVswXS5zdGFydDtcbiAgICAgIHRoaXMuZW5kID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgIHRoaXMuYmluc0NvdW50ID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLm1vZGVsLnNldCh7IHN0YXJ0OiB0aGlzLnN0YXJ0LCBlbmQ6IHRoaXMuZW5kLCBiaW5zOiB0aGlzLmJpbnNDb3VudCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgX2lzWm9vbWVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3TW9kZWwuZ2V0KCd6b29tZWQnKTtcbiAgfSxcblxuICBfb25DaGFuZ2VNb2RlbDogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBXaGVuIHRoZSBoaXN0b2dyYW0gaXMgem9vbWVkLCB3ZSBkb24ndCBuZWVkIHRvIHJlbHlcbiAgICAvLyBvbiB0aGUgY2hhbmdlIHVybCB0byB1cGRhdGUgdGhlIGhpc3RvZ3JhbVxuICAgIGlmICh0aGlzLm1vZGVsLmNoYW5nZWQudXJsICYmIHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgYWN0aW9uIHdhcyBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgICAvLyBkb24ndCByZXBsYWNlIHRoZSBzdG9yZWQgZGF0YVxuICAgIGlmICh0aGlzLmxvY2tlZEJ5VXNlcikge1xuICAgICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgICAgdGhpcy56b29tZWREYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5zaG93U2hhZG93QmFycygpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZXBsYWNlRGF0YSh0aGlzLm1vZGVsLmdldERhdGEoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudW5zZXR0aW5nUmFuZ2UpIHtcbiAgICAgIHRoaXMuX3Vuc2V0UmFuZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkgJiYgIXRoaXMubG9ja1pvb21lZERhdGEpIHtcbiAgICAgICAgdGhpcy5sb2NrWm9vbWVkRGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMuem9vbWVkRGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0YXRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLm1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgaXRlbXNDb3VudDogIWlzRGF0YUVtcHR5ID8gZGF0YS5sZW5ndGggOiAnLSdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmIChpc0RhdGFFbXB0eSkge1xuICAgICAgdGhpcy5fYWRkUGxhY2Vob2xkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcmlnaW5hbERhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICAgIHRoaXMuX3NldHVwQmluZGluZ3MoKTtcbiAgICAgIHRoaXMuX2luaXRWaWV3cygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF91bnNldFJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVuc2V0dGluZ1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVwbGFjZURhdGEodGhpcy5vcmlnaW5hbERhdGEpO1xuICAgIHRoaXMudmlld01vZGVsLnNldCh7IGxvX2luZGV4OiBudWxsLCBoaV9pbmRleDogbnVsbCB9KTtcblxuICAgIGlmICghdGhpcy5faXNab29tZWQoKSkge1xuICAgICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuc2hvd1NoYWRvd0JhcnMoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2FkZFBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHBsYWNlaG9sZGVyKCkpO1xuICB9LFxuXG4gIF9yZW5kZXJNYWluQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3ID0gbmV3IEhpc3RvZ3JhbUNoYXJ0Vmlldygoe1xuICAgICAgbWFyZ2luOiB7IHRvcDogNCwgcmlnaHQ6IDQsIGJvdHRvbTogNCwgbGVmdDogNCB9LFxuICAgICAgaGFzU2hhZG93QmFyZHM6IHRydWUsXG4gICAgICBoYXNIYW5kbGVzOiB0cnVlLFxuICAgICAgaGFzQXhpc1RpcDogdHJ1ZSxcbiAgICAgIHdpZHRoOiB0aGlzLmNhbnZhc1dpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRlZmF1bHRzLmNoYXJ0SGVpZ2h0LFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKCksXG4gICAgICBzaGFkb3dEYXRhOiB0aGlzLm1vZGVsLmdldERhdGEoKVxuICAgIH0pKTtcblxuICAgIHRoaXMuJCgnLmpzLWNvbnRlbnQnKS5hcHBlbmQodGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldyk7XG5cbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5iaW5kKCdyYW5nZV91cGRhdGVkJywgdGhpcy5fb25SYW5nZVVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LmJpbmQoJ29uX2JydXNoX2VuZCcsIHRoaXMuX29uQnJ1c2hFbmQsIHRoaXMpO1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LmJpbmQoJ2hvdmVyJywgdGhpcy5fb25WYWx1ZUhvdmVyLCB0aGlzKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW5kZXIoKS5zaG93KCk7XG5cbiAgICB0aGlzLl91cGRhdGVTdGF0cygpO1xuICB9LFxuXG4gIF9yZW5kZXJNaW5pQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0VmlldyA9IG5ldyBIaXN0b2dyYW1DaGFydFZpZXcoKHtcbiAgICAgIGNsYXNzTmFtZTogJ0NEQi1DaGFydC0tbWluaScsXG4gICAgICBtYXJnaW46IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiA0LCBsZWZ0OiA0IH0sXG4gICAgICBoZWlnaHQ6IDQwLFxuICAgICAgc2hvd09uV2lkdGhDaGFuZ2U6IGZhbHNlLFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKClcbiAgICB9KSk7XG5cbiAgICB0aGlzLmFkZFZpZXcodGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3KTtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0Vmlldy5lbCk7XG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LmJpbmQoJ29uX2JydXNoX2VuZCcsIHRoaXMuX29uTWluaVJhbmdlVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIF9zZXR1cEJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6em9vbWVkJywgdGhpcy5fb25DaGFuZ2Vab29tZWQsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTp6b29tX2VuYWJsZWQnLCB0aGlzLl9vbkNoYW5nZVpvb21FbmFibGVkLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6ZmlsdGVyX2VuYWJsZWQnLCB0aGlzLl9vbkNoYW5nZUZpbHRlckVuYWJsZWQsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTp0b3RhbCcsIHRoaXMuX29uQ2hhbmdlVG90YWwsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTpudWxscycsIHRoaXMuX29uQ2hhbmdlTnVsbHMsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTptYXgnLCAgIHRoaXMuX29uQ2hhbmdlTWF4LCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6bWluJywgICB0aGlzLl9vbkNoYW5nZU1pbiwgdGhpcyk7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOmF2ZycsICAgdGhpcy5fb25DaGFuZ2VBdmcsIHRoaXMpO1xuICB9LFxuXG4gIF9jbGVhclRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJChcIi5qcy10b29sdGlwXCIpLnN0b3AoKS5oaWRlKCk7XG4gIH0sXG5cbiAgX29uVmFsdWVIb3ZlcjogZnVuY3Rpb24oaW5mbykge1xuICAgIHZhciAkdG9vbHRpcCA9IHRoaXMuJChcIi5qcy10b29sdGlwXCIpO1xuXG4gICAgaWYgKGluZm8gJiYgaW5mby5kYXRhKSB7XG4gICAgICB2YXIgYm90dG9tID0gdGhpcy5kZWZhdWx0cy5jaGFydEhlaWdodCArIDMgLSBpbmZvLnRvcDtcblxuICAgICAgJHRvb2x0aXAuY3NzKHsgYm90dG9tOiBib3R0b20sIGxlZnQ6IGluZm8ubGVmdCB9KTtcbiAgICAgICR0b29sdGlwLnRleHQoaW5mby5kYXRhKTtcbiAgICAgICR0b29sdGlwLmNzcyh7IGxlZnQ6IGluZm8ubGVmdCAtICR0b29sdGlwLndpZHRoKCkvMiB9KTtcbiAgICAgICR0b29sdGlwLmZhZGVJbig3MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NsZWFyVG9vbHRpcCgpO1xuICAgIH1cbiAgfSxcblxuICBfb25NaW5pUmFuZ2VVcGRhdGVkOiBmdW5jdGlvbihsb0JhckluZGV4LCBoaUJhckluZGV4KSB7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgICB0aGlzLmxvY2tab29tZWREYXRhID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jbGVhclRvb2x0aXAoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW1vdmVTZWxlY3Rpb24oKTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5vcmlnaW5hbERhdGE7XG5cbiAgICBpZiAobG9CYXJJbmRleCA+PSAwICYmIGxvQmFySW5kZXggPCBkYXRhLmxlbmd0aCAmJiAoaGlCYXJJbmRleCAtIDEpID49IDAgJiYgKGhpQmFySW5kZXggLSAxKSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZpbHRlci5zZXRSYW5nZShcbiAgICAgICAgZGF0YVtsb0JhckluZGV4XS5zdGFydCxcbiAgICAgICAgZGF0YVtoaUJhckluZGV4IC0gMV0uZW5kXG4gICAgICApO1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIGFycmF5IGJvdW5kcycsIGxvQmFySW5kZXgsIGhpQmFySW5kZXgsIGRhdGEpO1xuICAgIH1cbiAgfSxcblxuICBfb25CcnVzaEVuZDogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fZ2V0RGF0YSgpO1xuICAgIFxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNab29tZWQoKSkge1xuICAgICAgdGhpcy5sb2NrZWRCeVVzZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0aWVzID0geyBmaWx0ZXJfZW5hYmxlZDogdHJ1ZSwgbG9faW5kZXg6IGxvQmFySW5kZXgsIGhpX2luZGV4OiBoaUJhckluZGV4IH07XG5cbiAgICBpZiAoIXRoaXMudmlld01vZGVsLmdldCgnem9vbWVkJykpIHtcbiAgICAgIHByb3BlcnRpZXMuem9vbV9lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQocHJvcGVydGllcyk7XG5cbiAgICBpZiAobG9CYXJJbmRleCA+PSAwICYmIGxvQmFySW5kZXggPCBkYXRhLmxlbmd0aCAmJiAoaGlCYXJJbmRleCAtIDEpID49IDAgJiYgKGhpQmFySW5kZXggLSAxKSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZpbHRlci5zZXRSYW5nZShcbiAgICAgICAgZGF0YVtsb0JhckluZGV4XS5zdGFydCxcbiAgICAgICAgZGF0YVtoaUJhckluZGV4IC0gMV0uZW5kXG4gICAgICApO1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIGFycmF5IGJvdW5kcycsIGxvQmFySW5kZXgsIGhpQmFySW5kZXgsIGRhdGEpO1xuICAgIH1cbiAgfSxcblxuICBfb25SYW5nZVVwZGF0ZWQ6IGZ1bmN0aW9uKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZ2V0KCd6b29tZWQnKSkge1xuICAgICAgdGhpcy52aWV3TW9kZWwuc2V0KHsgem9vbV9lbmFibGVkOiBmYWxzZSwgbG9faW5kZXg6IGxvQmFySW5kZXgsIGhpX2luZGV4OiBoaUJhckluZGV4IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZXdNb2RlbC5zZXQoeyBsb19pbmRleDogbG9CYXJJbmRleCwgaGlfaW5kZXg6IGhpQmFySW5kZXggfSk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZVN0YXRzID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHsgc2VsZi5fdXBkYXRlU3RhdHMoKTsgfSwgNDAwKTtcbiAgICB1cGRhdGVTdGF0cygpO1xuICB9LFxuXG4gIF9nZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnpvb21lZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIF9vbkNoYW5nZUZpbHRlckVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJChcIi5qcy1maWx0ZXJcIikudG9nZ2xlQ2xhc3MoJ2lzLWhpZGRlbicsICF0aGlzLnZpZXdNb2RlbC5nZXQoJ2ZpbHRlcl9lbmFibGVkJykpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVpvb21FbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoXCIuanMtem9vbVwiKS50b2dnbGVDbGFzcygnaXMtaGlkZGVuJywgIXRoaXMudmlld01vZGVsLmdldCgnem9vbV9lbmFibGVkJykpO1xuICB9LFxuXG4gIF9jaGFuZ2VIZWFkZXJWYWx1ZTogZnVuY3Rpb24oY2xhc3NOYW1lLCB3aGF0LCBzdWZmaXgpIHtcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZ2V0KHdoYXQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuJChjbGFzc05hbWUpLnRleHQoJzAgJyArIHN1ZmZpeCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fYWRkVGl0bGVGb3JWYWx1ZShjbGFzc05hbWUsIHdoYXQsIHN1ZmZpeCk7XG5cbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0ZVZhbHVlcyh7XG4gICAgICBlbDogdGhpcy4kZWxcbiAgICB9KTtcblxuICAgIGFuaW1hdG9yLmFuaW1hdGVWYWx1ZSh0aGlzLnZpZXdNb2RlbCwgd2hhdCwgY2xhc3NOYW1lLCBhbmltYXRpb25UZW1wbGF0ZSwge1xuICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyLFxuICAgICAgdGVtcGxhdGVEYXRhOiB7IHN1ZmZpeDogXCIgXCIgKyBzdWZmaXggfVxuICAgIH0pO1xuICB9LFxuXG4gIF9vbkNoYW5nZU51bGxzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFuZ2VIZWFkZXJWYWx1ZSgnLmpzLW51bGxzJywgJ251bGxzJywgJ05VTEwgUk9XUycpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVRvdGFsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFuZ2VIZWFkZXJWYWx1ZSgnLmpzLXZhbCcsICd0b3RhbCcsICdTRUxFQ1RFRCcpO1xuICB9LFxuXG4gIF9vbkNoYW5nZU1heDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1tYXgnLCAnbWF4JywgJ01BWCcpO1xuICB9LFxuXG4gIF9vbkNoYW5nZU1pbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1taW4nLCAnbWluJywgJ01JTicpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUF2ZzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1hdmcnLCAnYXZnJywgJ0FWRycpO1xuICB9LFxuXG4gIF9hZGRUaXRsZUZvclZhbHVlOiBmdW5jdGlvbihjbGFzc05hbWUsIHdoYXQsIHVuaXQpIHtcbiAgICB0aGlzLiQoY2xhc3NOYW1lKS5hdHRyKCd0aXRsZScsIHRoaXMuX2Zvcm1hdE51bWJlcldpdGhDb21tYXModGhpcy52aWV3TW9kZWwuZ2V0KHdoYXQpLnRvRml4ZWQoMikpICsgJyAnICsgdW5pdCk7XG4gIH0sXG5cbiAgX2Zvcm1hdE51bWJlcldpdGhDb21tYXM6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geC50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTtcbiAgfSxcblxuICBfdXBkYXRlU3RhdHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5vcmlnaW5hbERhdGE7XG5cbiAgICBpZiAodGhpcy5faXNab29tZWQoKSkge1xuICAgICAgZGF0YSA9IHRoaXMuem9vbWVkRGF0YTtcbiAgICB9XG5cbiAgICB2YXIgbnVsbHMgPSB0aGlzLm1vZGVsLmdldCgnbnVsbHMnKTtcblxuICAgIHZhciBtaW4sIG1heDtcblxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG5cbiAgICAgIHZhciBsb0JhckluZGV4ID0gdGhpcy52aWV3TW9kZWwuZ2V0KCdsb19pbmRleCcpIHx8IDA7XG4gICAgICB2YXIgaGlCYXJJbmRleCA9IHRoaXMudmlld01vZGVsLmdldCgnaGlfaW5kZXgnKSB8fCBkYXRhLmxlbmd0aDtcblxuICAgICAgdmFyIHN1bSA9IHRoaXMuX2NhbGNTdW0oZGF0YSwgbG9CYXJJbmRleCwgaGlCYXJJbmRleCk7XG4gICAgICB2YXIgYXZnID0gdGhpcy5fY2FsY0F2ZyhkYXRhLCBsb0JhckluZGV4LCBoaUJhckluZGV4KTtcblxuICAgICAgaWYgKGxvQmFySW5kZXggPj0gMCAmJiBsb0JhckluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbWluID0gZGF0YVtsb0JhckluZGV4XS5zdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhpQmFySW5kZXggPj0gMCAmJiBoaUJhckluZGV4IC0gMSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIG1heCA9IGRhdGFbaGlCYXJJbmRleCAtIDFdLmVuZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3TW9kZWwuc2V0KHsgdG90YWw6IHN1bSwgbnVsbHM6IG51bGxzLCBtaW46IG1pbiwgbWF4OiBtYXgsIGF2ZzogYXZnIH0pO1xuICAgIH1cbiAgfSxcblxuICBfY2FsY0F2ZzogZnVuY3Rpb24oZGF0YSwgc3RhcnQsIGVuZCkge1xuXG4gICAgdmFyIHNlbGVjdGVkRGF0YSA9IGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICB2YXIgdG90YWwgPSB0aGlzLl9jYWxjU3VtKGRhdGEsIHN0YXJ0LCBlbmQsIHRvdGFsKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBhcmVhID0gXy5yZWR1Y2Uoc2VsZWN0ZWREYXRhLCBmdW5jdGlvbihtZW1vLCBkKSB7XG4gICAgICByZXR1cm4gKGQuYXZnICYmIGQuZnJlcSkgPyAoZC5hdmcgKiBkLmZyZXEpICsgbWVtbyA6IG1lbW87XG4gICAgfSwgMCk7XG5cbiAgICByZXR1cm4gYXJlYSAvIHRvdGFsO1xuICB9LFxuXG4gIF9jYWxjU3VtOiBmdW5jdGlvbihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCksIGZ1bmN0aW9uKG1lbW8sIGQpIHtcbiAgICAgIHJldHVybiBkLmZyZXEgKyBtZW1vO1xuICAgIH0sIDApO1xuICB9LFxuXG4gIF9vbkNoYW5nZVpvb21lZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmlld01vZGVsLmdldCgnem9vbWVkJykpIHtcbiAgICAgIHRoaXMuX29uWm9vbUluKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29uWm9vbU91dCgpO1xuICAgIH1cbiAgfSxcblxuICBfb25ab29tSW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Nob3dNaW5pUmFuZ2UoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5leHBhbmQoMjApO1xuXG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVtb3ZlU2hhZG93QmFycygpO1xuXG4gICAgdGhpcy5tb2RlbC5zZXQoeyBzdGFydDogbnVsbCwgZW5kOiBudWxsLCBiaW5zOiBudWxsLCBvd25fZmlsdGVyOiAxIH0pO1xuICAgIHRoaXMubW9kZWwuX2ZldGNoKCk7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgfSxcblxuICBfem9vbTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSB0cnVlO1xuICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21lZDogdHJ1ZSwgem9vbV9lbmFibGVkOiBmYWxzZSB9KTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW1vdmVTZWxlY3Rpb24oKTtcbiAgfSxcblxuICBfb25ab29tT3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxvY2tlZEJ5VXNlciAgID0gdHJ1ZTtcbiAgICB0aGlzLmxvY2tab29tZWREYXRhID0gZmFsc2U7XG4gICAgdGhpcy51bnNldHRpbmdSYW5nZSA9IHRydWU7XG5cbiAgICB0aGlzLm1vZGVsLnNldCh7IHN0YXJ0OiB0aGlzLnN0YXJ0LCBlbmQ6IHRoaXMuZW5kLCBiaW5zOiB0aGlzLmJpbnNDb3VudCwgb3duX2ZpbHRlcjogbnVsbCB9KTtcblxuICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21fZW5hYmxlZDogZmFsc2UsIGZpbHRlcl9lbmFibGVkOiBmYWxzZSwgbG9faW5kZXg6IG51bGwsIGhpX2luZGV4OiBudWxsIH0pO1xuXG4gICAgdGhpcy5maWx0ZXIudW5zZXRSYW5nZSgpO1xuXG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuY29udHJhY3QodGhpcy5kZWZhdWx0cy5jaGFydEhlaWdodCk7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVzZXRJbmRleGVzKCk7XG5cbiAgICB0aGlzLm1pbmlIaXN0b2dyYW1DaGFydFZpZXcuaGlkZSgpO1xuICB9LFxuXG4gIF9zaG93TWluaVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgdmFyIGxvQmFySW5kZXggPSB0aGlzLnZpZXdNb2RlbC5nZXQoJ2xvX2luZGV4Jyk7XG4gICAgdmFyIGhpQmFySW5kZXggPSB0aGlzLnZpZXdNb2RlbC5nZXQoJ2hpX2luZGV4Jyk7XG5cbiAgICB0aGlzLm1pbmlIaXN0b2dyYW1DaGFydFZpZXcuc2VsZWN0UmFuZ2UobG9CYXJJbmRleCwgaGlCYXJJbmRleCk7XG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LnNob3coKTtcbiAgfSxcblxuICBfY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LnJlbW92ZVNlbGVjdGlvbigpO1xuICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21lZDogZmFsc2UsIHpvb21fZW5hYmxlZDogZmFsc2UgfSk7XG4gICAgdGhpcy52aWV3TW9kZWwudHJpZ2dlcignY2hhbmdlOnpvb21lZCcpO1xuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyXCI+IDxkaXYgY2xhc3M9XCJqcy10aXRsZVwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aXRsZSBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPC9kaXY+IDwvZGl2PiA8ZGwgY2xhc3M9XCJDREItV2lkZ2V0LWluZm8gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIGpzLW51bGxzXCI+MCBOVUxMIFJPV1M8L2R0PiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIGpzLW1pblwiPjAgTUlOPC9kdD4gPGR0IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvSXRlbSBqcy1hdmdcIj4wIEFWRzwvZHQ+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0ganMtbWF4XCI+MCBNQVg8L2R0PiA8L2RsPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudCBqcy1jb250ZW50XCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRvb2x0aXAganMtdG9vbHRpcFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1maWx0ZXIgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkIGpzLWZpbHRlciBpcy1oaWRkZW5cIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXIganMtdmFsXCI+PC9wPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1maWx0ZXJCdXR0b25zXCI+IDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWxpbmsgQ0RCLVdpZGdldC1maWx0ZXJCdXR0b24ganMtem9vbVwiPnpvb208L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayBDREItV2lkZ2V0LWZpbHRlckJ1dHRvbiBqcy1jbGVhclwiPmNsZWFyPC9idXR0b24+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8aDMgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDM+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LW9wdGlvbnMgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWJ1dHRvbkljb24gQ0RCLVdpZGdldC1idXR0b25JY29uLS1jaXJjbGUganMtc2l6ZXMgJytcbigoX190PSggaXNTaXplc0FwcGxpZWQgPyAnaXMtc2VsZWN0ZWQnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nICcrXG4oKF9fdD0oIGlzU2l6ZXNBcHBsaWVkID8gJ2pzLWNhbmNlbFNpemVzJyA6ICdqcy1hcHBseVNpemVzJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBkYXRhLXRvb2x0aXA9XCInK1xuKChfX3Q9KCBpc1NpemVzQXBwbGllZCA/ICdSZW1vdmUgc2l6ZXMnIDogJ0FwcGx5IHNpemVzJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4gPGkgY2xhc3M9XCJDREItSWNvbiBDREItSWNvbi1zeXJpbmdlIENEQi1JY29uLS10b3BcIj48L2k+IDwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzIGpzLWNvbGxhcHNlXCIgZGF0YS10b29sdGlwPVwiJytcbigoX190PSggaXNDb2xsYXBzZWQgPyAnU2hvdycgOiAnSGlkZScgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzSXRlbVwiPjwvc3Bhbj4gPC9idXR0b24+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFRvb2x0aXBWaWV3ID0gcmVxdWlyZSgnLi4vd2lkZ2V0LXRvb2x0aXAtdmlldycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9oaXN0b2dyYW1fdGl0bGVfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogIFNob3cgdGl0bGUgKyBzaG93IGlmIGhpc3RvZ3JhbSBzaXplcyBhcmUgYXBwbGllZCBvciBub3RcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC10aXRsZSBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQnLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtYXBwbHlTaXplcyc6ICdfYXBwbHlTaXplcycsXG4gICAgJ2NsaWNrIC5qcy1jYW5jZWxTaXplcyc6ICdfY2FuY2VsU2l6ZXMnLFxuICAgICdjbGljayAuanMtY29sbGFwc2UnOiAnX3RvZ2dsZUNvbGxhcHNlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGlzU2l6ZXNBcHBsaWVkOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ2hpc3RvZ3JhbVNpemVzJyksXG4gICAgICAgIGlzQ29sbGFwc2VkOiB0aGlzLmRhdGFNb2RlbC5pc0NvbGxhcHNlZCgpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5faW5pdFZpZXdzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6aGlzdG9ncmFtU2l6ZXMgY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2l6ZXNUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtc2l6ZXMnKVxuICAgIH0pO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoc2l6ZXNUb29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2l6ZXNUb29sdGlwKTtcblxuICAgIHZhciBjb2xsYXBzZVRvb2x0aXAgPSBuZXcgVG9vbHRpcFZpZXcoe1xuICAgICAgdGFyZ2V0OiB0aGlzLiQoJy5qcy1jb2xsYXBzZScpXG4gICAgfSk7XG4gICAgJCgnYm9keScpLmFwcGVuZChjb2xsYXBzZVRvb2x0aXAucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhjb2xsYXBzZVRvb2x0aXApO1xuICB9LFxuXG4gIF9hcHBseVNpemVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5zZXQoJ2hpc3RvZ3JhbVNpemVzJywgdHJ1ZSk7XG4gIH0sXG5cbiAgX2NhbmNlbFNpemVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5zZXQoJ2hpc3RvZ3JhbVNpemVzJywgZmFsc2UpO1xuICB9LFxuXG4gIF90b2dnbGVDb2xsYXBzZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwudG9nZ2xlQ29sbGFwc2VkKCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIFdpZGdldE1vZGVsID0gcmVxdWlyZSgnLi4vd2lkZ2V0X21vZGVsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0TW9kZWwuZXh0ZW5kKHtcblxuICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmdldCgnY29sdW1uVHlwZScpKSB7XG4gICAgICBwYXJhbXMucHVzaCgnY29sdW1uX3R5cGU9JyArIHRoaXMuZ2V0KCdjb2x1bW5UeXBlJykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnc3RhcnQnKSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdzdGFydD0nICsgdGhpcy5nZXQoJ3N0YXJ0JykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnZW5kJykpKSB7XG4gICAgICBwYXJhbXMucHVzaCgnZW5kPScgKyB0aGlzLmdldCgnZW5kJykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnYmlucycpKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2JpbnM9JyArIHRoaXMuZ2V0KCdiaW5zJykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnb3duX2ZpbHRlcicpKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ293bl9maWx0ZXI9JyArIHRoaXMuZ2V0KCdvd25fZmlsdGVyJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXQoJ2JvdW5kaW5nQm94JykgJiYgdGhpcy5nZXQoJ3N1Ym1pdEJCb3gnKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2Jib3g9JyArIHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsID0gdGhpcy5nZXQoJ3VybCcpO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICB1cmwgKz0gJz8nICsgcGFyYW1zLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fZGF0YSA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKHRoaXMuZ2V0KCdkYXRhJykpO1xuXG4gICAgLy8gQkJveCBzaG91bGQgb25seSBiZSBpbmNsdWRlZCB1bnRpbCBhZnRlciB0aGUgZmlyc3QgZmV0Y2gsIHNpbmNlIHdlIHdhbnQgdG8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgZnVsbCBkYXRhc2V0XG4gICAgdGhpcy5vbmNlKCdjaGFuZ2U6ZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQoJ3N1Ym1pdEJCb3gnLCB0cnVlKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMubGF5ZXIuYmluZCgnY2hhbmdlOm1ldGEnLCB0aGlzLl9vbkNoYW5nZUxheWVyTWV0YSwgdGhpcyk7XG4gIH0sXG5cbiAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEudG9KU09OKCk7XG4gIH0sXG5cbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZSgpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIG51bWJlck9mQmlucyA9IGRhdGEuYmluc19jb3VudDtcbiAgICB2YXIgd2lkdGggPSBkYXRhLmJpbl93aWR0aDtcbiAgICB2YXIgbnVsbHMgPSBkYXRhLm51bGxzX2NvdW50O1xuICAgIHZhciBzdGFydCA9IGRhdGEuYmluc19zdGFydDtcblxuICAgIHZhciBidWNrZXRzID0gbmV3IEFycmF5KG51bWJlck9mQmlucyk7XG5cbiAgICBfLmVhY2goZGF0YS5iaW5zLCBmdW5jdGlvbihiKSB7XG4gICAgICBidWNrZXRzW2IuYmluXSA9IGI7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mQmluczsgaSsrKSB7XG4gICAgICBidWNrZXRzW2ldID0gXy5leHRlbmQoe1xuICAgICAgICBiaW46IGksXG4gICAgICAgIHN0YXJ0OiBzdGFydCArIChpICogd2lkdGgpLFxuICAgICAgICBlbmQ6IHN0YXJ0ICsgKChpICsgMSkgKiB3aWR0aCksXG4gICAgICAgIGZyZXE6IDBcbiAgICAgIH0sIGJ1Y2tldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEucmVzZXQoYnVja2V0cyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogYnVja2V0cyxcbiAgICAgIG51bGxzOiBkYXRhLm51bGxzXG4gICAgfTtcbiAgfSxcblxuICAvLyBzZXQgYmlucyBmb3IgdGhlIGhpc3RvZ3JhbXNcbiAgLy8gQGJpbnMgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdGhlIGZvcm1hdCBbeyBzdGFydDogLi4uLCBlbmQ6IC4uLiwgZnJlcTogLi4uLCBtaW46IC4uLiwgbWF4OiAgIH0sIC4uLl1cbiAgLy8gICAgLSBzdGFydCwgZW5kOiBhcmUgdGhlIGJ1Y2tldCBib3VuZHNcbiAgLy8gICAgLSBtaW4sIG1heDogdGhlIG1pbiBhbmQgdGhlIG1heCB2YWx1ZSBmb3IgYWxsIHRoZSBwb2ludHMgaW4gdGhhdCBidWNrZXRcbiAgLy8gICAgLSBmcmVxOiBjb3VudFxuICBzZXRCaW5zOiBmdW5jdGlvbihiaW5zLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fZGF0YS5yZXNldChiaW5zLCBvcHRpb25zKTtcbiAgICB0aGlzLnNldCgnZGF0YScsIHsgYmluczogYmlucyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaXN0b2dyYW1cIixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29sdW1uOiB0aGlzLmdldCgnY29sdW1uJyksXG4gICAgICAgIGJpbnM6IHRoaXMuZ2V0KCdiaW5zJylcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIF9vbkNoYW5nZUxheWVyTWV0YTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXIuc2V0KCdjb2x1bW5UeXBlJywgdGhpcy5sYXllci5nZXQoJ21ldGEnKS5jb2x1bW5fdHlwZSk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlQmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5fb25DaGFuZ2VCaW5kcy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOmhpc3RvZ3JhbVNpemVzJywgZnVuY3Rpb24obWRsLCBpc1NpemVzQXBwbGllZCwgZCkge1xuICAgICAgaWYgKGlzU2l6ZXNBcHBsaWVkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignaGlzdG9ncmFtU2l6ZXMnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jzx1bCBjbGFzcz1cIkNEQi1XaWRnZXQtY2hhcnQgQ0RCLVdpZGdldC1jaGFydC0tZmFrZVwiPiAnO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykgeyBcbl9fcCs9JyA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWNoYXJ0SXRlbSBDREItV2lkZ2V0LWNoYXJ0SXRlbS0tJytcbigoX190PSggXy5zYW1wbGUoWydzbWFsbCcsICdtZWRpdW0nLCAnYmlnJ10sIDEpWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBXaWRnZXQtY2hhcnRJdGVtLS1mYWtlXCI+PC9saT4gJztcbiB9IFxuX19wKz0nIDwvdWw+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxoMyBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiIHRpdGxlPVwiJytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPC9kaXY+IDxkbCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb1wiPiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4nK1xuKChfX3Q9KCBpdGVtc0NvdW50ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyByb3dzPC9kdD4gPC9kbD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS1ub1NpZGVzTWFyZ2luXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RXcmFwcGVyIGpzLWNvbnRlbnRcIj48L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWZvb3RlciBqcy1mb290ZXJcIj48L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdCA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBXaWRnZXRDb250ZW50VmlldyA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBXaWRnZXRMaXN0SXRlbXNWaWV3ID0gcmVxdWlyZSgnLi9pdGVtc192aWV3Jyk7XG52YXIgV2lkZ2V0TGlzdFBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgV2lkZ2V0TGlzdEVkZ2VzVmlldyA9IHJlcXVpcmUoJy4vZWRnZXNfdmlldycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9jb250ZW50X3RlbXBsYXRlLnRwbCcpO1xudmFyIHRlbXBsYXRlUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL3BsYWNlaG9sZGVyX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IGNvbnRlbnQgdmlldzpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRDb250ZW50Vmlldy5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBzaG93U2Nyb2xsOiBmYWxzZVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgaXNEYXRhRW1wdHkgPSBfLmlzRW1wdHkoZGF0YSkgfHwgXy5zaXplKGRhdGEpID09PSAwO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLm1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgaXRlbXNDb3VudDogIWlzRGF0YUVtcHR5ID8gZm9ybWF0LmZvcm1hdFZhbHVlKGRhdGEubGVuZ3RoKSA6ICctJ1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKGlzRGF0YUVtcHR5KSB7XG4gICAgICB0aGlzLl9hZGRQbGFjZWhvbGRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSB0aGlzLm1vZGVsLmdldFNpemUoKTtcblxuICAgIC8vIExpc3QgdmlldyAtPiBpdGVtcyB2aWV3XG4gICAgdGhpcy5fbGlzdCA9IG5ldyBXaWRnZXRMaXN0SXRlbXNWaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmh0bWwodGhpcy5fbGlzdC5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHRoaXMuX2xpc3QpO1xuXG4gICAgdmFyIGlzU2Nyb2xsTGlzdCA9ICh0aGlzLl9saXN0LiRlbC5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fbGlzdC4kZWwub3V0ZXJIZWlnaHQoKSkgPiAwO1xuXG4gICAgaWYgKGlzU2Nyb2xsTGlzdCB8fMKgdGhpcy5vcHRpb25zLnNob3dTY3JvbGwpIHtcbiAgICAgIC8vIFBhZ2luYXRvclxuICAgICAgdGhpcy5fcGFnaW5hdGlvbiA9IG5ldyBXaWRnZXRMaXN0UGFnaW5hdG9yVmlldyh7XG4gICAgICAgICR0YXJnZXQ6IHRoaXMuX2xpc3QuJGVsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJCgnLmpzLWZvb3RlcicpLmFwcGVuZCh0aGlzLl9wYWdpbmF0aW9uLnJlbmRlcigpLmVsKTtcbiAgICAgIHRoaXMuYWRkVmlldyh0aGlzLl9wYWdpbmF0aW9uKTtcblxuICAgICAgLy8gRWRnZXNcbiAgICAgIHRoaXMuX2VkZ2VzID0gbmV3IFdpZGdldExpc3RFZGdlc1ZpZXcoe1xuICAgICAgICAkdGFyZ2V0OiB0aGlzLl9saXN0LiRlbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHRoaXMuX2VkZ2VzLnJlbmRlcigpLmVsKTtcbiAgICAgIHRoaXMuYWRkVmlldyh0aGlzLl9lZGdlcyk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcblxuLyoqXG4gKiAgTGlzdCBlZGdlcyB2aWV3OlxuICpcbiAqICAtIEl0IHNob3dzIHRoZSBib3JkZXJzIGFuZCB0aGUgc2hhZG93cywgaWYgbmVlZGVkLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBfVEVNUExBVEU6ICcgJyArXG4gICAgJzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RFZGdlIENEQi1XaWRnZXQtbGlzdEVkZ2UtLXRvcFwiPicrXG4gICAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEVkZ2VTaGFkb3cganMtdG9wU2hhZG93XCI+PC9kaXY+JytcbiAgICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0RWRnZUJvcmRlclwiPjwvZGl2PicrXG4gICAgJzwvZGl2PicrXG4gICAgJzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RFZGdlIENEQi1XaWRnZXQtbGlzdEVkZ2UtLWJvdHRvbVwiPicrXG4gICAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEVkZ2VTaGFkb3cganMtYm90dG9tU2hhZG93XCI+PC9kaXY+JytcbiAgICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0RWRnZUJvcmRlclwiPjwvZGl2PicrXG4gICAgJzwvZGl2PicsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fJHRhcmdldCA9IHRoaXMub3B0aW9ucy4kdGFyZ2V0O1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZSh0aGlzLl9URU1QTEFURSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl8kdGFyZ2V0LmJpbmQoJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fY2hlY2tTY3JvbGwoKTtcbiAgICB9KTtcbiAgfSxcblxuICBfdW5iaW5kU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0LnVuYmluZCgnc2Nyb2xsJyk7XG4gIH0sXG5cbiAgX2NoZWNrU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudFNjcm9sbCA9IHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKCk7XG4gICAgdmFyIG1heFNjcm9sbCA9IHRoaXMuXyR0YXJnZXQuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHRoaXMuXyR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcbiAgICB0aGlzLiQoJy5qcy10b3BTaGFkb3cnKS50b2dnbGUoY3VycmVudFNjcm9sbCAhPT0gMCk7XG4gICAgdGhpcy4kKCcuanMtYm90dG9tU2hhZG93JykudG9nZ2xlKGN1cnJlbnRTY3JvbGwgIT09IG1heFNjcm9sbCk7XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VuYmluZFNjcm9sbCgpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jyc7XG4gaWYgKGlzQ2xpY2thYmxlKSB7IFxuX19wKz0nIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0SXRlbUlubmVyIENEQi1XaWRnZXQtbGlzdEJ1dHRvbiBDREItV2lkZ2V0LWxpc3RCdXR0b24tLXdpdGhCb3JkZXIganMtYnV0dG9uXCI+ICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciBDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXItLXdpdGhCb3JkZXJzXCI+ICc7XG4gfSBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkIENEQi1XaWRnZXQtY29udGVudFNwYWNlZC0tdG9wQWxpZ25lZCBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQtLXN0YXJ0XCI+IDxlbSBjbGFzcz1cIkNEQi1TaGFwZS1kb3QgQ0RCLVdpZGdldC1saXN0RG90XCI+PC9lbT4gJztcbiBpZiAoaXRlbXNDb3VudCA+IDApIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudEZ1bGxcIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCBDREItV2lkZ2V0LXRleHRTbWFsbC0tdXBwZXIgQ0RCLVdpZGdldC10ZXh0U21hbGwtLWJvbGRcIiB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zWzBdWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zWzBdWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gJztcbiBpZiAoaXRlbXNDb3VudCA+IDIpIHsgXG5fX3ArPScgPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmxpbmVMaXN0XCI+ICc7XG4gZm9yICh2YXIgaSA9IDEsIGwgPSBpdGVtc0NvdW50OyBpIDwgbDsgaSsrKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWlubGluZUxpc3RJdGVtIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tbm9FbGxpcFwiPiA8ZGQgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWRhcmsgdS1yU3BhY2VcIiB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zW2ldWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zW2ldWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZGQ+IDxkdCB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zW2ldWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zW2ldWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZHQ+IDwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kbD4gJztcbiB9IGVsc2UgaWYgKGl0ZW1zQ291bnQgPT09IDIpIHsgXG5fX3ArPScgPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ub0VsbGlwIHUtdFNwYWNlXCI+IDxkZCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tZGFyayB1LXJTcGFjZVwiIHRpdGxlPVwiJytcbigoX190PSggaXRlbXNbMV1bMV0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggaXRlbXNbMV1bMV0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9kZD4gPGR0IHRpdGxlPVwiJytcbigoX190PSggaXRlbXNbMV1bMF0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggaXRlbXNbMV1bMF0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9kdD4gPC9kbD4gJztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kaXY+ICc7XG4gaWYgKGlzQ2xpY2thYmxlKSB7IFxuX19wKz0nIDwvZGl2PjwvYnV0dG9uPiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nICAnO1xuIH0gXG5fX3ArPScnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdCA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaXRlbV90ZW1wbGF0ZS50cGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgdGFnTmFtZTogJ2xpJyxcbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0SXRlbScsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1idXR0b24nOiAnX29uSXRlbUNsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC50b0pTT04oKTtcbiAgICB2YXIgaGFzSW50ZXJhY3Rpdml0eSA9IHRoaXMuX2hhc0ludGVyYWN0aXZpdHkoZGF0YSk7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fc2FuaXRpemVEYXRhKGRhdGEpO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICBpc0NsaWNrYWJsZTogaGFzSW50ZXJhY3Rpdml0eSxcbiAgICAgICAgaXRlbXNDb3VudDogXy5zaXplKGl0ZW1zKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY2FydG9kYl9pZCBkZWZpbmVkLCBjbGljayBldmVudCBzaG91bGRcbiAgICAvLyBiZSBkaXNhYmxlZFxuICAgIHRoaXNbIGhhc0ludGVyYWN0aXZpdHkgPyAnZGVsZWdhdGVFdmVudHMnIDogJ3VuZGVsZWdhdGVFdmVudHMnIF0oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBSZW1vdmUgY2FydG9kYl9pZCwgaWYgZXhpc3RzXG4gIC8vIFJlcGxhY2UgdGl0bGVzIGlmIHRoZXJlIGFyZSBhbHRlcm5hdGl2ZXNcbiAgLy8gQ29udmVydCBkYXRhIG9iamVjdCB0byBhcnJheSBpdGVtc1xuICBfc2FuaXRpemVEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGhhc0ludGVyYWN0aXZpdHkgPSB0aGlzLl9oYXNJbnRlcmFjdGl2aXR5KGRhdGEpO1xuICAgIHZhciBkYXRhID0gXy5vbWl0KGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGtleSA9PT0gJ2NhcnRvZGJfaWQnO1xuICAgIH0pO1xuXG4gICAgdmFyIGNvbHVtblRpdGxlcyA9IHRoaXMudmlld01vZGVsLmdldCgnY29sdW1uc190aXRsZScpO1xuICAgIGlmIChoYXNJbnRlcmFjdGl2aXR5ICYmICFfLmlzRW1wdHkoY29sdW1uVGl0bGVzKSkge1xuICAgICAgY29sdW1uVGl0bGVzID0gXy5yZXN0KGNvbHVtblRpdGxlcywgMSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0byBwYWlyIGl0ZW1zIGFuZCBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbHVtbiB0aXRsZVxuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgdmFyIHRpdGxlID0gY29sdW1uVGl0bGVzICYmIGNvbHVtblRpdGxlc1tpXSB8fCBrZXk7XG4gICAgICBhcnIucHVzaChbIHRpdGxlLCBmb3JtYXQuZm9ybWF0VmFsdWUodmFsdWUpIF0pO1xuICAgICAgKytpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcblxuICBfaGFzSW50ZXJhY3Rpdml0eTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiAhXy5pc0VtcHR5KFxuICAgICAgXy5maWx0ZXIoZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSl7XG4gICAgICAgIHJldHVybiBrZXkgPT09ICdjYXJ0b2RiX2lkJ1xuICAgICAgfSlcbiAgICApXG4gIH0sXG5cbiAgX29uSXRlbUNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2l0ZW1DbGlja2VkJywgdGhpcy5tb2RlbCwgdGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgV2lkZ2V0TGlzdEl0ZW1WaWV3ID0gcmVxdWlyZSgnLi9pdGVtX3ZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0IGpzLWxpc3QnLFxuICB0YWdOYW1lOiAndWwnLFxuXG4gIGV2ZW50czoge1xuICAgICdzY3JvbGwnOiAnX2NoZWNrU2Nyb2xsJ1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmdldERhdGEoKS5lYWNoKHRoaXMuX2FkZEl0ZW0sIHRoaXMpO1xuICB9LFxuXG4gIF9hZGRJdGVtOiBmdW5jdGlvbihtZGwpIHtcbiAgICB2YXIgdiA9IG5ldyBXaWRnZXRMaXN0SXRlbVZpZXcoe1xuICAgICAgbW9kZWw6IG1kbCxcbiAgICAgIHZpZXdNb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHYuYmluZCgnaXRlbUNsaWNrZWQnLCBmdW5jdGlvbigpe1xuICAgICAgdGhpcy50cmlnZ2VyKCdpdGVtQ2xpY2tlZCcsIG1kbCwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5hZGRWaWV3KHYpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh2LnJlbmRlcigpLmVsKTtcbiAgfVxuXG59KTtcbiIsInZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBXaWRnZXRNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9tb2RlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldE1vZGVsLmV4dGVuZCh7XG5cbiAgb3B0aW9uczoge1xuICAgIHBhZ2U6IDAsXG4gICAgcGVyX3BhZ2U6IDEwMFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgdGhpcy5fZGF0YSA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKHRoaXMuZ2V0KCdkYXRhJykpO1xuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdHMpO1xuICB9LFxuXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9LFxuXG4gIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNpemUoKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciByb3dzID0gZGF0YS5yb3dzO1xuICAgIHRoaXMuX2RhdGEucmVzZXQocm93cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHJvd3NcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2x1bW5zOiB0aGlzLmdldCgnY29sdW1ucycpXG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LW5hdiBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQnLFxuXG4gIF9URU1QTEFURTogJyAnICtcbiAgICAnPHNwYW4+PC9zcGFuPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1uYXZBcnJvd3MgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+JytcbiAgICAgICc8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLWFycm93IENEQi1TaGFwZS1hcnJvdy0tdXAganMtdXBcIj48L2J1dHRvbj4nK1xuICAgICAgJzxidXR0b24gY2xhc3M9XCJDREItU2hhcGUtYXJyb3cgQ0RCLVNoYXBlLWFycm93LS1kb3duIGpzLWRvd25cIj48L2J1dHRvbj4nK1xuICAgICc8L2Rpdj4nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtdXAnOiAnX3Njcm9sbFVwJyxcbiAgICAnY2xpY2sgLmpzLWRvd24nOiAnX3Njcm9sbERvd24nXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuJHRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgc2hvdWxkIGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBwYWdpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLl8kdGFyZ2V0ID0gdGhpcy5vcHRpb25zLiR0YXJnZXQ7XG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fJHRhcmdldC5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fJHRhcmdldC5vdXRlckhlaWdodCgpO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZSh0aGlzLl9URU1QTEFURSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl8kdGFyZ2V0LmJpbmQoJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fY2hlY2tTY3JvbGwoKTtcbiAgICB9KTtcbiAgfSxcblxuICBfdW5iaW5kU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0LnVuYmluZCgnc2Nyb2xsJyk7XG4gIH0sXG5cbiAgX2NoZWNrU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudFNjcm9sbCA9IHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKCk7XG4gICAgdGhpcy4kKCcuanMtdXAnKS50b2dnbGVDbGFzcygnaXMtZGlzYWJsZWQnLCBjdXJyZW50U2Nyb2xsID09PSAwKTtcbiAgICB0aGlzLiQoJy5qcy1kb3duJykudG9nZ2xlQ2xhc3MoJ2lzLWRpc2FibGVkJywgY3VycmVudFNjcm9sbCA+PSB0aGlzLl9zY3JvbGxIZWlnaHQpO1xuICB9LFxuXG4gIF9nZXRFZGdlVmlzaWJsZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYUhlaWdodCA9IHRoaXMuXyR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgZmlyc3RFbCA9IG51bGw7XG4gICAgdmFyIGxhc3RFbCA9IG51bGw7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fJHRhcmdldC5jaGlsZHJlbignLkNEQi1XaWRnZXQtbGlzdEl0ZW0nKTtcblxuICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgdG9wID0gJCh0aGlzKS5wb3NpdGlvbigpLnRvcDtcbiAgICAgIHZhciBoZWlnaHQgPSAkKHRoaXMpLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIGlmICh0b3AgPiAtMSAmJiBmaXJzdEVsID09PSBudWxsKXsgLy9maXJzdCBlbnRpcmVseSB2aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgZmlyc3RFbCA9IHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKCh0b3AgKyBoZWlnaHQpID4gYXJlYUhlaWdodCAmJiBsYXN0RWwgPT09IG51bGwpe1xuICAgICAgICBsYXN0RWwgPSBpdGVtc1tpbmRleC0xXTsvL3RoZSBsYXN0IGVudGlyZWx5IHZpc2libGUgd2FzIHRoZSBlbGVtZW50IGJlZm9yZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtmaXJzdEVsLGxhc3RFbF07XG4gIH0sXG5cbiAgX3Njcm9sbERvd246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0VmlzaWJsZUl0ZW0gPSB0aGlzLl9nZXRFZGdlVmlzaWJsZUl0ZW1zKClbMV07XG4gICAgdmFyIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcCgpO1xuICAgIHZhciAkbmV4dCA9ICQobGFzdFZpc2libGVJdGVtKS5uZXh0KCk7XG4gICAgaWYgKCRuZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIHRvcCA9ICRuZXh0LnBvc2l0aW9uKCkudG9wO1xuICAgICAgdmFyIGhlaWdodCA9ICRuZXh0Lm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gdG9wICsgaGVpZ2h0IC0gdGhpcy5fJHRhcmdldC5vdXRlckhlaWdodCgpICsgY3VycmVudFNjcm9sbDtcbiAgICAgIGlmIChzY3JvbGxQb3MgPiAwKSB7XG4gICAgICAgIHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKHNjcm9sbFBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9zY3JvbGxVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpcnN0VmlzaWJsZUl0ZW0gPSB0aGlzLl9nZXRFZGdlVmlzaWJsZUl0ZW1zKClbMF07XG4gICAgdmFyIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcCgpO1xuICAgIHZhciAkcHJldiA9ICQoZmlyc3RWaXNpYmxlSXRlbSkucHJldigpO1xuICAgIGlmICgkcHJldi5sZW5ndGgpIHtcbiAgICAgIHZhciB0b3AgPSAkcHJldi5wb3NpdGlvbigpLnRvcDtcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjdXJyZW50U2Nyb2xsICsgdG9wO1xuICAgICAgdGhpcy5fJHRhcmdldC5zY3JvbGxUb3Aoc2Nyb2xsUG9zKTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VuYmluZFNjcm9sbCgpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jzx1bCBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdCBDREItV2lkZ2V0LWxpc3QtLXdpdGhCb3JkZXJzXCI+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDwvdWw+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gzPiA8L2Rpdj4gPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvXCI+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIGl0ZW1zQ291bnQgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIGl0ZW1zPC9kdD4gPC9kbD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQganMtY29udGVudFwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIGxvZyA9IGNkYi5sb2c7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgZDMgPSBjZGIuZDM7XG52YXIgY29udGVudFRlbXBsYXRlID0gcmVxdWlyZSgnLi93aWRnZXRfY29udGVudF90ZW1wbGF0ZS50cGwnKTtcbnZhciBwbGFjZWhvbGRlclRlbXBsYXRlID0gcmVxdWlyZSgnLi93aWRnZXRfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogRGVmYXVsdCB3aWRnZXQgY29udGVudCB2aWV3OlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWJvZHknLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgY29udGVudFRlbXBsYXRlKHtcbiAgICAgICAgdGl0bGU6IHRoaXMubW9kZWwuZ2V0KCd0aXRsZScpLFxuICAgICAgICBpdGVtc0NvdW50OiAhaXNEYXRhRW1wdHkgPyBkYXRhLmxlbmd0aCA6ICctJ1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKGlzRGF0YUVtcHR5KSB7XG4gICAgICB0aGlzLl9hZGRQbGFjZWhvbGRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmRhdGEnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gIH0sXG5cbiAgX2FkZFBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAocGxhY2Vob2xkZXJUZW1wbGF0ZSkge1xuICAgICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZChwbGFjZWhvbGRlclRlbXBsYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbygnUGxhY2Vob2xkZXIgdGVtcGxhdGUgZG9lc25cXCd0IGV4aXN0Jyk7XG4gICAgfVxuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtYnV0dG9uIENEQi1XaWRnZXQtZXJyb3JCdXR0b24ganMtcmVmcmVzaFwiPiA8c3BhbiBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIENEQi1XaWRnZXQtdGV4dFNtYWxsLS1ib2xkXCI+UkVGUkVTSDwvc3Bhbj4gPC9idXR0b24+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vd2lkZ2V0X2Vycm9yX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqICBEZWZhdWx0IHdpZGdldCBlcnJvciB2aWV3OlxuICpcbiAqICBJdCB3aWxsIGxpc3RlbiBvciBub3QgdG8gZGF0YU1vZGVsIGNoYW5nZXMgd2hlblxuICogIGZpcnN0IGxvYWQgaXMgZG9uZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1lcnJvciBpcy1oaWRkZW4nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtcmVmcmVzaCc6ICdfb25SZWZyZXNoQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnZXJyb3InLCB0aGlzLnNob3csIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnbG9hZGluZycsIHRoaXMuaGlkZSwgdGhpcyk7XG4gIH0sXG5cbiAgX29uUmVmcmVzaENsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnJlZnJlc2goKTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnaXMtaGlkZGVuJyk7XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICB9XG5cbn0pO1xuIiwidmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG4vKipcbiAqICBEZWZhdWx0IHdpZGdldCBsb2FkZXIgdmlldzpcbiAqXG4gKiAgSXQgd2lsbCBsaXN0ZW4gb3Igbm90IHRvIGRhdGFNb2RlbCBjaGFuZ2VzIHdoZW5cbiAqICBmaXJzdCBsb2FkIGlzIGRvbmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbG9hZGVyJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2xvYWRpbmcnLCB0aGlzLnNob3csIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnc3luYyBlcnJvcicsIHRoaXMuaGlkZSwgdGhpcyk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuJGVsLnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XG4gICAgfSwgNTAwKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPHVsIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0IENEQi1XaWRnZXQtbGlzdC0td2l0aEJvcmRlcnNcIj4gPGxpIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0SXRlbSBDREItV2lkZ2V0LWxpc3RJdGVtLS13aXRoQm9yZGVycyBDREItV2lkZ2V0LWxpc3RJdGVtLS1mYWtlXCI+PC9saT4gPC91bD4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIHBsYWNlaG9sZGVyVGVtcGxhdGUgPSByZXF1aXJlKCcuL3BsYWNlaG9sZGVyLnRwbCcpO1xudmFyIEhpc3RvZ3JhbVZpZXcgPSByZXF1aXJlKCcuL2hpc3RvZ3JhbS12aWV3Jyk7XG5cbi8qKlxuICogV2lkZ2V0IGNvbnRlbnQgdmlldyBmb3IgYSB0aW1lLXNlcmllc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWJvZHkgQ0RCLVdpZGdldC1ib2R5LS10aW1lU2VyaWVzJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25GaXJzdExvYWQsIHRoaXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuaHRtbCgnJyk7IC8vIHRvIHJlbW92ZSBwbGFjZWhvbGRlciBpZiB0aGVyZSBpcyBhbnlcblxuICAgIGlmICh0aGlzLl9pc0RhdGFFbXB0eSgpKSB7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQocGxhY2Vob2xkZXJUZW1wbGF0ZSh7XG4gICAgICAgIGhhc1RvcnF1ZUxheWVyOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcHBlbmRWaWV3KG5ldyBIaXN0b2dyYW1WaWV3KHRoaXMub3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9vbkZpcnN0TG9hZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc3RvcmVCb3VuZHMoKTtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuX2ZldGNoKCk7XG4gIH0sXG5cbiAgX3N0b3JlQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHN0YXJ0ID0gZGF0YVswXS5zdGFydDtcbiAgICAgIHZhciBlbmQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZW5kO1xuICAgICAgdGhpcy5tb2RlbC5zZXQoeyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBiaW5zOiBkYXRhLmxlbmd0aCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgX2FwcGVuZFZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuICB9LFxuXG4gIF9pc0RhdGFFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICByZXR1cm4gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIEhpc3RvZ3JhbUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4uL2hpc3RvZ3JhbS9jaGFydCcpO1xuXG4vKipcbiAqIFRpbWUtc2VyaWVzIGhpc3RvZ3JhbSB2aWV3LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS10aW1lU2VyaWVzJyxcblxuICBkZWZhdWx0czoge1xuICAgIG1vYmlsZVRocmVzaG9sZDogOTYwLCAvLyBweDsgc2hvdWxkIG1hdGNoIENTUyBtZWRpYS1xdWVyeVxuICAgIGhpc3RvZ3JhbUNoYXJ0SGVpZ2h0OlxuICAgICAgNDggKyAvLyBpbmxpbmUgYmFycyBoZWlnaHRcbiAgICAgIDQgKyAvLyBib3R0b20gbWFyZ2luXG4gICAgICAxNiArIC8vIGxhYmVsc1xuICAgICAgNCwgLy8gbWFyZ2luc1xuICAgIGhpc3RvZ3JhbUNoYXJ0TW9iaWxlSGVpZ2h0OlxuICAgICAgMjAgKyAvLyBpbmxpbmUgYmFycyBoZWlnaHQgKG5vIGJvdHRvbSBsYWJlbHMpXG4gICAgICA0IC8vIG1hcmdpbnNcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG5cbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25DaGFuZ2VEYXRhLCB0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuX2NyZWF0ZUhpc3RvZ3JhbVZpZXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfY3JlYXRlSGlzdG9ncmFtVmlldzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhcnRWaWV3ID0gbmV3IEhpc3RvZ3JhbUNoYXJ0Vmlldyh7XG4gICAgICB0eXBlOiAndGltZScsXG4gICAgICBhbmltYXRpb25TcGVlZDogMTAwLFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgcmlnaHQ6IDQsXG4gICAgICAgIGJvdHRvbTogNCxcbiAgICAgICAgbGVmdDogNFxuICAgICAgfSxcbiAgICAgIGhhc0hhbmRsZXM6IHRydWUsXG4gICAgICBhbmltYXRpb25CYXJEZWxheTogZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gKGkgKiAzKTtcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHRoaXMuZGVmYXVsdHMuaGlzdG9ncmFtQ2hhcnRIZWlnaHQsXG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLmdldERhdGEoKVxuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLl9jaGFydFZpZXcpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9jaGFydFZpZXcucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5zaG93KCk7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcuYmluZCgnb25fYnJ1c2hfZW5kJywgdGhpcy5fb25CcnVzaEVuZCwgdGhpcyk7XG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTp3aWR0aCcsIHRoaXMuX29uQ2hhbmdlQ2hhcnRXaWR0aCwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLl9jaGFydFZpZXcubW9kZWwpO1xuICB9LFxuXG4gIF9vbkNoYW5nZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jaGFydFZpZXcpIHtcbiAgICAgIHRoaXMuX2NoYXJ0Vmlldy5yZXBsYWNlRGF0YSh0aGlzLm1vZGVsLmdldERhdGEoKSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkJydXNoRW5kOiBmdW5jdGlvbihsb0JhckluZGV4LCBoaUJhckluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICB0aGlzLmZpbHRlci5zZXRSYW5nZShcbiAgICAgIGRhdGFbbG9CYXJJbmRleF0uc3RhcnQsXG4gICAgICBkYXRhW2hpQmFySW5kZXggLSAxXS5lbmRcbiAgICApO1xuICB9LFxuXG4gIF9vbkNoYW5nZUNoYXJ0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc01vYmlsZVNpemUgPSAkKHdpbmRvdykud2lkdGgoKSA8IHRoaXMuZGVmYXVsdHMubW9iaWxlVGhyZXNob2xkO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3LnRvZ2dsZUxhYmVscyghaXNNb2JpbGVTaXplKTtcblxuICAgIHZhciBoZWlnaHQgPSBpc01vYmlsZVNpemVcbiAgICAgID8gdGhpcy5kZWZhdWx0cy5oaXN0b2dyYW1DaGFydE1vYmlsZUhlaWdodFxuICAgICAgOiB0aGlzLmRlZmF1bHRzLmhpc3RvZ3JhbUNoYXJ0SGVpZ2h0O1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5tb2RlbC5zZXQoJ2hlaWdodCcsIGhlaWdodCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWhlYWRlciBDREItV2lkZ2V0LWhlYWRlci0tdGltZVNlcmllc1wiPiAnO1xuIGlmIChoYXNUb3JxdWVMYXllcikgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aW1lU2VyaWVzRmFrZUNvbnRyb2xcIj48L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGltZVNlcmllc1RpbWVJbmZvIENEQi1XaWRnZXQtdGltZVNlcmllc1RpbWVJbmZvLS1mYWtlXCI+PC9kaXY+ICc7XG4gfSBcbl9fcCs9JyA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudCBDREItV2lkZ2V0LWNvbnRlbnQtLXRpbWVTZXJpZXNcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGltZVNlcmllc0Zha2VDaGFydCAnO1xuIGlmIChoYXNUb3JxdWVMYXllcikgeyBcbl9fcCs9J0NEQi1XaWRnZXQtdGltZVNlcmllc0Zha2VDaGFydC0tdG9ycXVlJztcbiB9IFxuX19wKz0nXCI+ICc7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgaSsrKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpbWVTZXJpZXNGYWtlQ2hhcnRJdGVtXCIgc3R5bGU9XCJoZWlnaHQ6ICcrXG4oKF9fdD0oIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJVwiPjwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kaXY+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdG9ycXVlVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS10ZW1wbGF0ZS50cGwnKTtcbnZhciBwbGFjZWhvbGRlclRlbXBsYXRlID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlci50cGwnKTtcbnZhciBUb3JxdWVDb250cm9sc1ZpZXcgPSByZXF1aXJlKCcuL3RvcnF1ZS1jb250cm9scy12aWV3Jyk7XG52YXIgVG9ycXVlVGltZUluZm9WaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtdGltZS1pbmZvLXZpZXcnKTtcbnZhciBUb3JxdWVIaXN0b2dyYW1WaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtaGlzdG9ncmFtLXZpZXcnKTtcblxuLyoqXG4gKiBXaWRnZXQgY29udGVudCB2aWV3IGZvciBhIFRvcnF1ZSB0aW1lLXNlcmllc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWJvZHkgQ0RCLVdpZGdldC1ib2R5LS10aW1lU2VyaWVzJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG5cbiAgICBpZiAodGhpcy5faXNEYXRhRW1wdHkoKSkge1xuICAgICAgdGhpcy4kZWwuaHRtbChwbGFjZWhvbGRlclRlbXBsYXRlKHtcbiAgICAgICAgaGFzVG9ycXVlTGF5ZXI6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyQ29udGVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZW5kZXJDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRvcnF1ZVRlbXBsYXRlKCkpO1xuICAgIHRoaXMuX2FwcGVuZFZpZXcoXG4gICAgICBuZXcgVG9ycXVlQ29udHJvbHNWaWV3KHsgbW9kZWw6IHRoaXMub3B0aW9ucy50b3JxdWVMYXllck1vZGVsIH0pLFxuICAgICAgJy5qcy1oZWFkZXInXG4gICAgKTtcbiAgICB0aGlzLl9hcHBlbmRWaWV3KFxuICAgICAgbmV3IFRvcnF1ZVRpbWVJbmZvVmlldyh7IG1vZGVsOiB0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbCB9KSxcbiAgICAgICcuanMtaGVhZGVyJ1xuICAgICk7XG4gICAgdGhpcy5fYXBwZW5kVmlldyhuZXcgVG9ycXVlSGlzdG9ncmFtVmlldyh0aGlzLm9wdGlvbnMpKTtcbiAgfSxcblxuICBfYXBwZW5kVmlldzogZnVuY3Rpb24odmlldywgc2VsZWN0b3IpIHtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB0aGlzLiQoc2VsZWN0b3IpLmFwcGVuZCh2aWV3LmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcuZWwpO1xuICAgIH1cbiAgICB2aWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIF9pc0RhdGFFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICByZXR1cm4gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgfVxufSk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS1jb250cm9scy50cGwnKTtcblxuLyoqXG4gKiBUb3JxdWUgYW5pbWF0aW9uIGNvbnRyb2xzLCB0byBtYW5hZ2UgcnVuIHN0YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIHRhZ05hbWU6ICdidXR0b24nLFxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWNvbnRyb2xCdXR0b24nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayc6ICdfb25DbGljaydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTppc1J1bm5pbmcnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICBpY29uQ2xhc3M6ICdDREItV2lkZ2V0LWNvbnRyb2xCdXR0b24taWNvbiBDREItV2lkZ2V0LWNvbnRyb2xCdXR0b24taWNvbi0tJyArIChcbiAgICAgICAgICB0aGlzLm1vZGVsLmdldCgnaXNSdW5uaW5nJylcbiAgICAgICAgICAgID8gJ3BhdXNlJ1xuICAgICAgICAgICAgOiAncGxheScpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdpc1J1bm5pbmcnKSkge1xuICAgICAgdGhpcy5tb2RlbC5wYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vZGVsLnBsYXkoKTtcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250cm9sQnV0dG9uLWNvbnRlbnRcIj4gPGkgY2xhc3M9XCInK1xuKChfX3Q9KCBpY29uQ2xhc3MgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9pPiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIEhpc3RvZ3JhbUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4uL2hpc3RvZ3JhbS9jaGFydCcpO1xudmFyIFRvcnF1ZVRpbWVTbGlkZXJWaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtdGltZS1zbGlkZXItdmlldycpO1xuXG4vKipcbiAqIFRvcnF1ZSB0aW1lLXNlcmllcyBoaXN0b2dyYW0gdmlldy5cbiAqIEV4dGVuZHMgdGhlIGNvbW1vbiBoaXN0b2dyYW0gY2hhcnQgdmlldyB3aXRoIHRpbWUtY29udHJvbFxuICogdGhpcy5tb2RlbCBpcyBhIGhpc3RvZ3JhbSBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS10aW1lU2VyaWVzJyxcblxuICAvLyBUT0RPIGNvdWxkIGJlIGNhbGN1bGF0ZWQgZnJvbSBlbGVtZW50IHN0eWxlcyBpbnN0ZWFkIG9mIGR1cGxpY2F0ZWQgbnVtYmVycyBoZXJlP1xuICBkZWZhdWx0czoge1xuICAgIG1vYmlsZVRocmVzaG9sZDogOTYwLCAvLyBweDsgc2hvdWxkIG1hdGNoIENTUyBtZWRpYS1xdWVyeVxuICAgIGhpc3RvZ3JhbUNoYXJ0SGVpZ2h0OlxuICAgICAgNDggKyAvLyBpbmxpbmUgYmFycyBoZWlnaHRcbiAgICAgIDQgKyAvLyBib3R0b20gbWFyZ2luXG4gICAgICAxNiArIC8vIGJvdHRvbSBsYWJlbHNcbiAgICAgIDQsIC8vIG1hcmdpbnNcbiAgICBoaXN0b2dyYW1DaGFydE1vYmlsZUhlaWdodDpcbiAgICAgIDIwICsgLy8gaW5saW5lIGJhcnMgaGVpZ2h0IChubyBib3R0b20gbGFiZWxzKVxuICAgICAgNCAvLyBtYXJnaW5zXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbCkgdGhyb3cgbmV3IEVycm9yKCd0b3JxZUxheWVyTW9kZWwgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yYW5nZUZpbHRlcikgdGhyb3cgbmV3IEVycm9yKCdyYW5nZUZpbHRlciBpcyByZXF1aXJlZCcpO1xuXG4gICAgdGhpcy5fcmFuZ2VGaWx0ZXIgPSB0aGlzLm9wdGlvbnMucmFuZ2VGaWx0ZXI7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCA9IHRoaXMub3B0aW9ucy50b3JxdWVMYXllck1vZGVsO1xuXG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6ZGF0YScsIHRoaXMuX29uQ2hhbmdlRGF0YSwgdGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLl9jcmVhdGVIaXN0b2dyYW1WaWV3KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2NyZWF0ZUhpc3RvZ3JhbVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NoYXJ0VmlldyA9IG5ldyBIaXN0b2dyYW1DaGFydFZpZXcoe1xuICAgICAgdHlwZTogJ3RpbWUnLFxuICAgICAgYW5pbWF0aW9uU3BlZWQ6IDEwMCxcbiAgICAgIGFuaW1hdGlvbkJhckRlbGF5OiBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiAoaSAqIDMpO1xuICAgICAgfSxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIHJpZ2h0OiA0LFxuICAgICAgICBib3R0b206IDQsXG4gICAgICAgIGxlZnQ6IDRcbiAgICAgIH0sXG4gICAgICBoYXNIYW5kbGVzOiB0cnVlLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRlZmF1bHRzLmhpc3RvZ3JhbUNoYXJ0SGVpZ2h0LFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKCksXG4gICAgICBzaGFkb3dEYXRhOiB0aGlzLm1vZGVsLmdldERhdGEoKVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRWaWV3KHRoaXMuX2NoYXJ0Vmlldyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuX2NoYXJ0Vmlldy5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5fY2hhcnRWaWV3LnNob3coKTtcblxuICAgIHRoaXMuX2NoYXJ0Vmlldy5iaW5kKCdvbl9icnVzaF9lbmQnLCB0aGlzLl9vbkJydXNoRW5kLCB0aGlzKTtcbiAgICB0aGlzLl9jaGFydFZpZXcubW9kZWwuYmluZCgnY2hhbmdlOndpZHRoJywgdGhpcy5fb25DaGFuZ2VDaGFydFdpZHRoLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX2NoYXJ0Vmlldy5tb2RlbCk7XG5cbiAgICB2YXIgdGltZVNsaWRlclZpZXcgPSBuZXcgVG9ycXVlVGltZVNsaWRlclZpZXcoe1xuICAgICAgbW9kZWw6IHRoaXMubW9kZWwsIC8vIGEgaGlzdG9ncmFtIG1vZGVsXG4gICAgICBjaGFydFZpZXc6IHRoaXMuX2NoYXJ0VmlldyxcbiAgICAgIHRvcnF1ZUxheWVyTW9kZWw6IHRoaXMuX3RvcnF1ZUxheWVyTW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodGltZVNsaWRlclZpZXcpO1xuICAgIHRpbWVTbGlkZXJWaWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIF9vbkNoYW5nZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jaGFydFZpZXcpIHtcbiAgICAgIHRoaXMuX2NoYXJ0Vmlldy5yZXBsYWNlRGF0YSh0aGlzLm1vZGVsLmdldERhdGEoKSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkJydXNoRW5kOiBmdW5jdGlvbihsb0JhckluZGV4LCBoaUJhckluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICB0aGlzLl9yYW5nZUZpbHRlci5zZXRSYW5nZShcbiAgICAgIGRhdGFbbG9CYXJJbmRleF0uc3RhcnQsXG4gICAgICBkYXRhW2hpQmFySW5kZXggLSAxXS5lbmRcbiAgICApO1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuc2V0U3RlcHNSYW5nZShsb0JhckluZGV4LCBoaUJhckluZGV4KTtcbiAgfSxcblxuICBfb25DaGFuZ2VDaGFydFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNNb2JpbGVTaXplID0gJCh3aW5kb3cpLndpZHRoKCkgPCB0aGlzLmRlZmF1bHRzLm1vYmlsZVRocmVzaG9sZDtcblxuICAgIHRoaXMuX2NoYXJ0Vmlldy50b2dnbGVMYWJlbHMoIWlzTW9iaWxlU2l6ZSk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gaXNNb2JpbGVTaXplXG4gICAgICA/IHRoaXMuZGVmYXVsdHMuaGlzdG9ncmFtQ2hhcnRNb2JpbGVIZWlnaHRcbiAgICAgIDogdGhpcy5kZWZhdWx0cy5oaXN0b2dyYW1DaGFydEhlaWdodDtcbiAgICB0aGlzLl9jaGFydFZpZXcubW9kZWwuc2V0KCdoZWlnaHQnLCBoZWlnaHQpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXIgQ0RCLVdpZGdldC1oZWFkZXItLXRpbWVTZXJpZXMganMtaGVhZGVyXCI+PC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBkMyA9IGNkYi5kMztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdG9ycXVlLXRpbWUtaW5mby50cGwnKTtcblxuLyoqXG4gKiBWaWV3IHJlbmRlcmluZyB0aGUgY3VycmVudCBzdGVwIHRpbWVcbiAqXG4gKiBNb2RlbCBpcyBleHBlY3RlZCB0byBiZSBhIHRvcnF1ZSBsYXllciBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LXRpbWVTZXJpZXNUaW1lSW5mbycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6c3RlcCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcblxuICAgIC8vIGZvciBmb3JtYXQgcnVsZXMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9kMy93aWtpL1RpbWUtRm9ybWF0dGluZ1xuICAgIHRoaXMuX3RpbWVGb3JtYXR0ZXIgPSBkMy50aW1lLmZvcm1hdCgnJUg6JU0nKTtcbiAgICB0aGlzLl9kYXRlRm9ybWF0dGVyID0gZDMudGltZS5mb3JtYXQoJyV4Jyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0ZSA9IHRoaXMubW9kZWwuZ2V0KCd0aW1lJyk7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgaXNOYU4oZGF0ZSAmJiBkYXRlLmdldFRpbWUoKSlcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IHRlbXBsYXRlKHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuX3RpbWVGb3JtYXR0ZXIoZGF0ZSksXG4gICAgICAgICAgICBkYXRlOiB0aGlzLl9kYXRlRm9ybWF0dGVyKGRhdGUpXG4gICAgICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiPiAnK1xuKChfX3Q9KCB0aW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyA8L3A+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnIENEQi1XaWRnZXQtdGV4dC0tc2Vjb25kYXJ5XCI+ICcrXG4oKF9fdD0oIGRhdGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIDwvcD4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgZDMgPSBjZGIuZDM7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcblxuLyoqXG4gKiBUaW1lLXNsaWRlciwgZXhwZWN0ZWQgdG8gYmUgdXNlZCBpbiBhIGhpc3RvZ3JhbSB2aWV3XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgd2lkdGg6IDQsXG4gICAgaGVpZ2h0OiA4XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubW9kZWwpIHRocm93IG5ldyBFcnJvcignbW9kZWwgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jaGFydFZpZXcpIHRocm93IG5ldyBFcnJvcignY2hhcnRWaWV3IGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbCkgdGhyb3cgbmV3IEVycm9yKCd0b3JxZUxheWVyTW9kZWwgaXMgcmVxdWlyZWQnKTtcblxuICAgIHRoaXMuX2NoYXJ0VmlldyA9IHRoaXMub3B0aW9ucy5jaGFydFZpZXc7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCA9IHRoaXMub3B0aW9ucy50b3JxdWVMYXllck1vZGVsO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IE1vZGVsKCk7XG5cbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLmJpbmQoJ2NoYW5nZTpzdGVwJywgdGhpcy5fb25DaGFuZ2VTdGVwLCB0aGlzKTtcbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLmJpbmQoJ2NoYW5nZTpzdGVwcycsIHRoaXMuX29uQ2hhbmdlU3RlcHMsIHRoaXMpO1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuYmluZCgnY2hhbmdlOnN0ZXBzUmFuZ2UnLCB0aGlzLl9vblN0ZXBzUmFuZ2UsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCk7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcubW9kZWwuYmluZCgnY2hhbmdlOndpZHRoJywgdGhpcy5fb25DaGFuZ2VDaGFydFdpZHRoLCB0aGlzKTtcbiAgICB0aGlzLl9jaGFydFZpZXcubW9kZWwuYmluZCgnY2hhbmdlOmhlaWdodCcsIHRoaXMuX29uQ2hhbmdlQ2hhcnRIZWlnaHQsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5fY2hhcnRWaWV3Lm1vZGVsKTtcblxuICAgIHRoaXMuX3VwZGF0ZVhTY2FsZSgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gTWFrZSB0aGUgcmVuZGVyIGNhbGwgaWRlbXBvdGVudDsgb25seSBjcmVhdGUgdGltZSBzbGlkZXIgb25jZVxuICAgIGlmICghdGhpcy50aW1lU2xpZGVyKSB7XG4gICAgICB2YXIgZHJhZ0JlaGF2aW9yID0gZDMuYmVoYXZpb3IuZHJhZygpXG4gICAgICAgIC5vbignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSlcbiAgICAgICAgLm9uKCdkcmFnJywgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcblxuICAgICAgdGhpcy50aW1lU2xpZGVyID0gdGhpcy5fY2hhcnRWaWV3LmNhbnZhcy5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnQ0RCLVRpbWVTbGlkZXInKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLmRlZmF1bHRzLndpZHRoKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5fY2FsY0hlaWdodCgpKVxuICAgICAgICAuYXR0cigncngnLCAzKVxuICAgICAgICAuYXR0cigncnknLCAzKVxuICAgICAgICAuZGF0YShbeyB4OiAwLCB5OiAwIH1dKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdGhpcy5fdHJhbnNsYXRlWFkpXG4gICAgICAgIC5jYWxsKGRyYWdCZWhhdmlvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRpbWVTbGlkZXIpIHtcbiAgICAgIHRoaXMudGltZVNsaWRlci5yZW1vdmUoKTtcbiAgICB9XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfSxcblxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc1J1bm5pbmcgPSB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnaXNSdW5uaW5nJyk7XG4gICAgaWYgKGlzUnVubmluZykge1xuICAgICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5wYXVzZSgpO1xuICAgIH1cbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoe1xuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIHdhc1J1bm5pbmc6IGlzUnVubmluZ1xuICAgIH0pO1xuICB9LFxuXG4gIF9vbkRyYWc6IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICB2YXIgbmV4dFggPSBkLnggKyBkMy5ldmVudC5keDtcbiAgICBpZiAodGhpcy5faXNXaXRoaW5SYW5nZShuZXh0WCkpIHtcbiAgICAgIGQueCA9IG5leHRYO1xuICAgICAgdGhpcy50aW1lU2xpZGVyLmF0dHIoJ3RyYW5zZm9ybScsIHRoaXMuX3RyYW5zbGF0ZVhZKTtcblxuICAgICAgdmFyIHN0ZXAgPSBNYXRoLnJvdW5kKHRoaXMuX3hTY2FsZS5pbnZlcnQoZC54KSk7XG4gICAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLnNldFN0ZXAoc3RlcCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsLnNldCgnaXNEcmFnZ2luZycsIGZhbHNlKTtcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZ2V0KCd3YXNSdW5uaW5nJykpIHtcbiAgICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwucGxheSgpO1xuICAgIH1cbiAgfSxcblxuICBfdHJhbnNsYXRlWFk6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgW2QueCwgZC55XSArICcpJztcbiAgfSxcblxuICBfaXNXaXRoaW5SYW5nZTogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4ID49IDAgJiYgeCA8PSB0aGlzLl93aWR0aCgpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVN0ZXA6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRpbWUgc2xpZGVyIG1pZ2h0IG5vdCBiZSBjcmVhdGVkIHdoZW4gdGhpcyBtZXRob2QgaXMgZmlyc3QgY2FsbGVkXG4gICAgaWYgKHRoaXMudGltZVNsaWRlciAmJiAhdGhpcy52aWV3TW9kZWwuZ2V0KCdpc0RyYWdnaW5nJykpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy50aW1lU2xpZGVyLmRhdGEoKTtcbiAgICAgIHZhciBuZXdYID0gdGhpcy5feFNjYWxlKHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuZ2V0KCdzdGVwJykpO1xuICAgICAgaWYgKCFpc05hTihuZXdYKSkge1xuICAgICAgICBkYXRhWzBdLnggPSBuZXdYO1xuICAgICAgICB0aGlzLnRpbWVTbGlkZXJcbiAgICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuZWFzZSgnbGluZWFyJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdGhpcy5fdHJhbnNsYXRlWFkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VTdGVwczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlWFNjYWxlKCk7XG4gIH0sXG5cbiAgX29uU3RlcHNSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnc3RlcHNSYW5nZScpO1xuICAgIGlmIChyLnN0YXJ0ID09PSAwICYmIHIuZW5kID09PSB0aGlzLm1vZGVsLmdldCgnYmlucycpKSB7XG4gICAgICB0aGlzLl9jaGFydFZpZXcucmVtb3ZlU2VsZWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoYXJ0Vmlldy5zZWxlY3RSYW5nZShyLnN0YXJ0LCByLmVuZCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNoYW5nZUNoYXJ0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VwZGF0ZVhTY2FsZSgpO1xuICAgIHRoaXMuX29uQ2hhbmdlU3RlcCgpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUNoYXJ0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVTbGlkZXIuYXR0cignaGVpZ2h0JywgdGhpcy5fY2FsY0hlaWdodCgpKTtcbiAgfSxcblxuICBfY2FsY0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0Vmlldy5jaGFydEhlaWdodCgpICsgdGhpcy5kZWZhdWx0cy5oZWlnaHQ7XG4gIH0sXG5cbiAgX3VwZGF0ZVhTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feFNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgIC5kb21haW4oWzAsIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuZ2V0KCdzdGVwcycpXSlcbiAgICAgIC5yYW5nZShbMCwgdGhpcy5fd2lkdGgoKV0pO1xuICB9LFxuXG4gIF93aWR0aDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0Vmlldy5tb2RlbC5nZXQoJ3dpZHRoJyk7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcblxudmFyIFdpZGdldE1vZGVsRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlcykge1xuICB0eXBlcyA9IHR5cGVzIHx8IHt9O1xuICB0aGlzLnR5cGVzID0ge307XG4gIGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcbiAgICB2YXIgY3JlYXRlTW9kZWwgPSB0eXBlc1t0eXBlXTtcbiAgICB0aGlzLmFkZFR5cGUodHlwZSwgY3JlYXRlTW9kZWwpO1xuICB9XG59O1xuXG5XaWRnZXRNb2RlbEZhY3RvcnkucHJvdG90eXBlLmFkZFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3JlYXRlTW9kZWwpIHtcbiAgaWYgKCFfLmlzU3RyaW5nKHR5cGUpKSBuZXcgRXJyb3IoJ3R5cGUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uJyk7XG4gIGlmICghXy5pc0Z1bmN0aW9uKGNyZWF0ZU1vZGVsKSkgbmV3IEVycm9yKCdjcmVhdGVNb2RlbCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy50eXBlc1t0eXBlXSA9IGNyZWF0ZU1vZGVsO1xufTtcblxuV2lkZ2V0TW9kZWxGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChsYXllciwgbGF5ZXJJbmRleCwgYXR0cnMpIHtcbiAgaWYgKCFhdHRycy5pZCkgdGhyb3cgbmV3IEVycm9yKCdhdHRycy5pZCBpcyByZXF1aXJlZCcpO1xuXG4gIHZhciBjcmVhdGVNb2RlbCA9IHRoaXMudHlwZXNbYXR0cnMudHlwZV07XG4gIGlmIChjcmVhdGVNb2RlbCkge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgbGF5ZXI6IGxheWVyXG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlTW9kZWwoYXR0cnMsIG9wdHMsIGxheWVySW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gbW9kZWwgZm91bmQgZm9yIGFyZ3VtZW50cyAnICsgYXJndW1lbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRNb2RlbEZhY3Rvcnk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgXyA9IGNkYi5fO1xuXG4vKipcbiAqIFN0YW5kYXJkIHdpZGdldCB0b29sdGlwIHZpZXdcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtdG9vbHRpcCcsXG5cbiAgb3B0aW9uczoge1xuICAgIGF0dHJpYnV0ZTogJ2RhdGEtdG9vbHRpcCcsXG4gICAgb2Zmc2V0WDogMTAsXG4gICAgb2Zmc2V0WTogLTI4XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgIGlmICghb3B0cy50YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICAgIHRoaXMuXyR0YXJnZXQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0O1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5fJHRhcmdldC5hdHRyKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGUpO1xuICAgIHRoaXMuJGVsLmh0bWwodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuXyR0YXJnZXQuaG92ZXIoXG4gICAgICBfLmJpbmQodGhpcy5zaG93LCB0aGlzKSxcbiAgICAgIF8uYmluZCh0aGlzLmhpZGUsIHRoaXMpXG4gICAgKTtcbiAgfSxcblxuICBfc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3MgPSB0aGlzLl8kdGFyZ2V0Lm9mZnNldCgpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuJGVsLm91dGVyV2lkdGgoKTtcblxuICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICB0b3A6IHBvcy50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0WSxcbiAgICAgIGxlZnQ6IHBvcy5sZWZ0IC0gKHdpZHRoLzIpICsgdGhpcy5vcHRpb25zLm9mZnNldFhcbiAgICB9KTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgVmlldy5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMpO1xuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0Lm9mZignbW91c2VlbnRlciBtb3VzZWxlYXZlJyk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgV2lkZ2V0VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0LXZpZXcnKTtcblxudmFyIFdpZGdldFZpZXdGYWN0b3J5ID0gZnVuY3Rpb24oZGVmcykge1xuICB0aGlzLmRlZnMgPSBbXTtcbiAgXy5lYWNoKGRlZnMsIGZ1bmN0aW9uKGRlZikge1xuICAgIHRoaXMuYWRkVHlwZShkZWYpO1xuICB9LCB0aGlzKTtcbn07XG5cbldpZGdldFZpZXdGYWN0b3J5LnByb3RvdHlwZS5ERUZBVUxUX0NMQVNTX05BTUVTID0gJ0NEQi1XaWRnZXQgQ0RCLVdpZGdldC0tbGlnaHQnO1xuXG5XaWRnZXRWaWV3RmFjdG9yeS5wcm90b3R5cGUuYWRkVHlwZSA9IGZ1bmN0aW9uKGRlZikge1xuICBpZiAoIWRlZi5tYXRjaCkge1xuICAgIGlmIChkZWYudHlwZSkge1xuICAgICAgZGVmLm1hdGNoID0gZnVuY3Rpb24od2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB3aWRnZXQuZ2V0KCd0eXBlJykgPT09IHRoaXMudHlwZTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBFcnJvcignZGVmLnR5cGUgb3IgZGVmLm1hdGNoIG11c3QgYmUgcHJvdmlkZWQgZm9yIGNyZWF0ZUNvbnRlbnRWaWV3IHRvIHdvcmsnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFfLmlzRnVuY3Rpb24oZGVmLmNyZWF0ZUNvbnRlbnRWaWV3KSkgbmV3IEVycm9yKCdkZWYuY3JlYXRlQ29udGVudFZpZXcgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMuZGVmcy5wdXNoKGRlZik7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3QsIHVuZGVmaW5lZH0gUmV0dXJucyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vdCBtYXRjaGluZyB2aWV3IGZvciB0aGUgZ2l2ZW4gbW9kZWxcbiAqL1xuV2lkZ2V0Vmlld0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVdpZGdldFZpZXcgPSBmdW5jdGlvbih3aWRnZXQpIHtcbiAgdmFyIGRlZiA9IF8uZmluZCh0aGlzLmRlZnMsIGZ1bmN0aW9uKGRlZikge1xuICAgIHJldHVybiBkZWYubWF0Y2god2lkZ2V0KTtcbiAgfSk7XG5cbiAgaWYgKGRlZikge1xuICAgIHZhciBhdHRycyA9IHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5ERUZBVUxUX0NMQVNTX05BTUVTLFxuICAgICAgbW9kZWw6IHdpZGdldCxcbiAgICAgIGNvbnRlbnRWaWV3OiBkZWYuY3JlYXRlQ29udGVudFZpZXcod2lkZ2V0KVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFdpZGdldFZpZXcoXG4gICAgICBfLmlzRnVuY3Rpb24oZGVmLmN1c3RvbWl6ZVdpZGdldEF0dHJzKVxuICAgICAgICA/IGRlZi5jdXN0b21pemVXaWRnZXRBdHRycyhhdHRycylcbiAgICAgICAgOiBhdHRyc1xuICAgICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0Vmlld0ZhY3Rvcnk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgV2lkZ2V0TG9hZGVyVmlldyA9IHJlcXVpcmUoJy4vc3RhbmRhcmQvd2lkZ2V0X2xvYWRlcl92aWV3Jyk7XG52YXIgV2lkZ2V0RXJyb3JWaWV3ID0gcmVxdWlyZSgnLi9zdGFuZGFyZC93aWRnZXRfZXJyb3JfdmlldycpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IHZpZXdcbiAqIFRoZSBtb2RlbCBpcyBhIGV4cGVjdGVkIHRvIGJlIHdpZGdldCBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0IENEQi1XaWRnZXQtLWxpZ2h0JyxcblxuICBvcHRpb25zOiB7XG4gICAgY29sdW1uc190aXRsZTogW10sXG4gICAgc3luYzogdHJ1ZVxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwubGF5ZXIuYmluZCgnY2hhbmdlOnZpc2libGUnLCB0aGlzLl9vbkNoYW5nZUxheWVyVmlzaWJsZSwgdGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBuZXcgV2lkZ2V0TG9hZGVyVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9sb2FkZXIucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLl9sb2FkZXIpO1xuXG4gICAgdGhpcy5fZXJyb3IgPSBuZXcgV2lkZ2V0RXJyb3JWaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuX2Vycm9yLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcodGhpcy5fZXJyb3IpO1xuXG4gICAgdmFyIGNvbnRlbnRWaWV3ID0gdGhpcy5vcHRpb25zLmNvbnRlbnRWaWV3O1xuICAgIHRoaXMuJGVsLmFwcGVuZChjb250ZW50Vmlldy5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KGNvbnRlbnRWaWV3KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9vbkNoYW5nZUxheWVyVmlzaWJsZTogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAvLyAhISB0byBmb3JjZSBhIGJvb2xlYW4gdmFsdWUsIHNvIG9ubHkgYSB0cnVlIHZhbHVlIGFjdHVhbGx5IHNob3dzIHRoZSB2aWV3XG4gICAgdGhpcy4kZWwudG9nZ2xlKCEhbGF5ZXIuZ2V0KCd2aXNpYmxlJykpO1xuICB9XG59KTtcbiIsInZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xuXG4vKipcbiAqICBWaWV3IG1vZGVsLCBzcGVjaWFsIGZvciB3aWRnZXRzIHdpdGggc2VhcmNoIGFuZCBjb2xsYXBzZVxuICogIGZ1bmN0aW9uYWxpdGllc1xuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICBzZWFyY2g6IGZhbHNlXG4gIH0sXG5cbiAgdG9nZ2xlU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnc2VhcmNoJywgIXRoaXMuZ2V0KCdzZWFyY2gnKSk7XG4gIH0sXG5cbiAgZW5hYmxlU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnc2VhcmNoJywgdHJ1ZSk7XG4gIH0sXG5cbiAgZGlzYWJsZVNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ3NlYXJjaCcsIGZhbHNlKTtcbiAgfSxcblxuICBpc1NlYXJjaEVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnc2VhcmNoJyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKiBEZWZhdWx0IHdpZGdldCBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICB1cmw6ICcnLFxuICAgIGRhdGE6IFtdLFxuICAgIGNvbHVtbnM6IFtdLFxuICAgIHN5bmM6IHRydWUsXG4gICAgYmJveDogdHJ1ZSxcbiAgICBjb2xsYXBzZWQ6IGZhbHNlXG4gIH0sXG5cbiAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3VybCcpICsgJz9iYm94PScgKyB0aGlzLmdldCgnYm91bmRpbmdCb3gnKTtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdGhpcy5sYXllciA9IG9wdHMubGF5ZXI7XG4gICAgdGhpcy5maWx0ZXIgPSBvcHRzLmZpbHRlcjsgLy8gb3B0aW9uYWwvbWlnaHQgYmUgdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uY2UoJ2NoYW5nZTp1cmwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuX2ZldGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9vbkNoYW5nZUJpbmRzKCk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIFJldHJpZ2dlciBhbiBldmVudCB3aGVuIHRoZSBmaWx0ZXIgY2hhbmdlc1xuICAgIGlmICh0aGlzLmZpbHRlcikge1xuICAgICAgdGhpcy5maWx0ZXIuYmluZCgnY2hhbmdlJywgdGhpcy5fb25GaWx0ZXJDaGFuZ2VkLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlQmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOnVybCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAodGhpcy5nZXQoJ3N5bmMnKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6Ym91bmRpbmdCb3gnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdldCgnYmJveCcpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIGZ1bmN0aW9uKG1kbCwgaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICghaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKG1kbC5jaGFuZ2VkQXR0cmlidXRlcyh0aGlzLl9wcmV2aW91c0F0dHJzKSkge1xuICAgICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cnMgPSB7XG4gICAgICAgICAgdXJsOiB0aGlzLmdldCgndXJsJyksXG4gICAgICAgICAgYm91bmRpbmdCb3g6IHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2ZldGNoOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZldGNoKHtcbiAgICAgIHN1Y2Nlc3M6IGNhbGxiYWNrLFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZmV0Y2goKTtcbiAgfSxcblxuICBpc0NvbGxhcHNlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdjb2xsYXBzZWQnKTtcbiAgfSxcblxuICB0b2dnbGVDb2xsYXBzZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdjb2xsYXBzZWQnLCAhdGhpcy5nZXQoJ2NvbGxhcHNlZCcpKTtcbiAgfSxcblxuICBfb25GaWx0ZXJDaGFuZ2VkOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpmaWx0ZXInLCB0aGlzLCBmaWx0ZXIpO1xuICB9LFxuXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnZGF0YScpO1xuICB9LFxuXG4gIGdldFByZXZpb3VzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXMoJ2RhdGEnKTtcbiAgfSxcblxuICBmZXRjaDogZnVuY3Rpb24ob3B0cykge1xuICAgIHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIiwgdGhpcyk7XG4gICAgcmV0dXJuIE1vZGVsLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsb3B0cyk7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvSlNPTiBzaG91bGQgYmUgZGVmaW5lZCBmb3IgZWFjaCB3aWRnZXQnKTtcbiAgfVxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgXyA9IGNkYi5fO1xuXG4vKipcbiAqICBDb2xsZWN0aW9uIHRoYXQgY29udHJvbHMgd2lkZ2V0IG1vZGVscyBwZXIgbGF5ZXJcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIGEgY2F0ZWdvcnkgbW9kZWwgYXBwbGllcyB0aGUgY2F0ZWdvcnkgY29sb3JzLCByZXN0IHNob3VsZCByZW1vdmUvZGlzYWJsZVxuICAgIC8vIHRoZSBjYXRlZ29yeSBjb2xvcnMgYXBwbGllZCBiZWZvcmUuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6Y2F0ZWdvcnlDb2xvcnMnLCBmdW5jdGlvbihtLCBpc0NvbG9yQ2F0ZWdvcml6ZWQpIHtcbiAgICAgIGlmIChpc0NvbG9yQ2F0ZWdvcml6ZWQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKG1kbCkge1xuICAgICAgICAgIGlmIChtZGwgIT09IG0gJiYgbWRsLmdldCgnY2F0ZWdvcnlDb2xvcnMnKSkge1xuICAgICAgICAgICAgbWRsLnNldCgnY2F0ZWdvcnlDb2xvcnMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gSWYgYSBoaXN0b2dyYW0gbW9kZWwgYXBwbGllcyB0aGUgaGlzdG9ncmFtIHNpemVzLCByZXN0IHNob3VsZCByZW1vdmUvZGlzYWJsZVxuICAgIC8vIHRoZSBzaXplcyBhcHBsaWVkIGJlZm9yZS5cbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTpoaXN0b2dyYW1TaXplcycsIGZ1bmN0aW9uKG0sIGlzU2l6ZXNBcHBsaWVkKSB7XG4gICAgICBpZiAoaXNTaXplc0FwcGxpZWQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKG1kbCkge1xuICAgICAgICAgIGlmIChtZGwgIT09IG0gJiYgbWRsLmdldCgnaGlzdG9ncmFtU2l6ZXMnKSkge1xuICAgICAgICAgICAgbWRsLnNldCgnaGlzdG9ncmFtU2l6ZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgTFpNQSA9IGNkYi5MWk1BO1xudmFyIHV0aWwgPSBjZGIuY29yZS51dGlsO1xudmFyIFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtaW5zdGFuY2UnKTtcblxudmFyIHZhbGlkYXRlUHJlc2VuY2VPZk9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCByZXF1aXJlZE9wdGlvbnMpIHtcbiAgdmFyIG1pc3NpbmdPcHRpb25zID0gXy5maWx0ZXIocmVxdWlyZWRPcHRpb25zLCBmdW5jdGlvbihvcHRpb24pIHtcbiAgICByZXR1cm4gIW9wdGlvbnNbb3B0aW9uXTtcbiAgfSk7XG4gIGlmIChtaXNzaW5nT3B0aW9ucy5sZW5ndGgpIHtcbiAgICB0aHJvdyAnVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSByZXF1aXJlZDogJyArIG1pc3NpbmdPcHRpb25zLmpvaW4oJywgJyk7XG4gIH1cbn07XG5cbi8qKlxuICogV2luZHNoYWZ0IGNsaWVudC4gSXQgcHJvdmlkZXMgYSBtZXRob2QgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBkYXNoYm9hcmRzLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9ucyB0byBzZXQgdXAgdGhlIGNsaWVudFxuICovXG5XaW5kc2hhZnRDbGllbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhbGlkYXRlUHJlc2VuY2VPZk9wdGlvbnMob3B0aW9ucywgWyd1cmxUZW1wbGF0ZScsICd1c2VyTmFtZScsICdlbmRwb2ludCcsICdzdGF0VGFnJ10pO1xuXG4gIHRoaXMudXJsVGVtcGxhdGUgPSBvcHRpb25zLnVybFRlbXBsYXRlO1xuICB0aGlzLnVzZXJOYW1lID0gb3B0aW9ucy51c2VyTmFtZTtcbiAgdGhpcy5lbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gIHRoaXMuc3RhdFRhZyA9IG9wdGlvbnMuc3RhdFRhZztcbiAgdGhpcy5mb3JjZUNvcnMgPSBvcHRpb25zLmZvcmNlQ29ycyB8fCBmYWxzZTtcblxuICB0aGlzLnVybCA9IHRoaXMudXJsVGVtcGxhdGUucmVwbGFjZSgne3VzZXJ9JywgdGhpcy51c2VyTmFtZSk7XG59O1xuXG5XaW5kc2hhZnRDbGllbnQuREVGQVVMVF9DT01QUkVTU0lPTl9MRVZFTCA9IDM7XG5XaW5kc2hhZnRDbGllbnQuTUFYX0dFVF9TSVpFID0gMjAzMztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgbWFwIGluIFdpbmRzaGFmdFxuICogQHBhcmFtIHtvYmplY3R9IG1hcERlZmluaXRpb24gQW4gb2JqZWN0IHRoYXQgcmVzcG9uZHMgdG8gLnRvSlNPTiB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBtYXBcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgd2lsbCBnZXQgdGhlIHB1YmxpYyBvciBwcml2YXRlIG1hcFxuICogQHJldHVybiB7Y2RiLndpbmRzaGFmdC5EYXNoYm9hcmRJbnN0YW5jZX0gVGhlIGluc3RhbmNlIG9mIHRoZSBkYXNoYm9hcmRcbiAqL1xuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5pbnN0YW50aWF0ZU1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG1hcERlZmluaXRpb24gPSBvcHRpb25zLm1hcERlZmluaXRpb247XG4gIHZhciBmaWx0ZXJzID0gb3B0aW9ucy5maWx0ZXJzO1xuICB2YXIgc3VjY2Vzc0NhbGxiYWNrID0gb3B0aW9ucy5zdWNjZXNzO1xuICB2YXIgZXJyb3JDYWxsYmFjayA9IG9wdGlvbnMuZXJyb3I7XG4gIHZhciBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkobWFwRGVmaW5pdGlvbik7XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZXJyb3JzKSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZGF0YS5lcnJvcnNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS51cmxUZW1wbGF0ZSA9IHRoaXMudXJsVGVtcGxhdGU7XG4gICAgICAgIGRhdGEudXNlck5hbWUgPSB0aGlzLnVzZXJOYW1lO1xuICAgICAgICBzdWNjZXNzQ2FsbGJhY2sobmV3IFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlKGRhdGEpKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyksXG4gICAgZXJyb3I6IGZ1bmN0aW9uKHhocikge1xuICAgICAgdmFyIGVyciA9IHsgZXJyb3JzOiBbJ1Vua25vd24gZXJyb3InXSB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIGVycm9yQ2FsbGJhY2soZXJyLmVycm9yc1swXSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IE1vdmUgdGhpc1xuICB2YXIgcGFyYW1zID0gW1xuICAgIFtcInN0YXRfdGFnXCIsIHRoaXMuc3RhdFRhZ10uam9pbihcIj1cIilcbiAgXTtcblxuICB2YXIgZmlsdGVycyA9IGZpbHRlcnMgfHwge307XG4gIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJzKS5sZW5ndGgpIHtcbiAgICBwYXJhbXMucHVzaChbXCJmaWx0ZXJzXCIsIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmaWx0ZXJzKSldLmpvaW4oJz0nKSk7XG4gIH1cblxuICBpZiAodGhpcy5fdXNlUE9TVChwYXlsb2FkLCBwYXJhbXMpKSB7XG4gICAgdGhpcy5fcG9zdChwYXlsb2FkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2dldChwYXlsb2FkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG59XG5cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuX3VzZVBPU1QgPSBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMpIHtcbiAgaWYgKHV0aWwuaXNDT1JTU3VwcG9ydGVkKCkgJiYgdGhpcy5mb3JjZUNvcnMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZC5sZW5ndGggPj0gdGhpcy5jb25zdHJ1Y3Rvci5NQVhfR0VUX1NJWkU7XG59XG5cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuX3Bvc3QgPSBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgJC5hamF4KHtcbiAgICBjcm9zc09yaWdpbjogdHJ1ZSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgdXJsOiB0aGlzLl9nZXRVUkwocGFyYW1zKSxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICAgIHN1Y2Nlc3M6IG9wdGlvbnMuc3VjY2VzcyxcbiAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxuICB9KTtcbn1cblxuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIHZhciBjb21wcmVzc0Z1bmN0aW9uID0gdGhpcy5fZ2V0Q29tcHJlc3NvcihwYXlsb2FkKTtcbiAgY29tcHJlc3NGdW5jdGlvbihwYXlsb2FkLCB0aGlzLmNvbnN0cnVjdG9yLkRFRkFVTFRfQ09NUFJFU1NJT05fTEVWRUwsIGZ1bmN0aW9uKGRhdGFQYXJhbWV0ZXIpIHtcbiAgICBwYXJhbXMucHVzaChkYXRhUGFyYW1ldGVyKTtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB0aGlzLl9nZXRVUkwocGFyYW1zKSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBkYXRhVHlwZTogJ2pzb25wJyxcbiAgICAgIGpzb25wQ2FsbGJhY2s6IHRoaXMuX2pzb25wQ2FsbGJhY2tOYW1lKHBheWxvYWQpLFxuICAgICAgY2FjaGU6IHRydWUsXG4gICAgICBzdWNjZXNzOiBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxuICAgIH0pO1xuICB9LmJpbmQodGhpcykpO1xufVxuXG5XaW5kc2hhZnRDbGllbnQucHJvdG90eXBlLl9nZXRDb21wcmVzc29yID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5sZW5ndGggPCB0aGlzLmNvbnN0cnVjdG9yLk1BWF9HRVRfU0laRSkge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBsZXZlbCwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKFwiY29uZmlnPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGxldmVsLCBjYWxsYmFjaykge1xuICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh7IGNvbmZpZzogZGF0YSB9KTtcbiAgICBMWk1BLmNvbXByZXNzKGRhdGEsIGxldmVsLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICBjYWxsYmFjayhcImx6bWE9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbC5hcnJheTJoZXgoZW5jb2RlZCkpKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuXG5XaW5kc2hhZnRDbGllbnQucHJvdG90eXBlLl9nZXRVUkwgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIFt0aGlzLnVybCwgdGhpcy5lbmRwb2ludF0uam9pbignLycpICsgJz8nICsgcGFyYW1zLmpvaW4oJyYnKTtcbn1cblxuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5fanNvbnBDYWxsYmFja05hbWUgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gIHJldHVybiAnX2NkYmNfJyArIHV0aWwudW5pcXVlQ2FsbGJhY2tOYW1lKHBheWxvYWQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdENsaWVudDtcbiIsInZhciBjb25maWcgPSB7fTtcbmNvbmZpZy5NQVBTX0FQSV9CQVNFX1VSTCA9ICdhcGkvdjEvbWFwJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZztcbiIsInZhciBfID0gY2RiLl87XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBXaW5kc2hhZnRDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIEVNUFRZX0dJRiA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBUSUxFX0VYVEVOU0lPTlNfQllfTEFZRVJfVFlQRToge1xuICAgICdtYXBuaWsnOiAnLnBuZycsXG4gICAgJ3RvcnF1ZSc6ICcuanNvbi50b3JxdWUnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBUT0RPOiBXaGF0IHBhcmFtcyBhcmUgcmVhbGx5IHVzZWQ/XG4gICAgdGhpcy5wbmdQYXJhbXMgPSBbJ21hcF9rZXknLCAnYXBpX2tleScsICdjYWNoZV9wb2xpY3knLCAndXBkYXRlZF9hdCddO1xuICAgIHRoaXMuZ3JpZFBhcmFtcyA9IFsnbWFwX2tleScsICdhcGlfa2V5JywgJ2NhY2hlX3BvbGljeScsICd1cGRhdGVkX2F0J107XG4gIH0sXG5cbiAgaXNMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0KCdsYXllcmdyb3VwaWQnKTtcbiAgfSxcblxuICBnZXRCYXNlVVJMOiBmdW5jdGlvbihzdWJob3N0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuX2dldEhvc3Qoc3ViaG9zdCksXG4gICAgICBXaW5kc2hhZnRDb25maWcuTUFQU19BUElfQkFTRV9VUkwsXG4gICAgICB0aGlzLl9nZXRNYXBJZCgpLFxuICAgIF0uam9pbignLycpO1xuICB9LFxuXG4gIF9nZXRNYXBJZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdsYXllcmdyb3VwaWQnKTtcbiAgfSxcblxuICBfZ2V0SG9zdDogZnVuY3Rpb24oc3ViaG9zdCkge1xuICAgIHZhciB1c2VyTmFtZSA9IHRoaXMuZ2V0KCd1c2VyTmFtZScpO1xuICAgIHZhciBwcm90b2NvbCA9IHRoaXMuX3VzZUhUVFBTKCkgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgIHZhciBzdWJob3N0ID0gc3ViaG9zdCA/IHN1Ymhvc3QgKyAnLicgOiAnJztcbiAgICB2YXIgaG9zdCA9IHRoaXMuZ2V0KCd1cmxUZW1wbGF0ZScpLnJlcGxhY2UoJ3t1c2VyfScsIHVzZXJOYW1lKTtcbiAgICB2YXIgY2RuSG9zdCA9IHRoaXMuZ2V0KCdjZG5fdXJsJykgJiYgdGhpcy5nZXQoJ2Nkbl91cmwnKVtwcm90b2NvbF07XG4gICAgaWYgKGNkbkhvc3QpIHtcbiAgICAgIGhvc3QgPSBbcHJvdG9jb2wsICc6Ly8nLCBzdWJob3N0LCBjZG5Ib3N0LCAnLycsIHVzZXJOYW1lXS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdDtcbiAgfSxcblxuICBfdXNlSFRUUFM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndXJsVGVtcGxhdGUnKS5pbmRleE9mKCdodHRwcycpID09PSAwO1xuICB9LFxuXG4gIGdldFRpbGVzOiBmdW5jdGlvbihsYXllclR5cGUsIHBhcmFtcykge1xuICAgIHZhciBncmlkcyA9IFtdO1xuICAgIHZhciB0aWxlcyA9IFtdO1xuXG4gICAgdmFyIHBuZ1BhcmFtcyA9IHRoaXMuX2VuY29kZVBhcmFtcyhwYXJhbXMsIHRoaXMucG5nUGFyYW1zKTtcbiAgICB2YXIgZ3JpZFBhcmFtcyA9IHRoaXMuX2VuY29kZVBhcmFtcyhwYXJhbXMsIHRoaXMuZ3JpZFBhcmFtcyk7XG4gICAgdmFyIHN1YmRvbWFpbnMgPSBbJzAnLCAnMScsICcyJywgJzMnXTtcblxuICAgIGlmKHRoaXMuX3VzZUhUVFBTKCkpIHtcbiAgICAgIHN1YmRvbWFpbnMgPSBbJyddO1xuICAgIH1cblxuICAgIGxheWVyVHlwZSA9IGxheWVyVHlwZSB8fCAnbWFwbmlrJztcblxuICAgIHZhciBsYXllckluZGV4ZXMgPSB0aGlzLl9nZXRMYXllckluZGV4ZXNCeVR5cGUobGF5ZXJUeXBlKTtcbiAgICBpZiAobGF5ZXJJbmRleGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGdyaWRUZW1wbGF0ZSA9ICcve3p9L3t4fS97eX0nO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ViZG9tYWlucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3ViZG9tYWluID0gc3ViZG9tYWluc1tpXTtcbiAgICAgICAgdmFyIHRpbGVVUkxUZW1wbGF0ZSA9IFtcbiAgICAgICAgICB0aGlzLmdldEJhc2VVUkwoc3ViZG9tYWluKSxcbiAgICAgICAgICAnLycsXG4gICAgICAgICAgbGF5ZXJJbmRleGVzLmpvaW4oJywnKSxcbiAgICAgICAgICAnL3t6fS97eH0ve3l9JyxcbiAgICAgICAgICB0aGlzLlRJTEVfRVhURU5TSU9OU19CWV9MQVlFUl9UWVBFW2xheWVyVHlwZV0sXG4gICAgICAgICAgKHBuZ1BhcmFtcyA/IFwiP1wiICsgcG5nUGFyYW1zOiAnJylcbiAgICAgICAgXS5qb2luKCcnKTtcblxuICAgICAgICB0aWxlcy5wdXNoKHRpbGVVUkxUZW1wbGF0ZSk7XG5cbiAgICAgICAgLy8gZm9yIG1hcG5payBsYXllcnMgYWRkIGdyaWQganNvbiB0b29cbiAgICAgICAgaWYgKGxheWVyVHlwZSA9PT0gJ21hcG5paycpIHtcbiAgICAgICAgICBmb3IodmFyIGxheWVyID0gMDsgbGF5ZXIgPCB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnMubGVuZ3RoOyArK2xheWVyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9nZXRMYXllckluZGV4QnlUeXBlKGxheWVyLCBcIm1hcG5pa1wiKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBncmlkVVJMVGVtcGxhdGUgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCYXNlVVJMKHN1YmRvbWFpbiksXG4gICAgICAgICAgICAgICAgXCIvXCIsXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIFwiLmdyaWQuanNvblwiLFxuICAgICAgICAgICAgICAgIChncmlkUGFyYW1zID8gXCI/XCIgKyBncmlkUGFyYW1zOiAnJylcbiAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICBncmlkc1tsYXllcl0gPSBncmlkc1tsYXllcl0gfHwgW107XG4gICAgICAgICAgICAgIGdyaWRzW2xheWVyXS5wdXNoKGdyaWRVUkxUZW1wbGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IENsaWVudHMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIGRlY2lkZSB3aGF0IHRvIHJlbmRlciBpZiBubyBsYXllcnMgYXJlIHByZXNlbnRcbiAgICAgIHRpbGVzID0gW0VNUFRZX0dJRl07XG4gICAgfVxuXG4gICAgdGhpcy51cmxzID0ge1xuICAgICAgdGlsZXM6IHRpbGVzLFxuICAgICAgZ3JpZHM6IGdyaWRzXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy51cmxzO1xuICB9LFxuXG4gIGdldExheWVyTWV0YTogZnVuY3Rpb24obGF5ZXJJbmRleCkge1xuICAgIHZhciBsYXllck1ldGEgPSB7fTtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXQoJ21ldGFkYXRhJykgJiYgdGhpcy5nZXQoJ21ldGFkYXRhJykubGF5ZXJzO1xuICAgIGlmIChsYXllcnMgJiYgbGF5ZXJzW2xheWVySW5kZXhdKSB7XG4gICAgICAgIGxheWVyTWV0YSA9IGxheWVyc1tsYXllckluZGV4XS5tZXRhIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJNZXRhO1xuICB9LFxuXG4gIF9lbmNvZGVQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcywgaW5jbHVkZWQpIHtcbiAgICBpZighcGFyYW1zKSByZXR1cm4gJyc7XG4gICAgdmFyIHVybF9wYXJhbXMgPSBbXTtcbiAgICBpbmNsdWRlZCA9IGluY2x1ZGVkIHx8IF8ua2V5cyhwYXJhbXMpO1xuICAgIGZvcih2YXIgaSBpbiBpbmNsdWRlZCkge1xuICAgICAgdmFyIGsgPSBpbmNsdWRlZFtpXTtcbiAgICAgIHZhciBwID0gcGFyYW1zW2tdO1xuICAgICAgaWYocCkge1xuICAgICAgICBpZiAoXy5pc0FycmF5KHApKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHAubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHVybF9wYXJhbXMucHVzaChrICsgXCJbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwW2pdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBxID0gZW5jb2RlVVJJQ29tcG9uZW50KHApO1xuICAgICAgICAgIHEgPSBxLnJlcGxhY2UoLyU3QnglN0QvZyxcInt4fVwiKS5yZXBsYWNlKC8lN0J5JTdEL2csXCJ7eX1cIikucmVwbGFjZSgvJTdCeiU3RC9nLFwie3p9XCIpO1xuICAgICAgICAgIHVybF9wYXJhbXMucHVzaChrICsgXCI9XCIgKyBxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsX3BhcmFtcy5qb2luKCcmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgbGF5ZXIgb2YgYSBnaXZlbiB0eXBlLCBhcyB0aGUgdGlsZXIga3dvd3MgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB0eXBlcyAtIFR5cGUgb3IgdHlwZXMgb2YgbGF5ZXJzXG4gICAqL1xuICBfZ2V0TGF5ZXJJbmRleGVzQnlUeXBlOiBmdW5jdGlvbih0eXBlcykge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldCgnbWV0YWRhdGEnKSAmJiB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnM7XG5cbiAgICBpZiAoIWxheWVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGF5ZXJJbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBpc1ZhbGlkVHlwZSA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXNWYWxpZFR5cGUgPSB0eXBlcy5pbmRleE9mKGxheWVyLnR5cGUpICE9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGlzVmFsaWRUeXBlKSB7XG4gICAgICAgIGxheWVySW5kZXhlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJJbmRleGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxheWVyIG9mIGEgZ2l2ZW4gdHlwZSwgYXMgdGhlIHRpbGVyIGt3b3dzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gbnVtYmVyIG9mIGxheWVyIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJUeXBlIC0gdHlwZSBvZiB0aGUgbGF5ZXJzXG4gICAqL1xuICBfZ2V0TGF5ZXJJbmRleEJ5VHlwZTogZnVuY3Rpb24oaW5kZXgsIGxheWVyVHlwZSkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldCgnbWV0YWRhdGEnKSAmJiB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnM7XG5cbiAgICBpZiAoIWxheWVycykge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIHZhciB0aWxlckxheWVySW5kZXggPSB7fTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsYXllcnNbaV0udHlwZSA9PSBsYXllclR5cGUpIHtcbiAgICAgICAgdGlsZXJMYXllckluZGV4W2pdID0gaTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGlsZXJMYXllckluZGV4W2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiB0aWxlckxheWVySW5kZXhbaW5kZXhdO1xuICB9LFxuXG4gIGdldFdpZGdldFVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciB3aWRnZXRJZCA9IG9wdGlvbnMud2lkZ2V0SWQ7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbDtcbiAgICB2YXIgdXJsO1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldCgnbWV0YWRhdGEnKSAmJiB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnM7XG5cbiAgICBfLmVhY2gobGF5ZXJzLCBmdW5jdGlvbihsYXllcikge1xuICAgICAgdmFyIHdpZGdldHMgPSBsYXllci53aWRnZXRzO1xuICAgICAgZm9yICh2YXIgaWQgaW4gd2lkZ2V0cykge1xuICAgICAgICBpZiAod2lkZ2V0SWQgPT09IGlkKSB7XG4gICAgICAgICAgdXJsID0gd2lkZ2V0c1tpZF0udXJsW3Byb3RvY29sXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB1cmw7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBXaW5kc2hhZnRGaWx0ZXJzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vZmlsdGVycy9jb2xsZWN0aW9uJyk7XG52YXIgV2luZHNoYWZ0RmlsdGVyc0JvdW5kaW5nQm94RmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL2JvdW5kaW5nX2JveCcpO1xudmFyIFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtaW5zdGFuY2UnKTtcblxudmFyIFdpbmRzaGFmdERhc2hib2FyZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgQk9VTkRJTkdfQk9YX0ZJTFRFUl9XQUlUID0gNTAwO1xuXG4gIHRoaXMubGF5ZXJHcm91cCA9IG9wdGlvbnMubGF5ZXJHcm91cDtcbiAgdGhpcy5sYXllcnMgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbihvcHRpb25zLmxheWVycyk7XG4gIHRoaXMud2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcbiAgdGhpcy5tYXAgPSBvcHRpb25zLm1hcDtcbiAgdGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgdGhpcy5zdGF0VGFnID0gb3B0aW9ucy5zdGF0VGFnO1xuICB0aGlzLmNvbmZpZ0dlbmVyYXRvciA9IG9wdGlvbnMuY29uZmlnR2VuZXJhdG9yO1xuXG4gIHRoaXMuaW5zdGFuY2UgPSBuZXcgV2luZHNoYWZ0RGFzaGJvYXJkSW5zdGFuY2UoKTtcblxuICB0aGlzLm1hcC5iaW5kKCdjaGFuZ2U6Y2VudGVyIGNoYW5nZTp6b29tJywgXy5kZWJvdW5jZSh0aGlzLl9ib3VuZGluZ0JveENoYW5nZWQsIEJPVU5ESU5HX0JPWF9GSUxURVJfV0FJVCksIHRoaXMpO1xuXG4gIHRoaXMubGF5ZXJzLmJpbmQoJ2NoYW5nZScsIHRoaXMuX2xheWVyQ2hhbmdlZCwgdGhpcyk7XG4gIHRoaXMud2lkZ2V0cy5iaW5kKCdjaGFuZ2U6ZmlsdGVyJywgdGhpcy5fZmlsdGVyQ2hhbmdlZCwgdGhpcyk7XG5cbiAgdGhpcy5fY3JlYXRlSW5zdGFuY2UoKTtcbn07XG5cbldpbmRzaGFmdERhc2hib2FyZC5wcm90b3R5cGUuX2NyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGRhc2hib2FyZENvbmZpZyA9IHRoaXMuY29uZmlnR2VuZXJhdG9yLmdlbmVyYXRlKHtcbiAgICBsYXllcnM6IHRoaXMubGF5ZXJzLm1vZGVscyxcbiAgICB3aWRnZXRzOiB0aGlzLndpZGdldHNcbiAgfSk7XG5cblxuICB2YXIgZmlsdGVyc0Zyb21WaXNpYmxlTGF5ZXJzID0gdGhpcy53aWRnZXRzLmNoYWluKClcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHcubGF5ZXIuaXNWaXNpYmxlKCkgfSlcbiAgICAubWFwKGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHcuZmlsdGVyIH0pXG4gICAgLmNvbXBhY3QoKSAvLyBub3QgYWxsIHdpZGdldHMgaGF2ZSBmaWx0ZXJzXG4gICAgLnZhbHVlKCk7XG5cbiAgdmFyIGZpbHRlcnMgPSBuZXcgV2luZHNoYWZ0RmlsdGVyc0NvbGxlY3Rpb24oZmlsdGVyc0Zyb21WaXNpYmxlTGF5ZXJzKTtcblxuICB0aGlzLmNsaWVudC5pbnN0YW50aWF0ZU1hcCh7XG4gICAgbWFwRGVmaW5pdGlvbjogZGFzaGJvYXJkQ29uZmlnLFxuICAgIGZpbHRlcnM6IGZpbHRlcnMudG9KU09OKCksXG4gICAgc3VjY2VzczogZnVuY3Rpb24oZGFzaGJvYXJkSW5zdGFuY2UpIHtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBkYXNoYm9hcmQgaW5zdGFuY2Ugd2l0aCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbmV3IG9uZVxuICAgICAgdGhpcy5pbnN0YW5jZS5zZXQoZGFzaGJvYXJkSW5zdGFuY2UudG9KU09OKCkpO1xuXG4gICAgICAvLyBUT0RPOiBTZXQgdGhlIFVSTCBvZiB0aGUgYXR0cmlidXRlcyBzZXJ2aWNlIG9uY2UgaXQncyBhdmFpbGFibGVcbiAgICAgIHRoaXMubGF5ZXJHcm91cCAmJiB0aGlzLmxheWVyR3JvdXAuc2V0KHtcbiAgICAgICAgYmFzZVVSTDogZGFzaGJvYXJkSW5zdGFuY2UuZ2V0QmFzZVVSTCgpLFxuICAgICAgICB1cmxzOiBkYXNoYm9hcmRJbnN0YW5jZS5nZXRUaWxlcygnbWFwbmlrJylcbiAgICAgIH0pO1xuXG4gICAgICAvLyB1cGRhdGUgb3RoZXIga2luZCBvZiBsYXllcnMgdG9vXG4gICAgICB0aGlzLmxheWVycy5lYWNoKGZ1bmN0aW9uKGxheWVyLCBsYXllckluZGV4KSB7XG4gICAgICAgIGlmIChsYXllci5nZXQoJ3R5cGUnKSA9PT0gJ3RvcnF1ZScpIHtcbiAgICAgICAgICBsYXllci5zZXQoJ21ldGEnLCBkYXNoYm9hcmRJbnN0YW5jZS5nZXRMYXllck1ldGEobGF5ZXJJbmRleCkpO1xuICAgICAgICAgIGxheWVyLnNldCgndXJscycsIGRhc2hib2FyZEluc3RhbmNlLmdldFRpbGVzKCd0b3JxdWUnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl91cGRhdGVXaWRnZXRVUkxzKHtcbiAgICAgICAgbGF5ZXJJZDogb3B0aW9ucy5sYXllcklkXG4gICAgICB9KTtcblxuICAgIH0uYmluZCh0aGlzKSxcbiAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBjcmVhdGluZyBkYXNoYm9hcmQgaW5zdGFuY2U6ICcgKyBlcnJvcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbn07XG5cbldpbmRzaGFmdERhc2hib2FyZC5wcm90b3R5cGUuX2JvdW5kaW5nQm94Q2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pbnN0YW5jZS5pc0xvYWRlZCgpKSB7XG4gICAgdGhpcy5fdXBkYXRlV2lkZ2V0VVJMcygpO1xuICB9XG59O1xuXG5XaW5kc2hhZnREYXNoYm9hcmQucHJvdG90eXBlLl91cGRhdGVXaWRnZXRVUkxzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGJvdW5kaW5nQm94RmlsdGVyID0gbmV3IFdpbmRzaGFmdEZpbHRlcnNCb3VuZGluZ0JveEZpbHRlcih0aGlzLm1hcC5nZXRWaWV3Qm91bmRzKCkpO1xuICB2YXIgYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveEZpbHRlci50b1N0cmluZygpO1xuICB2YXIgbGF5ZXJJZCA9IG9wdGlvbnMubGF5ZXJJZDtcblxuICB0aGlzLndpZGdldHMuZWFjaChmdW5jdGlvbih3aWRnZXQpIHtcbiAgICB2YXIgdXJsID0gdGhpcy5pbnN0YW5jZS5nZXRXaWRnZXRVUkwoe1xuICAgICAgd2lkZ2V0SWQ6IHdpZGdldC5nZXQoJ2lkJyksXG4gICAgICBwcm90b2NvbDogJ2h0dHAnXG4gICAgfSk7XG5cbiAgICB2YXIgbGF5ZXJNZXRhID0gd2lkZ2V0LmxheWVyLmdldCgnbWV0YScpIHx8IHt9O1xuICAgIHZhciBleHRyYUF0dHJzID0ge307XG4gICAgaWYgKGxheWVyTWV0YS5zdGVwcyAmJiBsYXllck1ldGEuY29sdW1uX3R5cGUgJiYgXy5pc051bWJlcihsYXllck1ldGEuc3RhcnQpICYmIF8uaXNOdW1iZXIobGF5ZXJNZXRhLmVuZCkpIHtcbiAgICAgIGV4dHJhQXR0cnMgPSB7XG4gICAgICAgIGJpbnM6IGxheWVyTWV0YS5zdGVwcyxcbiAgICAgICAgY29sdW1uVHlwZTogbGF5ZXJNZXRhLmNvbHVtbl90eXBlLFxuICAgICAgICBzdGFydDogbGF5ZXJNZXRhLnN0YXJ0ICAvIDEwMDAsXG4gICAgICAgIGVuZDogIGxheWVyTWV0YS5lbmQgLyAxMDAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHdpZGdldC5zZXQoXy5leHRlbmQoe1xuICAgICAgJ3VybCc6IHVybCxcbiAgICAgICdib3VuZGluZ0JveCc6IGJvdW5kaW5nQm94XG4gICAgfSwgZXh0cmFBdHRycyksIHtcbiAgICAgIHNpbGVudDogbGF5ZXJJZCAmJiBsYXllcklkICE9PSB3aWRnZXQubGF5ZXIuZ2V0KCdpZCcpXG4gICAgfSk7XG4gIH0sIHRoaXMpO1xufTtcblxuV2luZHNoYWZ0RGFzaGJvYXJkLnByb3RvdHlwZS5fZmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uKHcpIHtcbiAgdGhpcy5fY3JlYXRlSW5zdGFuY2Uoe1xuICAgIGxheWVySWQ6IHcubGF5ZXIuZ2V0KCdpZCcpXG4gIH0pO1xufTtcblxuV2luZHNoYWZ0RGFzaGJvYXJkLnByb3RvdHlwZS5fbGF5ZXJDaGFuZ2VkID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIGxheWVySWQgPSBsYXllci5nZXQoJ2lkJyk7XG4gIHRoaXMuX2NyZWF0ZUluc3RhbmNlKHtcbiAgICBsYXllcklkOiBsYXllcklkXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnREYXNoYm9hcmQ7XG4iLCJ2YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbC5leHRlbmQoe1xuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IFwiRmlsdGVycyBtdXN0IGltcGxlbWVudCB0aGUgLmlzRW1wdHkgbWV0aG9kXCI7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBcIkZpbHRlcnMgbXVzdCBpbXBsZW1lbnQgdGhlIC50b0pTT04gbWV0aG9kXCI7XG4gIH1cbn0pO1xuIiwidmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICB0aGlzLnNldEJvdW5kcyhib3VuZHMpO1xuICB9LFxuXG4gIHNldEJvdW5kczogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgd2VzdDogYm91bmRzWzBdWzFdLFxuICAgICAgc291dGg6IGJvdW5kc1swXVswXSxcbiAgICAgIGVhc3Q6IGJvdW5kc1sxXVsxXSxcbiAgICAgIG5vcnRoOiBib3VuZHNbMV1bMF1cbiAgICB9KTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZ2V0KCd3ZXN0JyksXG4gICAgICB0aGlzLmdldCgnc291dGgnKSxcbiAgICAgIHRoaXMuZ2V0KCdlYXN0JyksXG4gICAgICB0aGlzLmdldCgnbm9ydGgnKVxuICAgIF0uam9pbignLCcpO1xuICB9XG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgV2luZHNoYWZ0RmlsdGVyQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG4vKipcbiAqICBGaWx0ZXIgdXNlZCBieSB0aGUgY2F0ZWdvcnkgd2lkZ2V0XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdEZpbHRlckJhc2UuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHJlamVjdEFsbDogZmFsc2VcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcyA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLmJpbmQoJ2FkZCByZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0KCdyZWplY3RBbGwnLCBmYWxzZSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMuYmluZCgnYWRkIHJlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQoJ3JlamVjdEFsbCcsIGZhbHNlKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3RlZENhdGVnb3JpZXMuc2l6ZSgpID09PSAwICYmIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLnNpemUoKSA9PT0gMCAmJiAhdGhpcy5nZXQoJ3JlamVjdEFsbCcpO1xuICB9LFxuXG4gIGFjY2VwdDogZnVuY3Rpb24odmFsdWVzLCBhcHBseUZpbHRlcikge1xuICAgIHZhbHVlcyA9ICFfLmlzQXJyYXkodmFsdWVzKSA/IFt2YWx1ZXNdIDogdmFsdWVzO1xuICAgIHZhciBhY2NlcHRlZENvdW50ID0gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMuc2l6ZSgpO1xuXG4gICAgXy5lYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBkID0geyBuYW1lOiB2YWx1ZSB9O1xuICAgICAgdmFyIHJlamVjdGVkTWRscyA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLndoZXJlKGQpO1xuICAgICAgdmFyIGFjY2VwdGVkTWRscyA9IHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLndoZXJlKGQpO1xuICAgICAgaWYgKHJlamVjdGVkTWRscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnJlbW92ZShyZWplY3RlZE1kbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFhY2NlcHRlZE1kbHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLmFkZChkKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmIChhcHBseUZpbHRlciAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgYWNjZXB0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgncmVqZWN0QWxsJywgZmFsc2UpO1xuICAgIHRoaXMuY2xlYW5GaWx0ZXIoKTtcbiAgfSxcblxuICBpc0FjY2VwdGVkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLndoZXJlKHsgbmFtZTogbmFtZSB9KS5sZW5ndGggPiAwO1xuICB9LFxuXG4gIGdldEFjY2VwdGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXM7XG4gIH0sXG5cbiAgcmVqZWN0OiBmdW5jdGlvbih2YWx1ZXMsIGFwcGx5RmlsdGVyKSB7XG4gICAgdmFsdWVzID0gIV8uaXNBcnJheSh2YWx1ZXMpID8gW3ZhbHVlc10gOiB2YWx1ZXM7XG5cbiAgICBfLmVhY2godmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGQgPSB7IG5hbWU6IHZhbHVlIH07XG4gICAgICB2YXIgYWNjZXB0ZWRNZGxzID0gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMud2hlcmUoZCk7XG4gICAgICB2YXIgcmVqZWN0ZWRNZGxzID0gdGhpcy5yZWplY3RlZENhdGVnb3JpZXMud2hlcmUoZCk7XG4gICAgICBpZiAoYWNjZXB0ZWRNZGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMucmVtb3ZlKGFjY2VwdGVkTWRscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXJlamVjdGVkTWRscy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5hZGQoZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmIChhcHBseUZpbHRlciAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgaXNSZWplY3RlZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciByZWplY3RDb3VudCA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnNpemUoKTtcbiAgICB2YXIgYWNjZXB0Q291bnQgPSB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5zaXplKCk7XG4gICAgaWYgKHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLndoZXJlKHsgbmFtZTogbmFtZSB9KS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGFjY2VwdENvdW50ID4gMCAmJiB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy53aGVyZSh7IG5hbWU6IG5hbWUgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KCdyZWplY3RBbGwnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UmVqZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcztcbiAgfSxcblxuICByZWplY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdyZWplY3RBbGwnLCB0cnVlKTtcbiAgICB0aGlzLmNsZWFuRmlsdGVyKCk7XG4gIH0sXG5cbiAgY2xlYW5GaWx0ZXI6IGZ1bmN0aW9uKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5yZXNldCgpO1xuICAgIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnJlc2V0KCk7XG4gICAgaWYgKHRyaWdnZXJDaGFuZ2UgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5RmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlciA9IHt9O1xuICAgIHZhciByZWplY3RDb3VudCA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnNpemUoKTtcbiAgICB2YXIgYWNjZXB0Q291bnQgPSB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5zaXplKCk7XG4gICAgdmFyIGFjY2VwdGVkQ2F0cyA9IHvCoGFjY2VwdDogXy5wbHVjayh0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy50b0pTT04oKSwgJ25hbWUnKSB9O1xuICAgIHZhciByZWplY3RlZENhdHMgPSB7IHJlamVjdDogXy5wbHVjayh0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy50b0pTT04oKSwgJ25hbWUnKSB9O1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdyZWplY3RBbGwnKSkge1xuICAgICAgZmlsdGVyID0geyBhY2NlcHQ6IFtdIH07XG4gICAgfSBlbHNlIGlmIChhY2NlcHRDb3VudCA+IDApIHtcbiAgICAgIGZpbHRlciA9IGFjY2VwdGVkQ2F0cztcbiAgICB9IGVsc2UgaWYgKHJlamVjdENvdW50ID4gMCAmJiBhY2NlcHRDb3VudCA9PT0gMCkge1xuICAgICAgZmlsdGVyID0gcmVqZWN0ZWRDYXRzO1xuICAgIH1cblxuICAgIHZhciBqc29uID0ge307XG4gICAganNvblt0aGlzLmdldCgnd2lkZ2V0SWQnKV0gPSBmaWx0ZXI7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBqc29uID0ge307XG4gICAgdmFyIGFjdGl2ZUZpbHRlcnMgPSB0aGlzLmdldEFjdGl2ZUZpbHRlcnMoKTtcbiAgICBpZiAoYWN0aXZlRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGpzb24ubGF5ZXJzID0gW107XG4gICAgICBfLmVhY2goYWN0aXZlRmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGlmICghZmlsdGVyLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGZpbHRlci5nZXQoJ2xheWVySW5kZXgnKTtcbiAgICAgICAgICBpZiAoanNvbi5sYXllcnNbaW5kZXhdKSB7XG4gICAgICAgICAgICBfLmV4dGVuZChqc29uLmxheWVyc1tpbmRleF0sZmlsdGVyLnRvSlNPTigpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAganNvbi5sYXllcnNbaW5kZXhdID0gZmlsdGVyLnRvSlNPTigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBmaWxsIHRoZSBob2xlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBqc29uLmxheWVyc1tpXSA9IGpzb24ubGF5ZXJzW2ldIHx8IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9LFxuXG4gIGdldEFjdGl2ZUZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHJldHVybiAhZmlsdGVyLmlzRW1wdHkoKTtcbiAgICB9KTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpbmRzaGFmdEZpbHRlckJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnRGaWx0ZXJCYXNlLmV4dGVuZCh7XG5cbiAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodGhpcy5nZXQoJ21pbicpKSAmJiBfLmlzVW5kZWZpbmVkKHRoaXMuZ2V0KCdtYXgnKSk7XG4gIH0sXG5cbiAgc2V0UmFuZ2U6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH0pO1xuICB9LFxuXG4gIHVuc2V0UmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0UmFuZ2UodW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGpzb24gPSB7fTtcbiAgICBqc29uW3RoaXMuZ2V0KCd3aWRnZXRJZCcpXSA9IHtcbiAgICAgIG1pbjogdGhpcy5nZXQoJ21pbicpLFxuICAgICAgbWF4OiB0aGlzLmdldCgnbWF4JyksXG4gICAgICBjb2x1bW5fdHlwZTogdGhpcy5nZXQoJ2NvbHVtblR5cGUnKVxuICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWcgPSB7fTtcblxuV2luZHNoYWZ0UHJpdmF0ZURhc2hib2FyZENvbmZpZy5nZW5lcmF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGxheWVycyA9IG9wdGlvbnMubGF5ZXJzO1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgXy5lYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIsIGluZGV4KXtcbiAgICBjb25maWdbJ2xheWVyJyArIGluZGV4XSA9IGxheWVyLmlzVmlzaWJsZSgpID8gMSA6IDA7XG4gIH0pO1xuXG4gIC8vIFRPRE86IFdlIHNob3VsZCBhZGQgdGhlIHBhcmFtc1xuICAvLyBUT0RPOiBXZSBzaG91bGQgYWRkIHRoZSBhdXRoX3Rva2VuXG4gIHJldHVybiBjb25maWc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWc7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpbmRzaGFmdFB1YmxpY0Rhc2hib2FyZENvbmZpZyA9IHt9O1xuXG5XaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWcuZ2VuZXJhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgdmFyIHdpZGdldHMgPSBvcHRpb25zLndpZGdldHM7XG4gIHZhciBjb25maWcgPSB7IGxheWVyczogW10gfTtcbiAgXy5lYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIuaXNWaXNpYmxlKCkpIHtcbiAgICAgIHZhciBsYXllckNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogbGF5ZXIuZ2V0KCd0eXBlJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNxbDogbGF5ZXIuZ2V0KCdzcWwnKSxcbiAgICAgICAgICBjYXJ0b2NzczogbGF5ZXIuZ2V0KCdjYXJ0b2NzcycpLFxuICAgICAgICAgIGNhcnRvY3NzX3ZlcnNpb246IGxheWVyLmdldCgnY2FydG9jc3NfdmVyc2lvbicpLFxuICAgICAgICAgIGludGVyYWN0aXZpdHk6IGxheWVyLmdldEludGVyYWN0aXZlQ29sdW1uTmFtZXMoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGxheWVyLmdldEluZm93aW5kb3dGaWVsZE5hbWVzKCkubGVuZ3RoKSB7XG4gICAgICAgIGxheWVyQ29uZmlnLm9wdGlvbnMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBpZDogXCJjYXJ0b2RiX2lkXCIsXG4gICAgICAgICAgY29sdW1uczogbGF5ZXIuZ2V0SW5mb3dpbmRvd0ZpZWxkTmFtZXMoKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsYXllckNvbmZpZy5vcHRpb25zLndpZGdldHMgPSB7fTtcbiAgICAgIHZhciBsYXllcklkID0gbGF5ZXIuZ2V0KCdpZCcpO1xuICAgICAgd2lkZ2V0cy5lYWNoKGZ1bmN0aW9uKHdpZGdldCkge1xuICAgICAgICBpZiAobGF5ZXJJZCA9PT0gd2lkZ2V0LmxheWVyLmdldCgnaWQnKSkge1xuICAgICAgICAgIGxheWVyQ29uZmlnLm9wdGlvbnMud2lkZ2V0c1t3aWRnZXQuZ2V0KCdpZCcpXSA9IHdpZGdldC50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25maWcubGF5ZXJzLnB1c2gobGF5ZXJDb25maWcpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZHNoYWZ0UHVibGljRGFzaGJvYXJkQ29uZmlnO1xuIl19
