// cartodb.js version:
// uncompressed version: cartodb.mod.torque.uncompressed.js
// sha: d082dfc34a5ad15d2b1769707562cc8435477f8b
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
//     Backbone.js 1.2.3

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = (typeof self == 'object' && self.self == self && self) ||
            (typeof global == 'object' && global.global == global && global);

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'), $;
    try { $ = require('jquery-cdb-v3'); } catch(e) {}
    factory(root, exports, _, $);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.2.3';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function(length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return _[method](this[attribute]);
      };
      case 2: return function(value) {
        return _[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return _[method](this[attribute], cb(iteratee, this), context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return _[method].apply(_, args);
      };
    }
  };
  var addUnderscoreMethods = function(Class, methods, attribute) {
    _.each(methods, function(length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
    return iteratee;
  };
  var modelMatcher = function(attrs) {
    var matcher = _.matches(attrs);
    return function(model) {
      return matcher(model.attributes);
    };
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function(iteratee, events, name, callback, opts) {
    var i = 0, names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length ; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {
    return internalOn(this, name, callback, context);
  };

  // Guard the `listening` argument from the public API.
  var internalOn = function(obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
        context: context,
        ctx: obj,
        listening: listening
    });

    if (listening) {
      var listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    return obj;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo =  function(obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
    }

    // Bind callbacks on obj, and keep track of them on listening.
    internalOn(obj, name, callback, this, listening);
    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context, ctx = options.ctx, listening = options.listening;
      if (listening) listening.count++;

      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off =  function(name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
        context: context,
        listeners: this._listeners
    });
    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening =  function(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
    }
    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {
    if (!events) return;

    var i = 0, listening;
    var context = options.context, listeners = options.listeners;

    // Delete all events listeners and "drop" events.
    if (!name && !callback && !context) {
      var ids = _.keys(listeners);
      for (; i < ids.length; i++) {
        listening = listeners[ids[i]];
        delete listeners[listening.id];
        delete listening.listeningTo[listening.objId];
      }
      return;
    }

    var names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Replace events if there are any remaining.  Otherwise, clean up.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (
          callback && callback !== handler.callback &&
            callback !== handler.callback._callback ||
              context && context !== handler.context
        ) {
          remaining.push(handler);
        } else {
          listening = handler.listening;
          if (listening && --listening.count === 0) {
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
        }
      }

      // Update tail event if the list has any events.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }
    if (_.size(events)) return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once =  function(name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
    return this.on(events, void 0, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce =  function(obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function() {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger =  function(name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, cb, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset      = options.unset;
      var silent     = options.silent;
      var changes    = [];
      var changing   = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev    = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      this.id = this.get(this.idAttribute);

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
      }
      return _.size(changed) ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.defaults({validate: true}, options));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
      omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Splices `insert` into `array` at index `at`.
  var splice = function(array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    for (var i = 0; i < tail.length; i++) tail[i] = array[i + at];
    for (i = 0; i < length; i++) array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model) { return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      var removed = this._removeModels(models, options);
      if (!options.silent && removed) this.trigger('update', this, options);
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      if (models == null) return;

      options = _.defaults({}, options, setOptions);
      if (options.parse && !this._isModel(models)) models = this.parse(models, options);

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model;
      for (var i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length != set.length || _.some(this.models, function(model, index) {
          return model !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length) this.trigger('update', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp, callbackOpts) {
        if (wait) collection.add(model, callbackOpts);
        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function (attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed.length ? removed : false;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function (model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (event === 'change') {
        var prevId = this.modelId(model.previousAttributes());
        var id = this.modelId(model.attributes);
        if (prevId !== id) {
          if (prevId != null) delete this._byId[prevId];
          if (id != null) this._byId[id] = model;
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
      sortBy: 3, indexBy: 3};

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], _.bind(method, this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    this.checkUrl = _.bind(this.checkUrl, this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var root = path.slice(0, this.root.length - 1) + '/';
      return root === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var root = this.root.slice(0, -1) || '/';
          this.location.replace(root + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function (eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function (eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var root = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        root = root.slice(0, -1) || '/';
      }
      var url = root + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"jquery":"jquery","underscore":9}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":8}],4:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],5:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":6}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],8:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":7,"_process":6,"inherits":4}],9:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],10:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone-cdb-v3');

/**
 * base layer for all google maps
 */
var GMapsLayerView = function(layerModel, gmapsLayer, gmapsMap) {
  this.gmapsLayer = gmapsLayer;
  this.map = this.gmapsMap = gmapsMap;
  this.model = layerModel;
  this.model.bind('change', this._update, this);

  this.type = layerModel.get('type') || layerModel.get('kind');
  this.type = this.type.toLowerCase();
};

_.extend(GMapsLayerView.prototype, Backbone.Events);
_.extend(GMapsLayerView.prototype, {

  // hack function to search layer inside google maps layers
  _searchLayerIndex: function() {
    var self = this;
    var index = -1;
    this.gmapsMap.overlayMapTypes.forEach(
      function(layer, i) {
        if (layer == self) {
          index = i;
        }
      }
    );
    return index;
  },

  /**
   * remove layer from the map and unbind events
   */
  remove: function() {
    if(!this.isBase) {
      var self = this;
      var idx = this._searchLayerIndex();
      if(idx >= 0) {
        this.gmapsMap.overlayMapTypes.removeAt(idx);
      } else if (this.gmapsLayer.setMap){
        this.gmapsLayer.setMap(null);
      }
      this.model.unbind(null, null, this);
      this.unbind();
    }
  },

  refreshView: function() {
    var self = this;
    //reset to update
    if(this.isBase) {
      var a = '_baseLayer';
      this.gmapsMap.setMapTypeId(null);
      this.gmapsMap.mapTypes.set(a, this.gmapsLayer);
      this.gmapsMap.setMapTypeId(a);
    } else {
      var idx = this._searchLayerIndex();
      if(idx >= 0) {
        this.gmapsMap.overlayMapTypes.setAt(idx, this);
      }
    }
  },

  reload: function() { this.refreshView() ; },
  _update: function() { this.refreshView(); }

});

module.exports = GMapsLayerView;

},{"backbone":1,"underscore":9}],11:[function(require,module,exports){
// Depends on cartodb standard bundle being loaded and present in global namespace
var torque = require('torque.js');
var cdb = window.cdb;
var _ = cdb._;
var Backbone = cdb.Backbone;

var GMapsLayerView = require('cdb/geo/gmaps/gmaps-layer-view');
var CartoDBLogo = cdb.geo.common.CartoDBLogo;

var GMapsTorqueLayerView = function(layerModel, gmapsMap) {

  var extra = layerModel.get('extra_params');
  GMapsLayerView.call(this, layerModel, this, gmapsMap);

  var query = this._getQuery(layerModel);
  torque.GMapsTorqueLayer.call(this, {
      table: layerModel.get('table_name'),
      user: layerModel.get('user_name'),
      column: layerModel.get('property'),
      blendmode: layerModel.get('torque-blend-mode'),
      resolution: 1,
      //TODO: manage time columns
      countby: 'count(cartodb_id)',
      sql_api_domain: layerModel.get('sql_api_domain'),
      sql_api_protocol: layerModel.get('sql_api_protocol'),
      sql_api_port: layerModel.get('sql_api_port'),
      tiler_protocol: layerModel.get('tiler_protocol'),
      tiler_domain: layerModel.get('tiler_domain'),
      tiler_port: layerModel.get('tiler_port'),
      maps_api_template: layerModel.get('maps_api_template'),
      stat_tag: layerModel.get('stat_tag'),
      animationDuration: layerModel.get('torque-duration'),
      steps: layerModel.get('torque-steps'),
      sql: query,
      visible: layerModel.get('visible'),
      extra_params: {
        api_key: extra ? extra.map_key: ''
      },
      map: gmapsMap,
      cartodb_logo: layerModel.get('cartodb_logo'),
      attribution: layerModel.get('attribution'),
      cartocss: layerModel.get('cartocss') || layerModel.get('tile_style'),
      named_map: layerModel.get('named_map'),
      auth_token: layerModel.get('auth_token'),
      no_cdn: layerModel.get('no_cdn'),
      loop: layerModel.get('loop') === false? false: true,
  });

  //this.setCartoCSS(this.model.get('tile_style'));
  if (layerModel.get('visible')) {
    this.play();
  }

  layerModel.initForTorqueLayerView(this);
};

_.extend(
  GMapsTorqueLayerView.prototype,
  GMapsLayerView.prototype,
  torque.GMapsTorqueLayer.prototype,
  {

  _update: function() {
    var changed = this.model.changedAttributes();
    if(changed === false) return;
    changed.tile_style && this.setCartoCSS(this.model.get('tile_style'));
    if ('query' in changed || 'query_wrapper' in changed) {
      this.setSQL(this._getQuery(this.model));
    }
    if ('visible' in changed)
      this.model.get('visible') ? this.show(): this.hide();
  },

  _getQuery: function(layerModel) {
    var query = layerModel.get('query');
    var qw = layerModel.get('query_wrapper');
    if(qw) {
      query = _.template(qw)({ sql: query || ('select * from ' + layerModel.get('table_name')) });
    }
    return query;
  },

  refreshView: function() {
    //TODO: update screen
  },

  onAdd: function() {
    torque.GMapsTorqueLayer.prototype.onAdd.apply(this);
    // Add CartoDB logo
    if (this.options.cartodb_logo != false)
      CartoDBLogo.addWadus({ left: 74, bottom:8 }, 2000, this.map.getDiv())
  },

  onTilesLoaded: function() {
    //this.trigger('load');
    Backbone.Events.trigger.call(this, 'load');
  },

  onTilesLoading: function() {
    Backbone.Events.trigger.call(this, 'loading');
  }

});

module.exports = GMapsTorqueLayerView;

},{"cdb/geo/gmaps/gmaps-layer-view":10,"torque.js":25}],12:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone-cdb-v3');

/**
 * base layer for all leaflet layers
 */
var LeafletLayerView = function(layerModel, leafletLayer, leafletMap) {
  this.leafletLayer = leafletLayer;
  this.leafletMap = leafletMap;
  this.model = layerModel;

  this.setModel(layerModel);

  this.type = layerModel.get('type') || layerModel.get('kind');
  this.type = this.type.toLowerCase();
};

_.extend(LeafletLayerView.prototype, Backbone.Events);
_.extend(LeafletLayerView.prototype, {

  setModel: function(model) {
    if (this.model) {
      this.model.unbind('change', this._modelUpdated, this);
    }
    this.model = model;
    this.model.bind('change', this._modelUpdated, this);
  },

  /**
   * remove layer from the map and unbind events
   */
  remove: function() {
    this.leafletMap.removeLayer(this.leafletLayer);
    this.trigger('remove', this);
    this.model.unbind(null, null, this);
    this.unbind();
  },

  reload: function() {
    this.leafletLayer.redraw();
  }

});

module.exports = LeafletLayerView;

},{"backbone":1,"underscore":9}],13:[function(require,module,exports){
// NOTE this is ONLY used for torque bundle AND the leaflet.spec.js, that assumed torque lib to be loaded)
// Depends on cartodb to be loaded and present in global namespace.
var cdb = window.cdb;
var L = cdb.L;
var _ = cdb._;
var util = cdb.core.util;
var LeafletLayerView = require('cdb/geo/leaflet/leaflet-layer-view');
var CartoDBLogo = cdb.geo.common.CartoDBLogo;

/**
 * leaflet torque layer
 */
var LeafletTorqueLayer = L.TorqueLayer.extend({

  initialize: function(layerModel, leafletMap) {
    var extra = layerModel.get('extra_params');

    var query = this._getQuery(layerModel);

    // initialize the base layers
    L.TorqueLayer.prototype.initialize.call(this, {
      table: layerModel.get('table_name'),
      user: layerModel.get('user_name'),
      column: layerModel.get('property'),
      blendmode: layerModel.get('torque-blend-mode'),
      resolution: 1,
      //TODO: manage time columns
      countby: 'count(cartodb_id)',
      sql_api_domain: layerModel.get('sql_api_domain'),
      sql_api_protocol: layerModel.get('sql_api_protocol'),
      sql_api_port: layerModel.get('sql_api_port'),
      tiler_protocol: layerModel.get('tiler_protocol'),
      tiler_domain: layerModel.get('tiler_domain'),
      tiler_port: layerModel.get('tiler_port'),
      maps_api_template: layerModel.get('maps_api_template'),
      stat_tag: layerModel.get('stat_tag'),
      animationDuration: layerModel.get('torque-duration'),
      steps: layerModel.get('torque-steps'),
      sql: query,
      visible: layerModel.get('visible'),
      extra_params: {
        api_key: extra ? extra.map_key: ''
      },
      cartodb_logo: layerModel.get('cartodb_logo'),
      attribution: layerModel.get('attribution'),
      cartocss: layerModel.get('cartocss') || layerModel.get('tile_style'),
      named_map: layerModel.get('named_map'),
      auth_token: layerModel.get('auth_token'),
      no_cdn: layerModel.get('no_cdn'),
      dynamic_cdn: layerModel.get('dynamic_cdn'),
      loop: layerModel.get('loop') === false? false: true,
      instanciateCallback: function() {
        var cartocss = layerModel.get('cartocss') || layerModel.get('tile_style');

        return '_cdbct_' + util.uniqueCallbackName(cartocss + query);
      }
    });

    LeafletLayerView.call(this, layerModel, this, leafletMap);

    // match leaflet events with backbone events
    this.fire = this.trigger;

    //this.setCartoCSS(layerModel.get('tile_style'));
    if (layerModel.get('visible')) {
      this.play();
    }

    this.bind('tilesLoaded', function() {
      this.trigger('load');
    }, this);

    this.bind('tilesLoading', function() {
      this.trigger('loading');
    }, this);

    layerModel.initForTorqueLayerView(this);
  },

  onAdd: function(map) {
    L.TorqueLayer.prototype.onAdd.apply(this, [map]);
    // Add CartoDB logo
    if (this.options.cartodb_logo != false)
      CartoDBLogo.addWadus({ left:8, bottom:8 }, 0, map._container)
  },

  _getQuery: function(layerModel) {
    var query = layerModel.get('query');
    var qw = layerModel.get('query_wrapper');
    if(qw) {
      query = _.template(qw)({ sql: query || ('select * from ' + layerModel.get('table_name')) });
    }
    return query;
  },

  _modelUpdated: function(model) {
    var changed = this.model.changedAttributes();
    if(changed === false) return;
    /*
    changed.tile_style && this.setCartoCSS(this.model.get('tile_style'));
    if ('query' in changed || 'query_wrapper' in changed) {
      this.setSQL(this._getQuery(this.model));
    }
    */

    if ('visible' in changed)
      this.model.get('visible') ? this.show(): this.hide();

    if ('urls' in changed) {
      // REAL HACK
      this.provider.templateUrl = this.model.get('urls').tiles[0];
      this.provider._setReady(true);
      this._reloadTiles();
    }
  }
});

_.extend(LeafletTorqueLayer.prototype, LeafletLayerView.prototype);

module.exports = LeafletTorqueLayer;

},{"cdb/geo/leaflet/leaflet-layer-view":12}],14:[function(require,module,exports){
var torque = window.torque = require('torque.js'); // standalone torque lib, required for gmaps/leaflet layer view

// Get and mutate the global cdb object, add expected objects for gmaps/leaflet if present:
var cdb = window.cdb;
if (!cdb) {
  throw new Error('cartodb.js is required for this lib to work, load it before this one');
}

if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
  cdb.geo.GMapsTorqueLayerView = require('./geo/gmaps/gmaps-torque-layer-view');
}

cdb.geo.LeafletTorqueLayer = require('./geo/leaflet/leaflet-torque-layer');

cdb.moduleLoad('torque', torque);

module.exports = torque;

},{"./geo/gmaps/gmaps-torque-layer-view":11,"./geo/leaflet/leaflet-torque-layer":13,"torque.js":25}],15:[function(require,module,exports){
/**
 * Abstract handler for animator steps
 */
var AnimatorStepsRange = function(start, end) {
  if (start < 0) throw new Error('start must be a positive number');
  if (start >= end) throw new Error('start must be smaller than end');

  this.start = start;
  this.end = end;
};

AnimatorStepsRange.prototype = {

  diff: function() {
    return this.end - this.start;
  },

  isLast: function(step) {
    // round step into an integer, to be able to compare number as expected (also converts bad input to 0)
    return (step | 0) === this.end;
  }
};

module.exports = AnimatorStepsRange;

},{}],16:[function(require,module,exports){
(function (global){
var torque = require('./');
var AnimatorStepsRange = require('./animator-steps-range');

var requestAnimationFrame = global.requestAnimationFrame
    || global.mozRequestAnimationFrame
    || global.webkitRequestAnimationFrame
    || global.msRequestAnimationFrame
    || function(callback) { return global.setTimeout(callback, 1000 / 60); };

var cancelAnimationFrame = global.cancelAnimationFrame
    || global.mozCancelAnimationFrame
    || global.webkitCancelAnimationFrame
    || global.msCancelAnimationFrame
    || function(id) { clearTimeout(id); };

  /**
   * options:
   *    animationDuration in seconds
   *    animationDelay in seconds
   */
  function Animator(callback, options) {
    if(!options.steps) {
      throw new Error("steps option missing")
    }
    this.options = options;
    this.running = false;
    this._tick = this._tick.bind(this);
    this._t0 = +new Date();
    this.callback = callback;
    this._time = 0.0;
    this.itemsReady = false;

    this.options = torque.extend({
        animationDelay: 0,
        maxDelta: 0.2,
        loop: options.loop === undefined ? true : options.loop
    }, this.options);

    this.steps(options.steps);
  }

  Animator.prototype = {

    start: function() {
        this.running = true;
        requestAnimationFrame(this._tick);
        this.options.onStart && this.options.onStart();
        if (this.stepsRange().diff() === 1) {
          this.running = false;
        }
    },

    isRunning: function() {
      return this.running;
    },

    stop: function() {
      this.pause();
      this.time(this.stepsRange().start);
      this.options.onStop && this.options.onStop();
    },

    // real animation time
    time: function(_) {
      if (!arguments.length) return this._time;
      this._time = _;
      var t = this.range(this.domain(this._time));
      this.callback(t);
    },

    toggle: function() {
      if (this.running) {
        this.pause()
      } else {
        this.start()
      }
    },

    rescale: function() {
      this.domainInv = torque.math.linear(this.options.animationDelay, this.options.animationDelay + this.options.animationDuration);
      this.domain = this.domainInv.invert();
      this.range = torque.math.linear(0, this._defaultStepsRange.end);
      this.rangeInv = this.range.invert();
      this.time(this._time);
      this.running? this.start(): this.pause();
      return this;
    },

    duration: function(_) {
      if (!arguments.length)  return this.options.animationDuration;
      this.options.animationDuration = _;
      if (this.time() > _) {
        this.time(0);
      }
      this.rescale();
      return this;
    },

    steps: function(_) {
      this.options.steps = _;
      this._defaultStepsRange = new AnimatorStepsRange(0, _);
      return this.rescale();
    },

    // Returns or sets a (custom) steps range
    // Setting a steps range must be within the full range
    stepsRange: function(start, end) {
      if (arguments.length === 2) {
        if (start < this._defaultStepsRange.start) throw new Error('start must be within default steps range');
        if (end > this._defaultStepsRange.end) throw new Error('end must be within default steps range');

        this._customStepsRange = new AnimatorStepsRange(start, end);
        this.options.onStepsRange && this.options.onStepsRange();

        // Change current step if it's outside the new custom range
        var step = this.step() | 0; // round to an integer
        if (step < start || step > end) {
          this.step(start);
        }
      }
      return this._customStepsRange || this._defaultStepsRange;
    },

    removeCustomStepsRange: function() {
      this._customStepsRange = undefined;
      this.options.onStepsRange && this.options.onStepsRange();
    },

    step: function(s) {
      if(arguments.length === 0) return this.range(this.domain(this._time));
      this._time = this.domainInv(this.rangeInv(s));
    },

    pause: function() {
      this.running = false;
      cancelAnimationFrame(this._tick);
      this.options.onPause && this.options.onPause();
    },

    _tick: function() {
      var t1 = +new Date();
      var delta = (t1 - this._t0)*0.001;
      // if delta is really big means the tab lost the focus
      // at some point, so limit delta change
      delta = Math.min(this.options.maxDelta, delta);
      this._t0 = t1;
      this._time += delta;

      var stepsRange = this.stepsRange();
      if (stepsRange.isLast(this.step())) {
        if(!this.options.loop){
          // set time to max time
          this.time(this.options.animationDuration);
          this.pause();
        } else {
          this.step(stepsRange.start);
        }
      }
      if(this.running) {
        this.time(this._time);
        requestAnimationFrame(this._tick);
      }
    }

  };

module.exports = Animator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./":25,"./animator-steps-range":15}],17:[function(require,module,exports){
var _torque_reference_latest = {
    "version": "1.0.0",
    "style": {
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": [
                "src", //
                "src-over", //
                "dst-over", //
                "src-in", //
                "dst-in", //
                "src-out", //
                "dst-out", //
                "src-atop", //
                "dst-atop", //
                "xor", //
                "darken", //
                "lighten" //
            ]
        }
    },
    "layer" : {
        "buffer-size": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "-torque-clear-color": {
            "css": "-torque-clear-color",
            "type": "color",
            "default-value": "rgba(255, 255, 255, 0)",
            "default-meaning": "full clear",
            "doc": "color used to clear canvas on each frame"
        },
        "-torque-frame-count": {
            "css": "-torque-frame-count",
            "default-value": "128",
            "type":"number",
            "default-meaning": "the data is broken into 128 time frames",
            "doc": "Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used."
        },
        "-torque-resolution": {
            "css": "-torque-resolution",
            "default-value": "2",
            "type":"number",
            "default-meaning": "",
            "doc": "Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2"
        },
        "-torque-animation-duration": {
            "css": "-torque-animation-duration",
            "default-value": "30",
            "type":"number",
            "default-meaning": "the animation lasts 30 seconds",
            "doc": "Animation duration in seconds"
        },
        "-torque-aggregation-function": {
            "css": "-torque-aggregation-function",
            "default-value": "count(cartodb_id)",
            "type": "string",
            "default-meaning": "the value for each cell is the count of points in that cell",
            "doc": "A function used to calculate a value from the aggregate data for each cell. See -torque-resolution"
        },
        "-torque-time-attribute": {
            "css": "-torque-time-attribute",
            "default-value": "time",
            "type": "string",
            "default-meaning": "the data column in your table that is of a time based type",
            "doc": "The table column that contains the time information used create the animation"
        },
        "-torque-data-aggregation": {
            "css": "-torque-data-aggregation",
            "default-value": "linear",
            "type": [
              "cumulative"
            ],
            "default-meaning": "previous values are discarded",
            "doc": "A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts"
        }
    },
    "symbolizers" : {
        "*": {
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": [
                  "src", //
                  "src-over", //
                  "dst-over", //
                  "src-in", //
                  "dst-in", //
                  "src-out", //
                  "dst-out", //
                  "src-atop", //
                  "dst-atop", //
                  "xor", //
                  "darken", //
                  "lighten" //
                ]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "trail": {
          "steps": {
            "css": "trail-steps",
            "type": "float",
            "default-value": 1,
            "default-meaning": "no trail steps",
            "doc": "How many steps of trails are going to be rendered"
          }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon"
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque"
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line"
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels"
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": [
                    "miter",
                    "round",
                    "bevel"
                ],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": [
                    "butt",
                    "round",
                    "square"
                ],
                "doc": "The display of line endings"
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri"
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color"
            },
            "marker-type": {
                "css": "marker-type",
                "type": [
                    "rectangle",
                    "ellipse"
                ],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an rectangle or an ellipse (a circle if height is equal to width)"
            },
             "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "float"
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            }
        }
    },
    "colors": {
        "aliceblue":  [240, 248, 255],
        "antiquewhite":  [250, 235, 215],
        "aqua":  [0, 255, 255],
        "aquamarine":  [127, 255, 212],
        "azure":  [240, 255, 255],
        "beige":  [245, 245, 220],
        "bisque":  [255, 228, 196],
        "black":  [0, 0, 0],
        "blanchedalmond":  [255,235,205],
        "blue":  [0, 0, 255],
        "blueviolet":  [138, 43, 226],
        "brown":  [165, 42, 42],
        "burlywood":  [222, 184, 135],
        "cadetblue":  [95, 158, 160],
        "chartreuse":  [127, 255, 0],
        "chocolate":  [210, 105, 30],
        "coral":  [255, 127, 80],
        "cornflowerblue":  [100, 149, 237],
        "cornsilk":  [255, 248, 220],
        "crimson":  [220, 20, 60],
        "cyan":  [0, 255, 255],
        "darkblue":  [0, 0, 139],
        "darkcyan":  [0, 139, 139],
        "darkgoldenrod":  [184, 134, 11],
        "darkgray":  [169, 169, 169],
        "darkgreen":  [0, 100, 0],
        "darkgrey":  [169, 169, 169],
        "darkkhaki":  [189, 183, 107],
        "darkmagenta":  [139, 0, 139],
        "darkolivegreen":  [85, 107, 47],
        "darkorange":  [255, 140, 0],
        "darkorchid":  [153, 50, 204],
        "darkred":  [139, 0, 0],
        "darksalmon":  [233, 150, 122],
        "darkseagreen":  [143, 188, 143],
        "darkslateblue":  [72, 61, 139],
        "darkslategrey":  [47, 79, 79],
        "darkturquoise":  [0, 206, 209],
        "darkviolet":  [148, 0, 211],
        "deeppink":  [255, 20, 147],
        "deepskyblue":  [0, 191, 255],
        "dimgray":  [105, 105, 105],
        "dimgrey":  [105, 105, 105],
        "dodgerblue":  [30, 144, 255],
        "firebrick":  [178, 34, 34],
        "floralwhite":  [255, 250, 240],
        "forestgreen":  [34, 139, 34],
        "fuchsia":  [255, 0, 255],
        "gainsboro":  [220, 220, 220],
        "ghostwhite":  [248, 248, 255],
        "gold":  [255, 215, 0],
        "goldenrod":  [218, 165, 32],
        "gray":  [128, 128, 128],
        "grey":  [128, 128, 128],
        "green":  [0, 128, 0],
        "greenyellow":  [173, 255, 47],
        "honeydew":  [240, 255, 240],
        "hotpink":  [255, 105, 180],
        "indianred":  [205, 92, 92],
        "indigo":  [75, 0, 130],
        "ivory":  [255, 255, 240],
        "khaki":  [240, 230, 140],
        "lavender":  [230, 230, 250],
        "lavenderblush":  [255, 240, 245],
        "lawngreen":  [124, 252, 0],
        "lemonchiffon":  [255, 250, 205],
        "lightblue":  [173, 216, 230],
        "lightcoral":  [240, 128, 128],
        "lightcyan":  [224, 255, 255],
        "lightgoldenrodyellow":  [250, 250, 210],
        "lightgray":  [211, 211, 211],
        "lightgreen":  [144, 238, 144],
        "lightgrey":  [211, 211, 211],
        "lightpink":  [255, 182, 193],
        "lightsalmon":  [255, 160, 122],
        "lightseagreen":  [32, 178, 170],
        "lightskyblue":  [135, 206, 250],
        "lightslategray":  [119, 136, 153],
        "lightslategrey":  [119, 136, 153],
        "lightsteelblue":  [176, 196, 222],
        "lightyellow":  [255, 255, 224],
        "lime":  [0, 255, 0],
        "limegreen":  [50, 205, 50],
        "linen":  [250, 240, 230],
        "magenta":  [255, 0, 255],
        "maroon":  [128, 0, 0],
        "mediumaquamarine":  [102, 205, 170],
        "mediumblue":  [0, 0, 205],
        "mediumorchid":  [186, 85, 211],
        "mediumpurple":  [147, 112, 219],
        "mediumseagreen":  [60, 179, 113],
        "mediumslateblue":  [123, 104, 238],
        "mediumspringgreen":  [0, 250, 154],
        "mediumturquoise":  [72, 209, 204],
        "mediumvioletred":  [199, 21, 133],
        "midnightblue":  [25, 25, 112],
        "mintcream":  [245, 255, 250],
        "mistyrose":  [255, 228, 225],
        "moccasin":  [255, 228, 181],
        "navajowhite":  [255, 222, 173],
        "navy":  [0, 0, 128],
        "oldlace":  [253, 245, 230],
        "olive":  [128, 128, 0],
        "olivedrab":  [107, 142, 35],
        "orange":  [255, 165, 0],
        "orangered":  [255, 69, 0],
        "orchid":  [218, 112, 214],
        "palegoldenrod":  [238, 232, 170],
        "palegreen":  [152, 251, 152],
        "paleturquoise":  [175, 238, 238],
        "palevioletred":  [219, 112, 147],
        "papayawhip":  [255, 239, 213],
        "peachpuff":  [255, 218, 185],
        "peru":  [205, 133, 63],
        "pink":  [255, 192, 203],
        "plum":  [221, 160, 221],
        "powderblue":  [176, 224, 230],
        "purple":  [128, 0, 128],
        "red":  [255, 0, 0],
        "rosybrown":  [188, 143, 143],
        "royalblue":  [65, 105, 225],
        "saddlebrown":  [139, 69, 19],
        "salmon":  [250, 128, 114],
        "sandybrown":  [244, 164, 96],
        "seagreen":  [46, 139, 87],
        "seashell":  [255, 245, 238],
        "sienna":  [160, 82, 45],
        "silver":  [192, 192, 192],
        "skyblue":  [135, 206, 235],
        "slateblue":  [106, 90, 205],
        "slategray":  [112, 128, 144],
        "slategrey":  [112, 128, 144],
        "snow":  [255, 250, 250],
        "springgreen":  [0, 255, 127],
        "steelblue":  [70, 130, 180],
        "tan":  [210, 180, 140],
        "teal":  [0, 128, 128],
        "thistle":  [216, 191, 216],
        "tomato":  [255, 99, 71],
        "turquoise":  [64, 224, 208],
        "violet":  [238, 130, 238],
        "wheat":  [245, 222, 179],
        "white":  [255, 255, 255],
        "whitesmoke":  [245, 245, 245],
        "yellow":  [255, 255, 0],
        "yellowgreen":  [154, 205, 50],
        "transparent":  [0, 0, 0, 0]
    }
};

module.exports = {
  version: {
    latest: _torque_reference_latest,
    '1.0.0': _torque_reference_latest
  }
};

},{}],18:[function(require,module,exports){
(function (global){
//
// common functionallity for torque layers
//
var carto = global.carto || require('carto');

function TorqueLayer() {}

TorqueLayer.prototype = {
};

TorqueLayer.optionsFromLayer = function(mapConfig) {
  var opts = {};
  if (!mapConfig) return opts;
  var attrs = {
    'buffer-size': 'buffer-size',
    '-torque-frame-count': 'steps',
    '-torque-resolution': 'resolution',
    '-torque-animation-duration': 'animationDuration',
    '-torque-aggregation-function': 'countby',
    '-torque-time-attribute': 'column',
    '-torque-data-aggregation': 'data_aggregation'
  };
  for (var i in attrs) {
    var v = mapConfig.eval(i);
    if (v !== undefined) {
      var a = attrs[i];
      opts[a] = v;
    }
  }
  return opts;
};

TorqueLayer.optionsFromCartoCSS = function(cartocss) {
  var shader = new carto.RendererJS().render(cartocss);
  var mapConfig = shader.findLayer({ name: 'Map' });
  return TorqueLayer.optionsFromLayer(mapConfig);
};

module.exports.TorqueLayer = TorqueLayer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"carto":45}],19:[function(require,module,exports){
(function (global){
  var Event = {};
  Event.on = function(evt, callback) {
      var cb = this._evt_callbacks = this._evt_callbacks || {};
      var l = cb[evt] || (cb[evt] = []);
      l.push(callback);
      return this;
  };

  Event.trigger = function(evt) {
      var c = this._evt_callbacks && this._evt_callbacks[evt];
      for(var i = 0; c && i < c.length; ++i) {
          c[i].apply(this, Array.prototype.slice.call(arguments, 1));
      }
      return this;
  };

  Event.fire = Event.trigger;

  Event.off = function (evt, callback) {
      var c = this._evt_callbacks && this._evt_callbacks[evt];
      if (c && !callback) {
        delete this._evt_callbacks[evt];
        return this;
     }
     var remove = [];
     for(var i = 0; c && i < c.length; ++i) {
       if(c[i] === callback) remove.push(i);
     }
     while((i = remove.pop()) !== undefined) c.splice(i, 1);
    return this;
  };

  Event.callbacks = function(evt) {
    return (this._evt_callbacks && this._evt_callbacks[evt]) || [];
  };

  function extend() {
      var objs = arguments;
      var a = objs[0];
      for (var i = 1; i < objs.length; ++i) {
          var b = objs[i];
          for (var k in b) {
              a[k] = b[k];
          }
      }
      return a;
  }

  function clone(a) {
    return extend({}, a);
  }

  function isFunction(f) {
    return typeof f == 'function' || false;
  }

  function isArray(value) {
      return value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object Array]';
  }

  // types
  var types = {
    Uint8Array: typeof(global['Uint8Array']) !== 'undefined' ? global.Uint8Array : Array,
    Uint8ClampedArray: typeof(global['Uint8ClampedArray']) !== 'undefined' ? global.Uint8ClampedArray: Array,
    Uint32Array: typeof(global['Uint32Array']) !== 'undefined' ? global.Uint32Array : Array,
    Int16Array: typeof(global['Int16Array']) !== 'undefined' ? global.Int16Array : Array,
    Int32Array: typeof(global['Int32Array']) !== 'undefined' ? global.Int32Array: Array
  };

  function isBrowserSupported() {
    return !!document.createElement('canvas');
  }

  function userAgent() {
      return typeof navigator !== 'undefined' ? navigator.userAgent : '';
  }

  var flags = {
    sprites_to_images: userAgent().indexOf('Safari') === -1 && userAgent().indexOf('Firefox') === -1
  };

module.exports = {
    Event: Event,
    extend: extend,
    clone: clone,
    isFunction: isFunction,
    isArray: isArray,
    types: types,
    isBrowserSupported: isBrowserSupported,
    flags: flags
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Extends OverlayView to provide a canvas "Layer".
 * @author Brendan Kenny
 */

/**
 * A map layer that provides a canvas over the slippy map and a callback
 * system for efficient animation. Requires canvas and CSS 2D transform
 * support.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {CanvasLayerOptions=} opt_options Options to set in this CanvasLayer.
 */

function CanvasLayer(opt_options) {
  /**
   * If true, canvas is in a map pane and the OverlayView is fully functional.
   * See google.maps.OverlayView.onAdd for more information.
   * @type {boolean}
   * @private
   */
  this.isAdded_ = false;

  /**
   * If true, each update will immediately schedule the next.
   * @type {boolean}
   * @private
   */
  this.isAnimated_ = false;

  /**
   * The name of the MapPane in which this layer will be displayed.
   * @type {string}
   * @private
   */
  this.paneName_ = CanvasLayer.DEFAULT_PANE_NAME_;

  /**
   * A user-supplied function called whenever an update is required. Null or
   * undefined if a callback is not provided.
   * @type {?function=}
   * @private
   */
  this.updateHandler_ = null;

  /**
   * A user-supplied function called whenever an update is required and the
   * map has been resized since the last update. Null or undefined if a
   * callback is not provided.
   * @type {?function}
   * @private
   */
  this.resizeHandler_ = null;

  /**
   * The LatLng coordinate of the top left of the current view of the map. Will
   * be null when this.isAdded_ is false.
   * @type {google.maps.LatLng}
   * @private
   */
  this.topLeft_ = null;

  /**
   * The map-pan event listener. Will be null when this.isAdded_ is false. Will
   * be null when this.isAdded_ is false.
   * @type {?function}
   * @private
   */
  this.centerListener_ = null;

  /**
   * The map-resize event listener. Will be null when this.isAdded_ is false.
   * @type {?function}
   * @private
   */
  this.resizeListener_ = null;

  /**
   * If true, the map size has changed and this.resizeHandler_ must be called
   * on the next update.
   * @type {boolean}
   * @private
   */
  this.needsResize_ = true;

  /**
   * A browser-defined id for the currently requested callback. Null when no
   * callback is queued.
   * @type {?number}
   * @private
   */
  this.requestAnimationFrameId_ = null;

  var canvas = document.createElement('canvas');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.pointerEvents = 'none';

  /**
   * The canvas element.
   * @type {!HTMLCanvasElement}
   */
  this.canvas = canvas;

  /**
   * Simple bind for functions with no args for bind-less browsers (Safari).
   * @param {Object} thisArg The this value used for the target function.
   * @param {function} func The function to be bound.
   */
  function simpleBindShim(thisArg, func) {
    return function() { func.apply(thisArg); };
  }

  /**
   * A reference to this.repositionCanvas_ with this bound as its this value.
   * @type {function}
   * @private
   */
  this.repositionFunction_ = simpleBindShim(this, this.repositionCanvas_);

  /**
   * A reference to this.resize_ with this bound as its this value.
   * @type {function}
   * @private
   */
  this.resizeFunction_ = simpleBindShim(this, this.resize_);

  /**
   * A reference to this.update_ with this bound as its this value.
   * @type {function}
   * @private
   */
  this.requestUpdateFunction_ = simpleBindShim(this, this.update_);

  // set provided options, if any
  if (opt_options) {
    this.setOptions(opt_options);
  }
}

CanvasLayer.prototype = new google.maps.OverlayView();

/**
 * The default MapPane to contain the canvas.
 * @type {string}
 * @const
 * @private
 */
CanvasLayer.DEFAULT_PANE_NAME_ = 'overlayLayer';

/**
 * Transform CSS property name, with vendor prefix if required. If browser
 * does not support transforms, property will be ignored.
 * @type {string}
 * @const
 * @private
 */
CanvasLayer.CSS_TRANSFORM_ = (function() {
  var div = document.createElement('div');
  var transformProps = [
    'transform',
    'WebkitTransform',
    'MozTransform',
    'OTransform',
    'msTransform'
  ];
  for (var i = 0; i < transformProps.length; i++) {
    var prop = transformProps[i];
    if (div.style[prop] !== undefined) {
      return prop;
    }
  }

  // return unprefixed version by default
  return transformProps[0];
})();

/**
 * The requestAnimationFrame function, with vendor-prefixed or setTimeout-based
 * fallbacks. MUST be called with window as thisArg.
 * @type {function}
 * @param {function} callback The function to add to the frame request queue.
 * @return {number} The browser-defined id for the requested callback.
 * @private
 */
CanvasLayer.prototype.requestAnimFrame_ =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };

/**
 * The cancelAnimationFrame function, with vendor-prefixed fallback. Does not
 * fall back to clearTimeout as some platforms implement requestAnimationFrame
 * but not cancelAnimationFrame, and the cost is an extra frame on onRemove.
 * MUST be called with window as thisArg.
 * @type {function}
 * @param {number=} requestId The id of the frame request to cancel.
 * @private
 */
CanvasLayer.prototype.cancelAnimFrame_ =
    window.cancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.oCancelAnimationFrame ||
    window.msCancelAnimationFrame ||
    function(requestId) {};

/**
 * Sets any options provided. See CanvasLayerOptions for more information.
 * @param {CanvasLayerOptions} options The options to set.
 */
CanvasLayer.prototype.setOptions = function(options) {
  if (options.animate !== undefined) {
    this.setAnimate(options.animate);
  }

  if (options.paneName !== undefined) {
    this.setPane(options.paneName);
  }

  if (options.updateHandler !== undefined) {
    this.setUpdateHandler(options.updateHandler);
  }

  if (options.resizeHandler !== undefined) {
    this.setResizeHandler(options.resizeHandler);
  }

  if(options.readyHandler) {
    this.readyHandler = options.readyHandler;
  }

};

/**
 * Set the animated state of the layer. If true, updateHandler will be called
 * repeatedly, once per frame. If false, updateHandler will only be called when
 * a map property changes that could require the canvas content to be redrawn.
 * @param {boolean} animate Whether the canvas is animated.
 */
CanvasLayer.prototype.setAnimate = function(animate) {
  this.isAnimated_ = !!animate;

  if (this.isAnimated_) {
    this.scheduleUpdate();
  }
};

/**
 * @return {boolean} Whether the canvas is animated.
 */
CanvasLayer.prototype.isAnimated = function() {
  return this.isAnimated_;
};

/**
 * Set the MapPane in which this layer will be displayed, by name. See
 * {@code google.maps.MapPanes} for the panes available.
 * @param {string} paneName The name of the desired MapPane.
 */
CanvasLayer.prototype.setPaneName = function(paneName) {
  this.paneName_ = paneName;

  this.setPane_();
};

/**
 * Set the opacity for the canvas.
 *
 * @param {number} opacity The opacity of the canvas
 */
CanvasLayer.prototype.setOpacity = function (opacity) {
  this.canvas.style.opacity = opacity;
};

/**
 * Get the canvases opacity.
 *
 * @return {number} The opacity of the canvas
 */
CanvasLayer.prototype.getOpacity = function () {
  return this.canvas.style.opacity;
};

/**
 * @return {string} The name of the current container pane.
 */
CanvasLayer.prototype.getPaneName = function() {
  return this.paneName_;
};

/**
 * Adds the canvas to the specified container pane. Since this is guaranteed to
 * execute only after onAdd is called, this is when paneName's existence is
 * checked (and an error is thrown if it doesn't exist).
 * @private
 */
CanvasLayer.prototype.setPane_ = function() {
  if (!this.isAdded_) {
    return;
  }

  // onAdd has been called, so panes can be used
  var panes = this.getPanes();
  if (!panes[this.paneName_]) {
    throw new Error('"' + this.paneName_ + '" is not a valid MapPane name.');
  }

  panes[this.paneName_].appendChild(this.canvas);
};

/**
 * Set a function that will be called whenever the parent map and the overlay's
 * canvas have been resized. If opt_resizeHandler is null or unspecified, any
 * existing callback is removed.
 * @param {?function=} opt_resizeHandler The resize callback function.
 */
CanvasLayer.prototype.setResizeHandler = function(opt_resizeHandler) {
  this.resizeHandler_ = opt_resizeHandler;
};

/**
 * Set a function that will be called when a repaint of the canvas is required.
 * If opt_updateHandler is null or unspecified, any existing callback is
 * removed.
 * @param {?function=} opt_updateHandler The update callback function.
 */
CanvasLayer.prototype.setUpdateHandler = function(opt_updateHandler) {
  this.updateHandler_ = opt_updateHandler;
};

/**
 * @inheritDoc
 */
CanvasLayer.prototype.onAdd = function() {
  if (this.isAdded_) {
    return;
  }

  this.isAdded_ = true;
  this.setPane_();

  this.resizeListener_ = google.maps.event.addListener(this.getMap(),
      'resize', this.resizeFunction_);
  this.centerListener_ = google.maps.event.addListener(this.getMap(),
      'center_changed', this.repositionFunction_);

  this.resize_();
  this.repositionCanvas_();
  this.readyHandler && this.readyHandler();
};

/**
 * @inheritDoc
 */
CanvasLayer.prototype.onRemove = function() {
  if (!this.isAdded_) {
    return;
  }

  this.isAdded_ = false;
  this.topLeft_ = null;

  // remove canvas and listeners for pan and resize from map
  this.canvas.parentElement.removeChild(this.canvas);
  if (this.centerListener_) {
    google.maps.event.removeListener(this.centerListener_);
    this.centerListener_ = null;
  }
  if (this.resizeListener_) {
    google.maps.event.removeListener(this.resizeListener_);
    this.resizeListener_ = null;
  }

  // cease canvas update callbacks
  if (this.requestAnimationFrameId_) {
    this.cancelAnimFrame_.call(window, this.requestAnimationFrameId_);
    this.requestAnimationFrameId_ = null;
  }
};

/**
 * The internal callback for resize events that resizes the canvas to keep the
 * map properly covered.
 * @private
 */
CanvasLayer.prototype.resize_ = function() {
  // TODO(bckenny): it's common to use a smaller canvas but use CSS to scale
  // what is drawn by the browser to save on fill rate. Add an option to do
  // this.

  if (!this.isAdded_) {
    return;
  }

  var map = this.getMap();
  var width = map.getDiv().offsetWidth;
  var height = map.getDiv().offsetHeight;
  var oldWidth = this.canvas.width;
  var oldHeight = this.canvas.height;

  // resizing may allocate a new back buffer, so do so conservatively
  if (oldWidth !== width || oldHeight !== height) {
    this.canvas.width = width;
    this.canvas.height = height;
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';

    this.needsResize_ = true;
    this.scheduleUpdate();
  }
};

/**
 * @inheritDoc
 */
CanvasLayer.prototype.draw = function() {
  this.repositionCanvas_();
};

/**
 * Internal callback for map view changes. Since the Maps API moves the overlay
 * along with the map, this function calculates the opposite translation to
 * keep the canvas in place.
 * @private
 */
CanvasLayer.prototype.repositionCanvas_ = function() {
  // TODO(bckenny): *should* only be executed on RAF, but in current browsers
  //     this causes noticeable hitches in map and overlay relative
  //     positioning.

  var bounds = this.getMap().getBounds();
  this.topLeft_ = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getSouthWest().lng());

  // canvas position relative to draggable map's conatainer depends on
  // overlayView's projection, not the map's
  var projection = this.getProjection();
  var divTopLeft = projection.fromLatLngToDivPixel(this.topLeft_);

  // when the zoom level is low, more than one map can be shown in the screen
  // so the canvas should be attach to the map with more are in the screen
  var mapSize = (1 << this.getMap().getZoom())*256;
  if (Math.abs(divTopLeft.x) > mapSize) {
    divTopLeft.x -= mapSize;
  }
  this.canvas.style[CanvasLayer.CSS_TRANSFORM_] = 'translate(' +
      Math.round(divTopLeft.x) + 'px,' + Math.round(divTopLeft.y) + 'px)';

  this.scheduleUpdate();
};

/**
 * Internal callback that serves as main animation scheduler via
 * requestAnimationFrame. Calls resize and update callbacks if set, and
 * schedules the next frame if overlay is animated.
 * @private
 */
CanvasLayer.prototype.update_ = function() {
  this.requestAnimationFrameId_ = null;

  if (!this.isAdded_) {
    return;
  }

  if (this.isAnimated_) {
    this.scheduleUpdate();
  }

  if (this.needsResize_ && this.resizeHandler_) {
    this.needsResize_ = false;
    this.resizeHandler_();
  }

  if (this.updateHandler_) {
    this.updateHandler_();
  }
};

/**
 * A convenience method to get the current LatLng coordinate of the top left of
 * the current view of the map.
 * @return {google.maps.LatLng} The top left coordinate.
 */
CanvasLayer.prototype.getTopLeft = function() {
  return this.topLeft_;
};

/**
 * Schedule a requestAnimationFrame callback to updateHandler. If one is
 * already scheduled, there is no effect.
 */
CanvasLayer.prototype.scheduleUpdate = function() {
  if (this.isAdded_ && !this.requestAnimationFrameId_) {
    this.requestAnimationFrameId_ =
        this.requestAnimFrame_.call(window, this.requestUpdateFunction_);
  }
};

module.exports = CanvasLayer;

},{}],21:[function(require,module,exports){
/*
 ====================
 canvas setup for drawing tiles
 ====================
 */

function CanvasTileLayer(canvas_setup, render) {
  this.tileSize = new google.maps.Size(256, 256);
  this.maxZoom = 19;
  this.name = "Tile #s";
  this.alt = "Canvas tile layer";
  this.tiles = {};
  this.canvas_setup = canvas_setup;
  this.render = render;
  if (!render) {
      this.render = canvas_setup;
  }
}


// create a tile with a canvas element
CanvasTileLayer.prototype.create_tile_canvas = function (coord, zoom, ownerDocument) {

  // create canvas and reset style
  var canvas = ownerDocument.createElement('canvas');
  var hit_canvas = ownerDocument.createElement('canvas');
  canvas.style.border = hit_canvas.style.border = "none";
  canvas.style.margin = hit_canvas.style.margin = "0";
  canvas.style.padding = hit_canvas.style.padding = "0";

  // prepare canvas and context sizes
  var ctx = canvas.getContext('2d');
  ctx.width = canvas.width = this.tileSize.width;
  ctx.height = canvas.height = this.tileSize.height;

  var hit_ctx = hit_canvas.getContext('2d');
  hit_canvas.width = hit_ctx.width = this.tileSize.width;
  hit_canvas.height = hit_ctx.height = this.tileSize.height;

  //set unique id
  var tile_id = coord.x + '_' + coord.y + '_' + zoom;

  canvas.setAttribute('id', tile_id);
  hit_canvas.setAttribute('id', tile_id);

  if (tile_id in this.tiles)
      delete this.tiles[tile_id];

  this.tiles[tile_id] = {canvas:canvas, ctx:ctx, hit_canvas:hit_canvas, hit_ctx:hit_ctx, coord:coord, zoom:zoom, primitives:null};

  // custom setup
  //if (tile_id == '19295_24654_16'){
  if (this.canvas_setup)
      this.canvas_setup(this.tiles[tile_id], coord, zoom);
  //}
  return canvas;

}


CanvasTileLayer.prototype.each = function (callback) {
  for (var t in this.tiles) {
      var tile = this.tiles[t];
      callback(tile);
  }
}

CanvasTileLayer.prototype.recreate = function () {
  for (var t in this.tiles) {
      var tile = this.tiles[t];
      this.canvas_setup(tile, tile.coord, tile.zoom);
  }
};

CanvasTileLayer.prototype.redraw_tile = function (tile) {
  this.render(tile, tile.coord, tile.zoom);
};

CanvasTileLayer.prototype.redraw = function () {
  for (var t in this.tiles) {
      var tile = this.tiles[t];
      this.render(tile, tile.coord, tile.zoom);
  }
};

// could be called directly...
CanvasTileLayer.prototype.getTile = function (coord, zoom, ownerDocument) {
  return this.create_tile_canvas(coord, zoom, ownerDocument);
};

CanvasTileLayer.prototype.releaseTile = function (tile) {
  var id = tile.getAttribute('id');
  delete this.tiles[id];
};

module.exports = CanvasTileLayer;

},{}],22:[function(require,module,exports){
function GMapsTileLoader() {
}


GMapsTileLoader.prototype = {

  _initTileLoader: function(map, projection) {
    this._map = map;
    this._projection = projection;
    this._tiles = {};
    this._tilesLoading = {};
    this._tilesToLoad = 0;
    this._updateTiles = this._updateTiles.bind(this);
    this._listeners = [];
    this._listeners.push(
      google.maps.event.addListener(this._map, 'dragend', this._updateTiles),
      google.maps.event.addListener(this._map, 'zoom_changed', this._updateTiles)
    );
    this.tileSize = 256;
    this._updateTiles();
  },

  _removeTileLoader: function() {
    this._listeners.forEach(function (listener) {
      google.maps.event.removeListener(listener);
    });

    this._removeTiles();
  },

  _removeTiles: function () {
    for (var key in this._tiles) {
      this._removeTile(key);
    }
  },

  _reloadTiles: function() {
    this._removeTiles();
    this._updateTiles();
  },

  _updateTiles: function () {

      if (!this._map) { return; }

      var bounds = this._map.getBounds();
      var zoom = this._map.getZoom();
      var tileSize = this.tileSize;
      var mzoom = (1 << zoom);

      var topLeft = new google.maps.LatLng(
        bounds.getNorthEast().lat(),
        bounds.getSouthWest().lng()
      );

      var bottomRigth = new google.maps.LatLng(
        bounds.getSouthWest().lat(),
        bounds.getNorthEast().lng()
      );


      this._projection = this._map.getProjection();
      var divTopLeft = this._projection.fromLatLngToPoint(topLeft);
      var divBottomRight = this._projection.fromLatLngToPoint(bottomRigth);


      var nwTilePoint = new google.maps.Point(
              Math.floor(divTopLeft.x*mzoom / tileSize),
              Math.floor(divTopLeft.y*mzoom / tileSize)),
          seTilePoint = new google.maps.Point(
              Math.floor(divBottomRight.x*mzoom / tileSize),
              Math.floor(divBottomRight.y*mzoom / tileSize));


      this._addTilesFromCenterOut(nwTilePoint, seTilePoint);
      this._removeOtherTiles(nwTilePoint, seTilePoint);
  },

  _removeOtherTiles: function (nwTilePoint, seTilePoint) {
      var kArr, x, y, key;

      var zoom = this._map.getZoom();
      for (key in this._tiles) {
          if (this._tiles.hasOwnProperty(key)) {
              kArr = key.split(':');
              x = parseInt(kArr[0], 10);
              y = parseInt(kArr[1], 10);
              z = parseInt(kArr[2], 10);

              // remove tile if it's out of bounds
              if (z !== zoom || x < nwTilePoint.x || x > seTilePoint.x || y < nwTilePoint.y || y > seTilePoint.y) {
                  this._removeTile(key);
              }
          }
      }
  },

  _removeTile: function (key) {
      this.onTileRemoved && this.onTileRemoved(this._tiles[key]);
      delete this._tiles[key];
      delete this._tilesLoading[key];
  },

  _tileKey: function(tilePoint) {
    return tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom;
  },

  _tileShouldBeLoaded: function (tilePoint) {
      var k = this._tileKey(tilePoint);
      return !(k in this._tiles) && !(k in this._tilesLoading);
  },

  _tileLoaded: function(tilePoint, tileData) {
    this._tilesToLoad--;
    var k = tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom
    this._tiles[k] = tileData;
    delete this._tilesLoading[k];
    if(this._tilesToLoad === 0) {
      this.onTilesLoaded && this.onTilesLoaded();
    }
  },

  getTilePos: function (tilePoint) {
    var limit = (1 << this._map.getZoom());
    // wrap tile
    tilePoint = {
      x: ((tilePoint.x % limit) + limit) % limit,
      y: tilePoint.y
    };

    tilePoint = new google.maps.Point(
      tilePoint.x * this.tileSize,
      tilePoint.y * this.tileSize
    );

    var bounds = this._map.getBounds();
    var topLeft = new google.maps.LatLng(
      bounds.getNorthEast().lat(),
      bounds.getSouthWest().lng()
    );

    var divTopLeft = this._map.getProjection().fromLatLngToPoint(topLeft);
    zoom = (1 << this._map.getZoom());
    divTopLeft.x = divTopLeft.x * zoom;
    divTopLeft.y = divTopLeft.y * zoom;

    return new google.maps.Point(
      tilePoint.x - divTopLeft.x,
      tilePoint.y - divTopLeft.y
    );
  },

  _addTilesFromCenterOut: function (nwTilePoint, seTilePoint) {
      var queue = [],
          center = new google.maps.Point(
            (nwTilePoint.x + seTilePoint.x) * 0.5,
            (nwTilePoint.y + seTilePoint.y) * 0.5
          ),
          zoom = this._map.getZoom();

      var j, i, point;

      for (j = nwTilePoint.y; j <= seTilePoint.y; j++) {
          for (i = nwTilePoint.x; i <= seTilePoint.x; i++) {
              point = new google.maps.Point (i, j);
              point.zoom = zoom;

              if (this._tileShouldBeLoaded(point)) {
                  queue.push(point);
              }
          }
      }

      var tilesToLoad = queue.length;

      if (tilesToLoad === 0) { return; }

      function distanceToCenterSq(point) {
        var dx = point.x - center.x;
        var dy = point.y - center.y;
        return dx * dx + dy * dy;
      }

      // load tiles in order of their distance to center
      queue.sort(function (a, b) {
          return distanceToCenterSq(a) - distanceToCenterSq(b);
      });

      this._tilesToLoad += tilesToLoad;

        for (i = 0; i < tilesToLoad; i++) {
          var t = queue[i];
          var k = this._tileKey(t);
          this._tilesLoading[k] = t;
          // events
          if (this.onTileAdded) {
            this.onTileAdded(t);
          }
        }

      this.onTilesLoading && this.onTilesLoading();
  }

}

module.exports = GMapsTileLoader;

},{}],23:[function(require,module,exports){
var gmaps = {};
if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
    gmaps = require('./torque');
    gmaps.GMapsTileLoader = require('./gmaps_tileloader_mixin');
}
module.exports = gmaps;

},{"./gmaps_tileloader_mixin":22,"./torque":24}],24:[function(require,module,exports){
(function (global){
var carto = global.carto || require('carto');
var torque = require('../');
var CanvasLayer = require('./CanvasLayer');
var CanvasTileLayer = require('./canvas_tile_layer');
var GMapsTileLoader = require('./gmaps_tileloader_mixin');

function GMapsTorqueLayer(options) {
  var self = this;
  if (!torque.isBrowserSupported()) {
    throw new Error("browser is not supported by torque");
  }
  this.key = 0;
  this.shader = null;
  this.ready = false;
  this.options = torque.extend({}, options);
  this.options = torque.extend({
    provider: 'windshaft',
    renderer: 'point',
    resolution: 2,
    steps: 100,
    visible: true
  }, this.options);
  if (options.cartocss) {
    torque.extend(this.options,
        torque.common.TorqueLayer.optionsFromCartoCSS(options.cartocss));
  }

  if(options.tileJSON) this.options.provider = "tileJSON";

  this.hidden = !this.options.visible;

  this.animator = new torque.Animator(function(time) {
    var k = time | 0;
    if(self.key !== k) {
      self.setKey(k);
    }
  }, torque.extend(torque.clone(this.options), {
    onPause: function() {
      self.fire('pause');
    },
    onStop: function() {
      self.fire('stop');
    },
    onStart: function() {
      self.fire('play');
    },
    onStepsRange: function() {
      self.fire('change:stepsRange', self.animator.stepsRange());
    }
  }));

  this.play = this.animator.start.bind(this.animator);
  this.stop = this.animator.stop.bind(this.animator);
  this.pause = this.animator.pause.bind(this.animator);
  this.toggle = this.animator.toggle.bind(this.animator);
  this.setDuration = this.animator.duration.bind(this.animator);
  this.isRunning = this.animator.isRunning.bind(this.animator);


  CanvasLayer.call(this, {
    map: this.options.map,
    //resizeHandler: this.redraw,
    animate: false,
    updateHandler: this.render,
    readyHandler: this.initialize
  });

}

/**
 * torque layer
 */
GMapsTorqueLayer.prototype = torque.extend({},
  CanvasLayer.prototype,
  GMapsTileLoader.prototype,
  torque.Event,
  {

  providers: {
    'sql_api': torque.providers.json,
    'url_template': torque.providers.JsonArray,
    'windshaft': torque.providers.windshaft,
    'tileJSON': torque.providers.tileJSON
  },

  renderers: {
    'point': torque.renderer.Point,
    'pixel': torque.renderer.Rectangle
  },

  initialize: function() {
    var self = this;

    this.onTileAdded = this.onTileAdded.bind(this);

    this.options.ready = function() {
      self.fire("change:bounds", {
        bounds: self.provider.getBounds()
      });
      self.animator.steps(self.provider.getSteps());
      self.animator.rescale();
      self.fire('change:steps', {
        steps: self.provider.getSteps()
      });
      self.setKey(self.key);
    };

    this.provider = new this.providers[this.options.provider](this.options);
    this.renderer = new this.renderers[this.options.renderer](this.getCanvas(), this.options);
    this.renderer.options.errorCallback = this.options.errorCallback;

    // this listener should be before tile loader
    this._cacheListener = google.maps.event.addListener(this.options.map, 'zoom_changed', function() {
      self.renderer && self.renderer.clearSpriteCache();
    });

    this._initTileLoader(this.options.map, this.getProjection());

    if (this.shader) {
      this.renderer.setShader(this.shader);
    }

  },

  hide: function() {
    if(this.hidden) return this;
    this.pause();
    this.clear();
    this.hidden = true;
    return this;
  },

  show: function() {
    if(!this.hidden) return this;
    this.hidden = false;
    this.play();
    if (this.options.steps === 1){
      this.redraw();
    }
    return this;
  },

  setSQL: function(sql) {
    if (this.provider.options.named_map) throw new Error("SQL queries on named maps are read-only");
    if (!this.provider || !this.provider.setSQL) {
      throw new Error("this provider does not support SQL");
    }
    this.provider.setSQL(sql);
    this._reloadTiles();
    return this;
  },

  setBlendMode: function(_) {
    this.renderer && this.renderer.setBlendMode(_);
    this.redraw();
  },

  setSteps: function(steps) {
    this.provider && this.provider.setSteps(steps);
    this.animator && this.animator.steps(steps);
    this._reloadTiles();
  },

  setColumn: function(column, isTime) {
    this.provider && this.provider.setColumn(column, isTime);
    this._reloadTiles();
  },

  getTimeBounds: function() {
    return this.provider && this.provider.getKeySpan();
  },

  getCanvas: function() {
    return this.canvas;
  },

    // for each tile shown on the map request the data
  onTileAdded: function(t) {
    var self = this;
    this.provider.getTileData(t, t.zoom, function(tileData) {
      // don't load tiles that are not being shown
      if (t.zoom !== self.options.map.getZoom()) return;
      self._tileLoaded(t, tileData);
      self.fire('tileLoaded');
      if (tileData) {
        self.redraw();
      }
    });
  },

  clear: function() {
    var canvas = this.canvas;
    canvas.width = canvas.width;
  },

  /**
   * render the selectef key
   * don't call this function directly, it's called by
   * requestAnimationFrame. Use redraw to refresh it
   */
  render: function() {
    if(this.hidden) return;
    var t, tile, pos;
    var canvas = this.canvas;
    this.renderer.clearCanvas();
    var ctx = canvas.getContext('2d');

    // renders only a "frame"
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        pos = this.getTilePos(tile.coord);
        ctx.setTransform(1, 0, 0, 1, pos.x, pos.y);
        this.renderer.renderTile(tile, this.key);
      }
    }
    this.renderer.applyFilters();
  },

  getActivePointsBBox: function(step) {
    var positions = [];
    var tileMax = this.options.resolution * (256/this.options.resolution - 1);
    for(var t in this._tiles) {
      var tile = this._tiles[t];
      positions = positions.concat(this.renderer.getActivePointsBBox(tile, step));
    }
    return positions;
  },

  /**
   * set key to be shown. If it's a single value
   * it renders directly, if it's an array it renders
   * accumulated
   */
  setKey: function(key) {
    this.key = key;
    this.animator.step(key);
    this.redraw();
    this.fire('change:time', { time: this.getTime(), step: this.key });
  },

  /**
   * helper function, does the same than ``setKey`` but only
   * accepts scalars.
   */
  setStep: function(time) {
    if(time === undefined || time.length !== undefined) {
      throw new Error("setTime only accept scalars");
    }
    this.setKey(time);
  },

  /**
   * transform from animation step to Date object
   * that contains the animation time
   *
   * ``step`` should be between 0 and ``steps - 1``
   */
  stepToTime: function(step) {
    if (!this.provider) return 0;
    var times = this.provider.getKeySpan();
    var time = times.start + (times.end - times.start)*(step/this.provider.getSteps());
    return new Date(time);
  },

  timeToStep: function(timestamp) {
    if (typeof timestamp === "Date") timestamp = timestamp.getTime();
    if (!this.provider) return 0;
    var times = this.provider.getKeySpan();
    var step = (this.provider.getSteps() * (timestamp - times.start)) / (times.end - times.start);
    return step;
  },

  getStep: function() {
    return this.key;
  },

  /**
   * returns the animation time defined by the data
   * in the defined column. Date object
   */
  getTime: function() {
    return this.stepToTime(this.key);
  },

  /**
   * set the cartocss for the current renderer
   */
  setCartoCSS: function(cartocss) {
    if (this.provider && this.provider.options.named_map) throw new Error("CartoCSS style on named maps is read-only");
    var shader = new carto.RendererJS().render(cartocss);
    this.shader = shader;
    if (this.renderer) {
      this.renderer.setShader(shader);
    }

    // provider options
    var options = torque.common.TorqueLayer.optionsFromLayer(shader.findLayer({ name: 'Map' }));
    this.provider && this.provider.setCartoCSS && this.provider.setCartoCSS(cartocss);
    if(this.provider && this.provider.setOptions(options)) {
      this._reloadTiles();
    }
    torque.extend(this.options, options);

    // animator options
    if (options.animationDuration) {
      this.animator.duration(options.animationDuration);
    }

    this.redraw();
    return this;
  },

  redraw: function() {
    this.scheduleUpdate();
  },

  onRemove: function() {
    this.fire('remove');
    CanvasLayer.prototype.onRemove.call(this);
    this.animator.stop();
    this._removeTileLoader();
    google.maps.event.removeListener(this._cacheListener);
  },

  /**
   * return an array with the values for all the pixels active for the step
   */
  getValues: function(step) {
    var values = [];
    step = step === undefined ? this.key: step;
    var t, tile;
    for(t in this._tiles) {
      tile = this._tiles[t];
      this.renderer.getValues(tile, step, values);
    }
    return values;
  },

  getValueForPos: function(x, y, step) {
    step = step === undefined ? this.key: step;
    var t, tile, pos, value = null, xx, yy;
    for(t in this._tiles) {
      tile = this._tiles[t];
      pos = this.getTilePos(tile.coord);
      xx = x - pos.x;
      yy = y - pos.y;
      if (xx >= 0 && yy >= 0 && xx < this.renderer.TILE_SIZE && yy <= this.renderer.TILE_SIZE) {
        value = this.renderer.getValueFor(tile, step, xx, yy);
      }
      if (value !== null) {
        return value;
      }
    }
    return null;
  },
  getValueForBBox: function(x, y, w, h) {
    var xf = x + w, yf = y + h;
    var sum = 0;
    for(_y = y; y<yf; y+=this.options.resolution){
      for(_x = x; x<xf; x+=this.options.resolution){
        var thisValue = this.getValueForPos(_x,_y);
        if (thisValue){
          var bb = thisValue.bbox;
          var proj = this.getProjection()
          var xy = proj.fromLatLngToContainerPixel(new google.maps.LatLng(bb[1].lat, bb[1].lon));
          if(xy.x < xf && xy.y < yf){
            sum += thisValue.value;
          }
        }
      }
    }
    return sum;
  },

  error: function (callback) {
    this.options.errorCallback = callback;
    return this;
  }

});



function GMapsTiledTorqueLayer(options) {
  this.options = torque.extend({}, options);
  CanvasTileLayer.call(this, this._loadTile.bind(this), this.drawTile.bind(this));
  this.initialize(options);
}

GMapsTiledTorqueLayer.prototype = torque.extend({}, CanvasTileLayer.prototype, {

  providers: {
    'sql_api': torque.providers.json,
    'url_template': torque.providers.JsonArray
  },

  renderers: {
    'point': torque.renderer.Point,
    'pixel': torque.renderer.Rectangle
  },

  initialize: function(options) {
    var self = this;
    this.key = 0;

    this.options.renderer = this.options.renderer || 'pixel';
    this.options.provider = this.options.provider || 'sql_api';

    this.provider = new this.providers[this.options.provider](options);
    this.renderer = new this.renderers[this.options.renderer](null, options);

  },

  _tileLoaded: function(tile, tileData) {
    tile.data = tileData;
    this.drawTile(tile);
  },

  _loadTile: function(tile, coord, zoom) {
    var self = this;
    var limit = 1 << zoom;
    // wrap tile
    var wrappedCoord = {
      x: ((coord.x % limit) + limit) % limit,
      y: coord.y
    };

    this.provider.getTileData(wrappedCoord, zoom, function(tileData) {
      self._tileLoaded(tile, tileData);
    });
  },

  drawTile: function (tile) {
    var canvas = tile.canvas;
    if(!tile.data) return;
    canvas.width = canvas.width;

    this.renderer.setCanvas(canvas);

    var accum = this.renderer.accumulate(tile.data, this.key);
    this.renderer.renderTileAccum(accum, 0, 0);
  },

  setKey: function(key) {
    this.key = key;
    this.redraw();
  },

  /**
   * set the cartocss for the current renderer
   */
  setCartoCSS: function(cartocss) {
    if (!this.renderer) throw new Error('renderer is not valid');
    return this.renderer.setCartoCSS(cartocss);
  },

  setStepsRange: function(start, end) {
    this.animator.stepsRange(start, end);
  },

  removeStepsRange: function() {
    this.animator.removeCustomStepsRange();
  },

  getStepsRange: function() {
    return this.animator.stepsRange();
  }

});

module.exports = {
    GMapsTiledTorqueLayer: GMapsTiledTorqueLayer,
    GMapsTorqueLayer: GMapsTorqueLayer
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":25,"./CanvasLayer":20,"./canvas_tile_layer":21,"./gmaps_tileloader_mixin":22,"carto":45}],25:[function(require,module,exports){
module.exports = require('./core');

module.exports.Animator = require('./animator');
module.exports.cartocss_reference = require('./cartocss_reference');
module.exports.common = require('./common');
module.exports.math = require('./math');
module.exports.Mercator = require('./mercator');
module.exports.net = require('./request');
module.exports.renderer = require('./renderer');
module.exports.providers = require('./provider');

require('./leaflet');

var gmaps = require('./gmaps');
module.exports.GMapsTileLoader = gmaps.GMapsTileLoader;
module.exports.GMapsTorqueLayer = gmaps.GMapsTorqueLayer;
module.exports.GMapsTiledTorqueLayer = gmaps.GMapsTiledTorqueLayer;

},{"./animator":16,"./cartocss_reference":17,"./common":18,"./core":19,"./gmaps":23,"./leaflet":27,"./math":30,"./mercator":31,"./provider":33,"./renderer":39,"./request":43}],26:[function(require,module,exports){
require('./leaflet_tileloader_mixin');

/**
 * full canvas layer implementation for Leaflet
 */

L.CanvasLayer = L.Class.extend({

  includes: [L.Mixin.Events, L.Mixin.TileLoader],

  options: {
      minZoom: 0,
      maxZoom: 28,
      tileSize: 256,
      subdomains: 'abc',
      errorTileUrl: '',
      attribution: '',
      zoomOffset: 0,
      opacity: 1,
      unloadInvisibleTiles: L.Browser.mobile,
      updateWhenIdle: L.Browser.mobile,
      tileLoader: false, // installs tile loading events
      zoomAnimation: true
  },

  initialize: function (options) {
    var self = this;
    options = options || {};
    //this.project = this._project.bind(this);
    this.render = this.render.bind(this);
    L.Util.setOptions(this, options);
    this._canvas = this._createCanvas();
    // backCanvas for zoom animation
    if (this.options.zoomAnimation) {
      this._backCanvas = this._createCanvas();
    }
    this._ctx = this._canvas.getContext('2d');
    this.currentAnimationFrame = -1;
    this.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                                    return window.setTimeout(callback, 1000 / 60);
                                };
    this.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame ||
                                window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function(id) { clearTimeout(id); };
  },

  _createCanvas: function() {
    var canvas;
    canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.top = 0;
    canvas.style.left = 0;
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = this.options.zIndex || 0;
    var className = 'leaflet-tile-container';
    if (this.options.zoomAnimation) {
      className += ' leaflet-zoom-animated';
    }
    canvas.setAttribute('class', className);
    return canvas;
  },

  onAdd: function (map) {
    this._map = map;

    // add container with the canvas to the tile pane
    // the container is moved in the oposite direction of the
    // map pane to keep the canvas always in (0, 0)
    var tilePane = this._map._panes.tilePane;
    var _container = L.DomUtil.create('div', 'leaflet-layer');
    _container.appendChild(this._canvas);
    if (this.options.zoomAnimation) {
      _container.appendChild(this._backCanvas);
      this._backCanvas.style.display = 'none';
    }
    tilePane.appendChild(_container);

    this._container = _container;

    // hack: listen to predrag event launched by dragging to
    // set container in position (0, 0) in screen coordinates
    map.dragging._draggable.on('predrag', function() {
      var d = map.dragging._draggable;
      L.DomUtil.setPosition(this._canvas, { x: -d._newPos.x, y: -d._newPos.y });
    }, this);

    map.on({ 'viewreset': this._reset }, this);
    map.on('move', this.redraw, this);
    map.on('resize', this._reset, this);

    if (this.options.zoomAnimation) {
      map.on({
        'zoomanim': this._animateZoom,
        'zoomend': this._endZoomAnim,
        'moveend': this._reset
      }, this);
    }

    if(this.options.tileLoader) {
      this._initTileLoader();
    }

    this._reset();
  },

  _animateZoom: function (e) {
    if (!this._animating) {
        this._animating = true;
    }
    var back = this._backCanvas;

    back.width = this._canvas.width;
    back.height = this._canvas.height;

    // paint current canvas in back canvas with trasnformation
    var pos = this._canvas._leaflet_pos || { x: 0, y: 0 };
    back.getContext('2d').drawImage(this._canvas, 0, 0);

    L.DomUtil.setPosition(back, L.DomUtil.getPosition(this._canvas));

    // hide original
    this._canvas.style.display = 'none';
    back.style.display = 'block';
    var map = this._map;
    var scale = map.getZoomScale(e.zoom);
    var newCenter = map._latLngToNewLayerPoint(map.getCenter(), e.zoom, e.center);
    var oldCenter = map._latLngToNewLayerPoint(e.center, e.zoom, e.center);

    var origin = {
      x:  newCenter.x - oldCenter.x + pos.x,
      y:  newCenter.y - oldCenter.y + pos.y,
    };

    var bg = back;
    var transform = L.DomUtil.TRANSFORM;
    setTimeout(function() {
      bg.style[transform] = L.DomUtil.getTranslateString(origin) + ' scale(' + e.scale + ') ';
    }, 0)
  },

  _endZoomAnim: function () {
    this._animating = false;
    this._canvas.style.display = 'block';
    this._backCanvas.style.display = 'none';
    this._backCanvas.style[L.DomUtil.TRANSFORM] = '';
  },

  getCanvas: function() {
    return this._canvas;
  },

  getAttribution: function() {
    return this.options.attribution;
  },

  draw: function() {
    return this._reset();
  },

  onRemove: function (map) {
    this._container.parentNode.removeChild(this._container);
    map.off({
      'viewreset': this._reset,
      'move': this._render,
      'moveend': this._reset,
      'resize': this._reset,
      'zoomanim': this._animateZoom,
      'zoomend': this._endZoomAnim
    }, this);
  },

  addTo: function (map) {
    map.addLayer(this);
    return this;
  },

  error: function (callback) {
    this.provider.options.errorCallback = callback;
    return this;
  },

  setOpacity: function (opacity) {
    this.options.opacity = opacity;
    this._updateOpacity();
    return this;
  },

  setZIndex: function(zIndex) {
    this._canvas.style.zIndex = zIndex;
    if (this.options.zoomAnimation) {
      this._backCanvas.style.zIndex = zIndex;
    }
  },

  bringToFront: function () {
    return this;
  },

  bringToBack: function () {
    return this;
  },

  _reset: function () {
    var size = this._map.getSize();
    this._canvas.width = size.x;
    this._canvas.height = size.y;

    // fix position
    var pos = L.DomUtil.getPosition(this._map.getPanes().mapPane);
    if (pos) {
      L.DomUtil.setPosition(this._canvas, { x: -pos.x, y: -pos.y });
    }
    this.onResize();
    this._render();
  },

  /*
  _project: function(x) {
    var point = this._map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
    return [point.x, point.y];
  },
  */

  _updateOpacity: function () { },

  _render: function() {
    if (this.currentAnimationFrame >= 0) {
      this.cancelAnimationFrame.call(window, this.currentAnimationFrame);
    }
    this.currentAnimationFrame = this.requestAnimationFrame.call(window, this.render);
  },

  // use direct: true if you are inside an animation frame call
  redraw: function(direct) {
    var domPosition = L.DomUtil.getPosition(this._map.getPanes().mapPane);
    if (domPosition) {
      L.DomUtil.setPosition(this._canvas, { x: -domPosition.x, y: -domPosition.y });
    }
    if (direct) {
      this.render();
    } else {
      this._render();
    }
  },

  onResize: function() {
  },

  render: function() {
    throw new Error('render function should be implemented');
  }

});

},{"./leaflet_tileloader_mixin":28}],27:[function(require,module,exports){
if (typeof L !== 'undefined') {
    require('./torque');
}

},{"./torque":29}],28:[function(require,module,exports){
L.Mixin.TileLoader = {

  _initTileLoader: function() {
    this._tiles = {}
    this._tilesLoading = {};
    this._tilesToLoad = 0;
    this._map.on({
        'moveend': this._updateTiles
    }, this);
    this._updateTiles();
  },

  _removeTileLoader: function() {
    this._map.off({
        'moveend': this._updateTiles
    }, this);
    this._removeTiles();
  },

  visibleTiles: function() {
    if (!this._map) { return []; }
    var j, i, point, tiles = [];
    var bounds = this._map.getPixelBounds(),
        zoom = this._map.getZoom(),
        tileSize = this.options.tileSize;

    var nwTilePoint = new L.Point(
            Math.floor(bounds.min.x / tileSize),
            Math.floor(bounds.min.y / tileSize)),

        seTilePoint = new L.Point(
            Math.floor(bounds.max.x / tileSize),
            Math.floor(bounds.max.y / tileSize)),

        tileBounds = new L.Bounds(nwTilePoint, seTilePoint);

    for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
        for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
            tiles.push({ x: i, y: j, z: zoom });
        }
    }
    return tiles;
  },

  _updateTiles: function () {

      if (!this._map) { return; }

      var bounds = this._map.getPixelBounds(),
          zoom = this._map.getZoom(),
          tileSize = this.options.tileSize;

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
          return;
      }

      var nwTilePoint = new L.Point(
              Math.floor(bounds.min.x / tileSize),
              Math.floor(bounds.min.y / tileSize)),

          seTilePoint = new L.Point(
              Math.floor(bounds.max.x / tileSize),
              Math.floor(bounds.max.y / tileSize)),

          tileBounds = new L.Bounds(nwTilePoint, seTilePoint);

      this._addTilesFromCenterOut(tileBounds);
      this._resampleOldTiles(tileBounds);
      this._removeOtherTiles(tileBounds);
  },

  _isParent: function (p, tile) {
    return p.z == tile.z - 1 &&
            (tile.x >> 1) == p.x &&
            (tile.y >> 1) == p.y;
  },

  // after adding new tiles to load and _before_ removing old
  // tiles we get this ones to see if we can oversample o undersample using current tiles
  // sampling the tiles should be done at a different level because needs to know how to sample them
  _resampleOldTiles: function(tileBounds) {
    for (var t in this._tilesLoading) {
      // check for parent one
      var tile = this._tileFromKey(t);
      var parents = [];
      for (var p in this._tiles) {
        var c = this._tileFromKey(p);
        if (this._isParent(tile, c)) {
          parents.push(c);
        }
      }
      // if there are parents a parent level is being loaded
      // so no look for children
      if (!parents.length) {
        // check children
        var children = [];
        for (var p in this._tiles) {
          var c = this._tileFromKey(p);
          if (this._isParent(c, tile)) {
            children.push(c);
          }
        }
      } else {
      }
    }
  },

  _removeTiles: function (bounds) {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
  },

  _reloadTiles: function() {
    this._removeTiles();
    this._updateTiles();
  },

  _removeOtherTiles: function (bounds) {
      var self = this;
      var kArr, x, y, z, key;
      var zoom = this._map.getZoom();

      function checkTile(c, key) {
          if (c.hasOwnProperty(key)) {
              kArr = key.split(':');
              x = parseInt(kArr[0], 10);
              y = parseInt(kArr[1], 10);
              z = parseInt(kArr[2], 10);

              // remove tile if it's out of bounds
              if (zoom !== z || x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                  self._removeTile(key);
              }
          }
      }

      for (key in this._tiles) {
        checkTile(this._tiles, key);
      }
      for (key in this._tilesLoading) {
        checkTile(this._tilesLoading, key);
      }
  },

  _removeTile: function (key) {
      this.fire('tileRemoved', this._tiles[key]);
      delete this._tiles[key];
      if (this._tilesLoading[key]) {
        --this._tilesToLoad;
        delete this._tilesLoading[key];
      }
  },

  _tileKey: function(tilePoint) {
    return tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom;
  },

  _tileFromKey: function(key) {
      var kArr = key.split(':');
      return {
        x: parseInt(kArr[0], 10),
        y: parseInt(kArr[1], 10),
        z: parseInt(kArr[2], 10)
      }
  },

  _tileShouldBeLoaded: function (tilePoint) {
      var k = this._tileKey(tilePoint);
      return !(k in this._tiles) && !(k in this._tilesLoading);
  },

  _tileLoaded: function(tilePoint, tileData) {
    this._tilesToLoad--;
    var k = tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom
    this._tiles[k] = tileData;
    delete this._tilesLoading[k];
    if(this._tilesToLoad === 0) {
      this.fire("tilesLoaded");
    }
  },

  getTilePos: function (tilePoint) {
    tilePoint = new L.Point(tilePoint.x, tilePoint.y);
    var origin = this._map._getNewTopLeftPoint(this._map.getCenter()),
        tileSize = this.options.tileSize;

    return tilePoint.multiplyBy(tileSize).subtract(origin);
  },

  _addTilesFromCenterOut: function (bounds) {
      var queue = [],
          center = bounds.getCenter(),
          zoom = this._map.getZoom();

      var j, i, point;

      for (j = bounds.min.y; j <= bounds.max.y; j++) {
          for (i = bounds.min.x; i <= bounds.max.x; i++) {
              point = new L.Point(i, j);
              point.zoom =  zoom;

              if (this._tileShouldBeLoaded(point)) {
                  queue.push(point);
              }
          }
      }

      var tilesToLoad = queue.length;

      if (tilesToLoad === 0) { return; }

      // load tiles in order of their distance to center
      queue.sort(function (a, b) {
          return a.distanceTo(center) - b.distanceTo(center);
      });

      this._tilesToLoad += tilesToLoad;

      for (i = 0; i < tilesToLoad; i++) {
        var t = queue[i];
        var k = this._tileKey(t);
        this._tilesLoading[k] = t;
        this.fire('tileAdded', t);
      }
      this.fire("tilesLoading");

  }

}

},{}],29:[function(require,module,exports){
(function (global){
var carto = global.carto || require('carto');
var torque = require('../');

require('./canvas_layer');

/**
 * torque layer
 */
L.TorqueLayer = L.CanvasLayer.extend({

  providers: {
    'sql_api': torque.providers.json,
    'url_template': torque.providers.JsonArray,
    'windshaft': torque.providers.windshaft,
    'tileJSON': torque.providers.tileJSON
  },

  renderers: {
    'point': torque.renderer.Point,
    'pixel': torque.renderer.Rectangle
  },

  initialize: function(options) {
    var self = this;
    if (!torque.isBrowserSupported()) {
      throw new Error("browser is not supported by torque");
    }
    options.tileLoader = true;
    this.key = 0;
    this.prevRenderedKey = 0;
    if (options.cartocss) {
      torque.extend(options, torque.common.TorqueLayer.optionsFromCartoCSS(options.cartocss));
    }

    options.resolution = options.resolution || 2;
    options.steps = options.steps || 100;
    options.visible = options.visible === undefined ? true: options.visible;
    this.hidden = !options.visible;

    this.animator = new torque.Animator(function(time) {
      var k = time | 0;
      if(self.key !== k) {
        self.setKey(k, { direct: true });
      }
    }, torque.extend(torque.clone(options), {
      onPause: function() {
        self.fire('pause');
      },
      onStop: function() {
        self.fire('stop');
      },
      onStart: function() {
        self.fire('play');
      },
      onStepsRange: function() {
        self.fire('change:stepsRange', self.animator.stepsRange());
      }
    }));

    this.play = this.animator.start.bind(this.animator);
    this.stop = this.animator.stop.bind(this.animator);
    this.pause = this.animator.pause.bind(this.animator);
    this.toggle = this.animator.toggle.bind(this.animator);
    this.setDuration = this.animator.duration.bind(this.animator);
    this.isRunning = this.animator.isRunning.bind(this.animator);


    L.CanvasLayer.prototype.initialize.call(this, options);

    this.options.renderer = this.options.renderer || 'point';
    this.options.provider = this.options.provider || 'windshaft';

    if (this.options.tileJSON) this.options.provider = 'tileJSON';

    this.provider = new this.providers[this.options.provider](this.options);
    this.renderer = new this.renderers[this.options.renderer](this.getCanvas(), this.options);

    options.ready = function() {
      self.fire("change:bounds", {
        bounds: self.provider.getBounds()
      });
      self.animator.steps(self.provider.getSteps());
      self.animator.rescale();
      self.fire('change:steps', {
        steps: self.provider.getSteps()
      });
      self.setKey(self.key);
    };

    this.renderer.on("allIconsLoaded", this.render.bind(this));


    // for each tile shown on the map request the data
    this.on('tileAdded', function(t) {
      var tileData = this.provider.getTileData(t, t.zoom, function(tileData) {
        // don't load tiles that are not being shown
        if (t.zoom !== self._map.getZoom()) return;
        self._tileLoaded(t, tileData);
        self._clearTileCaches();
        if (tileData) {
          self.redraw();
        }
        self.fire('tileLoaded');
      });
    }, this);

  },

  _clearTileCaches: function() {
    var t, tile;
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile && tile._tileCache) {
        tile._tileCache = null;
      }
    }
  },

  _clearCaches: function() {
    this.renderer && this.renderer.clearSpriteCache();
    this._clearTileCaches();
  },

  onAdd: function (map) {
    map.on({
      'zoomend': this._clearCaches,
      'zoomstart': this._pauseOnZoom,
    }, this);

    map.on({
      'zoomend': this._resumeOnZoom
    }, this);
    L.CanvasLayer.prototype.onAdd.call(this, map);
  },

  onRemove: function(map) {
    this.fire('remove');
    this._removeTileLoader();
    map.off({
      'zoomend': this._clearCaches,
      'zoomstart': this._pauseOnZoom,
    }, this);
    map.off({
      'zoomend': this._resumeOnZoom
    }, this);
    L.CanvasLayer.prototype.onRemove.call(this, map);
  },

  _pauseOnZoom: function() {
    this.wasRunning = this.isRunning();
    if (this.wasRunning) {
      this.pause();
    }
  },

  _resumeOnZoom: function() {
    if (this.wasRunning) {
      this.play();
    }
  },

  hide: function() {
    if(this.hidden) return this;
    this.pause();
    this.clear();
    this.hidden = true;
    return this;
  },

  show: function() {
    if(!this.hidden) return this;
    this.hidden = false;
    this.play();
    if (this.options.steps === 1){
      this.redraw();
    }
    return this;
  },

  setSQL: function(sql) {
    if (this.provider.options.named_map) throw new Error("SQL queries on named maps are read-only");
    if (!this.provider || !this.provider.setSQL) {
      throw new Error("this provider does not support SQL");
    }
    this.provider.setSQL(sql);
    this._reloadTiles();
    return this;
  },

  setBlendMode: function(_) {
    this.renderer.setBlendMode(_);
    this.redraw();
  },

  setSteps: function(steps) {
    this.provider.setSteps(steps);
    this._reloadTiles();
  },

  setColumn: function(column, isTime) {
    this.provider.setColumn(column, isTime);
    this._reloadTiles();
  },

  getTimeBounds: function() {
    return this.provider && this.provider.getKeySpan();
  },

  clear: function() {
    var canvas = this.getCanvas();
    canvas.width = canvas.width;
  },

  /**
   * render the selectef key
   * don't call this function directly, it's called by
   * requestAnimationFrame. Use redraw to refresh it
   */
  render: function() {
    if(this.hidden) return;
    var t, tile, pos;
    var canvas = this.getCanvas();
    this.renderer.clearCanvas();
    var ctx = canvas.getContext('2d');

    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        // clear cache
        if (this.animator.isRunning()) {
          tile._tileCache = null;
        }

        pos = this.getTilePos(tile.coord);
        ctx.setTransform(1, 0, 0, 1, pos.x, pos.y);

        if (tile._tileCache) {
          // when the tile has a cached image just render it and avoid to render
          // all the points
          this.renderer._ctx.drawImage(tile._tileCache, 0, 0);
        } else {
          this.renderer.renderTile(tile, this.key);
        }
      }
    }

    this.renderer.applyFilters();

    // prepare caches if the animation is not running
    // don't cache if the key has just changed, this avoids to cache
    // when the user is dragging, it only cache when the map is still
    if (!this.animator.isRunning() && this.key === this.prevRenderedKey) {
      var tile_size = this.renderer.TILE_SIZE;
      for(t in this._tiles) {
        tile = this._tiles[t];
        if (tile && !tile._tileCache) {
          var c = tile._tileCache = document.createElement('canvas');
          c.width = c.height = tile_size;
          pos = this.getTilePos(tile.coord);
          // clip bounds, firefox raise an exception when try to get data from outside canvas
          var x = Math.max(0, pos.x)
          var y = Math.max(0, pos.y)
          var w = Math.min(tile_size, this.getCanvas().width - x);
          var h = Math.min(tile_size, this.getCanvas().height - y);
          if (w > 0 && h > 0) {
            c.getContext('2d').drawImage(this.getCanvas(), x, y, w, h, x - pos.x, y - pos.y, w, h);
          }
        }
      }
    }

    this.prevRenderedKey = this.key;

  },

  /**
   * set key to be shown. If it's a single value
   * it renders directly, if it's an array it renders
   * accumulated
   */
  setKey: function(key, options) {
    this.key = key;
    this.animator.step(key);
    this._clearTileCaches();
    this.redraw(options && options.direct);
    this.fire('change:time', { time: this.getTime(), step: this.key });
  },

  /**
   * helper function, does the same than ``setKey`` but only
   * accepts scalars.
   */
  setStep: function(time) {
    if(time === undefined || time.length !== undefined) {
      throw new Error("setTime only accept scalars");
    }
    this.setKey(time);
  },

  /**
   * transform from animation step to Date object
   * that contains the animation time
   *
   * ``step`` should be between 0 and ``steps - 1``
   */
  stepToTime: function(step) {
    var times = this.provider.getKeySpan();
    var time = times.start + (times.end - times.start)*(step/this.provider.getSteps());
    return new Date(time);
  },

  timeToStep: function(timestamp) {
    if (typeof timestamp === "Date") timestamp = timestamp.getTime();
    if (!this.provider) return 0;
    var times = this.provider.getKeySpan();
    var step = (this.provider.getSteps() * (timestamp - times.start)) / (times.end - times.start);
    return step;
  },

  getStep: function() {
    return this.key;
  },

  /**
   * returns the animation time defined by the data
   * in the defined column. Date object
   */
  getTime: function() {
    return this.stepToTime(this.key);
  },

  /**
   * returns an object with the start and end times
   */
  getTimeSpan: function() {
    return this.provider.getKeySpan();
  },

  /**
   * set the cartocss for the current renderer
   */
  setCartoCSS: function(cartocss) {
    if (this.provider.options.named_map) throw new Error("CartoCSS style on named maps is read-only");
    if (!this.renderer) throw new Error('renderer is not valid');
    this.options.cartocss = cartocss;
    var shader = new carto.RendererJS().render(cartocss);
    this.renderer.setShader(shader);

    // provider options
    var options = torque.common.TorqueLayer.optionsFromLayer(shader.findLayer({ name: 'Map' }));
    this.provider.setCartoCSS && this.provider.setCartoCSS(cartocss);
    if(this.provider.setOptions(options)) {
      this._reloadTiles();
    }

    torque.extend(this.options, options);

    // animator options
    if (options.animationDuration) {
      this.animator.duration(options.animationDuration);
    }
    this._clearCaches();
    this.redraw();
    return this;
  },

  /**
   * get active points for a step in active zoom
   * returns a list of bounding boxes [[] , [], []]
   * empty list if there is no active pixels
   */
  getActivePointsBBox: function(step) {
    var positions = [];
    for(var t in this._tiles) {
      var tile = this._tiles[t];
      positions = positions.concat(this.renderer.getActivePointsBBox(tile, step));
    }
    return positions;
  },

  /**
   * return an array with the values for all the pixels active for the step
   */
  getValues: function(step) {
    var values = [];
    step = step === undefined ? this.key: step;
    var t, tile;
    for(t in this._tiles) {
      tile = this._tiles[t];
      this.renderer.getValues(tile, step, values);
    }
    return values;
  },

  /**
   * return the value for position relative to map coordinates. null for no value
   */
  getValueForPos: function(x, y, step) {
    step = step === undefined ? this.key: step;
    var t, tile, pos, value = null, xx, yy;
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        pos = this.getTilePos(tile.coord);
        xx = x - pos.x;
        yy = y - pos.y;
        if (xx >= 0 && yy >= 0 && xx < this.renderer.TILE_SIZE && yy <= this.renderer.TILE_SIZE) {
          value = this.renderer.getValueFor(tile, step, xx, yy);
        }
        if (value !== null) {
          return value;
        }
      }
    }
    return null;
  },

  /**
   * return tile pos given screen x,y coordinates
   */
  getTilePosForPixel: function(x, y) {
    var t, tile, pos, xx, yy;
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        pos = this.getTilePos(tile.coord);
        xx = x - pos.x;
        yy = y - pos.y;
        if (xx >= 0 && yy >= 0 && xx < this.renderer.TILE_SIZE && yy <= this.renderer.TILE_SIZE) {
          return {
            x: xx,
            y: yy,
            tile: tile.coord
          }
        }
      }
    }
    return null;
  },

  /**
   * return a list of the closest values for a given coord.
   * returned format is [{ x: .., y: .., value: ...}, .. ]
   */
  getClosestValuesFor: function(x, y, dist, step) {
    var xf = x + dist,
        yf = y + dist,
        _x = x;
    var values = []
    for(_y = y; _y < yf; _y += this.options.resolution){
      for(_x = x; _x < xf; _x += this.options.resolution){
        var thisValue = this.getValueForPos(_x,_y);
        if (thisValue !== null) {
          var bb = thisValue.bbox;
          var xy = this._map.latLngToContainerPoint([bb[0].lat, bb[0].lon]);
          values.push({
            x: xy.x,
            y: xy.y,
            value: thisValue.value
          })
        }
      }
    }
    return values;
  },

  getValueForBBox: function(x, y, w, h) {
    var xf = x + w, yf = y + h, _x=x;
    var sum = 0;
    for(_y = y; _y < yf; _y += this.options.resolution){
      for(_x = x; _x < xf; _x += this.options.resolution){
        var thisValue = this.getValueForPos(_x,_y);
        if (thisValue) {
          var bb = thisValue.bbox;
          var xy = this._map.latLngToContainerPoint([bb[1].lat, bb[1].lon]);
          if(xy.x < xf && xy.y < yf){
            sum += thisValue.value;
          }
        }
      }
    }
    return sum;
  },

  /** return the number of points for a step */
  pointCount: function(step) {
    var t, tile;
    step = step === undefined ? this.key: step;
    var c = 0;
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        c += tile.timeCount[step];
      }
    }
    return c;
  },

  invalidate: function() {
    this.provider.reload();
  },

  setStepsRange: function(start, end) {
    this.animator.stepsRange(start, end);
  },

  removeStepsRange: function() {
    this.animator.removeCustomStepsRange();
  },

  getStepsRange: function() {
    return this.animator.stepsRange();
  }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":25,"./canvas_layer":26,"carto":45}],30:[function(require,module,exports){
  function clamp(a, b) {
    return function(t) {
      return Math.max(Math.min(t, b), a);
    };
  }

  function invLinear(a, b) {
    var c = clamp(0, 1.0);
    return function(t) {
      return c((t - a)/(b - a));
    };
  }

  function linear(a, b) {
    var c = clamp(a, b);
    function _linear(t) {
      return c(a*(1.0 - t) + t*b);
    }

    _linear.invert = function() {
      return invLinear(a, b);
    };

    return _linear;
  }

module.exports = {
    clamp: clamp,
    linear: linear,
    invLinear: invLinear
};

},{}],31:[function(require,module,exports){
var Point = function(x, y) {
  this.x = x || 0;
  this.y = y || 0;
};

function clamp(value, optMin, optMax) {
  if (optMin !== null) value = Math.max(value, optMin);
  if (optMax !== null) value = Math.min(value, optMax);
  return value;
}

function degreesToRadians(deg) {
  return deg * (Math.PI / 180);
}

function radiansToDegrees(rad) {
  return rad / (Math.PI / 180);
}


var MercatorProjection = function() {
//  this._tileSize = L.Browser.retina ? 512 : 256;
  this._tileSize = 256;
  this._pixelOrigin = new Point(this._tileSize / 2, this._tileSize / 2);
  this._pixelsPerLonDegree = this._tileSize / 360;
  this._pixelsPerLonRadian = this._tileSize / (2 * Math.PI);
};

MercatorProjection.prototype._fromLatLonToPoint = function(lat, lon) {
  var point = new Point(0, 0);
  var origin = this._pixelOrigin;

  point.x = origin.x + lon * this._pixelsPerLonDegree;

  // NOTE(appleton): Truncating to 0.9999 effectively limits latitude to
  // 89.189.  This is about a third of a tile past the edge of the world
  // tile.
  var siny = clamp(Math.sin(degreesToRadians(lat)), -0.9999, 0.9999);
  point.y = origin.y + 0.5 * Math.log((1 + siny) / (1 - siny)) * -this._pixelsPerLonRadian;
  return point;
};

MercatorProjection.prototype._fromPointToLatLon = function(point) {
  var me = this;
  var origin = me._pixelOrigin;
  var lon = (point.x - origin.x) / me._pixelsPerLonDegree;
  var latRadians = (point.y - origin.y) / -me._pixelsPerLonRadian;
  var lat = radiansToDegrees(2 * Math.atan(Math.exp(latRadians)) - Math.PI / 2);
  return { lat:lat, lon:lon };
};

MercatorProjection.prototype._tilePixelPos = function(tileX, tileY) {
  return {
    x: tileX*this._tileSize,
    y: tileY*this._tileSize
  };
};

MercatorProjection.prototype.tilePixelBBox = function(x, y, zoom, px, py, res) {
  res = res || 1.0;
  var numTiles = 1 <<zoom;
  var inc = res/numTiles;
  px = (x*this._tileSize + px)/numTiles;
  py = (y*this._tileSize + py)/numTiles;
  return [
    this._fromPointToLatLon(new Point(px, py + inc)),
    this._fromPointToLatLon(new Point(px + inc, py))
  ];
};

MercatorProjection.prototype.tileBBox = function(x, y, zoom, bufferSize) {
  var numTiles = 1 <<zoom;
  bufferSize = bufferSize || 0;
  var inc =  (this._tileSize + bufferSize*2)/numTiles;
  var px = (x*this._tileSize - bufferSize  )/numTiles;
  var py = (y*this._tileSize - bufferSize  )/numTiles;
  return [
    this._fromPointToLatLon(new Point(px, py + inc)),
    this._fromPointToLatLon(new Point(px + inc, py))
  ];
};

MercatorProjection.prototype.latLonToTilePoint = function(lat, lon, tileX, tileY, zoom) {
  var numTiles = 1 <<zoom;
  var worldCoordinate = this._fromLatLonToPoint(lat, lon);
  var pixelCoordinate = new Point(worldCoordinate.x*numTiles, worldCoordinate.y*numTiles);
  var tilePixelPos    = this._tilePixelPos(tileX, tileY);
  return new Point(Math.round(pixelCoordinate.x-tilePixelPos.x), Math.round(pixelCoordinate.y-tilePixelPos.y));
};

module.exports = MercatorProjection;

},{}],32:[function(require,module,exports){
/*
# metrics profiler

## timing

```
 var timer = Profiler.metric('resource:load')
 time.start();
 ...
 time.end();
```

## counters

```
 var counter = Profiler.metric('requests')
 counter.inc();   // 1
 counter.inc(10); // 11
 counter.dec()    // 10
 counter.dec(10)  // 0
```

## Calls per second
```
  var fps = Profiler.metric('fps')
  function render() {
    fps.mark();
  }
```
*/
var MAX_HISTORY = 1024;
function Profiler() {}
Profiler.metrics = {};

Profiler.get = function(name) {
  return Profiler.metrics[name] || {
    max: 0,
    min: Number.MAX_VALUE,
    avg: 0,
    total: 0,
    count: 0,
    history: typeof(Float32Array) !== 'undefined' ? new Float32Array(MAX_HISTORY) : []
  };
};

Profiler.new_value = function (name, value) {
  var t = Profiler.metrics[name] = Profiler.get(name);

  t.max = Math.max(t.max, value);
  t.min = Math.min(t.min, value);
  t.total += value;
  ++t.count;
  t.avg = t.total / t.count;
  t.history[t.count%MAX_HISTORY] = value;
};

Profiler.print_stats = function () {
  for (k in Profiler.metrics) {
    var t = Profiler.metrics[k];
    console.log(" === " + k + " === ");
    console.log(" max: " + t.max);
    console.log(" min: " + t.min);
    console.log(" avg: " + t.avg);
    console.log(" count: " + t.count);
    console.log(" total: " + t.total);
  }
};

function Metric(name) {
  this.t0 = null;
  this.name = name;
  this.count = 0;
}

Metric.prototype = {

  //
  // start a time measurement
  //
  start: function() {
    this.t0 = +new Date();
    return this;
  },

  // elapsed time since start was called
  _elapsed: function() {
    return +new Date() - this.t0;
  },

  //
  // finish a time measurement and register it
  // ``start`` should be called first, if not this
  // function does not take effect
  //
  end: function() {
    if (this.t0 !== null) {
      Profiler.new_value(this.name, this._elapsed());
      this.t0 = null;
    }
  },

  //
  // increments the value
  // qty: how many, default = 1
  //
  inc: function(qty) {
    qty = qty === undefined ? 1: qty;
    Profiler.new_value(this.name, Profiler.get(this.name).count + (qty ? qty: 0));
  },

  //
  // decrements the value
  // qty: how many, default = 1
  //
  dec: function(qty) {
    qty = qty === undefined ? 1: qty;
    this.inc(-qty);
  },

  //
  // measures how many times per second this function is called
  //
  mark: function() {
    ++this.count;
    if(this.t0 === null) {
      this.start();
      return;
    }
    var elapsed = this._elapsed();
    if(elapsed > 1) {
      Profiler.new_value(this.name, this.count);
      this.count = 0;
      this.start();
    }
  }
};

Profiler.metric = function(name) {
  return new Metric(name);
};

module.exports = Profiler;

},{}],33:[function(require,module,exports){
module.exports = {
    json: require('./json'),
    JsonArray: require('./jsonarray'),
    windshaft: require('./windshaft'),
    tileJSON: require('./tilejson')
};

},{"./json":34,"./jsonarray":35,"./tilejson":36,"./windshaft":37}],34:[function(require,module,exports){
var torque = require('../');
var Profiler = require('../profiler');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var json = function (options) {
    this._ready = false;
    this._tileQueue = [];
    this.options = options;

    this.options.is_time = this.options.is_time === undefined ? true: this.options.is_time;
    this.options.tiler_protocol = options.tiler_protocol || 'http';
    this.options.tiler_domain = options.tiler_domain || 'cartodb.com';
    this.options.tiler_port = options.tiler_port || 80;

    if (this.options.data_aggregation) {
      this.options.cumulative = this.options.data_aggregation === 'cumulative';
    }

    // check options
    if (options.resolution === undefined ) throw new Error("resolution should be provided");
    if (options.steps === undefined ) throw new Error("steps should be provided");
    if(options.start === undefined) {
      this._fetchKeySpan();
    } else {
      this._setReady(true);
    }
  };

  json.prototype = {

    /**
     * return the torque tile encoded in an efficient javascript
     * structure:
     * {
     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255
     *   y:Uint8Array y coordinates in tile reference system
     *   Index: Array index to the properties
     * }
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new Uint8Array(rows.length);
      var y = new Uint8Array(rows.length);

      var prof_mem = Profiler.metric('ProviderJSON:mem');
      var prof_point_count = Profiler.metric('ProviderJSON:point_count');
      var prof_process_time = Profiler.metric('ProviderJSON:process_time').start()

      // count number of dates
      var dates = 0;
      var maxDateSlots = -1;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.dates__uint16.length;
        for(var d = 0; d < row.dates__uint16.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);
        }
      }

      if(this.options.cumulative) {
        dates = (1 + maxDateSlots) * rows.length;
      }

      var type = this.options.cumulative ? Uint32Array: Uint8Array;

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || type)(dates);
      var renderDataPos = new Uint32Array(dates);

      prof_mem.inc(
        4 * maxDateSlots + // timeIndex
        4 * maxDateSlots + // timeCount
        dates + //renderData
        dates * 4
      ); //renderDataPos

      prof_point_count.inc(rows.length);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x__uint8 * this.options.resolution;
        // fix value when it's in the tile EDGE
        // TODO: this should be fixed in SQL query
        if (row.y__uint8 === -1) {
          y[r] = 0;
        } else {
          y[r] = row.y__uint8 * this.options.resolution;
        }

        var dates = row.dates__uint16;
        var vals = row.vals__uint8;
        if (!this.options.cumulative) {
          for (var j = 0, len = dates.length; j < len; ++j) {
              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
              if(this.options.cumulative) {
                  vals[j] += prev_val;
              }
              prev_val = vals[j];
              rr.push([r, vals[j]]);
          }
        } else {
          var valByDate = {}
          for (var j = 0, len = dates.length; j < len; ++j) {
            valByDate[dates[j]] = vals[j];
          }
          var accum = 0;

          // extend the latest to the end
          for (var j = dates[0]; j <= maxDateSlots; ++j) {
              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
              var v = valByDate[j];
              if (v) {
                accum += v;
              }
              rr.push([r, accum]);
          }

          /*var lastDateSlot = dates[dates.length - 1];
          for (var j = lastDateSlot + 1; j <= maxDateSlots; ++j) {
            var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
            rr.push([r, prev_val]);
          }
          */
        }

      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      prof_process_time.end();

      return {
        x: x,
        y: y,
        z: zoom,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData,
        maxDate: maxDateSlots
      };
    },

    _host: function() {
      var opts = this.options;
      var port = opts.sql_api_port;
      var domain = ((opts.user_name || opts.user) + '.' + (opts.sql_api_domain || 'cartodb.com')) + (port ? ':' + port: '');
      var protocol = opts.sql_api_protocol || 'http';
      return this.options.url || protocol + '://' + domain + '/api/v2/sql';
    },

    url: function(subhost) {
      var opts = this.options;
      var protocol = opts.sql_api_protocol || 'http';
      if (!this.options.cdn_url) {
        return this._host();
      }
      var h = protocol+ "://";
      if (subhost) {
        h += subhost + ".";
      }
      var cdn_host = opts.cdn_url;
      if(!cdn_host.http && !cdn_host.https) {
        throw new Error("cdn_host should contain http and/or https entries");
      }
      h += cdn_host[protocol] + "/" + (opts.user_name || opts.user) + '/api/v2/sql';
      return h;
    },

    _hash: function(str) {
      var hash = 0;
      if (!str || str.length == 0) return hash;
      for (var i = 0, l = str.length; i < l; ++i) {
          hash = (( (hash << 5 ) - hash ) + str.charCodeAt(i)) | 0;
      }
      return hash;
    },

    _extraParams: function() {
      if (this.options.extra_params) {
        var p = [];
        for(var k in this.options.extra_params) {
          var v = this.options.extra_params[k];
          if (v) {
            p.push(k + "=" + encodeURIComponent(v));
          }
        }
        return p.join('&');
      }
      return null;
    },

    isHttps: function() {
      return this.options.sql_api_protocol && this.options.sql_api_protocol === 'https';
    },

    // execute actual query
    sql: function(sql, callback, options) {
      options = options || {};
      var subdomains = this.options.subdomains || '0123';
      if(this.isHttps()) {
        subdomains = [null]; // no subdomain
      }


      var url;
      if (options.no_cdn) {
        url = this._host();
      } else {
        url = this.url(subdomains[Math.abs(this._hash(sql))%subdomains.length]);
      }
      var extra = this._extraParams();
      torque.net.get( url + "?q=" + encodeURIComponent(sql) + (extra ? "&" + extra: ''), function (data) {
          if(options.parseJSON) {
            data = JSON.parse(data && data.responseText);
          }
          callback && callback(data);
      });
    },

    getTileData: function(coord, zoom, callback) {
      if(!this._ready) {
        this._tileQueue.push([coord, zoom, callback]);
      } else {
        this._getTileData(coord, zoom, callback);
      }
    },

    _setReady: function(ready) {
      this._ready = true;
      this._processQueue();
      this.options.ready && this.options.ready();
    },

    _processQueue: function() {
      var item;
      while (item = this._tileQueue.pop()) {
        this._getTileData.apply(this, item);
      }
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    _getTileData: function(coord, zoom, callback) {
      var prof_fetch_time = Profiler.metric('ProviderJSON:tile_fetch_time').start()
      this.table = this.options.table;
      var numTiles = 1 << zoom;

      var column_conv = this.options.column;

      if(this.options.is_time) {
        column_conv = format("date_part('epoch', {column})", this.options);
      }

      var sql = "" +
        "WITH " +
        "par AS (" +
        "  SELECT CDB_XYZ_Resolution({zoom})*{resolution} as res" +
        ",  256/{resolution} as tile_size" +
        ", CDB_XYZ_Extent({x}, {y}, {zoom}) as ext "  +
        ")," +
        "cte AS ( "+
        "  SELECT ST_SnapToGrid(i.the_geom_webmercator, p.res) g" +
        ", {countby} c" +
        ", floor(({column_conv} - {start})/{step}) d" +
        "  FROM ({_sql}) i, par p " +
        "  WHERE i.the_geom_webmercator && p.ext " +
        "  GROUP BY g, d" +
        ") " +
        "" +
        "SELECT (st_x(g)-st_xmin(p.ext))/p.res x__uint8, " +
        "       (st_y(g)-st_ymin(p.ext))/p.res y__uint8," +
        " array_agg(c) vals__uint8," +
        " array_agg(d) dates__uint16" +
        // the tile_size where are needed because the overlaps query in cte subquery includes the points
        // in the left and bottom borders of the tile
        " FROM cte, par p where (st_y(g)-st_ymin(p.ext))/p.res < tile_size and (st_x(g)-st_xmin(p.ext))/p.res < tile_size GROUP BY x__uint8, y__uint8";


      var query = format(sql, this.options, {
        zoom: zoom,
        x: coord.x,
        y: coord.y,
        column_conv: column_conv,
        _sql: this.getSQL()
      });

      var self = this;
      this.sql(query, function (data) {
        if (data) {
          var rows = JSON.parse(data.responseText).rows;
          callback(self.proccessTile(rows, coord, zoom));
        } else {
          callback(null);
        }
        prof_fetch_time.end();
      });
    },

    getKeySpan: function() {
      return {
        start: this.options.start * 1000,
        end: this.options.end * 1000,
        step: this.options.step,
        steps: this.options.steps,
        columnType: this.options.is_time ? 'date': 'number'
      };
    },

    setColumn: function(column, isTime) {
      this.options.column = column;
      this.options.is_time = isTime === undefined ? true: false;
      this.reload();
    },

    setResolution: function(res) {
      this.options.resolution = res;
    },

    // return true if tiles has been changed
    setOptions: function(opt) {
      var refresh = false;

      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {
        this.options.resolution = opt.resolution;
        refresh = true;
      }

      if(opt.steps !== undefined && opt.steps !== this.options.steps) {
        this.setSteps(opt.steps, { silent: true });
        refresh = true;
      }

      if(opt.column !== undefined && opt.column !== this.options.column) {
        this.options.column = opt.column;
        refresh = true;
      }

      if(opt.countby !== undefined && opt.countby !== this.options.countby) {
        this.options.countby = opt.countby;
        refresh = true;
      }

      if(opt.data_aggregation !== undefined) {
        var c = opt.data_aggregation === 'cumulative';
        if (this.options.cumulative !== c) {
          this.options.cumulative = c;
          refresh = true;
        }
      }

      if (refresh) this.reload();
      return refresh;

    },

    reload: function() {
      this._ready = false;
      this._fetchKeySpan();
    },

    setSQL: function(sql) {
      if (this.options.sql != sql) {
        this.options.sql = sql;
        this.reload();
      }
    },

    getSteps: function() {
      return Math.min(this.options.steps, this.options.data_steps);
    },

    setSteps: function(steps, opt) {
      opt = opt || {};
      if (this.options.steps !== steps) {
        this.options.steps = steps;
        this.options.step = (this.options.end - this.options.start)/this.getSteps();
        this.options.step = this.options.step || 1;
        if (!opt.silent) this.reload();
      }
    },

    getBounds: function() {
      return this.options.bounds;
    },

    getSQL: function() {
      return this.options.sql || "select * from " + this.options.table;
    },

    _tilerHost: function() {
      var opts = this.options;
      var user = (opts.user_name || opts.user);
      return opts.tiler_protocol +
           "://" + (user ? user + "." : "")  +
           opts.tiler_domain +
           ((opts.tiler_port != "") ? (":" + opts.tiler_port) : "");
    },

    _fetchUpdateAt: function(callback) {
      var self = this;
      var layergroup = {
        "version": "1.0.1",
        "stat_tag": this.options.stat_tag || 'torque',
        "layers": [{
          "type": "cartodb",
          "options": {
            "cartocss_version": "2.1.1",
            "cartocss": "#layer {}",
            "sql": this.getSQL()
          }
        }]
      };
      var url = this._tilerHost() + "/tiles/layergroup";
      var extra = this._extraParams();

      // tiler needs map_key instead of api_key
      // so replace it
      if (extra) {
        extra = extra.replace('api_key=', 'map_key=');
      }

      url = url +
        "?config=" + encodeURIComponent(JSON.stringify(layergroup)) +
        "&callback=?" + (extra ? "&" + extra: '');

      torque.net.jsonp(url, function (data) {
        var query = format("select * from ({sql}) __torque_wrap_sql limit 0", { sql: self.getSQL() });
        self.sql(query, function (queryData) {
          if (data && queryData) {
            callback({
              updated_at: data.last_updated,
              fields: queryData.fields
            });
          }
        }, { parseJSON: true });
      });
    },

    //
    // the data range could be set by the user though ``start``
    // option. It can be fecthed from the table when the start
    // is not specified.
    //
    _fetchKeySpan: function() {
      var self = this;
      var max_col, min_col, max_tmpl, min_tmpl;

      this._fetchUpdateAt(function(data) {
        if (!data) return;
        self.options.extra_params = self.options.extra_params || {};
        self.options.extra_params.last_updated = data.updated_at || 0;
        self.options.extra_params.cache_policy = 'persist';
        self.options.is_time = data.fields[self.options.column].type === 'date';

        var column_conv = self.options.column;
        if (self.options.is_time){
          max_tmpl = "date_part('epoch', max({column}))";
          min_tmpl = "date_part('epoch', min({column}))";
          column_conv = format("date_part('epoch', {column})", self.options);
        } else {
          max_tmpl = "max({column})";
          min_tmpl = "min({column})";
        }

        max_col = format(max_tmpl, { column: self.options.column });
        min_col = format(min_tmpl, { column: self.options.column });

        /*var sql_stats = "" +
        "WITH summary_groups as ( " +
          "WITH summary as ( " +
           "select   (row_number() over (order by __time_col asc nulls last)+1)/2 as rownum, __time_col " +
            "from (select *, {column} as __time_col from ({sql}) __s) __torque_wrap_sql " +
            "order by __time_col asc " +
          ") " +
          "SELECT " +
          "max(__time_col) OVER(PARTITION BY rownum) -  " +
          "min(__time_col) OVER(PARTITION BY rownum) diff " +
          "FROM summary " +
        "), subq as ( " +
        " SELECT " +
            "st_xmax(st_envelope(st_collect(the_geom))) xmax, " +
            "st_ymax(st_envelope(st_collect(the_geom))) ymax, " +
            "st_xmin(st_envelope(st_collect(the_geom))) xmin, " +
            "st_ymin(st_envelope(st_collect(the_geom))) ymin, " +
            "{max_col} max, " +
            "{min_col} min FROM  ({sql}) __torque_wrap_sql " +
        ")" +
        "SELECT " +
        "xmax, xmin, ymax, ymin, a.max as max_date, a.min as min_date, " +
        "avg(diff) as diffavg," +
        "(a.max - a.min)/avg(diff) as num_steps " +
        "FROM summary_groups, subq a  " +
        "WHERE diff > 0 group by xmax, xmin, ymax, ymin, max_date, min_date";
        */
        var sql_stats = " SELECT " +
            "st_xmax(st_envelope(st_collect(the_geom))) xmax, " +
            "st_ymax(st_envelope(st_collect(the_geom))) ymax, " +
            "st_xmin(st_envelope(st_collect(the_geom))) xmin, " +
            "st_ymin(st_envelope(st_collect(the_geom))) ymin, " +
            "count(*) as num_steps, " +
            "{max_col} max_date, " +
            "{min_col} min_date FROM  ({sql}) __torque_wrap_sql ";

        var sql = format(sql_stats, {
          max_col: max_col,
          min_col: min_col,
          column: column_conv,
          sql: self.getSQL()
        });

        self.sql(sql, function(data) {
          //TODO: manage bounds
          data = data.rows[0];
          self.options.start = data.min_date;
          self.options.end = data.max_date;
          self.options.step = (data.max_date - data.min_date)/Math.min(self.options.steps, data.num_steps>>0);
          self.options.data_steps = data.num_steps >> 0;
          // step can't be 0
          self.options.step = self.options.step || 1;
          self.options.bounds = [
            [data.ymin, data.xmin],
            [data.ymax, data.xmax]
          ];
          self._setReady(true);
        }, { parseJSON: true, no_cdn: true });
      }, { parseJSON: true, no_cdn: true})
    }

  };

module.exports = json;

},{"../":25,"../profiler":32}],35:[function(require,module,exports){
var torque = require('../');
var Profiler = require('../profiler');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str, attrs) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var json = function (options) {
    // check options
    this.options = options;
  };


  json.prototype = {

    //
    // return the data aggregated by key:
    // {
    //  key0: 12,
    //  key1: 32
    //  key2: 25
    // }
    //
    aggregateByKey: function(rows) {
      function getKeys(row) {
        var HEADER_SIZE = 3;
        var valuesCount = row.data[2];
        var keys = {};
        for (var s = 0; s < valuesCount; ++s) {
          keys[row.data[HEADER_SIZE + s]] = row.data[HEADER_SIZE + valuesCount + s];
        }
        return keys;
      }
      var keys = {};
      for (r = 0; r < rows.length; ++r) {
        var rowKeys = getKeys(rows[r]);
        for(var k in rowKeys) {
          keys[k] = keys[k] || 0;
          keys[k] += rowKeys[k];
        }
      }
      return keys;
    },




    /**
     *
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new Uint8Array(rows.length);
      var y = new Uint8Array(rows.length);
      var self = this;

      // decode into a javascript strcuture the array
      function decode_row(row) {
        var HEADER_SIZE = 3;
        var o = {
          x: row.data[0] * self.options.resolution,
          y: row.data[1] * self.options.resolution,
          valuesCount: row.data[2],
          times: [],
          values: []
        };
        for (var s = 0; s < o.valuesCount; ++s) {
           o.times.push(row.data[HEADER_SIZE + s]);
           o.values.push(row.data[HEADER_SIZE + o.valuesCount + s]);
        }
        if(self.options.cumulative) {
          for (var s = 1; s < o.valuesCount; ++s) {
           o.values[s] += o.values[s - 1];
          }
        }
        return o
      }

      // decode all the rows
      for (r = 0; r < rows.length; ++r) {
        rows[r] = decode_row(rows[r]);
      }

      // count number of dates
      var dates = 0;
      var maxDateSlots = 0;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.times.length;
        for(var d = 0; d < row.times.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.times[d]);
        }
      }

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || Uint8Array)(dates);
      var renderDataPos = new Uint32Array(dates);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x;
        y[r] = row.y;

        var dates = row.times;
        var vals = row.values;
        for (var j = 0, len = dates.length; j < len; ++j) {
            var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
            rr.push([r, vals[j]]);
        }
      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      return {
        x: x,
        y: y,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData
      };
    },

    url: function() {
      return this.options.url;
    },


    tileUrl: function(coord, zoom) {
      var template = this.url();
      var s = (this.options.subdomains || 'abcd')[(coord.x + coord.y + zoom) % 4];
      return template
        .replace('{x}', coord.x)
        .replace('{y}', coord.y)
        .replace('{z}', zoom)
        .replace('{s}', s);
    },

    getTile: function(coord, zoom, callback) {
      var template = this.tileUrl(coord, zoom);

      var self = this;
      var fetchTime = Profiler.metric('jsonarray:fetch time');
      fetchTime.start();
      torque.net.get(template, function (data) {
        fetchTime.end();
        if(data) {
          data = JSON.parse(data.responseText);
        }
        callback(data);
      });
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    getTileData: function(coord, zoom, callback) {
      var template = this.tileUrl(coord, zoom);

      var self = this;
      var fetchTime = Profiler.metric('jsonarray:fetch time');
      fetchTime.start();
      torque.net.get(template, function (data) {
        fetchTime.end();
        var processed = null;

        var processingTime = Profiler.metric('jsonarray:processing time');
        var parsingTime = Profiler.metric('jsonarray:parsing time');
        try {
          processingTime.start();
          parsingTime.start();
          var rows = JSON.parse(data.responseText || data.response).rows;
          parsingTime.end();
          processed = self.proccessTile(rows, coord, zoom);
          processingTime.end();
        } catch(e) {
          console.error("problem parsing JSON on ", coord, zoom);
        }

        callback(processed);

      });
    }

  };

  module.exports = json;

},{"../":25,"../profiler":32}],36:[function(require,module,exports){
  var torque = require('../');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;
  var Uint8ClampedArray = torque.types.Uint8ClampedArray;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var tileJSON = function (options) {
    this._ready = false;
    this._tileQueue = [];
    this.options = options;

    this.options.coordinates_data_type = this.options.coordinates_data_type || Uint8Array;

    if (this.options.data_aggregation) {
      this.options.cumulative = this.options.data_aggregation === 'cumulative';
    }
    if (this.options.auth_token) {
      var e = this.options.extra_params || (this.options.extra_params = {});
      e.auth_token = this.options.auth_token;
    }
    if (!this.options.no_fetch_map) {
      this._fetchMap();
    }
  };

  tileJSON.prototype = {

    NAME: "tileJSON",

    /**
     * return the torque tile encoded in an efficient javascript
     * structure:
     * {
     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255
     *   y:Uint8Array y coordinates in tile reference system
     *   Index: Array index to the properties
     * }
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new this.options.coordinates_data_type(rows.length);
      var y = new this.options.coordinates_data_type(rows.length);

      // count number of dates
      var dates = 0;
      var maxDateSlots = -1;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.dates__uint16.length;
        for(var d = 0; d < row.dates__uint16.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);
        }
      }

      if(this.options.cumulative) {
        dates = (1 + maxDateSlots) * rows.length;
      }

      var type = this.options.cumulative ? Uint32Array: Uint8ClampedArray;

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || type)(dates);
      var renderDataPos = new Uint32Array(dates);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x__uint8 * this.options.resolution;
        y[r] = row.y__uint8 * this.options.resolution;

        var dates = row.dates__uint16;
        var vals = row.vals__uint8;
        if (!this.options.cumulative) {
          for (var j = 0, len = dates.length; j < len; ++j) {
              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
              if(this.options.cumulative) {
                  vals[j] += prev_val;
              }
              prev_val = vals[j];
              rr.push([r, vals[j]]);
          }
        } else {
          var valByDate = {}
          for (var j = 0, len = dates.length; j < len; ++j) {
            valByDate[dates[j]] = vals[j];
          }
          var accum = 0;

          // extend the latest to the end
          for (var j = dates[0]; j <= maxDateSlots; ++j) {
              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
              var v = valByDate[j];
              if (v) {
                accum += v;
              }
              rr.push([r, accum]);
          }
        }
      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      return {
        x: x,
        y: y,
        z: zoom,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData,
        maxDate: maxDateSlots
      };
    },

    setSteps: function(steps, opt) {
      opt = opt || {};
      if (this.options.steps !== steps) {
        this.options.steps = steps;
        this.options.step = (this.options.end - this.options.start)/this.getSteps();
        this.options.step = this.options.step || 1;
        if (!opt.silent) this.reload();
      }
    },

    setOptions: function(opt) {
      var refresh = false;

      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {
        this.options.resolution = opt.resolution;
        refresh = true;
      }

      if(opt.steps !== undefined && opt.steps !== this.options.steps) {
        this.setSteps(opt.steps, { silent: true });
        refresh = true;
      }

      if(opt.column !== undefined && opt.column !== this.options.column) {
        this.options.column = opt.column;
        refresh = true;
      }

      if(opt.countby !== undefined && opt.countby !== this.options.countby) {
        this.options.countby = opt.countby;
        refresh = true;
      }

      if(opt.data_aggregation !== undefined) {
        var c = opt.data_aggregation === 'cumulative';
        if (this.options.cumulative !== c) {
          this.options.cumulative = c;
          refresh = true;
        }
      }

      if (refresh) this.reload();
      return refresh;
    },

    _extraParams: function(e) {
      e = torque.extend(torque.extend({}, e), this.options.extra_params);
      if (e) {
        var p = [];
        for(var k in e) {
          var v = e[k];
          if (v) {
            if (torque.isArray(v)) {
              for (var i = 0, len = v.length; i < len; i++) {
                p.push(k + "[]=" + encodeURIComponent(v[i]));
              }
            } else {
              p.push(k + "=" + encodeURIComponent(v));
            }
          }
        }
        return p.join('&');
      }
      return null;
    },

    getTileData: function(coord, zoom, callback) {
      if(!this._ready) {
        this._tileQueue.push([coord, zoom, callback]);
      } else {
        this._getTileData(coord, zoom, callback);
      }
    },

    _setReady: function(ready) {
      this._ready = true;
      this._processQueue();
      this.options.ready && this.options.ready();
    },

    _processQueue: function() {
      var item;
      while (item = this._tileQueue.pop()) {
        this._getTileData.apply(this, item);
      }
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    _getTileData: function(coord, zoom, callback) {
      var self = this;
      var subdomains = this.options.subdomains || '0123';
      var limit_x = Math.pow(2, zoom);
      var corrected_x = ((coord.x % limit_x) + limit_x) % limit_x;
      var index = Math.abs(corrected_x + coord.y) % subdomains.length;
      var extra = this._extraParams();
      var url = this.templateUrl
                .replace('{x}', corrected_x)
                .replace('{y}', coord.y)
                .replace('{z}', zoom)
                .replace('{s}', subdomains[index])
      url += extra;
      torque.net.get( url , function (data) {
        if (data && data.responseText) {
          var rows = JSON.parse(data.responseText);
          callback(self.proccessTile(rows, coord, zoom));
        } else {
          callback(null);
        }
      });
    },

    getKeySpan: function() {
      return {
        start: this.options.start,
        end: this.options.end,
        step: this.options.step,
        steps: this.options.steps,
        columnType: this.options.column_type
      };
    },

    setColumn: function(column, isTime) {
      this.options.column = column;
      this.options.is_time = isTime === undefined ? true: false;
      this.reload();
    },

    reload: function() {
      this._ready = false;
      this._fetchMap();
    },

    getSteps: function() {
      return Math.min(this.options.steps, this.options.data_steps);
    },

    getBounds: function() {
      return this.options.bounds;
    },

    getSQL: function() {
      return this.options.sql || "select * from " + this.options.table;
    },

    setSQL: function(sql) {
      if (this.options.sql != sql) {
        this.options.sql = sql;
        this.reload();
      }
    },

    _isUserTemplateUrl: function(t) {
      return t && t.indexOf('{user}') !== -1;
    },

    isHttps: function() {
      return this.options.maps_api_template.indexOf('https') === 0;
    },

    _fetchMap: function(callback) {
      var self = this;
      torque.net.get(this.options.tileJSON, function (data) {
        data = JSON.parse(data.response);
        if (data) {
          if (data.errors){
            self.options.errorCallback && self.options.errorCallback(data.errors);
            return;
          }
          for(var k in data) {
            self.options[k] = data[k];
          }
          self.templateUrl = data.tiles[0];
          if (self.templateUrl.indexOf("http") !== 0){
            self.templateUrl = self.options.tileJSON.substring(0, self.options.tileJSON.lastIndexOf("/") + 1) + self.templateUrl;
          }
          self._setReady(true);
        }
      });
    }
  };

  module.exports = tileJSON;
},{"../":25}],37:[function(require,module,exports){
  var torque = require('../');
  var Profiler = require('../profiler');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;
  var Uint8ClampedArray = torque.types.Uint8ClampedArray;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var windshaft = function (options) {
    this._ready = false;
    this._tileQueue = [];
    this.options = options;

    this.options.is_time = this.options.is_time === undefined ? true: this.options.is_time;
    this.options.tiler_protocol = options.tiler_protocol || 'http';
    this.options.tiler_domain = options.tiler_domain || 'cartodb.com';
    this.options.tiler_port = options.tiler_port || 80;

    // backwards compatible
    if (!options.maps_api_template) {
      this._buildMapsApiTemplate(this.options);
    } else {
      this.options.maps_api_template =  options.maps_api_template;
    }

    this.options.coordinates_data_type = this.options.coordinates_data_type || Uint8Array;

    if (this.options.data_aggregation) {
      this.options.cumulative = this.options.data_aggregation === 'cumulative';
    }
    if (this.options.auth_token) {
      var e = this.options.extra_params || (this.options.extra_params = {});
      e.auth_token = this.options.auth_token;
    }
    if (!this.options.no_fetch_map) {
      this._fetchMap();
    }
  };

  windshaft.prototype = {

    /**
     * return the torque tile encoded in an efficient javascript
     * structure:
     * {
     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255
     *   y:Uint8Array y coordinates in tile reference system
     *   Index: Array index to the properties
     * }
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new this.options.coordinates_data_type(rows.length);
      var y = new this.options.coordinates_data_type(rows.length);

      var prof_mem = Profiler.metric('torque.provider.windshaft.mem');
      var prof_point_count = Profiler.metric('torque.provider.windshaft.points');
      var prof_process_time = Profiler.metric('torque.provider.windshaft.process_time').start();

      // count number of dates
      var dates = 0;
      var maxDateSlots = -1;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.dates__uint16.length;
        for(var d = 0; d < row.dates__uint16.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);
        }
      }

      if(this.options.cumulative) {
        dates = (1 + maxDateSlots) * rows.length;
      }

      var type = this.options.cumulative ? Uint32Array: Uint8ClampedArray;

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || type)(dates);
      var renderDataPos = new Uint32Array(dates);

      prof_mem.inc(
        4 * maxDateSlots + // timeIndex
        4 * maxDateSlots + // timeCount
        dates + //renderData
        dates * 4
      ); //renderDataPos

      prof_point_count.inc(rows.length);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x__uint8 * this.options.resolution;
        y[r] = row.y__uint8 * this.options.resolution;

        var dates = row.dates__uint16;
        var vals = row.vals__uint8;
        if (!this.options.cumulative) {
          for (var j = 0, len = dates.length; j < len; ++j) {
              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
              if(this.options.cumulative) {
                  vals[j] += prev_val;
              }
              prev_val = vals[j];
              rr.push([r, vals[j]]);
          }
        } else {
          var valByDate = {}
          for (var j = 0, len = dates.length; j < len; ++j) {
            valByDate[dates[j]] = vals[j];
          }
          var accum = 0;

          // extend the latest to the end
          for (var j = dates[0]; j <= maxDateSlots; ++j) {
              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
              var v = valByDate[j];
              if (v) {
                accum += v;
              }
              rr.push([r, accum]);
          }

          /*var lastDateSlot = dates[dates.length - 1];
          for (var j = lastDateSlot + 1; j <= maxDateSlots; ++j) {
            var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
            rr.push([r, prev_val]);
          }
          */
        }

      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      prof_process_time.end();

      return {
        x: x,
        y: y,
        z: zoom,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData,
        maxDate: maxDateSlots
      };
    },

    /*setCartoCSS: function(c) {
      this.options.cartocss = c;
    },*/

    setSteps: function(steps, opt) {
      opt = opt || {};
      if (this.options.steps !== steps) {
        this.options.steps = steps;
        this.options.step = (this.options.end - this.options.start)/this.getSteps();
        this.options.step = this.options.step || 1;
        if (!opt.silent) this.reload();
      }
    },

    setOptions: function(opt) {
      var refresh = false;

      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {
        this.options.resolution = opt.resolution;
        refresh = true;
      }

      if(opt.steps !== undefined && opt.steps !== this.options.steps) {
        this.setSteps(opt.steps, { silent: true });
        refresh = true;
      }

      if(opt.column !== undefined && opt.column !== this.options.column) {
        this.options.column = opt.column;
        refresh = true;
      }

      if(opt.countby !== undefined && opt.countby !== this.options.countby) {
        this.options.countby = opt.countby;
        refresh = true;
      }

      if(opt.data_aggregation !== undefined) {
        var c = opt.data_aggregation === 'cumulative';
        if (this.options.cumulative !== c) {
          this.options.cumulative = c;
          refresh = true;
        }
      }

      if (refresh) this.reload();
      return refresh;
    },

    _extraParams: function(e) {
      e = torque.extend(torque.extend({}, e), this.options.extra_params);
      if (e) {
        var p = [];
        for(var k in e) {
          var v = e[k];
          if (v) {
            if (torque.isArray(v)) {
              for (var i = 0, len = v.length; i < len; i++) {
                p.push(k + "[]=" + encodeURIComponent(v[i]));
              }
            } else {
              p.push(k + "=" + encodeURIComponent(v));
            }
          }
        }
        return p.join('&');
      }
      return null;
    },

    getTileData: function(coord, zoom, callback) {
      if(!this._ready) {
        this._tileQueue.push([coord, zoom, callback]);
      } else {
        this._getTileData(coord, zoom, callback);
      }
    },

    _setReady: function(ready) {
      this._ready = true;
      this._processQueue();
      this.options.ready && this.options.ready();
    },

    _processQueue: function() {
      var item;
      while (item = this._tileQueue.pop()) {
        this._getTileData.apply(this, item);
      }
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    _getTileData: function(coord, zoom, callback) {
      var self = this;
      var prof_fetch_time = Profiler.metric('torque.provider.windshaft.tile.fetch').start();
      var subdomains = this.options.subdomains || '0123';
      var limit_x = Math.pow(2, zoom);
      var corrected_x = ((coord.x % limit_x) + limit_x) % limit_x;
      var index = Math.abs(corrected_x + coord.y) % subdomains.length;
      var url = this.templateUrl
                .replace('{x}', corrected_x)
                .replace('{y}', coord.y)
                .replace('{z}', zoom)
                .replace('{s}', subdomains[index])

      var extra = this._extraParams();
      torque.net.get( url + (extra ? "?" + extra: ''), function (data) {
        prof_fetch_time.end();
        if (data && data.responseText) {
          var rows = JSON.parse(data.responseText);
          callback(self.proccessTile(rows, coord, zoom));
        } else {
          Profiler.metric('torque.provider.windshaft.tile.error').inc();
          callback(null);
        }
      });
    },

    getKeySpan: function() {
      return {
        start: this.options.start,
        end: this.options.end,
        step: this.options.step,
        steps: this.options.steps,
        columnType: this.options.column_type
      };
    },

    setColumn: function(column, isTime) {
      this.options.column = column;
      this.options.is_time = isTime === undefined ? true: false;
      this.reload();
    },

    reload: function() {
      this._ready = false;
      this._fetchMap();
    },

    getSteps: function() {
      return Math.min(this.options.steps, this.options.data_steps);
    },

    getBounds: function() {
      return this.options.bounds;
    },

    getSQL: function() {
      return this.options.sql || "select * from " + this.options.table;
    },

    setSQL: function(sql) {
      if (this.options.sql != sql) {
        this.options.sql = sql;
        this.reload();
      }
    },

    _buildMapsApiTemplate: function(opts) {
       var user = opts.user_name || opts.user;
       opts.maps_api_template = opts.tiler_protocol +
           "://" + ((user) ? "{user}.":"")  +
           opts.tiler_domain +
           ((opts.tiler_port != "") ? (":" + opts.tiler_port) : "");
    },

    _tilerHost: function() {
      var opts = this.options;
      var user = opts.user_name || opts.user;
      return opts.maps_api_template.replace('{user}', user);
    },

    url: function () {
      var opts = this.options;
      var cdn_host = opts.cdn_url;
      var has_empty_cdn = !cdn_host || (cdn_host && (!cdn_host.http && !cdn_host.https));

      if (opts.no_cdn || has_empty_cdn) {
        return this._tilerHost();
      } else {
        var protocol = this.isHttps() ? 'https': 'http';
        var h = protocol + "://";
        if (!this.isHttps()) {
          h += "{s}.";
        }
        var cdn_url = cdn_host[protocol];
        // build default template url if the cdn url is not templatized
        // this is for backwards compatiblity, ideally we should use the url
        // that tiler sends to us right away
        if (!this._isUserTemplateUrl(cdn_url)) {
          cdn_url = cdn_url  + "/{user}";
        }
        var user = opts.user_name || opts.user;
        h += cdn_url.replace('{user}', user)
        return h;
      }

    },

    _isUserTemplateUrl: function(t) {
      return t && t.indexOf('{user}') !== -1;
    },

    isHttps: function() {
      return this.options.maps_api_template.indexOf('https') === 0;
    },

    _generateCartoCSS: function() {
      var attr = {
        '-torque-frame-count': this.options.steps,
        '-torque-resolution': this.options.resolution,
        '-torque-aggregation-function': "'" + this.options.countby + "'",
        '-torque-time-attribute': "'" + this.options.column + "'",
        '-torque-data-aggregation': this.options.cumulative ? 'cumulative': 'linear',
      };
      var st = 'Map{';
      for (var k in attr) {
        st += k + ":" + attr[k] + ";";
      }
      return st + "}";
    },

    _fetchMap: function(callback) {
      var self = this;
      var layergroup = {};
      var host = this.options.dynamic_cdn ? this.url().replace('{s}', '0'): this._tilerHost();
      var url = host + "/api/v1/map";
      var named = this.options.named_map;
      var allParams = {};

      if(named) {
        //tiles/template
        url = host + "/api/v1/map/named/" + named.name + "/jsonp";
        if(typeof named.params !== "undefined"){
          layergroup = named.params;
        }
      } else {
        layergroup = {
          "version": "1.0.1",
          "stat_tag": this.options.stat_tag || 'torque',
          "layers": [{
            "type": "torque",
            "options": {
              "cartocss_version": "1.0.0",
              "cartocss": this._generateCartoCSS(),
              "sql": this.getSQL()
            }
          }]
        };
      }

      if(this.options.stat_tag){
        allParams["stat_tag"] = this.options.stat_tag;
      }

      extra = this._extraParams(allParams);

      // tiler needs map_key instead of api_key
      // so replace it
      if (extra) {
        extra = extra.replace('api_key=', 'map_key=');
      }

      url = url +
        "?config=" + encodeURIComponent(JSON.stringify(layergroup)) +
        "&callback=?" + (extra ? "&" + extra: '');

      var map_instance_time = Profiler.metric('torque.provider.windshaft.layergroup.time').start();
      torque.net.jsonp(url, function (data) {
        map_instance_time.end();
        if (data) {
          if (data.errors){
            self.options.errorCallback && self.options.errorCallback(data.errors);
            return;
          }
          var torque_key = Object.keys(data.metadata.torque)[0]
          var opt = data.metadata.torque[torque_key];
          for(var k in opt) {
            self.options[k] = opt[k];
          }
          // use cdn_url if present
          if (data.cdn_url) {
            var c = self.options.cdn_url = self.options.cdn_url || {};
            c.http = data.cdn_url.http || c.http;
            c.https = data.cdn_url.https || c.https;
          }
          self.templateUrl = self.url() + "/api/v1/map/" + data.layergroupid + "/" + torque_key + "/{z}/{x}/{y}.json.torque";
          self._setReady(true);
        } else {
          Profiler.metric('torque.provider.windshaft.layergroup.error').inc();
        }
      }, { callbackName: self.options.instanciateCallback });
    }

  };

  module.exports = windshaft;

},{"../":25,"../profiler":32}],38:[function(require,module,exports){
  var TAU = Math.PI*2;
  // min value to render a line.
  // it does not make sense to render a line of a width is not even visible
  var LINEWIDTH_MIN_VALUE = 0.05;
  var MAX_SPRITE_RADIUS = 255;

  function renderPoint(ctx, st) {
    ctx.fillStyle = st['marker-fill'];
    var pixel_size = st['marker-width'];

    // render a circle
    // TODO: fill and stroke order should depend on the order of the properties
    // in the cartocss.

    // fill
    ctx.beginPath();
    ctx.arc(0, 0, pixel_size, 0, TAU, true, true);
    ctx.closePath();

    if (st['marker-opacity'] !== undefined )  st['marker-fill-opacity'] = st['marker-line-opacity'] = st['marker-opacity'];

    if (st['marker-fill']) {
        ctx.globalAlpha = st['marker-fill-opacity'] >= 0? st['marker-fill-opacity']: 1;

      if (ctx.globalAlpha > 0) {
        ctx.fill();
      }
    }

    // stroke
    if (st['marker-line-color'] && st['marker-line-width'] && st['marker-line-width'] > LINEWIDTH_MIN_VALUE) {
      ctx.globalAlpha = st['marker-line-opacity'] >= 0? st['marker-line-opacity']: 1;
      if (st['marker-line-width'] !== undefined) {
        ctx.lineWidth = st['marker-line-width'];
      }
      ctx.strokeStyle = st['marker-line-color'];

      // do not render for alpha = 0
      if (ctx.globalAlpha > 0) {
        ctx.stroke();
      }
    }
  }

  function renderRectangle(ctx, st) {
    ctx.fillStyle = st['marker-fill'];
    var pixel_size = st['marker-width'];
    var w = pixel_size * 2;

    // fill
    if (st['marker-fill']) {
      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {
        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];
      }
      ctx.fillRect(-pixel_size, -pixel_size, w, w)
    }

    // stroke
    ctx.globalAlpha = 1.0;
    if (st['marker-line-color'] && st['marker-line-width']) {
      if (st['marker-line-opacity']) {
        ctx.globalAlpha = st['marker-line-opacity'];
      }
      if (st['marker-line-width']) {
        ctx.lineWidth = st['marker-line-width'];
      }
      ctx.strokeStyle = st['marker-line-color'];

      // do not render for alpha = 0
      if (ctx.globalAlpha > 0) {
        ctx.strokeRect(-pixel_size, -pixel_size, w, w)
      }
    }
  }

  function renderSprite(ctx, img, st) {

    if(img.complete){
      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {
        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];
      }
      ctx.drawImage(img, 0, 0, Math.min(img.width, MAX_SPRITE_RADIUS), Math.min(img.height, MAX_SPRITE_RADIUS));
    }
  }

module.exports = {
    renderPoint: renderPoint,
    renderSprite: renderSprite,
    renderRectangle: renderRectangle,
    MAX_SPRITE_RADIUS: MAX_SPRITE_RADIUS
};

},{}],39:[function(require,module,exports){
module.exports = {
    cartocss: require('./cartocss_render'),
    Point: require('./point'),
    Rectangle: require('./rectangle')
};
},{"./cartocss_render":38,"./point":40,"./rectangle":41}],40:[function(require,module,exports){
(function (global){
var torque = require('../');
var cartocss = require('./cartocss_render');
var Profiler = require('../profiler');
var carto = global.carto || require('carto');
var Filters = require('./torque_filters');

  var TAU = Math.PI * 2;
  var DEFAULT_CARTOCSS = [
    '#layer {',
    '  marker-fill: #662506;',
    '  marker-width: 4;',
    '  [value > 1] { marker-fill: #FEE391; }',
    '  [value > 2] { marker-fill: #FEC44F; }',
    '  [value > 3] { marker-fill: #FE9929; }',
    '  [value > 4] { marker-fill: #EC7014; }',
    '  [value > 5] { marker-fill: #CC4C02; }',
    '  [value > 6] { marker-fill: #993404; }',
    '  [value > 7] { marker-fill: #662506; }',
    '}'
  ].join('\n');

  var COMP_OP_TO_CANVAS = {
    "src": 'source-over',
    "src-over": 'source-over',
    "dst-over": 'destination-over',
    "src-in": 'source-in',
    "dst-in": 'destination-in',
    "src-out": 'source-out',
    "dst-out": 'destination-out',
    "src-atop": 'source-atop',
    "dst-atop": 'destination-atop',
    "xor": 'xor',
    "darken": 'darken',
    "lighten": 'lighten',
    "screen": "screen"
  }

  function compop2canvas(compop) {
    return COMP_OP_TO_CANVAS[compop] || compop;
  }


  //
  // this renderer just render points depending of the value
  //
  function PointRenderer(canvas, options) {
    if (!canvas) {
      throw new Error("canvas can't be undefined");
    }
    this.options = options;
    this._canvas = canvas;
    this._ctx = canvas.getContext('2d');
    this._sprites = []; // sprites per layer
    this._shader = null;
    this._icons = {};
    this._iconsToLoad = 0;
    this._filters = new Filters(this._canvas, {canvasClass: options.canvasClass});
    this.setCartoCSS(this.options.cartocss || DEFAULT_CARTOCSS);
    this.TILE_SIZE = 256;
    this._style = null;
    this._gradients = {};

    this._forcePoints = false;
  }

  torque.extend(PointRenderer.prototype, torque.Event, {

    clearCanvas: function() {
      var canvas = this._canvas;
      var color = this._Map['-torque-clear-color']
      // shortcut for the default value
      if (color  === "rgba(255, 255, 255, 0)" || !color) {
        this._canvas.width = this._canvas.width;
      } else {
        var ctx = this._ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var compop = this._Map['comp-op']
        ctx.globalCompositeOperation = compop2canvas(compop);
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    },

    setCanvas: function(canvas) {
      this._canvas = canvas;
      this._ctx = canvas.getContext('2d');
    },

    //
    // sets the cartocss style to render stuff
    //
    setCartoCSS: function(cartocss) {
      // clean sprites
      this.setShader(new carto.RendererJS().render(cartocss));
    },

    setShader: function(shader) {
      // clean sprites
      this._sprites = [];
      this._shader = shader;
      this._Map = this._shader.getDefault().getStyle({}, { zoom: 0 });
      var img_names = this._shader.getImageURLs();
      this._preloadIcons(img_names);
    },

    clearSpriteCache: function() {
      this._sprites = [];
    },


    //
    // generate sprite based on cartocss style
    //
    generateSprite: function(shader, value, shaderVars) {
      var prof = Profiler.metric('torque.renderer.point.generateSprite').start();
      var st = shader.getStyle({
        value: value
      }, shaderVars);

      var ret = this.generateSpriteForStyle(st);
      prof.end(true);
      return ret;
    },

    generateSpriteForStyle: function(st) {
      var self = this;

      if(this._style === null || this._style !== st){
        this._style = st;
      }

      var pointSize = st['marker-width'];
      if (!pointSize) {
        return null;
      }

      if (st['marker-opacity'] === 0 && !st['marker-line-opacity']) {
        return null;
      }

      var canvas = this._createCanvas();
      var ctx = canvas.getContext('2d');

      var markerFile = st["marker-file"] || st["point-file"];
      var qualifiedUrl = markerFile && this._qualifyURL(markerFile);

      if (qualifiedUrl && this._iconsToLoad <= 0 && this._icons[qualifiedUrl]) {
        var img = this._icons[qualifiedUrl];

        var dWidth =  Math.min(st['marker-width'] * 2 || img.width, cartocss.MAX_SPRITE_RADIUS * 2);
        var dHeight = Math.min((st['marker-height'] || dWidth) * (img.width / img.height), cartocss.MAX_SPRITE_RADIUS * 2);

        canvas.width = ctx.width = dWidth;
        canvas.height = ctx.height = dHeight;

        ctx.scale(dWidth/img.width, dHeight/img.height);

        cartocss.renderSprite(ctx, img, st);
      } else {
        // take into account the exterior ring to calculate the size
        var canvasSize = (st['marker-line-width'] || 0) + pointSize*2 + 2;
        canvasSize = Math.ceil(canvasSize);
        // the sprite should be placed in the center of a pixel not in the middle so
        // make the canvas size odd
        canvasSize += canvasSize % 2 === 0 ? 1 : 0;
        var w = ctx.width = canvas.width = ctx.height = canvas.height = canvasSize;
        w = Math.floor(w/2) + 1;
        ctx.translate(w, w);

        var mt = st['marker-type'];
        if (mt && mt === 'rectangle') {
          cartocss.renderRectangle(ctx, st);
        } else {
          cartocss.renderPoint(ctx, st);
        }
      }
      if (torque.flags.sprites_to_images) {
        var i = this._createImage();
        i.src = canvas.toDataURL();
        return i;
      }

      return canvas;
    },

    //
    // renders all the layers (and frames for each layer) from cartocss
    //
    renderTile: function(tile, key, renderFlags, callback) {
      if (this._iconsToLoad > 0) {
          this.on('allIconsLoaded', function() {
              this.renderTile.apply(this, [tile, key, callback]);
          });
          return false;
      }
      var prof = Profiler.metric('torque.renderer.point.renderLayers').start();
      var layers = this._shader.getLayers();
      for(var i = 0, n = layers.length; i < n; ++i ) {
        var layer = layers[i];
        if (layer.name() !== "Map") {
          var sprites = this._sprites[i] || (this._sprites[i] = {});
          // frames for each layer
          for(var fr = 0; fr < layer.frames().length; ++fr) {
            var frame = layer.frames()[fr];
            var fr_sprites = sprites[frame] || (sprites[frame] = []);
            this._renderTile(tile, key - frame, frame, fr_sprites, layer);
          }
        }
      }

      prof.end(true);

      return callback && callback(null);
    },

    _createCanvas: function() {
      return this.options.canvasClass
        ? new this.options.canvasClass()
        : document.createElement('canvas');
    },

    _createImage: function() {
      return this.options.imageClass
        ? new this.options.imageClass()
        : new Image();
    },

    _setImageSrc: function(img, url, callback) {
      if (this.options.setImageSrc) {
        this.options.setImageSrc(img, url, callback);
      } else {
        img.onload = function(){
            callback(null);
        };
        img.onerror = function(){
            callback(new Error('Could not load image'));
        };
        img.src = url;
      }
    },

    _qualifyURL: function(url) {
      if (typeof this.options.qualifyURL !== "undefined"){
        return this.options.qualifyURL(url);
      }
      else{
        var a = document.createElement('a');
        a.href = url;
        return a.href;
      }
    },

    //
    // renders a tile in the canvas for key defined in
    // the torque tile
    //
    _renderTile: function(tile, key, frame_offset, sprites, shader, shaderVars) {
      if (!this._canvas) return;
      var prof = Profiler.metric('torque.renderer.point.renderTile').start();
      var ctx = this._ctx;
      var blendMode = compop2canvas(shader.eval('comp-op')) || this.options.blendmode;
      if (blendMode) {
        ctx.globalCompositeOperation = blendMode;
      }
      if (this.options.cumulative && key > tile.maxDate) {
        //TODO: precache because this tile is not going to change
        key = tile.maxDate;
      }
      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1)
      var activePixels = tile.x.length;
      var anchor = this.options.resolution/2;
      if (activePixels) {
        var pixelIndex = tile.timeIndex[key];
        for(var p = 0; p < activePixels; ++p) {
            var posIdx = tile.renderDataPos[pixelIndex + p];
            var c = tile.renderData[pixelIndex + p];
            var sp = sprites[c];
            if (sp === undefined) {
               sp = sprites[c] = this.generateSprite(shader, c, torque.extend({ zoom: tile.z, 'frame-offset': frame_offset }, shaderVars));
            }
            if (sp) {
               var x = tile.x[posIdx]- (sp.width >> 1) + anchor;
               var y = tileMax - tile.y[posIdx] + anchor; // flip mercator
               ctx.drawImage(sp, x, y - (sp.height >> 1));
            }
        }
      }


      prof.end(true);
    },

    setBlendMode: function(b) {
      this.options.blendmode = b;
    },

    /**
     * get active points for a step in active zoom
     * returns a list of bounding boxes [[sw, ne] , [], []] where ne is a {lat: .., lon: ...} obj
     * empty list if there is no active pixels
     */
    getActivePointsBBox: function(tile, step) {
      var positions = [];
      var mercator = new torque.Mercator();

      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1);
      //this.renderer.renderTile(tile, this.key, pos.x, pos.y);
      var activePixels = tile.timeCount[step];
      var pixelIndex = tile.timeIndex[step];
      for(var p = 0; p < activePixels; ++p) {
        var posIdx = tile.renderDataPos[pixelIndex + p];
        var c = tile.renderData[pixelIndex + p];
        if (c) {
         var x = tile.x[posIdx];
         var y = tileMax - tile.y[posIdx]; // flip mercator
         positions.push(mercator.tilePixelBBox(
           tile.coord.x,
           tile.coord.y,
           tile.coord.z,
           x, y
         ));
        }
      }
      return positions;
    },

    /**
     * returns an array with all the values for the active pixels
     * @tile tile object
     * @step integer with the step
     * @values (optional) an array where the values will be placed
     */
    getValues: function(tile, step, values) {
      values = values || [];
      var activePixels = tile.timeCount[step];
      var pixelIndex = tile.timeIndex[step];
      for(var p = 0; p < activePixels; ++p) {
        var posIdx = tile.renderDataPos[pixelIndex + p];
        values.push(tile.renderData[pixelIndex + p]);
      }
      return values;
    },

    // return the value for x, y (tile coordinates)
    // null for no value
    getValueFor: function(tile, step, px, py) {
      var mercator = new torque.Mercator();
      var res = this.options.resolution;
      var res2 = res >> 1;

      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1);
      //this.renderer.renderTile(tile, this.key, pos.x, pos.y);
      var activePixels = tile.timeCount[step];
      var pixelIndex = tile.timeIndex[step];
      for(var p = 0; p < activePixels; ++p) {
        var posIdx = tile.renderDataPos[pixelIndex + p];
        var c = tile.renderData[pixelIndex + p];
        if (c) {
         var x = tile.x[posIdx];
         var y = tileMax - tile.y[posIdx];
         var dx = px + res2 - x;
         var dy = py + res2 - y;
         if (dx >= 0 && dx < res && dy >= 0 && dy < res) {
           return {
             value: c,
             bbox: mercator.tilePixelBBox(
               tile.coord.x,
               tile.coord.y,
               tile.coord.z,
               x - res2, y - res2, res
             )
           }
         }
        }
      }
      return null;
    },

    _preloadIcons: function(img_names) {
      var self = this;

      if (img_names.length > 0 && !this._forcePoints) {

        var qualifiedImageUrlSet = Object.keys(img_names.reduce(function(imgNamesMap, imgName) {
            var qualifiedUrl = self._qualifyURL(imgName);
            if (!self._icons[qualifiedUrl]) {
                imgNamesMap[qualifiedUrl] = true;
            }
            return imgNamesMap;
        }, {}));

        var filtered = self._shader.getLayers().some(function(layer) {
          return typeof layer.shader["image-filters"] !== "undefined";
        });

        this._iconsToLoad += qualifiedImageUrlSet.length;

        qualifiedImageUrlSet.forEach(function(qualifiedImageUrl) {
          self._icons[qualifiedImageUrl] = null;

          var img = self._createImage();

          if (filtered) {
            img.crossOrigin = 'Anonymous';
          }

          self._setImageSrc(img, qualifiedImageUrl, function(err) {
            if (err) {
              self._forcePoints = true;
              self.clearSpriteCache();
              self._iconsToLoad = 0;
              self.fire("allIconsLoaded");
              if(filtered) {
                console.info("Only CORS-enabled, or same domain image-files can be used in combination with image-filters");
              }
              console.error("Couldn't get marker-file " + qualifiedImageUrl);
            } else {
              self._icons[qualifiedImageUrl] = img;
              self._iconsToLoad--;

              if (self._iconsToLoad <= 0){
                self.clearSpriteCache();
                self.fire("allIconsLoaded");
              }
            }
          });
        });
      } else {
          this.fire("allIconsLoaded");
      }
  },

  applyFilters: function(){
    if(this._style){
      if(this._style['image-filters']){
        function gradientKey(imf){
          var hash = ""
          for(var i = 0; i < imf.args.length; i++){
            var rgb = imf.args[i].rgb;
            hash += rgb[0] + ":" + rgb[1] + ":" + rgb[2];
          }
          return hash;
        }
        var gradient = this._gradients[gradientKey(this._style['image-filters'])];
        if(!gradient){
          function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
          }

          function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
          }
          gradient = {};
          var colorize = this._style['image-filters'].args;

          var increment = 1/colorize.length;
          for (var i = 0; i < colorize.length; i++){
            var key = increment * i + increment;
            var rgb = colorize[i].rgb;
            var formattedColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
            gradient[key] = formattedColor;
          }
          this._gradients[gradientKey(this._style['image-filters'])] = gradient;
        }
        this._filters.gradient(gradient);
        this._filters.draw();
      }
    }
  }
});

PointRenderer.COMP_OP_TO_CANVAS = COMP_OP_TO_CANVAS;


  // exports public api
module.exports = PointRenderer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":25,"../profiler":32,"./cartocss_render":38,"./torque_filters":42,"carto":45}],41:[function(require,module,exports){
(function (global){
var torque = require('../');
var cartocss = require('./cartocss_render');
var Profiler = require('../profiler');
var carto = global.carto || require('carto');
var Filters = require('./torque_filters');
var PointRenderer = require('./point')

var PixelRenderer = function(canvas, options) {
  PointRenderer.call(this, canvas, options);
}

torque.extend(PixelRenderer.prototype, PointRenderer.prototype, {

    generateSprite: function(shader, value, shaderVars) {
      var self = this;
      var prof = Profiler.metric('torque.renderer.point.generateSprite').start();
      var st = shader.getStyle({
        value: value
      }, shaderVars);
      if(this._style === null || this._style !== st){
        this._style = st;
      }

      return {
        width: st['marker-width'],
        color: st['marker-fill'],
        fill_opacity: st['marker-fill-opacity'] === undefined ? 1.0: st['marker-fill-opacity']
      }
    },

    _renderTile: function(tile, key, frame_offset, sprites, shader, shaderVars) {
      if (!this._canvas) return;
      var prof = Profiler.metric('torque.renderer.point.renderTile').start();
      var ctx = this._ctx;
      if (this.options.cumulative && key > tile.maxDate) {
        //TODO: precache because this tile is not going to change
        key = tile.maxDate;
      }
      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1)
      var activePixels = tile.x.length;
      var anchor = this.options.resolution/2;
      if (activePixels) {
        var pixelIndex = tile.timeIndex[key];
        for(var p = 0; p < activePixels; ++p) {
            var posIdx = tile.renderDataPos[pixelIndex + p];
            var c = tile.renderData[pixelIndex + p];
            var sp = sprites[c];
            if (sp === undefined) {
               sp = sprites[c] = this.generateSprite(shader, c, torque.extend({ zoom: tile.z, 'frame-offset': frame_offset }, shaderVars));
            }
            if (sp) {
              var x = tile.x[posIdx]- (sp.width >> 1) + anchor;
              var y = tileMax - tile.y[posIdx] + anchor; // flip mercator
              if (sp.fill_opacity > 0) {
                ctx.globalAlpha = sp.fill_opacity
                ctx.fillStyle = sp.color;
                ctx.fillRect(x, y, sp.width, sp.width);
              }
            }
        }
      }
    }
});

module.exports = PixelRenderer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":25,"../profiler":32,"./cartocss_render":38,"./point":40,"./torque_filters":42,"carto":45}],42:[function(require,module,exports){
/*
 Based on simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas,
 by Vladimir Agafonkin
 https://github.com/mourner/simpleheat
*/

'use strict';

function torque_filters(canvas, options) {
    // jshint newcap: false, validthis: true
    if (!(this instanceof torque_filters)) { return new torque_filters(canvas, options); }

    options = options || {};

    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;

    this._ctx = canvas.getContext('2d');
    this._width = canvas.width;
    this._height = canvas.height;

    this._max = 1;
    this._data = [];

    this.canvasClass = options.canvasClass;
}

torque_filters.prototype = {

    defaultGradient: {
        0.4: 'blue',
        0.6: 'cyan',
        0.7: 'lime',
        0.8: 'yellow',
        1.0: 'red'
    },

    gradient: function (grad) {
        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
        var canvas = this._createCanvas(),
            ctx = canvas.getContext('2d'),
            gradient = ctx.createLinearGradient(0, 0, 0, 256);

        canvas.width = 1;
        canvas.height = 256;

        for (var i in grad) {
            gradient.addColorStop(+i, grad[i]);
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1, 256);

        this._grad = ctx.getImageData(0, 0, 1, 256).data;

        return this;
    },

    draw: function () {
        if (!this._grad) {
            this.gradient(this.defaultGradient);
        }

        var ctx = this._ctx;
        var colored = ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);
        this._colorize(colored.data, this._grad);
        ctx.putImageData(colored, 0, 0);

        return this;
    },

    _colorize: function (pixels, gradient) {
        for (var i = 3, len = pixels.length, j; i < len; i += 4) {
            j = pixels[i] * 4; // get gradient color from opacity value

            if (j) {
                pixels[i - 3] = gradient[j];
                pixels[i - 2] = gradient[j + 1];
                pixels[i - 1] = gradient[j + 2];
            }
        }
    },

    _createCanvas: function() {
        return this.canvasClass
            ? new this.canvasClass()
            : document.createElement('canvas');
    }
};

module.exports = torque_filters;

},{}],43:[function(require,module,exports){
(function (global){
var torque = require('./core');

  var lastCall = null;

  function jsonp(url, callback, options) {
     options = options || {};
     options.timeout = options.timeout === undefined ? 10000: options.timeout;
     var head = document.getElementsByTagName('head')[0];
     var script = document.createElement('script');

     // function name
     var fnName = options.callbackName || 'torque_' + Date.now();

     if (torque.isFunction(fnName)) {
       fnName = fnName();
     }

     function clean() {
       head.removeChild(script);
       clearTimeout(timeoutTimer);
       delete window[fnName];
     }

     window[fnName] = function() {
       clean();
       callback.apply(window, arguments);
     };

     // timeout for errors
     var timeoutTimer = setTimeout(function() {
       clean();
       callback.call(window, null);
     }, options.timeout);

     // setup url
     url = url.replace('callback=\?', 'callback=' + fnName);
     script.type = 'text/javascript';
     script.src = url;
     script.async = true;
     // defer the loading because IE9 loads in the same frame the script
     // so Loader._script is null
     setTimeout(function() { head.appendChild(script); }, 0);
  }

  function get(url, callback, options) {
    options = options || {
      method: 'GET',
      data: null,
      responseType: 'text'
    };
    lastCall = { url: url, callback: callback };
    var request = XMLHttpRequest;
    // from d3.js
    if (global.XDomainRequest
        && !("withCredentials" in request)
        && /^(http(s)?:)?\/\//.test(url)) request = XDomainRequest;

    var req = new request();
    req.open(options.method, url, true);


    function respond() {
      var status = req.status, result;
      var r = options.responseType === 'arraybuffer' ? req.response: req.responseText;
      if (!status && r || status >= 200 && status < 300 || status === 304) {
        callback(req);
      } else {
        callback(null);
      }
    }

    "onload" in req
      ? req.onload = req.onerror = respond
      : req.onreadystatechange = function() { req.readyState > 3 && respond(); };

    req.onprogress = function() {};

    req.responseType = options.responseType; //'arraybuffer';
    if (options.data) {
      req.setRequestHeader("Content-type", "application/json");
      //req.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
      req.setRequestHeader("Accept", "*");
    }
    req.send(options.data);
    return req;
  }

  function post(url, data, callback) {
    return get(url, callback, {
      data: data,
      method: "POST"
    });
  }

module.exports = {
    get: get,
    post: post,
    jsonp: jsonp,
    lastCall: function() { return lastCall; }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./core":19}],44:[function(require,module,exports){
(function (tree) {

tree.functions = {
    rgb: function (r, g, b) {
        return this.rgba(r, g, b, 1.0);
    },
    rgba: function (r, g, b, a) {
        var rgb = [r, g, b].map(function (c) { return number(c); });
        a = number(a);
        if (rgb.some(isNaN) || isNaN(a)) return null;
        return new tree.Color(rgb, a);
    },
    // Only require val
    stop: function (val) {
        var color, mode;
        if (arguments.length > 1) color = arguments[1];
        if (arguments.length > 2) mode = arguments[2];

        return {
            is: 'tag',
            val: val,
            color: color,
            mode: mode,
            toString: function(env) {
                return '\n\t<stop value="' + val.ev(env) + '"' +
                    (color ? ' color="' + color.ev(env) + '" ' : '') +
                    (mode ? ' mode="' + mode.ev(env) + '" ' : '') +
                    '/>';
            }
        };
    },
    hsl: function (h, s, l) {
        return this.hsla(h, s, l, 1.0);
    },
    hsla: function (h, s, l, a) {
        h = (number(h) % 360) / 360;
        s = number(s); l = number(l); a = number(a);
        if ([h, s, l, a].some(isNaN)) return null;

        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            m1 = l * 2 - m2;

        return this.rgba(hue(h + 1/3) * 255,
                         hue(h)       * 255,
                         hue(h - 1/3) * 255,
                         a);

        function hue(h) {
            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
            if      (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
            else if (h * 2 < 1) return m2;
            else if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
            else                return m1;
        }
    },
    hue: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().h));
    },
    saturation: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().s * 100), '%');
    },
    lightness: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().l * 100), '%');
    },
    alpha: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(color.toHSL().a);
    },
    saturate: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.s += amount.value / 100;
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    desaturate: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.s -= amount.value / 100;
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    lighten: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.l += amount.value / 100;
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    darken: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.l -= amount.value / 100;
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    fadein: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.a += amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    fadeout: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.a -= amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    spin: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();
        var hue = (hsl.h + amount.value) % 360;

        hsl.h = hue < 0 ? 360 + hue : hue;

        return hsla(hsl);
    },
    replace: function (entity, a, b) {
        if (entity.is === 'field') {
            return entity.toString + '.replace(' + a.toString() + ', ' + b.toString() + ')';
        } else {
            return entity.replace(a, b);
        }
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function (color1, color2, weight) {
        var p = weight.value / 100.0;
        var w = p * 2 - 1;
        var a = color1.toHSL().a - color2.toHSL().a;

        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;

        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
                   color1.rgb[1] * w1 + color2.rgb[1] * w2,
                   color1.rgb[2] * w1 + color2.rgb[2] * w2];

        var alpha = color1.alpha * p + color2.alpha * (1 - p);

        return new tree.Color(rgb, alpha);
    },
    greyscale: function (color) {
        return this.desaturate(color, new tree.Dimension(100));
    },
    '%': function (quoted /* arg, arg, ...*/) {
        var args = Array.prototype.slice.call(arguments, 1),
            str = quoted.value;

        for (var i = 0; i < args.length; i++) {
            str = str.replace(/%s/,    args[i].value)
                     .replace(/%[da]/, args[i].toString());
        }
        str = str.replace(/%%/g, '%');
        return new tree.Quoted(str);
    }
};

var image_filter_functors = [
    'emboss', 'blur', 'gray', 'sobel', 'edge-detect',
    'x-gradient', 'y-gradient', 'sharpen'];

for (var i = 0; i < image_filter_functors.length; i++) {
    var f = image_filter_functors[i];
    tree.functions[f] = (function(f) {
        return function() {
            return new tree.ImageFilter(f);
        };
    })(f);
}

tree.functions['agg-stack-blur'] = function(x, y) {
    return new tree.ImageFilter('agg-stack-blur', [x, y]);
};

tree.functions['scale-hsla'] = function(h0,h1,s0,s1,l0,l1,a0,a1) {
    return new tree.ImageFilter('scale-hsla', [h0,h1,s0,s1,l0,l1,a0,a1]);
};

function hsla(h) {
    return tree.functions.hsla(h.h, h.s, h.l, h.a);
}

function number(n) {
    if (n instanceof tree.Dimension) {
        return parseFloat(n.unit == '%' ? n.value / 100 : n.value);
    } else if (typeof(n) === 'number') {
        return n;
    } else {
        return NaN;
    }
}

function clamp(val) {
    return Math.min(1, Math.max(0, val));
}

})(require('./tree'));

},{"./tree":50}],45:[function(require,module,exports){
(function (process,__dirname){
var util = require('util'),
    fs = require('fs'),
    path = require('path');


function getVersion() {
    if (process.browser) {
        return require('../../package.json').version.split('.');
    } else if (parseInt(process.version.split('.')[1], 10) > 4) {
        return require('../../package.json').version.split('.');
    } else {
        // older node
        var package_json = JSON.parse(fs.readFileSync(path.join(__dirname,'../../package.json')));
        return package_json.version.split('.');
    }
}

var carto = {
    version: getVersion(),
    Parser: require('./parser').Parser,
    Renderer: require('./renderer').Renderer,
    tree: require('./tree'),
    RendererJS: require('./renderer_js'),
    default_reference: require('./torque-reference'),

    // @TODO
    writeError: function(ctx, options) {
        var message = '';
        var extract = ctx.extract;
        var error = [];

        options = options || {};

        if (options.silent) { return; }

        options.indent = options.indent || '';

        if (!('index' in ctx) || !extract) {
            return util.error(options.indent + (ctx.stack || ctx.message));
        }

        if (typeof(extract[0]) === 'string') {
            error.push(stylize((ctx.line - 1) + ' ' + extract[0], 'grey'));
        }

        if (extract[1] === '' && typeof extract[2] === 'undefined') {
            extract[1] = '¶';
        }
        error.push(ctx.line + ' ' + extract[1].slice(0, ctx.column) +
            stylize(stylize(extract[1][ctx.column], 'bold') +
            extract[1].slice(ctx.column + 1), 'yellow'));

        if (typeof(extract[2]) === 'string') {
            error.push(stylize((ctx.line + 1) + ' ' + extract[2], 'grey'));
        }
        error = options.indent + error.join('\n' + options.indent) + '\033[0m\n';

        message = options.indent + message + stylize(ctx.message, 'red');
        if (ctx.filename) (message += stylize(' in ', 'red') + ctx.filename);

        util.error(message, error);

        if (ctx.callLine) {
            util.error(stylize('from ', 'red') + (ctx.filename || ''));
            util.error(stylize(ctx.callLine, 'grey') + ' ' + ctx.callExtract);
        }
        if (ctx.stack) { util.error(stylize(ctx.stack, 'red')); }
    }
};

require('./tree/call');
require('./tree/color');
require('./tree/comment');
require('./tree/definition');
require('./tree/dimension');
require('./tree/element');
require('./tree/expression');
require('./tree/filterset');
require('./tree/filter');
require('./tree/field');
require('./tree/keyword');
require('./tree/layer');
require('./tree/literal');
require('./tree/operation');
require('./tree/quoted');
require('./tree/imagefilter');
require('./tree/reference');
require('./tree/rule');
require('./tree/ruleset');
require('./tree/selector');
require('./tree/style');
require('./tree/url');
require('./tree/value');
require('./tree/variable');
require('./tree/zoom');
require('./tree/invalid');
require('./tree/fontset');
require('./tree/frame_offset');
require('./functions');

for (var k in carto) { exports[k] = carto[k]; }

// Stylize a string
function stylize(str, style) {
    var styles = {
        'bold' : [1, 22],
        'inverse' : [7, 27],
        'underline' : [4, 24],
        'yellow' : [33, 39],
        'green' : [32, 39],
        'red' : [31, 39],
        'grey' : [90, 39]
    };
    return '\033[' + styles[style][0] + 'm' + str +
           '\033[' + styles[style][1] + 'm';
}

}).call(this,require('_process'),"/../../viz/torque/node_modules/carto/lib/carto")

},{"../../package.json":81,"./functions":44,"./parser":46,"./renderer":47,"./renderer_js":48,"./torque-reference":49,"./tree":50,"./tree/call":51,"./tree/color":52,"./tree/comment":53,"./tree/definition":54,"./tree/dimension":55,"./tree/element":56,"./tree/expression":57,"./tree/field":58,"./tree/filter":59,"./tree/filterset":60,"./tree/fontset":61,"./tree/frame_offset":62,"./tree/imagefilter":63,"./tree/invalid":64,"./tree/keyword":65,"./tree/layer":66,"./tree/literal":67,"./tree/operation":68,"./tree/quoted":69,"./tree/reference":70,"./tree/rule":71,"./tree/ruleset":72,"./tree/selector":73,"./tree/style":74,"./tree/url":75,"./tree/value":76,"./tree/variable":77,"./tree/zoom":78,"_process":6,"fs":2,"path":5,"util":8}],46:[function(require,module,exports){
(function (global){
var carto = exports,
    tree = require('./tree'),
    _ = global._ || require('underscore');

//    Token matching is done with the `$` function, which either takes
//    a terminal string or regexp, or a non-terminal function to call.
//    It also takes care of moving all the indices forwards.
carto.Parser = function Parser(env) {
    var input,       // LeSS input string
        i,           // current index in `input`
        j,           // current chunk
        temp,        // temporarily holds a chunk's state, for backtracking
        memo,        // temporarily holds `i`, when backtracking
        furthest,    // furthest index the parser has gone to
        chunks,      // chunkified input
        current,     // index of current chunk, in `input`
        parser;

    var that = this;

    // This function is called after all files
    // have been imported through `@import`.
    var finish = function() {};

    function save()    {
        temp = chunks[j];
        memo = i;
        current = i;
    }
    function restore() {
        chunks[j] = temp;
        i = memo;
        current = i;
    }

    function sync() {
        if (i > current) {
            chunks[j] = chunks[j].slice(i - current);
            current = i;
        }
    }
    //
    // Parse from a token, regexp or string, and move forward if match
    //
    function $(tok) {
        var match, args, length, c, index, endIndex, k;

        // Non-terminal
        if (tok instanceof Function) {
            return tok.call(parser.parsers);
        // Terminal
        // Either match a single character in the input,
        // or match a regexp in the current chunk (chunk[j]).
        } else if (typeof(tok) === 'string') {
            match = input.charAt(i) === tok ? tok : null;
            length = 1;
            sync();
        } else {
            sync();

            match = tok.exec(chunks[j]);
            if (match) {
                length = match[0].length;
            } else {
                return null;
            }
        }

        // The match is confirmed, add the match length to `i`,
        // and consume any extra white-space characters (' ' || '\n')
        // which come after that. The reason for this is that LeSS's
        // grammar is mostly white-space insensitive.
        if (match) {
            var mem = i += length;
            endIndex = i + chunks[j].length - length;

            while (i < endIndex) {
                c = input.charCodeAt(i);
                if (! (c === 32 || c === 10 || c === 9)) { break; }
                i++;
            }
            chunks[j] = chunks[j].slice(length + (i - mem));
            current = i;

            if (chunks[j].length === 0 && j < chunks.length - 1) { j++; }

            if (typeof(match) === 'string') {
                return match;
            } else {
                return match.length === 1 ? match[0] : match;
            }
        }
    }

    // Same as $(), but don't change the state of the parser,
    // just return the match.
    function peek(tok) {
        if (typeof(tok) === 'string') {
            return input.charAt(i) === tok;
        } else {
            return !!tok.test(chunks[j]);
        }
    }

    function extractErrorLine(style, errorIndex) {
        return (style.slice(0, errorIndex).match(/\n/g) || '').length + 1;
    }


    // Make an error object from a passed set of properties.
    // Accepted properties:
    // - `message`: Text of the error message.
    // - `filename`: Filename where the error occurred.
    // - `index`: Char. index where the error occurred.
    function makeError(err) {
        var einput;

        _(err).defaults({
            index: furthest,
            filename: env.filename,
            message: 'Parse error.',
            line: 0,
            column: -1
        });

        if (err.filename && that.env.inputs && that.env.inputs[err.filename]) {
            einput = that.env.inputs[err.filename];
        } else {
            einput = input;
        }

        err.line = extractErrorLine(einput, err.index);
        for (var n = err.index; n >= 0 && einput.charAt(n) !== '\n'; n--) {
            err.column++;
        }

        return new Error(_('<%=filename%>:<%=line%>:<%=column%> <%=message%>').template(err));
    }

    this.env = env = env || {};
    this.env.filename = this.env.filename || null;
    this.env.inputs = this.env.inputs || {};

    // The Parser
    parser = {

        extractErrorLine: extractErrorLine,
        //
        // Parse an input string into an abstract syntax tree.
        // Throws an error on parse errors.
        parse: function(str) {
            var root, start, end, zone, line, lines, buff = [], c, error = null;

            i = j = current = furthest = 0;
            chunks = [];
            input = str.replace(/\r\n/g, '\n');
            if (env.filename) {
                that.env.inputs[env.filename] = input;
            }

            var early_exit = false;

            // Split the input into chunks.
            chunks = (function (chunks) {
                var j = 0,
                    skip = /(?:@\{[\w-]+\}|[^"'`\{\}\/\(\)\\])+/g,
                    comment = /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g,
                    string = /"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'|`((?:[^`]|\\.)*)`/g,
                    level = 0,
                    match,
                    chunk = chunks[0],
                    inParam;

                for (var i = 0, c, cc; i < input.length;) {
                    skip.lastIndex = i;
                    if (match = skip.exec(input)) {
                        if (match.index === i) {
                            i += match[0].length;
                            chunk.push(match[0]);
                        }
                    }
                    c = input.charAt(i);
                    comment.lastIndex = string.lastIndex = i;

                    if (match = string.exec(input)) {
                        if (match.index === i) {
                            i += match[0].length;
                            chunk.push(match[0]);
                            continue;
                        }
                    }

                    if (!inParam && c === '/') {
                        cc = input.charAt(i + 1);
                        if (cc === '/' || cc === '*') {
                            if (match = comment.exec(input)) {
                                if (match.index === i) {
                                    i += match[0].length;
                                    chunk.push(match[0]);
                                    continue;
                                }
                            }
                        }
                    }

                    switch (c) {
                        case '{': if (! inParam) { level ++;        chunk.push(c);                           break; }
                        case '}': if (! inParam) { level --;        chunk.push(c); chunks[++j] = chunk = []; break; }
                        case '(': if (! inParam) { inParam = true;  chunk.push(c);                           break; }
                        case ')': if (  inParam) { inParam = false; chunk.push(c);                           break; }
                        default:                                    chunk.push(c);
                    }

                    i++;
                }
                if (level !== 0) {
                    error = {
                        index: i - 1,
                        type: 'Parse',
                        message: (level > 0) ? "missing closing `}`" : "missing opening `{`"
                    };
                }

                return chunks.map(function (c) { return c.join(''); });
            })([[]]);

            if (error) {
                throw makeError(error);
            }

            // Start with the primary rule.
            // The whole syntax tree is held under a Ruleset node,
            // with the `root` property set to true, so no `{}` are
            // output.
            root = new tree.Ruleset([], $(this.parsers.primary));
            root.root = true;

            // Get an array of Ruleset objects, flattened
            // and sorted according to specificitySort
            root.toList = (function() {
                var line, lines, column;
                return function(env) {
                    env.error = function(e) {
                        if (!env.errors) env.errors = new Error('');
                        if (env.errors.message) {
                            env.errors.message += '\n' + makeError(e).message;
                        } else {
                            env.errors.message = makeError(e).message;
                        }
                    };
                    env.frames = env.frames || [];


                    // call populates Invalid-caused errors
                    var definitions = this.flatten([], [], env);
                    definitions.sort(specificitySort);
                    return definitions;
                };
            })();

            // Sort rules by specificity: this function expects selectors to be
            // split already.
            //
            // Written to be used as a .sort(Function);
            // argument.
            //
            // [1, 0, 0, 467] > [0, 0, 1, 520]
            var specificitySort = function(a, b) {
                var as = a.specificity;
                var bs = b.specificity;

                if (as[0] != bs[0]) return bs[0] - as[0];
                if (as[1] != bs[1]) return bs[1] - as[1];
                if (as[2] != bs[2]) return bs[2] - as[2];
                return bs[3] - as[3];
            };

            return root;
        },

        // Here in, the parsing rules/functions
        //
        // The basic structure of the syntax tree generated is as follows:
        //
        //   Ruleset ->  Rule -> Value -> Expression -> Entity
        //
        //  In general, most rules will try to parse a token with the `$()` function, and if the return
        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
        //  first, before parsing, that's when we use `peek()`.
        parsers: {
            // The `primary` rule is the *entry* and *exit* point of the parser.
            // The rules here can appear at any level of the parse tree.
            //
            // The recursive nature of the grammar is an interplay between the `block`
            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
            // as represented by this simplified grammar:
            //
            //     primary  →  (ruleset | rule)+
            //     ruleset  →  selector+ block
            //     block    →  '{' primary '}'
            //
            // Only at one point is the primary rule not called from the
            // block rule: at the root level.
            primary: function() {
                var node, root = [];

                while ((node = $(this.rule) || $(this.ruleset) ||
                               $(this.comment)) ||
                               $(/^[\s\n]+/) || (node = $(this.invalid))) {
                    if (node) root.push(node);
                }
                return root;
            },

            invalid: function () {
                var chunk = $(/^[^;\n]*[;\n]/);

                // To fail gracefully, match everything until a semicolon or linebreak.
                if (chunk) {
                    return new tree.Invalid(chunk, memo);
                }
            },

            // We create a Comment node for CSS comments `/* */`,
            // but keep the LeSS comments `//` silent, by just skipping
            // over them.
            comment: function() {
                var comment;

                if (input.charAt(i) !== '/') return;

                if (input.charAt(i + 1) === '/') {
                    return new tree.Comment($(/^\/\/.*/), true);
                } else if (comment = $(/^\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/)) {
                    return new tree.Comment(comment);
                }
            },

            // Entities are tokens which can be found inside an Expression
            entities: {

                // A string, which supports escaping " and ' "milky way" 'he\'s the one!'
                quoted: function() {
                    if (input.charAt(i) !== '"' && input.charAt(i) !== "'") return;
                    var str = $(/^"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'/);
                    if (str) {
                        return new tree.Quoted(str[1] || str[2]);
                    }
                },

                // A reference to a Mapnik field, like [NAME]
                // Behind the scenes, this has the same representation, but Carto
                // needs to be careful to warn when unsupported operations are used.
                field: function() {
                    if (! $('[')) return;
                    var field_name = $(/(^[^\]]+)/);
                    if (! $(']')) return;
                    if (field_name) return new tree.Field(field_name[1]);
                },

                // This is a comparison operator
                comparison: function() {
                    var str = $(/^=~|=|!=|<=|>=|<|>/);
                    if (str) {
                        return str;
                    }
                },

                // A catch-all word, such as: hard-light
                // These can start with either a letter or a dash (-),
                // and then contain numbers, underscores, and letters.
                keyword: function() {
                    var k = $(/^[A-Za-z-]+[A-Za-z-0-9_]*/);
                    if (k) { return new tree.Keyword(k); }
                },

                // A function call like rgb(255, 0, 255)
                // The arguments are parsed with the `entities.arguments` parser.
                call: function() {
                    var name, args;

                    if (!(name = /^([\w\-]+|%)\(/.exec(chunks[j]))) return;

                    name = name[1];

                    if (name === 'url') {
                        // url() is handled by the url parser instead
                        return null;
                    } else {
                        i += name.length;
                    }

                    $('('); // Parse the '(' and consume whitespace.

                    args = $(this.entities['arguments']);

                    if (!$(')')) return;

                    if (name) {
                        return new tree.Call(name, args, i);
                    }
                },
                // Arguments are comma-separated expressions
                'arguments': function() {
                    var args = [], arg;

                    while (arg = $(this.expression)) {
                        args.push(arg);
                        if (! $(',')) { break; }
                    }

                    return args;
                },
                literal: function() {
                    return $(this.entities.dimension) ||
                        $(this.entities.keywordcolor) ||
                        $(this.entities.hexcolor) ||
                        $(this.entities.quoted);
                },

                // Parse url() tokens
                //
                // We use a specific rule for urls, because they don't really behave like
                // standard function calls. The difference is that the argument doesn't have
                // to be enclosed within a string, so it can't be parsed as an Expression.
                url: function() {
                    var value;

                    if (input.charAt(i) !== 'u' || !$(/^url\(/)) return;
                    value = $(this.entities.quoted) || $(this.entities.variable) ||
                            $(/^[\-\w%@$\/.&=:;#+?~]+/) || '';
                    if (! $(')')) {
                        return new tree.Invalid(value, memo, 'Missing closing ) in URL.');
                    } else {
                        return new tree.URL((typeof value.value !== 'undefined' ||
                            value instanceof tree.Variable) ?
                            value : new tree.Quoted(value));
                    }
                },

                // A Variable entity, such as `@fink`, in
                //
                //     width: @fink + 2px
                //
                // We use a different parser for variable definitions,
                // see `parsers.variable`.
                variable: function() {
                    var name, index = i;

                    if (input.charAt(i) === '@' && (name = $(/^@[\w-]+/))) {
                        return new tree.Variable(name, index, env.filename);
                    }
                },

                hexcolor: function() {
                    var rgb;
                    if (input.charAt(i) === '#' && (rgb = $(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/))) {
                        return new tree.Color(rgb[1]);
                    }
                },

                keywordcolor: function() {
                    var rgb = chunks[j].match(/^[a-z]+/);
                    if (rgb && rgb[0] in tree.Reference.data.colors) {
                        return new tree.Color(tree.Reference.data.colors[$(/^[a-z]+/)]);
                    }
                },

                // A Dimension, that is, a number and a unit. The only
                // unit that has an effect is %
                dimension: function() {
                    var c = input.charCodeAt(i);
                    if ((c > 57 || c < 45) || c === 47) return;
                    var value = $(/^(-?\d*\.?\d+(?:[eE][-+]?\d+)?)(\%|\w+)?/);
                    if (value) {
                        return new tree.Dimension(value[1], value[2], memo);
                    }
                }
            },

            // The variable part of a variable definition.
            // Used in the `rule` parser. Like @fink:
            variable: function() {
                var name;

                if (input.charAt(i) === '@' && (name = $(/^(@[\w-]+)\s*:/))) {
                    return name[1];
                }
            },

            // Entities are the smallest recognized token,
            // and can be found inside a rule's value.
            entity: function() {
                return $(this.entities.call) ||
                    $(this.entities.literal) ||
                    $(this.entities.field) ||
                    $(this.entities.variable) ||
                    $(this.entities.url) ||
                    $(this.entities.keyword);
            },

            // A Rule terminator. Note that we use `peek()` to check for '}',
            // because the `block` rule will be expecting it, but we still need to make sure
            // it's there, if ';' was ommitted.
            end: function() {
                return $(';') || peek('}');
            },

            // Elements are the building blocks for Selectors. They consist of
            // an element name, such as a tag a class, or `*`.
            element: function() {
                var e = $(/^(?:[.#][\w\-]+|\*|Map)/);
                if (e) return new tree.Element(e);
            },

            // Attachments allow adding multiple lines, polygons etc. to an
            // object. There can only be one attachment per selector.
            attachment: function() {
                var s = $(/^::([\w\-]+(?:\/[\w\-]+)*)/);
                if (s) return s[1];
            },

            // Selectors are made out of one or more Elements, see above.
            selector: function() {
                var a, attachment,
                    e, elements = [],
                    f, filters = new tree.Filterset(),
                    z, zooms = [],
                    frame_offset = tree.FrameOffset.none;
                    segments = 0, conditions = 0;

                while (
                        (e = $(this.element)) ||
                        (z = $(this.zoom)) ||
                        (fo = $(this.frame_offset)) ||
                        (f = $(this.filter)) ||
                        (a = $(this.attachment))
                    ) {
                    segments++;
                    if (e) {
                        elements.push(e);
                    } else if (z) {
                        zooms.push(z);
                        conditions++;
                    } else if (fo) {
                        frame_offset = fo;
                        conditions++;
                    } else if (f) {
                        var err = filters.add(f);
                        if (err) {
                            throw makeError({
                                message: err,
                                index: i - 1
                            });
                        }
                        conditions++;
                    } else if (attachment) {
                        throw makeError({
                            message: 'Encountered second attachment name.',
                            index: i - 1
                        });
                    } else {
                        attachment = a;
                    }

                    var c = input.charAt(i);
                    if (c === '{' || c === '}' || c === ';' || c === ',') { break; }
                }

                if (segments) {
                    return new tree.Selector(filters, zooms, frame_offset, elements, attachment, conditions, memo);
                }
            },

            filter: function() {
                save();
                var key, op, val;
                if (! $('[')) return;
                if (key = $(/^[a-zA-Z0-9\-_]+/) ||
                    $(this.entities.quoted) ||
                    $(this.entities.variable) ||
                    $(this.entities.keyword) ||
                    $(this.entities.field)) {
                    // TODO: remove at 1.0.0
                    if (key instanceof tree.Quoted) {
                        key = new tree.Field(key.toString());
                    }
                    if ((op = $(this.entities.comparison)) &&
                        (val = $(this.entities.quoted) ||
                             $(this.entities.variable) ||
                             $(this.entities.dimension) ||
                             $(this.entities.keyword) ||
                             $(this.entities.field))) {
                        if (! $(']')) {
                            throw makeError({
                                message: 'Missing closing ] of filter.',
                                index: memo - 1
                            });
                        }
                        if (!key.is) key = new tree.Field(key);
                        return new tree.Filter(key, op, val, memo, env.filename);
                    }
                }
            },

            frame_offset: function() {
                save();
                var op, val;
                if ($(/^\[\s*frame-offset/g) &&
                    (op = $(this.entities.comparison)) &&
                    (val = $(/^\d+/)) &&
                    $(']'))  {
                        return tree.FrameOffset(op, val, memo);
                }
            },

            zoom: function() {
                save();
                var op, val;
                if ($(/^\[\s*zoom/g) &&
                    (op = $(this.entities.comparison)) &&
                    (val = $(this.entities.variable) || $(this.entities.dimension)) && $(']')) {
                        return new tree.Zoom(op, val, memo);
                } else {
                    // backtrack
                    restore();
                }
            },

            // The `block` rule is used by `ruleset`
            // It's a wrapper around the `primary` rule, with added `{}`.
            block: function() {
                var content;

                if ($('{') && (content = $(this.primary)) && $('}')) {
                    return content;
                }
            },

            // div, .class, body > p {...}
            ruleset: function() {
                var selectors = [], s, f, l, rules, filters = [];
                save();

                while (s = $(this.selector)) {
                    selectors.push(s);
                    while ($(this.comment)) {}
                    if (! $(',')) { break; }
                    while ($(this.comment)) {}
                }
                if (s) {
                    while ($(this.comment)) {}
                }

                if (selectors.length > 0 && (rules = $(this.block))) {
                    if (selectors.length === 1 &&
                        selectors[0].elements.length &&
                        selectors[0].elements[0].value === 'Map') {
                        var rs = new tree.Ruleset(selectors, rules);
                        rs.isMap = true;
                        return rs;
                    }
                    return new tree.Ruleset(selectors, rules);
                } else {
                    // Backtrack
                    restore();
                }
            },

            rule: function() {
                var name, value, c = input.charAt(i);
                save();

                if (c === '.' || c === '#') { return; }

                if (name = $(this.variable) || $(this.property)) {
                    value = $(this.value);

                    if (value && $(this.end)) {
                        return new tree.Rule(name, value, memo, env.filename);
                    } else {
                        furthest = i;
                        restore();
                    }
                }
            },

            font: function() {
                var value = [], expression = [], weight, font, e;

                while (e = $(this.entity)) {
                    expression.push(e);
                }

                value.push(new tree.Expression(expression));

                if ($(',')) {
                    while (e = $(this.expression)) {
                        value.push(e);
                        if (! $(',')) { break; }
                    }
                }
                return new tree.Value(value);
            },

            // A Value is a comma-delimited list of Expressions
            // In a Rule, a Value represents everything after the `:`,
            // and before the `;`.
            value: function() {
                var e, expressions = [];

                while (e = $(this.expression)) {
                    expressions.push(e);
                    if (! $(',')) { break; }
                }

                if (expressions.length > 1) {
                    return new tree.Value(expressions.map(function(e) {
                        return e.value[0];
                    }));
                } else if (expressions.length === 1) {
                    return new tree.Value(expressions);
                }
            },
            // A sub-expression, contained by parenthensis
            sub: function() {
                var e;

                if ($('(') && (e = $(this.expression)) && $(')')) {
                    return e;
                }
            },
            // This is a misnomer because it actually handles multiplication
            // and division.
            multiplication: function() {
                var m, a, op, operation;
                if (m = $(this.operand)) {
                    while ((op = ($('/') || $('*') || $('%'))) && (a = $(this.operand))) {
                        operation = new tree.Operation(op, [operation || m, a], memo);
                    }
                    return operation || m;
                }
            },
            addition: function() {
                var m, a, op, operation;
                if (m = $(this.multiplication)) {
                    while ((op = $(/^[-+]\s+/) || (input.charAt(i - 1) != ' ' && ($('+') || $('-')))) &&
                           (a = $(this.multiplication))) {
                        operation = new tree.Operation(op, [operation || m, a], memo);
                    }
                    return operation || m;
                }
            },

            // An operand is anything that can be part of an operation,
            // such as a Color, or a Variable
            operand: function() {
                return $(this.sub) || $(this.entity);
            },

            // Expressions either represent mathematical operations,
            // or white-space delimited Entities.  @var * 2
            expression: function() {
                var e, delim, entities = [], d;

                while (e = $(this.addition) || $(this.entity)) {
                    entities.push(e);
                }

                if (entities.length > 0) {
                    return new tree.Expression(entities);
                }
            },
            property: function() {
                var name = $(/^(([a-z][-a-z_0-9]*\/)?\*?-?[-a-z_0-9]+)\s*:/);
                if (name) return name[1];
            }
        }
    };
    return parser;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./tree":50,"underscore":80}],47:[function(require,module,exports){
(function (global){
var _ = global._ || require('underscore');
var carto = require('./index');

carto.Renderer = function Renderer(env, options) {
    this.env = env || {};
    this.options = options || {};
    this.options.mapnik_version = this.options.mapnik_version || '3.0.0';
};

/**
 * Prepare a MSS document (given as an string) into a
 * XML Style fragment (mostly useful for debugging)
 *
 * @param {String} data the mss contents as a string.
 */
carto.Renderer.prototype.renderMSS = function render(data) {
    // effects is a container for side-effects, which currently
    // are limited to FontSets.
    var env = _(this.env).defaults({
        benchmark: false,
        validation_data: false,
        effects: []
    });

    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {
        throw new Error("Could not set mapnik version to " + this.options.mapnik_version);
    }

    var output = [];
    var styles = [];

    if (env.benchmark) console.time('Parsing MSS');
    var parser = (carto.Parser(env)).parse(data);
    if (env.benchmark) console.timeEnd('Parsing MSS');

    if (env.benchmark) console.time('Rule generation');
    var rule_list = parser.toList(env);
    if (env.benchmark) console.timeEnd('Rule generation');

    if (env.benchmark) console.time('Rule inheritance');
    var rules = inheritDefinitions(rule_list, env);
    if (env.benchmark) console.timeEnd('Rule inheritance');

    if (env.benchmark) console.time('Style sort');
    var sorted = sortStyles(rules,env);
    if (env.benchmark) console.timeEnd('Style sort');

    if (env.benchmark) console.time('Total Style generation');
    for (var k = 0, rule, style_name; k < sorted.length; k++) {
        rule = sorted[k];
        style_name = 'style' + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');
        styles.push(style_name);
        var bench_name = '\tStyle "'+style_name+'" (#'+k+') toXML';
        if (env.benchmark) console.time(bench_name);
        // env.effects can be modified by this call
        output.push(carto.tree.StyleXML(style_name, rule.attachment, rule, env));
        if (env.benchmark) console.timeEnd(bench_name);
    }
    if (env.benchmark) console.timeEnd('Total Style generation');
    if (env.errors) throw env.errors;
    return output.join('\n');
};

/**
 * Prepare a MML document (given as an object) into a
 * fully-localized XML file ready for Mapnik2 consumption
 *
 * @param {String} m - the JSON file as a string.
 */
carto.Renderer.prototype.render = function render(m) {
    // effects is a container for side-effects, which currently
    // are limited to FontSets.
    var env = _(this.env).defaults({
        benchmark: false,
        validation_data: false,
        effects: [],
        ppi: 90.714
    });

    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {
        throw new Error("Could not set mapnik version to " + this.options.mapnik_version);
    }

    var output = [];

    // Transform stylesheets into definitions.
    var definitions = _(m.Stylesheet).chain()
        .map(function(s) {
            if (typeof s == 'string') {
                throw new Error("Stylesheet object is expected not a string: '" + s + "'");
            }
            // Passing the environment from stylesheet to stylesheet,
            // allows frames and effects to be maintained.
            env = _(env).extend({filename:s.id});

            var time = +new Date(),
                root = (carto.Parser(env)).parse(s.data);
            if (env.benchmark)
                console.warn('Parsing time: ' + (new Date() - time) + 'ms');
            return root.toList(env);
        })
        .flatten()
        .value();

    function appliesTo(name, classIndex) {
        return function(definition) {
            return definition.appliesTo(l.name, classIndex);
        };
    }

    // Iterate through layers and create styles custom-built
    // for each of them, and apply those styles to the layers.
    var styles, l, classIndex, rules, sorted, matching;
    for (var i = 0; i < m.Layer.length; i++) {
        l = m.Layer[i];
        styles = [];
        classIndex = {};

        if (env.benchmark) console.warn('processing layer: ' + l.id);
        // Classes are given as space-separated alphanumeric strings.
        var classes = (l['class'] || '').split(/\s+/g);
        for (var j = 0; j < classes.length; j++) {
            classIndex[classes[j]] = true;
        }
        matching = definitions.filter(appliesTo(l.name, classIndex));
        rules = inheritDefinitions(matching, env);
        sorted = sortStyles(rules, env);

        for (var k = 0, rule, style_name; k < sorted.length; k++) {
            rule = sorted[k];
            style_name = l.name + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');

            // env.effects can be modified by this call
            var styleXML = carto.tree.StyleXML(style_name, rule.attachment, rule, env);

            if (styleXML) {
                output.push(styleXML);
                styles.push(style_name);
            }
        }

        output.push(carto.tree.LayerXML(l, styles));
    }

    output.unshift(env.effects.map(function(e) {
        return e.toXML(env);
    }).join('\n'));

    var map_properties = getMapProperties(m, definitions, env);

    // Exit on errors.
    if (env.errors) throw env.errors;

    // Pass TileJSON and other custom parameters through to Mapnik XML.
    var parameters = _(m).reduce(function(memo, v, k) {
        if (!v && v !== 0) return memo;

        switch (k) {
        // Known skippable properties.
        case 'srs':
        case 'Layer':
        case 'Stylesheet':
            break;
        // Non URL-bound TileJSON properties.
        case 'bounds':
        case 'center':
        case 'minzoom':
        case 'maxzoom':
        case 'version':
            memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            break;
        // Properties that require CDATA.
        case 'name':
        case 'description':
        case 'legend':
        case 'attribution':
        case 'template':
            memo.push('  <Parameter name="' + k + '"><![CDATA[' + v + ']]></Parameter>');
            break;
        // Mapnik image format.
        case 'format':
            memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            break;
        // Mapnik interactivity settings.
        case 'interactivity':
            memo.push('  <Parameter name="interactivity_layer">' + v.layer + '</Parameter>');
            memo.push('  <Parameter name="interactivity_fields">' + v.fields + '</Parameter>');
            break;
        // Support any additional scalar properties.
        default:
            if ('string' === typeof v) {
                memo.push('  <Parameter name="' + k + '"><![CDATA[' + v + ']]></Parameter>');
            } else if ('number' === typeof v) {
                memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            } else if ('boolean' === typeof v) {
                memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            }
            break;
        }
        return memo;
    }, []);
    if (parameters.length) output.unshift(
        '<Parameters>\n' +
        parameters.join('\n') +
        '\n</Parameters>\n'
    );

    var properties = _(map_properties).map(function(v) { return ' ' + v; }).join('');

    output.unshift(
        '<?xml version="1.0" ' +
        'encoding="utf-8"?>\n' +
        '<!DOCTYPE Map[]>\n' +
        '<Map' + properties +'>\n');
    output.push('</Map>');
    return output.join('\n');
};

/**
 * This function currently modifies 'current'
 * @param {Array}  current  current list of rules
 * @param {Object} definition a Definition object to add to the rules
 * @param {Object} byFilter an object/dictionary of existing filters. This is
 * actually keyed `attachment->filter`
 * @param {Object} env the current environment
*/
function addRules(current, definition, byFilter, env) {
    var newFilters = definition.filters,
        newRules = definition.rules,
        updatedFilters, clone, previous;

    // The current definition might have been split up into
    // multiple definitions already.
    for (var k = 0; k < current.length; k++) {
        updatedFilters = current[k].filters.cloneWith(newFilters);
        if (updatedFilters) {
            previous = byFilter[updatedFilters];
            if (previous) {
                // There's already a definition with those exact
                // filters. Add the current definitions' rules
                // and stop processing it as the existing rule
                // has already gone down the inheritance chain.
                previous.addRules(newRules);
            } else {
                clone = current[k].clone(updatedFilters);
                // Make sure that we're only maintaining the clone
                // when we did actually add rules. If not, there's
                // no need to keep the clone around.
                if (clone.addRules(newRules)) {
                    // We inserted an element before this one, so we need
                    // to make sure that in the next loop iteration, we're
                    // not performing the same task for this element again,
                    // hence the k++.
                    byFilter[updatedFilters] = clone;
                    current.splice(k, 0, clone);
                    k++;
                }
            }
        } else if (updatedFilters === null) {
            // if updatedFilters is null, then adding the filters doesn't
            // invalidate or split the selector, so we addRules to the
            // combined selector

            // Filters can be added, but they don't change the
            // filters. This means we don't have to split the
            // definition.
            //
            // this is cloned here because of shared classes, see
            // sharedclass.mss
            current[k] = current[k].clone();
            current[k].addRules(newRules);
        }
        // if updatedFeatures is false, then the filters split the rule,
        // so they aren't the same inheritance chain
    }
    return current;
}

/**
 * Apply inherited styles from their ancestors to them.
 *
 * called either once per render (in the case of mss) or per layer
 * (for mml)
 *
 * @param {Object} definitions - a list of definitions objects
 *   that contain .rules
 * @param {Object} env - the environment
 * @return {Array<Array>} an array of arrays is returned,
 *   in which each array refers to a specific attachment
 */
function inheritDefinitions(definitions, env) {
    var inheritTime = +new Date();
    // definitions are ordered by specificity,
    // high (index 0) to low
    var byAttachment = {},
        byFilter = {};
    var result = [];
    var current, previous, attachment;

    // Evaluate the filters specified by each definition with the given
    // environment to correctly resolve variable references
    definitions.forEach(function(d) {
        d.filters.ev(env);
    });

    for (var i = 0; i < definitions.length; i++) {

        attachment = definitions[i].attachment;
        current = [definitions[i]];

        if (!byAttachment[attachment]) {
            byAttachment[attachment] = [];
            byAttachment[attachment].attachment = attachment;
            byFilter[attachment] = {};
            result.push(byAttachment[attachment]);
        }

        // Iterate over all subsequent rules.
        for (var j = i + 1; j < definitions.length; j++) {
            if (definitions[j].attachment === attachment) {
                // Only inherit rules from the same attachment.
                current = addRules(current, definitions[j], byFilter[attachment], env);
            }
        }

        for (var k = 0; k < current.length; k++) {
            byFilter[attachment][current[k].filters] = current[k];
            byAttachment[attachment].push(current[k]);
        }
    }

    if (env.benchmark) console.warn('Inheritance time: ' + ((new Date() - inheritTime)) + 'ms');

    return result;

}

// Sort styles by the minimum index of their rules.
// This sorts a slice of the styles, so it returns a sorted
// array but does not change the input.
function sortStylesIndex(a, b) { return b.index - a.index; }
function sortStyles(styles, env) {
    for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        style.index = Infinity;
        for (var b = 0; b < style.length; b++) {
            var rules = style[b].rules;
            for (var r = 0; r < rules.length; r++) {
                var rule = rules[r];
                if (rule.index < style.index) {
                    style.index = rule.index;
                }
            }
        }
    }

    var result = styles.slice();
    result.sort(sortStylesIndex);
    return result;
}

/**
 * Find a rule like Map { background-color: #fff; },
 * if any, and return a list of properties to be inserted
 * into the <Map element of the resulting XML. Translates
 * properties of the mml object at `m` directly into XML
 * properties.
 *
 * @param {Object} m the mml object.
 * @param {Array} definitions the output of toList.
 * @param {Object} env
 * @return {String} rendered properties.
 */
function getMapProperties(m, definitions, env) {
    var rules = {};
    var symbolizers = carto.tree.Reference.data.symbolizers.map;

    _(m).each(function(value, key) {
        if (key in symbolizers) rules[key] = key + '="' + value + '"';
    });

    definitions.filter(function(r) {
        return r.elements.join('') === 'Map';
    }).forEach(function(r) {
        for (var i = 0; i < r.rules.length; i++) {
            var key = r.rules[i].name;
            if (!(key in symbolizers)) {
                env.error({
                    message: 'Rule ' + key + ' not allowed for Map.',
                    index: r.rules[i].index
                });
            }
            rules[key] = r.rules[i].ev(env).toXML(env);
        }
    });
    return rules;
}

module.exports = carto;
module.exports.addRules = addRules;
module.exports.inheritDefinitions = inheritDefinitions;
module.exports.sortStyles = sortStyles;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./index":45,"underscore":80}],48:[function(require,module,exports){
(function (global){
(function(carto) {
var tree = require('./tree');
var _ = global._ || require('underscore');


function CartoCSS(style, options) {
  this.options = options || {};
  this.imageURLs = [];
  if(style) {
    this.setStyle(style);
  }
}

CartoCSS.Layer = function(shader, options) {
  this.options = options;
  this.shader = shader;
};


CartoCSS.Layer.prototype = {

  fullName: function() {
    return this.shader.attachment;
  },

  name: function() {
    return this.fullName().split('::')[0];
  },

  // frames this layer need to be rendered
  frames: function() {
    return this.shader.frames;
  },

  attachment: function() {
    return this.fullName().split('::')[1];
  },

  eval: function(prop) {
    var p = this.shader[prop];
    if (!p || !p.style) return;
    return p.style({}, { zoom: 0, 'frame-offset': 0 });
  },

  /*
   * `props`: feature properties
   * `context`: rendering properties, i.e zoom
   */
  getStyle: function(props, context) {
    var style = {};
    for(var i in this.shader) {
      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {
        style[i] = this.shader[i].style(props, context);
      }
    }
    return style;
  },

  /**
   * return the symbolizers that need to be rendered with
   * this style. The order is the rendering order.
   * @returns a list with 3 possible values 'line', 'marker', 'polygon'
   */
  getSymbolizers: function() {
    return this.shader.symbolizers;
  },

  /**
   * returns if the style varies with some feature property.
   * Useful to optimize rendering
   */
  isVariable: function() {
    for(var i in this.shader) {
      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {
        if (!this.shader[i].constant) {
          return true;
        }
      }
    }
    return false;
  },

  getShader: function() {
    return this.shader;
  },

  /**
   * returns true if a feature needs to be rendered
   */
  filter: function(featureType, props, context) {
    for(var i in this.shader) {
     var s = this.shader[i](props, context);
     if(s) {
       return true;
     }
    }
    return false;
  },

  //
  // given a geoemtry type returns the transformed one acording the CartoCSS
  // For points there are two kind of types: point and sprite, the first one
  // is a circle, second one is an image sprite
  //
  // the other geometry types are the same than geojson (polygon, linestring...)
  //
  transformGeometry: function(type) {
    return type;
  },

  transformGeometries: function(geojson) {
    return geojson;
  }

};

CartoCSS.prototype = {

  setStyle: function(style) {
    var layers = this.parse(style);
    if(!layers) {
      throw new Error(this.parse_env.errors);
    }
    this.layers = layers.map(function(shader) {
        return new CartoCSS.Layer(shader);
    });
  },

  getLayers: function() {
    return this.layers;
  },

  getDefault: function() {
    return this.findLayer({ attachment: '__default__' });
  },

  findLayer: function(where) {
    return _.find(this.layers, function(value) {
      for (var key in where) {
        var v = value[key];
        if (typeof(v) === 'function') {
          v = v.call(value);
        }
        if (where[key] !== v) return false;
      }
      return true;
    });
  },

  _createFn: function(ops) {
    var body = ops.join('\n');
    if(this.options.debug) console.log(body);
    return Function("data","ctx", "var _value = null; " +  body + "; return _value; ");
  },

  _compile: function(shader) {
    if(typeof shader === 'string') {
        shader = eval("(function() { return " + shader +"; })()");
    }
    this.shader_src = shader;
    for(var attr in shader) {
        var c = mapper[attr];
        if(c) {
            this.compiled[c] = eval("(function() { return shader[attr]; })();");
        }
    }
  },
  getImageURLs: function(){
    return this.imageURLs;
  },

  parse: function(cartocss) {
    var parse_env = {
      frames: [],
      errors: [],
      error: function(obj) {
        this.errors.push(obj);
      }
    };
    this.parse_env = parse_env;

    var ruleset = null;
    try {
      ruleset = (new carto.Parser(parse_env)).parse(cartocss);
    } catch(e) {
      // add the style.mss string to match the response from the server
      parse_env.errors.push(e.message);
      return;
    }
    if(ruleset) {

      function defKey(def) {
        return def.elements[0] + "::" + def.attachment;
      }
      var defs = ruleset.toList(parse_env);
      defs.reverse();
      // group by elements[0].value::attachment
      var layers = {};
      for(var i = 0; i < defs.length; ++i) {
        var def = defs[i];
        var key = defKey(def);
        var layer = layers[key] = (layers[key] || {
          symbolizers: []
        });
        for(var u = 0; u<def.rules.length; u++){
            if(def.rules[u].name === "marker-file" || def.rules[u].name === "point-file"){
                var value = def.rules[u].value.value[0].value[0].value.value;
                this.imageURLs.push(value);
            }
        }
        layer.frames = [];
        layer.zoom = tree.Zoom.all;
        var props = def.toJS(parse_env);
        if (this.options.debug) console.log("props", props);
        for(var v in props) {
          var lyr = layer[v] = layer[v] || {
            constant: false,
            symbolizer: null,
            js: [],
            index: 0
          };
          // build javascript statements
          lyr.js.push(props[v].map(function(a) { return a.js; }).join('\n'));
          // get symbolizer for prop
          lyr.symbolizer = _.first(props[v].map(function(a) { return a.symbolizer; }));
          // serach the max index to know rendering order
          lyr.index = _.max(props[v].map(function(a) { return a.index; }).concat(lyr.index));
          lyr.constant = !_.any(props[v].map(function(a) { return !a.constant; }));
        }
      }

      var ordered_layers = [];
      if (this.options.debug) console.log(layers);

      var done = {};
      for(var i = 0; i < defs.length; ++i) {
        var def = defs[i];
        var k = defKey(def);
        var layer = layers[k];
        if(!done[k]) {
          if(this.options.debug) console.log("**", k);
          for(var prop in layer) {
            if (prop !== 'zoom' && prop !== 'frames' && prop !== 'symbolizers') {
              if(this.options.debug) console.log("*", prop);
              layer[prop].style = this._createFn(layer[prop].js);
              layer.symbolizers.push(layer[prop].symbolizer);
              layer.symbolizers = _.uniq(layer.symbolizers);
            }
          }
          layer.attachment = k;
          ordered_layers.push(layer);
          done[k] = true;
        }
        layer.zoom |= def.zoom;
        layer.frames.push(def.frame_offset);
      }

      // uniq the frames
      for(i = 0; i < ordered_layers.length; ++i) {
        ordered_layers[i].frames = _.uniq(ordered_layers[i].frames);
      }

      return ordered_layers;

    }
    return null;
  }
};


carto.RendererJS = function (options) {
    this.options = options || {};
    this.options.mapnik_version = this.options.mapnik_version || 'latest';
};

// Prepare a javascript object which contains the layers
carto.RendererJS.prototype.render = function render(cartocss, callback) {
    var reference = require('./torque-reference');
    tree.Reference.setData(reference.version.latest);
    return new CartoCSS(cartocss, this.options);
}

if(typeof(module) !== 'undefined') {
  module.exports = carto.RendererJS;
}


})(require('../carto'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../carto":45,"./torque-reference":49,"./tree":50,"underscore":80}],49:[function(require,module,exports){
var _mapnik_reference_latest = {
    "version": "2.1.1",
    "style": {
        "filter-mode": {
            "type": [
                "all",
                "first"
            ],
            "doc": "Control the processing behavior of Rule filters within a Style. If 'all' is used then all Rules are processed sequentially independent of whether any previous filters matched. If 'first' is used then it means processing ends after the first match (a positive filter evaluation) and no further Rules in the Style are processed ('first' is usually the default for CSS implementations on top of Mapnik to simplify translation from CSS to Mapnik XML)",
            "default-value": "all",
            "default-meaning": "All Rules in a Style are processed whether they have filters or not and whether or not the filter conditions evaluate to true."
        },
        "image-filters": {
            "css": "image-filters",
            "default-value": "none",
            "default-meaning": "no filters",
            "type": "functions",
            "functions": [
                ["agg-stack-blur", 2],
                ["emboss", 0],
                ["blur", 0],
                ["gray", 0],
                ["sobel", 0],
                ["edge-detect", 0],
                ["x-gradient", 0],
                ["y-gradient", 0],
                ["invert", 0],
                ["sharpen", 0],
                ["colorize-alpha", -1],
                ["color-to-alpha", 1],
                ["scale-hsla", 8]
            ],
            "doc": "A list of image filters."
        },
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": ["clear",
                "src",
                "dst",
                "src-over",
                "source-over", // added for torque
                "dst-over",
                "src-in",
                "dst-in",
                "src-out",
                "dst-out",
                "src-atop",
                "dst-atop",
                "xor",
                "plus",
                "minus",
                "multiply",
                "screen",
                "overlay",
                "darken",
                "lighten",
                "lighter", // added for torque
                "color-dodge",
                "color-burn",
                "hard-light",
                "soft-light",
                "difference",
                "exclusion",
                "contrast",
                "invert",
                "invert-rgb",
                "grain-merge",
                "grain-extract",
                "hue",
                "saturation",
                "color",
                "value"
            ]
        },
        "opacity": {
            "css": "opacity",
            "type": "float",
            "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
            "default-value": 1,
            "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
        }
    },
    "layer" : {
        "name": {
            "default-value": "",
            "type":"string",
            "required" : true,
            "default-meaning": "No layer name has been provided",
            "doc": "The name of a layer. Can be anything you wish and is not strictly validated, but ideally unique  in the map"
        },
        "srs": {
            "default-value": "",
            "type":"string",
            "default-meaning": "No srs value is provided and the value will be inherited from the Map's srs",
            "doc": "The spatial reference system definition for the layer, aka the projection. Can either be a proj4 literal string like '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' or, if the proper proj4 epsg/nad/etc identifier files are installed, a string that uses an id like: '+init=epsg:4326'"
        },
        "status": {
            "default-value": true,
            "type":"boolean",
            "default-meaning": "This layer will be marked as active and available for processing",
            "doc": "A property that can be set to false to disable this layer from being processed"
        },
        "minzoom": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "The layer will be visible at the minimum possible scale",
            "doc": "The minimum scale denominator that this layer will be visible at. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "maxzoom": {
            "default-value": "1.79769e+308",
            "type":"float",
            "default-meaning": "The layer will be visible at the maximum possible scale",
            "doc": "The maximum scale denominator that this layer will be visible at. The default is the numeric limit of the C++ double type, which may vary slightly by system, but is likely a massive number like 1.79769e+308 and ensures that this layer will always be visible unless the value is reduced. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "queryable": {
            "default-value": false,
            "type":"boolean",
            "default-meaning": "The layer will not be available for the direct querying of data values",
            "doc": "This property was added for GetFeatureInfo/WMS compatibility and is rarely used. It is off by default meaning that in a WMS context the layer will not be able to be queried unless the property is explicitly set to true"
        },
        "clear-label-cache": {
            "default-value": false,
            "type":"boolean",
            "default-meaning": "The renderer's collision detector cache (used for avoiding duplicate labels and overlapping markers) will not be cleared immediately before processing this layer",
            "doc": "This property, by default off, can be enabled to allow a user to clear the collision detector cache before a given layer is processed. This may be desirable to ensure that a given layers data shows up on the map even if it normally would not because of collisions with previously rendered labels or markers"
        },
        "group-by": {
            "default-value": "",
            "type":"string",
            "default-meaning": "No special layer grouping will be used during rendering",
            "doc": "https://github.com/mapnik/mapnik/wiki/Grouped-rendering"
        },
        "buffer-size": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "maximum-extent": {
            "default-value": "none",
            "type":"bbox",
            "default-meaning": "No clipping extent will be used",
            "doc": "An extent to be used to limit the bounds used to query this specific layer data during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Layer."
        }
    },
    "symbolizers" : {
        "*": {
            "image-filters": {
                "css": "image-filters",
                "default-value": "none",
                "default-meaning": "no filters",
                "type": "functions",
                "functions": [
                    ["agg-stack-blur", 2],
                    ["emboss", 0],
                    ["blur", 0],
                    ["gray", 0],
                    ["sobel", 0],
                    ["edge-detect", 0],
                    ["x-gradient", 0],
                    ["y-gradient", 0],
                    ["invert", 0],
                    ["sharpen", 0],
                    ["colorize-alpha", -1],
                    ["color-to-alpha", 1],
                    ["scale-hsla", 8]
                ],
                "doc": "A list of image filters."
            },
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "source-over", // added for torque
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "lighter", // added for torque
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "map": {
            "background-color": {
                "css": "background-color",
                "default-value": "none",
                "default-meaning": "transparent",
                "type": "color",
                "doc": "Map Background color"
            },
            "background-image": {
                "css": "background-image",
                "type": "uri",
                "default-value": "",
                "default-meaning": "transparent",
                "doc": "An image that is repeated below all features on a map as a background.",
                "description": "Map Background image"
            },
            "srs": {
                "css": "srs",
                "type": "string",
                "default-value": "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
                "default-meaning": "The proj4 literal of EPSG:4326 is assumed to be the Map's spatial reference and all data from layers within this map will be plotted using this coordinate system. If any layers do not declare an srs value then they will be assumed to be in the same srs as the Map and not transformations will be needed to plot them in the Map's coordinate space",
                "doc": "Map spatial reference (proj4 string)"
            },
            "buffer-size": {
                "css": "buffer-size",
                "default-value": "0",
                "type":"float",
                "default-meaning": "No buffer will be used",
                "doc": "Extra tolerance around the map (in pixels) used to ensure labels crossing tile boundaries are equally rendered in each tile (e.g. cut in each tile). Not intended to be used in combination with \"avoid-edges\"."
            },
            "maximum-extent": {
                "css": "",
                "default-value": "none",
                "type":"bbox",
                "default-meaning": "No clipping extent will be used",
                "doc": "An extent to be used to limit the bounds used to query all layers during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Map."
            },
            "base": {
                "css": "base",
                "default-value": "",
                "default-meaning": "This base path defaults to an empty string meaning that any relative paths to files referenced in styles or layers will be interpreted relative to the application process.",
                "type": "string",
                "doc": "Any relative paths used to reference files will be understood as relative to this directory path if the map is loaded from an in memory object rather than from the filesystem. If the map is loaded from the filesystem and this option is not provided it will be set to the directory of the stylesheet."
            },
            "paths-from-xml": {
                "css": "",
                "default-value": true,
                "default-meaning": "Paths read from XML will be interpreted from the location of the XML",
                "type": "boolean",
                "doc": "value to control whether paths in the XML will be interpreted from the location of the XML or from the working directory of the program that calls load_map()"
            },
            "minimum-version": {
                "css": "",
                "default-value": "none",
                "default-meaning": "Mapnik version will not be detected and no error will be thrown about compatibility",
                "type": "string",
                "doc": "The minumum Mapnik version (e.g. 0.7.2) needed to use certain functionality in the stylesheet"
            },
            "font-directory": {
                "css": "font-directory",
                "type": "uri",
                "default-value": "none",
                "default-meaning": "No map-specific fonts will be registered",
                "doc": "Path to a directory which holds fonts which should be registered when the Map is loaded (in addition to any fonts that may be automatically registered)."
            }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon"
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque"
            },
            "gamma": {
                "css": "polygon-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon edges"
            },
            "gamma-method": {
                "css": "polygon-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "clip": {
                "css": "polygon-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line"
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels"
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": [
                    "miter",
                    "round",
                    "bevel"
                ],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": [
                    "butt",
                    "round",
                    "square"
                ],
                "doc": "The display of line endings"
            },
            "stroke-gamma": {
                "css": "line-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of stroke line"
            },
            "stroke-gamma-method": {
                "css": "line-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "stroke-dasharray": {
                "css": "line-dasharray",
                "type": "numbers",
                "doc": "A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-dashoffset": {
                "css": "line-dash-offset",
                "type": "numbers",
                "doc": "valid parameter but not currently used in renderers (only exists for experimental svg support in Mapnik which is not yet enabled)",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-miterlimit": {
                "css": "line-miterlimit",
                "type": "float",
                "doc": "The limit on the ratio of the miter length to the stroke-width. Used to automatically convert miter joins to bevel joins for sharp angles to avoid the miter extending beyond the thickness of the stroking path. Normally will not need to be set, but a larger value can sometimes help avoid jaggy artifacts.",
                "default-value": 4.0,
                "default-meaning": "Will auto-convert miters to bevel line joins when theta is less than 29 degrees as per the SVG spec: 'miterLength / stroke-width = 1 / sin ( theta / 2 )'"
            },
            "clip": {
                "css": "line-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "offset": {
                "css": "line-offset",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no offset",
                "doc": "Offsets a line a number of pixels parallel to its actual path. Postive values move the line left, negative values move it right (relative to the directionality of the line)."
            },
            "rasterizer": {
                "css": "line-rasterizer",
                "type": [
                    "full",
                    "fast"
                ],
                "default-value": "full",
                "doc": "Exposes an alternate AGG rendering method that sacrifices some accuracy for speed."
            },
            "geometry-transform": {
                "css": "line-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri"
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "placement": {
                "css": "marker-placement",
                "type": [
                    "point",
                    "line",
                    "interior"
                ],
                "default-value": "point",
                "default-meaning": "Place markers at the center point (centroid) of the geometry",
                "doc": "Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior"
            },
            "multi-policy": {
                "css": "marker-multi-policy",
                "type": [
                    "each",
                    "whole",
                    "largest"
                ],
                "default-value": "each",
                "default-meaning": "If a feature contains multiple geometries and the placement type is either point or interior then a marker will be rendered for each",
                "doc": "A special setting to allow the user to control rendering behavior for 'multi-geometries' (when a feature contains multiple geometries). This setting does not apply to markers placed along lines. The 'each' policy is default and means all geometries will get a marker. The 'whole' policy means that the aggregate centroid between all geometries will be used. The 'largest' policy means that only the largest (by bounding box areas) feature will get a rendered marker (this is how text labeling behaves by default)."
            },
            "marker-type": {
                "css": "marker-type",
                "type": [
                    "arrow",
                    "ellipse",
                    "rectangle"
                ],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width)"
            },
            "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "float",
                "expression": true
            },
            "height": {
                "css": "marker-height",
                "default-value": 10,
                "doc": "The height of the marker, if using one of the default types.",
                "type": "float",
                "expression": true
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color"
            },
            "allow-overlap": {
                "css": "marker-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping markers are shown or hidden.",
                "default-meaning": "Do not allow makers to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "marker-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "spacing": {
                "css": "marker-spacing",
                "doc": "Space between repeated labels",
                "default-value": 100,
                "type": "float"
            },
            "max-error": {
                "css": "marker-max-error",
                "type": "float",
                "default-value": 0.2,
                "doc": "The maximum difference between actual marker placement and the marker-spacing parameter. Setting a high value can allow the renderer to try to resolve placement conflicts with other symbolizers."
            },
            "transform": {
                "css": "marker-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "clip": {
                "css": "marker-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "marker-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "marker-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "marker-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "shield": {
            "name": {
                "css": "shield-name",
                "type": "string",
                "expression": true,
                "serialization": "content",
                "doc": "Value to use for a shield\"s text label. Data columns are specified using brackets like [column_name]"
            },
            "file": {
                "css": "shield-file",
                "required": true,
                "type": "uri",
                "default-value": "none",
                "doc": "Image file to render behind the shield text"
            },
            "face-name": {
                "css": "shield-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to use for the shield text",
                "default-value": "",
                "required": true
            },
            "unlock-image": {
                "css": "shield-unlock-image",
                "type": "boolean",
                "doc": "This parameter should be set to true if you are trying to position text beside rather than on top of the shield image",
                "default-value": false,
                "default-meaning": "text alignment relative to the shield image uses the center of the image as the anchor for text positioning."
            },
            "size": {
                "css": "shield-size",
                "type": "float",
                "doc": "The size of the shield text in pixels"
            },
            "fill": {
                "css": "shield-fill",
                "type": "color",
                "doc": "The color of the shield text"
            },
            "placement": {
                "css": "shield-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "How this shield should be placed. Point placement attempts to place it on top of points, line places along lines multiple times per feature, vertex places on the vertexes of polygons, and interior attempts to place inside of polygons."
            },
            "avoid-edges": {
                "css": "shield-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "type": "boolean",
                "default-value": false
            },
            "allow-overlap": {
                "css": "shield-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping shields are shown or hidden.",
                "default-meaning": "Do not allow shields to overlap with other map elements already placed."
            },
            "minimum-distance": {
                "css": "shield-min-distance",
                "type": "float",
                "default-value": 0,
                "doc": "Minimum distance to the next shield symbol, not necessarily the same shield."
            },
            "spacing": {
                "css": "shield-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "The spacing between repeated occurrences of the same shield on a line"
            },
            "minimum-padding": {
                "css": "shield-min-padding",
                "default-value": 0,
                "doc": "Determines the minimum amount of padding that a shield gets relative to other shields",
                "type": "float"
            },
            "wrap-width": {
                "css": "shield-wrap-width",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Length of a chunk of text in characters before wrapping text"
            },
            "wrap-before": {
                "css": "shield-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "shield-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long names."
            },
            "halo-fill": {
                "css": "shield-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "shield-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "character-spacing": {
                "css": "shield-character-spacing",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Horizontal spacing between characters (in pixels). Currently works for point placement only, not line placement."
            },
            "line-spacing": {
                "css": "shield-line-spacing",
                "doc": "Vertical spacing between lines of multiline labels (in pixels)",
                "type": "unsigned"
            },
            "dx": {
                "css": "shield-text-dx",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "shield-text-dy",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "shield-dx": {
                "css": "shield-dx",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "shield-dy": {
                "css": "shield-dy",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "opacity": {
                "css": "shield-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the image used for the shield",
                "default-value": 1
            },
            "text-opacity": {
                "css": "shield-text-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the text placed on top of the shield",
                "default-value": 1
            },
            "horizontal-alignment": {
                "css": "shield-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The shield's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "vertical-alignment": {
                "css": "shield-vertical-alignment",
                "type": [
                    "top",
                    "middle",
                    "bottom",
                    "auto"
                ],
                "doc": "The shield's vertical alignment from its centerpoint",
                "default-value": "middle"
            },
            "text-transform": {
                "css": "shield-text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "justify-alignment": {
                "css": "shield-justify-alignment",
                "type": [
                    "left",
                    "center",
                    "right",
                    "auto"
                ],
                "doc": "Define how text in a shield's label is justified",
                "default-value": "auto"
            },
            "clip": {
                "css": "shield-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "shield-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line-pattern": {
            "file": {
                "css": "line-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "An image file to be repeated and warped along a line"
            },
            "clip": {
                "css": "line-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "line-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "polygon-pattern": {
            "file": {
                "css": "polygon-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "Image to use as a repeated pattern fill within a polygon"
            },
            "alignment": {
                "css": "polygon-pattern-alignment",
                "type": [
                    "local",
                    "global"
                ],
                "default-value": "local",
                "doc": "Specify whether to align pattern fills to the layer or to the map."
            },
            "gamma": {
                "css": "polygon-pattern-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon pattern edges"
            },
            "opacity": {
                "css": "polygon-pattern-opacity",
                "type": "float",
                "doc": "(Default 1.0) - Apply an opacity level to the image used for the pattern",
                "default-value": 1,
                "default-meaning": "The image is rendered without modifications"
            },
            "clip": {
                "css": "polygon-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "raster": {
            "opacity": {
                "css": "raster-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float",
                "doc": "The opacity of the raster symbolizer on top of other symbolizers."
            },
            "filter-factor": {
                "css": "raster-filter-factor",
                "default-value": -1,
                "default-meaning": "Allow the datasource to choose appropriate downscaling.",
                "type": "float",
                "doc": "This is used by the Raster or Gdal datasources to pre-downscale images using overviews. Higher numbers can sometimes cause much better scaled image output, at the cost of speed."
            },
            "scaling": {
                "css": "raster-scaling",
                "type": [
                    "near",
                    "fast",
                    "bilinear",
                    "bilinear8",
                    "bicubic",
                    "spline16",
                    "spline36",
                    "hanning",
                    "hamming",
                    "hermite",
                    "kaiser",
                    "quadric",
                    "catrom",
                    "gaussian",
                    "bessel",
                    "mitchell",
                    "sinc",
                    "lanczos",
                    "blackman"
                ],
                "default-value": "near",
                "doc": "The scaling algorithm used to making different resolution versions of this raster layer. Bilinear is a good compromise between speed and accuracy, while lanczos gives the highest quality."
            },
            "mesh-size": {
                "css": "raster-mesh-size",
                "default-value": 16,
                "default-meaning": "Reprojection mesh will be 1/16 of the resolution of the source image",
                "type": "unsigned",
                "doc": "A reduced resolution mesh is used for raster reprojection, and the total image size is divided by the mesh-size to determine the quality of that mesh. Values for mesh-size larger than the default will result in faster reprojection but might lead to distortion."
            },
            "comp-op": {
                "css": "raster-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "allow-overlap": {
                "css": "point-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping points are shown or hidden.",
                "default-meaning": "Do not allow points to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "point-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            },
            "placement": {
                "css": "point-placement",
                "type": [
                    "centroid",
                    "interior"
                ],
                "doc": "How this point should be placed. Centroid calculates the geometric center of a polygon, which can be outside of it, while interior always places inside of a polygon.",
                "default-value": "centroid"
            },
            "transform": {
                "css": "point-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "comp-op": {
                "css": "point-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "text": {
            "name": {
                "css": "text-name",
                "type": "string",
                "expression": true,
                "required": true,
                "default-value": "",
                "serialization": "content",
                "doc": "Value to use for a text label. Data columns are specified using brackets like [column_name]"
            },
            "face-name": {
                "css": "text-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to render a label in",
                "required": true
            },
            "size": {
                "css": "text-size",
                "type": "float",
                "default-value": 10,
                "doc": "Text size in pixels"
            },
            "text-ratio": {
                "css": "text-ratio",
                "doc": "Define the amount of text (of the total) present on successive lines when wrapping occurs",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-width": {
                "css": "text-wrap-width",
                "doc": "Length of a chunk of text in characters before wrapping text",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-before": {
                "css": "text-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "text-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long text."
            },
            "spacing": {
                "css": "text-spacing",
                "type": "unsigned",
                "doc": "Distance between repeated text labels on a line (aka. label-spacing)"
            },
            "character-spacing": {
                "css": "text-character-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "Horizontal spacing adjustment between characters in pixels"
            },
            "line-spacing": {
                "css": "text-line-spacing",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Vertical spacing adjustment between lines in pixels"
            },
            "label-position-tolerance": {
                "css": "text-label-position-tolerance",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Allows the label to be displaced from its ideal position by a number of pixels (only works with placement:line)"
            },
            "max-char-angle-delta": {
                "css": "text-max-char-angle-delta",
                "type": "float",
                "default-value": "22.5",
                "doc": "The maximum angle change, in degrees, allowed between adjacent characters in a label. This value internally is converted to radians to the default is 22.5*math.pi/180.0. The higher the value the fewer labels will be placed around around sharp corners."
            },
            "fill": {
                "css": "text-fill",
                "doc": "Specifies the color for the text",
                "default-value": "#000000",
                "type": "color"
            },
            "opacity": {
                "css": "text-opacity",
                "doc": "A number from 0 to 1 specifying the opacity for the text",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "type": "float"
            },
            "halo-fill": {
                "css": "text-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "text-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "dx": {
                "css": "text-dx",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "text-dy",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "vertical-alignment": {
                "css": "text-vertical-alignment",
                "type": [
                  "top",
                  "middle",
                  "bottom",
                  "auto"
                ],
                "doc": "Position of label relative to point position.",
                "default-value": "auto",
                "default-meaning": "Default affected by value of dy; \"bottom\" for dy>0, \"top\" for dy<0."
            },
            "avoid-edges": {
                "css": "text-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "default-value": false,
                "type": "boolean"
            },
            "minimum-distance": {
                "css": "text-min-distance",
                "doc": "Minimum permitted distance to the next text symbolizer.",
                "type": "float"
            },
            "minimum-padding": {
                "css": "text-min-padding",
                "doc": "Determines the minimum amount of padding that a text symbolizer gets relative to other text",
                "type": "float"
            },
            "minimum-path-length": {
                "css": "text-min-path-length",
                "type": "float",
                "default-value": 0,
                "default-meaning": "place labels on all paths",
                "doc": "Place labels only on paths longer than this value."
            },
            "allow-overlap": {
                "css": "text-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping text is shown or hidden.",
                "default-meaning": "Do not allow text to overlap with other text - overlapping markers will not be shown."
            },
            "orientation": {
                "css": "text-orientation",
                "type": "float",
                "expression": true,
                "doc": "Rotate the text."
            },
            "placement": {
                "css": "text-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "Control the style of placement of a point versus the geometry it is attached to."
            },
            "placement-type": {
                "css": "text-placement-type",
                "doc": "Re-position and/or re-size text to avoid overlaps. \"simple\" for basic algorithm (using text-placements string,) \"dummy\" to turn this feature off.",
                "type": [
                    "dummy",
                    "simple"
                ],
                "default-value": "dummy"
            },
            "placements": {
                "css": "text-placements",
                "type": "string",
                "default-value": "",
                "doc": "If \"placement-type\" is set to \"simple\", use this \"POSITIONS,[SIZES]\" string. An example is `text-placements: \"E,NE,SE,W,NW,SW\";` "
            },
            "text-transform": {
                "css": "text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "horizontal-alignment": {
                "css": "text-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The text's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "justify-alignment": {
                "css": "text-align",
                "type": [
                    "left",
                    "right",
                    "center",
                    "auto"
                ],
                "doc": "Define how text is justified",
                "default-value": "auto",
                "default-meaning": "Auto alignment means that text will be centered by default except when using the `placement-type` parameter - in that case either right or left justification will be used automatically depending on where the text could be fit given the `text-placements` directives"
            },
            "clip": {
                "css": "text-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "text-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "building": {
            "fill": {
                "css": "building-fill",
                "default-value": "#FFFFFF",
                "doc": "The color of the buildings walls.",
                "type": "color"
            },
            "fill-opacity": {
                "css": "building-fill-opacity",
                "type": "float",
                "doc": "The opacity of the building as a whole, including all walls.",
                "default-value": 1
            },
            "height": {
                "css": "building-height",
                "doc": "The height of the building in pixels.",
                "type": "float",
                "expression": true,
                "default-value": "0"
            }
        },
        "torque": {
          "-torque-clear-color": {
              "css": "-torque-clear-color",
              "type": "color",
              "default-value": "rgba(255, 255, 255, 0)",
              "default-meaning": "full clear",
              "doc": "color used to clear canvas on each frame"
          },
          "-torque-frame-count": {
              "css": "-torque-frame-count",
              "default-value": "128",
              "type":"float",
              "default-meaning": "the data is broken into 128 time frames",
              "doc": "Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used."
          },
          "-torque-resolution": {
              "css": "-torque-resolution",
              "default-value": "2",
              "type":"float",
              "default-meaning": "",
              "doc": "Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2"
          },
          "-torque-animation-duration": {
              "css": "-torque-animation-duration",
              "default-value": "30",
              "type":"float",
              "default-meaning": "the animation lasts 30 seconds",
              "doc": "Animation duration in seconds"
          },
          "-torque-aggregation-function": {
              "css": "-torque-aggregation-function",
              "default-value": "count(cartodb_id)",
              "type": "string",
              "default-meaning": "the value for each cell is the count of points in that cell",
              "doc": "A function used to calculate a value from the aggregate data for each cell. See -torque-resolution"
          },
          "-torque-time-attribute": {
              "css": "-torque-time-attribute",
              "default-value": "time",
              "type": "string",
              "default-meaning": "the data column in your table that is of a time based type",
              "doc": "The table column that contains the time information used create the animation"
          },
          "-torque-data-aggregation": {
              "css": "-torque-data-aggregation",
              "default-value": "linear",
              "type": [
                "linear",
                "cumulative"
              ],
              "default-meaning": "previous values are discarded",
              "doc": "A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts"
          }
        }
    },
    "colors": {
        "aliceblue":  [240, 248, 255],
        "antiquewhite":  [250, 235, 215],
        "aqua":  [0, 255, 255],
        "aquamarine":  [127, 255, 212],
        "azure":  [240, 255, 255],
        "beige":  [245, 245, 220],
        "bisque":  [255, 228, 196],
        "black":  [0, 0, 0],
        "blanchedalmond":  [255,235,205],
        "blue":  [0, 0, 255],
        "blueviolet":  [138, 43, 226],
        "brown":  [165, 42, 42],
        "burlywood":  [222, 184, 135],
        "cadetblue":  [95, 158, 160],
        "chartreuse":  [127, 255, 0],
        "chocolate":  [210, 105, 30],
        "coral":  [255, 127, 80],
        "cornflowerblue":  [100, 149, 237],
        "cornsilk":  [255, 248, 220],
        "crimson":  [220, 20, 60],
        "cyan":  [0, 255, 255],
        "darkblue":  [0, 0, 139],
        "darkcyan":  [0, 139, 139],
        "darkgoldenrod":  [184, 134, 11],
        "darkgray":  [169, 169, 169],
        "darkgreen":  [0, 100, 0],
        "darkgrey":  [169, 169, 169],
        "darkkhaki":  [189, 183, 107],
        "darkmagenta":  [139, 0, 139],
        "darkolivegreen":  [85, 107, 47],
        "darkorange":  [255, 140, 0],
        "darkorchid":  [153, 50, 204],
        "darkred":  [139, 0, 0],
        "darksalmon":  [233, 150, 122],
        "darkseagreen":  [143, 188, 143],
        "darkslateblue":  [72, 61, 139],
        "darkslategrey":  [47, 79, 79],
        "darkturquoise":  [0, 206, 209],
        "darkviolet":  [148, 0, 211],
        "deeppink":  [255, 20, 147],
        "deepskyblue":  [0, 191, 255],
        "dimgray":  [105, 105, 105],
        "dimgrey":  [105, 105, 105],
        "dodgerblue":  [30, 144, 255],
        "firebrick":  [178, 34, 34],
        "floralwhite":  [255, 250, 240],
        "forestgreen":  [34, 139, 34],
        "fuchsia":  [255, 0, 255],
        "gainsboro":  [220, 220, 220],
        "ghostwhite":  [248, 248, 255],
        "gold":  [255, 215, 0],
        "goldenrod":  [218, 165, 32],
        "gray":  [128, 128, 128],
        "grey":  [128, 128, 128],
        "green":  [0, 128, 0],
        "greenyellow":  [173, 255, 47],
        "honeydew":  [240, 255, 240],
        "hotpink":  [255, 105, 180],
        "indianred":  [205, 92, 92],
        "indigo":  [75, 0, 130],
        "ivory":  [255, 255, 240],
        "khaki":  [240, 230, 140],
        "lavender":  [230, 230, 250],
        "lavenderblush":  [255, 240, 245],
        "lawngreen":  [124, 252, 0],
        "lemonchiffon":  [255, 250, 205],
        "lightblue":  [173, 216, 230],
        "lightcoral":  [240, 128, 128],
        "lightcyan":  [224, 255, 255],
        "lightgoldenrodyellow":  [250, 250, 210],
        "lightgray":  [211, 211, 211],
        "lightgreen":  [144, 238, 144],
        "lightgrey":  [211, 211, 211],
        "lightpink":  [255, 182, 193],
        "lightsalmon":  [255, 160, 122],
        "lightseagreen":  [32, 178, 170],
        "lightskyblue":  [135, 206, 250],
        "lightslategray":  [119, 136, 153],
        "lightslategrey":  [119, 136, 153],
        "lightsteelblue":  [176, 196, 222],
        "lightyellow":  [255, 255, 224],
        "lime":  [0, 255, 0],
        "limegreen":  [50, 205, 50],
        "linen":  [250, 240, 230],
        "magenta":  [255, 0, 255],
        "maroon":  [128, 0, 0],
        "mediumaquamarine":  [102, 205, 170],
        "mediumblue":  [0, 0, 205],
        "mediumorchid":  [186, 85, 211],
        "mediumpurple":  [147, 112, 219],
        "mediumseagreen":  [60, 179, 113],
        "mediumslateblue":  [123, 104, 238],
        "mediumspringgreen":  [0, 250, 154],
        "mediumturquoise":  [72, 209, 204],
        "mediumvioletred":  [199, 21, 133],
        "midnightblue":  [25, 25, 112],
        "mintcream":  [245, 255, 250],
        "mistyrose":  [255, 228, 225],
        "moccasin":  [255, 228, 181],
        "navajowhite":  [255, 222, 173],
        "navy":  [0, 0, 128],
        "oldlace":  [253, 245, 230],
        "olive":  [128, 128, 0],
        "olivedrab":  [107, 142, 35],
        "orange":  [255, 165, 0],
        "orangered":  [255, 69, 0],
        "orchid":  [218, 112, 214],
        "palegoldenrod":  [238, 232, 170],
        "palegreen":  [152, 251, 152],
        "paleturquoise":  [175, 238, 238],
        "palevioletred":  [219, 112, 147],
        "papayawhip":  [255, 239, 213],
        "peachpuff":  [255, 218, 185],
        "peru":  [205, 133, 63],
        "pink":  [255, 192, 203],
        "plum":  [221, 160, 221],
        "powderblue":  [176, 224, 230],
        "purple":  [128, 0, 128],
        "red":  [255, 0, 0],
        "rosybrown":  [188, 143, 143],
        "royalblue":  [65, 105, 225],
        "saddlebrown":  [139, 69, 19],
        "salmon":  [250, 128, 114],
        "sandybrown":  [244, 164, 96],
        "seagreen":  [46, 139, 87],
        "seashell":  [255, 245, 238],
        "sienna":  [160, 82, 45],
        "silver":  [192, 192, 192],
        "skyblue":  [135, 206, 235],
        "slateblue":  [106, 90, 205],
        "slategray":  [112, 128, 144],
        "slategrey":  [112, 128, 144],
        "snow":  [255, 250, 250],
        "springgreen":  [0, 255, 127],
        "steelblue":  [70, 130, 180],
        "tan":  [210, 180, 140],
        "teal":  [0, 128, 128],
        "thistle":  [216, 191, 216],
        "tomato":  [255, 99, 71],
        "turquoise":  [64, 224, 208],
        "violet":  [238, 130, 238],
        "wheat":  [245, 222, 179],
        "white":  [255, 255, 255],
        "whitesmoke":  [245, 245, 245],
        "yellow":  [255, 255, 0],
        "yellowgreen":  [154, 205, 50],
        "transparent":  [0, 0, 0, 0]
    },
    "filter": {
        "value": [
            "true",
            "false",
            "null",
            "point",
            "linestring",
            "polygon",
            "collection"
        ]
    }
}

module.exports = {
  version: {
    latest: _mapnik_reference_latest,
    '2.1.1': _mapnik_reference_latest
  }
};

},{}],50:[function(require,module,exports){
/**
 * TODO: document this. What does this do?
 */
if(typeof(module) !== "undefined") {
  module.exports.find = function (obj, fun) {
      for (var i = 0, r; i < obj.length; i++) {
          if (r = fun.call(obj, obj[i])) { return r; }
      }
      return null;
  };
}

},{}],51:[function(require,module,exports){
(function (global){
(function(tree) {
var _ = global._ || require('underscore');
tree.Call = function Call(name, args, index) {
    this.name = name;
    this.args = args;
    this.index = index;
};

tree.Call.prototype = {
    is: 'call',
    // When evuating a function call,
    // we either find the function in `tree.functions` [1],
    // in which case we call it, passing the  evaluated arguments,
    // or we simply print it out as it appeared originally [2].
    // The *functions.js* file contains the built-in functions.
    // The reason why we evaluate the arguments, is in the case where
    // we try to pass a variable to a function, like: `saturate(@color)`.
    // The function should receive the value, not the variable.
    'ev': function(env) {
        var args = this.args.map(function(a) { return a.ev(env); });

        for (var i = 0; i < args.length; i++) {
            if (args[i].is === 'undefined') {
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        }

        if (this.name in tree.functions) {
            if (tree.functions[this.name].length <= args.length) {
                var val = tree.functions[this.name].apply(tree.functions, args);
                if (val === null) {
                    env.error({
                        message: 'incorrect arguments given to ' + this.name + '()',
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return { is: 'undefined', value: 'undefined' };
                }
                return val;
            } else {
                env.error({
                    message: 'incorrect number of arguments for ' + this.name +
                        '(). ' + tree.functions[this.name].length + ' expected.',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        } else {
            var fn = tree.Reference.mapnikFunctions[this.name];
            if (fn === undefined) {
                var functions = _.pairs(tree.Reference.mapnikFunctions);
                // cheap closest, needs improvement.
                var name = this.name;
                var mean = functions.map(function(f) {
                    return [f[0], tree.Reference.editDistance(name, f[0]), f[1]];
                }).sort(function(a, b) {
                    return a[1] - b[1];
                });
                env.error({
                    message: 'unknown function ' + this.name + '(), did you mean ' +
                        mean[0][0] + '(' + mean[0][2] + ')',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
            if (fn !== args.length &&
                !(Array.isArray(fn) && _.include(fn, args.length)) &&
                // support variable-arg functions like `colorize-alpha`
                fn !== -1) {
                env.error({
                    message: 'function ' + this.name + '() takes ' +
                        fn + ' arguments and was given ' + args.length,
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            } else {
                // Save the evaluated versions of arguments
                this.args = args;
                return this;
            }
        }
    },

    toString: function(env, format) {
        if (this.args.length) {
            return this.name + '(' + this.args.join(',') + ')';
        } else {
            return this.name;
        }
    }
};

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":50,"underscore":80}],52:[function(require,module,exports){
(function(tree) {
// RGB Colors - #ff0014, #eee
// can be initialized with a 3 or 6 char string or a 3 or 4 element
// numerical array
tree.Color = function Color(rgb, a) {
    // The end goal here, is to parse the arguments
    // into an integer triplet, such as `128, 255, 0`
    //
    // This facilitates operations and conversions.
    if (Array.isArray(rgb)) {
        this.rgb = rgb.slice(0, 3);
    } else if (rgb.length == 6) {
        this.rgb = rgb.match(/.{2}/g).map(function(c) {
            return parseInt(c, 16);
        });
    } else {
        this.rgb = rgb.split('').map(function(c) {
            return parseInt(c + c, 16);
        });
    }

    if (typeof(a) === 'number') {
        this.alpha = a;
    } else if (rgb.length === 4) {
        this.alpha = rgb[3];
    } else {
        this.alpha = 1;
    }
};

tree.Color.prototype = {
    is: 'color',
    'ev': function() { return this; },

    // If we have some transparency, the only way to represent it
    // is via `rgba`. Otherwise, we use the hex representation,
    // which has better compatibility with older browsers.
    // Values are capped between `0` and `255`, rounded and zero-padded.
    toString: function() {
        if (this.alpha < 1.0) {
            return 'rgba(' + this.rgb.map(function(c) {
                return Math.round(c);
            }).concat(this.alpha).join(', ') + ')';
        } else {
            return '#' + this.rgb.map(function(i) {
                i = Math.round(i);
                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);
                return i.length === 1 ? '0' + i : i;
            }).join('');
        }
    },

    // Operations have to be done per-channel, if not,
    // channels will spill onto each other. Once we have
    // our result, in the form of an integer triplet,
    // we create a new Color node to hold the result.
    operate: function(env, op, other) {
        var result = [];

        if (! (other instanceof tree.Color)) {
            other = other.toColor();
        }

        for (var c = 0; c < 3; c++) {
            result[c] = tree.operate(op, this.rgb[c], other.rgb[c]);
        }
        return new tree.Color(result);
    },

    toHSL: function() {
        var r = this.rgb[0] / 255,
            g = this.rgb[1] / 255,
            b = this.rgb[2] / 255,
            a = this.alpha;

        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2, d = max - min;

        if (max === min) {
            h = s = 0;
        } else {
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s: s, l: l, a: a };
    }
};

})(require('../tree'));

},{"../tree":50}],53:[function(require,module,exports){
(function(tree) {

tree.Comment = function Comment(value, silent) {
    this.value = value;
    this.silent = !!silent;
};

tree.Comment.prototype = {
    toString: function(env) {
        return '<!--' + this.value + '-->';
    },
    'ev': function() { return this; }
};

})(require('../tree'));

},{"../tree":50}],54:[function(require,module,exports){
(function (global){
(function(tree) {
var assert = require('assert'),
    _ = global._ || require('underscore');

// A definition is the combination of a selector and rules, like
// #foo {
//     polygon-opacity:1.0;
// }
//
// The selector can have filters
tree.Definition = function Definition(selector, rules) {
    this.elements = selector.elements;
    assert.ok(selector.filters instanceof tree.Filterset);
    this.rules = rules;
    this.ruleIndex = {};
    for (var i = 0; i < this.rules.length; i++) {
        if ('zoom' in this.rules[i]) this.rules[i] = this.rules[i].clone();
        this.rules[i].zoom = selector.zoom;
        this.ruleIndex[this.rules[i].updateID()] = true;
    }
    this.filters = selector.filters;
    this.zoom = selector.zoom;
    this.frame_offset = selector.frame_offset;
    this.attachment = selector.attachment || '__default__';
    this.specificity = selector.specificity();
};

tree.Definition.prototype.toString = function() {
    var str = this.filters.toString();
    for (var i = 0; i < this.rules.length; i++) {
        str += '\n    ' + this.rules[i];
    }
    return str;
};

tree.Definition.prototype.clone = function(filters) {
    if (filters) assert.ok(filters instanceof tree.Filterset);
    var clone = Object.create(tree.Definition.prototype);
    clone.rules = this.rules.slice();
    clone.ruleIndex = _.clone(this.ruleIndex);
    clone.filters = filters ? filters : this.filters.clone();
    clone.attachment = this.attachment;
    return clone;
};

tree.Definition.prototype.addRules = function(rules) {
    var added = 0;

    // Add only unique rules.
    for (var i = 0; i < rules.length; i++) {
        if (!this.ruleIndex[rules[i].id]) {
            this.rules.push(rules[i]);
            this.ruleIndex[rules[i].id] = true;
            added++;
        }
    }

    return added;
};

// Determine whether this selector matches a given id
// and array of classes, by determining whether
// all elements it contains match.
tree.Definition.prototype.appliesTo = function(id, classes) {
    for (var i = 0, l = this.elements.length; i < l; i++) {
        var elem = this.elements[i];
        if (!(elem.wildcard ||
            (elem.type === 'class' && classes[elem.clean]) ||
            (elem.type === 'id' && id === elem.clean))) return false;
    }
    return true;
};

function symbolizerName(symbolizer) {
    function capitalize(str) { return str[1].toUpperCase(); }
    return symbolizer.charAt(0).toUpperCase() +
           symbolizer.slice(1).replace(/\-./, capitalize) + 'Symbolizer';
}

// Get a simple list of the symbolizers, in order
function symbolizerList(sym_order) {
    return sym_order.sort(function(a, b) { return a[1] - b[1]; })
        .map(function(v) { return v[0]; });
}

tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
    var xml = zoom.toXML(env).join('') + this.filters.toXML(env);

    // Sort symbolizers by the index of their first property definition
    var sym_order = [], indexes = [];
    for (var key in symbolizers) {
        indexes = [];
        for (var prop in symbolizers[key]) {
            indexes.push(symbolizers[key][prop].index);
        }
        var min_idx = Math.min.apply(Math, indexes);
        sym_order.push([key, min_idx]);
    }

    sym_order = symbolizerList(sym_order);
    var sym_count = 0;

    for (var i = 0; i < sym_order.length; i++) {
        var attributes = symbolizers[sym_order[i]];
        var symbolizer = sym_order[i].split('/').pop();

        // Skip the magical * symbolizer which is used for universal properties
        // which are bubbled up to Style elements intead of Symbolizer elements.
        if (symbolizer === '*') continue;
        sym_count++;

        var fail = tree.Reference.requiredProperties(symbolizer, attributes);
        if (fail) {
            var rule = attributes[Object.keys(attributes).shift()];
            env.error({
                message: fail,
                index: rule.index,
                filename: rule.filename
            });
        }

        var name = symbolizerName(symbolizer);

        var selfclosing = true, tagcontent;
        xml += '    <' + name + ' ';
        for (var j in attributes) {
            if (symbolizer === 'map') env.error({
                message: 'Map properties are not permitted in other rules',
                index: attributes[j].index,
                filename: attributes[j].filename
            });
            var x = tree.Reference.selector(attributes[j].name);
            if (x && x.serialization && x.serialization === 'content') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else if (x && x.serialization && x.serialization === 'tag') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else {
                xml += attributes[j].ev(env).toXML(env) + ' ';
            }
        }
        if (selfclosing) {
            xml += '/>\n';
        } else if (typeof tagcontent !== "undefined") {
            if (tagcontent.indexOf('<') != -1) {
                xml += '>' + tagcontent + '</' + name + '>\n';
            } else {
                xml += '><![CDATA[' + tagcontent + ']]></' + name + '>\n';
            }
        }
    }
    if (!sym_count || !xml) return '';
    return '  <Rule>\n' + xml + '  </Rule>\n';
};

// Take a zoom range of zooms and 'i', the index of a rule in this.rules,
// and finds all applicable symbolizers
tree.Definition.prototype.collectSymbolizers = function(zooms, i) {
    var symbolizers = {}, child;

    for (var j = i; j < this.rules.length; j++) {
        child = this.rules[j];
        var key = child.instance + '/' + child.symbolizer;
        if (zooms.current & child.zoom &&
           (!(key in symbolizers) ||
           (!(child.name in symbolizers[key])))) {
            zooms.current &= child.zoom;
            if (!(key in symbolizers)) {
                symbolizers[key] = {};
            }
            symbolizers[key][child.name] = child;
        }
    }

    if (Object.keys(symbolizers).length) {
        zooms.rule &= (zooms.available &= ~zooms.current);
        return symbolizers;
    }
};

// The tree.Zoom.toString function ignores the holes in zoom ranges and outputs
// scaledenominators that cover the whole range from the first to last bit set.
// This algorithm can produces zoom ranges that may have holes. However,
// when using the filter-mode="first", more specific zoom filters will always
// end up before broader ranges. The filter-mode will pick those first before
// resorting to the zoom range with the hole and stop processing further rules.
tree.Definition.prototype.toXML = function(env, existing) {
    var filter = this.filters.toString();
    if (!(filter in existing)) existing[filter] = tree.Zoom.all;

    var available = tree.Zoom.all, xml = '', zoom, symbolizers,
        zooms = { available: tree.Zoom.all };
    for (var i = 0; i < this.rules.length && available; i++) {
        zooms.rule = this.rules[i].zoom;
        if (!(existing[filter] & zooms.rule)) continue;

        while (zooms.current = zooms.rule & available) {
            if (symbolizers = this.collectSymbolizers(zooms, i)) {
                if (!(existing[filter] & zooms.current)) continue;
                xml += this.symbolizersToXML(env, symbolizers,
                    (new tree.Zoom()).setZoom(existing[filter] & zooms.current));
                existing[filter] &= ~zooms.current;
            }
        }
    }

    return xml;
};

tree.Definition.prototype.toJS = function(env) {
  var shaderAttrs = {};

  // merge conditions from filters with zoom condition of the
  // definition
  var zoom = "(" + this.zoom + " & (1 << ctx.zoom))";
  var frame_offset = this.frame_offset;
  var _if = this.filters.toJS(env);
  var filters = [zoom];
  if(_if) filters.push(_if);
  if(frame_offset) filters.push('ctx["frame-offset"] === ' + frame_offset);
  _if = filters.join(" && ");
  _.each(this.rules, function(rule) {
      if(rule instanceof tree.Rule) {
        shaderAttrs[rule.name] = shaderAttrs[rule.name] || [];

        var r = {
          index: rule.index,
          symbolizer: rule.symbolizer
        };

        if (_if) {
          r.js = "if(" + _if + "){" + rule.value.toJS(env) + "}"
        } else {
          r.js = rule.value.toJS(env);
        }

        r.constant = rule.value.ev(env).is !== 'field';
        r.filtered = !!_if;

        shaderAttrs[rule.name].push(r);
      } else {
        throw new Error("Ruleset not supported");
        //if (rule instanceof tree.Ruleset) {
          //var sh = rule.toJS(env);
          //for(var v in sh) {
            //shaderAttrs[v] = shaderAttrs[v] || [];
            //for(var attr in sh[v]) {
              //shaderAttrs[v].push(sh[v][attr]);
            //}
          //}
        //}
      }
  });
  return shaderAttrs;
};


})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":50,"assert":3,"underscore":80}],55:[function(require,module,exports){
(function (global){
(function(tree) {
var _ = global._ || require('underscore');
//
// A number with a unit
//
tree.Dimension = function Dimension(value, unit, index) {
    this.value = parseFloat(value);
    this.unit = unit || null;
    this.index = index;
};

tree.Dimension.prototype = {
    is: 'float',
    physical_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc'],
    screen_units: ['px', '%'],
    all_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc', 'px', '%'],
    densities: {
        m: 0.0254,
        mm: 25.4,
        cm: 2.54,
        pt: 72,
        pc: 6
    },
    ev: function (env) {
        if (this.unit && !_.contains(this.all_units, this.unit)) {
            env.error({
                message: "Invalid unit: '" + this.unit + "'",
                index: this.index
            });
            return { is: 'undefined', value: 'undefined' };
        }

        // normalize units which are not px or %
        if (this.unit && _.contains(this.physical_units, this.unit)) {
            if (!env.ppi) {
                env.error({
                    message: "ppi is not set, so metric units can't be used",
                    index: this.index
                });
                return { is: 'undefined', value: 'undefined' };
            }
            // convert all units to inch
            // convert inch to px using ppi
            this.value = (this.value / this.densities[this.unit]) * env.ppi;
            this.unit = 'px';
        }

        return this;
    },
    round: function() {
        this.value = Math.round(this.value);
        return this;
    },
    toColor: function() {
        return new tree.Color([this.value, this.value, this.value]);
    },
    round: function() {
        this.value = Math.round(this.value);
        return this;
    },
    toString: function() {
        return this.value.toString();
    },
    operate: function(env, op, other) {
        if (this.unit === '%' && other.unit !== '%') {
            env.error({
                message: 'If two operands differ, the first must not be %',
                index: this.index
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        if (this.unit !== '%' && other.unit === '%') {
            if (op === '*' || op === '/' || op === '%') {
                env.error({
                    message: 'Percent values can only be added or subtracted from other values',
                    index: this.index
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            return new tree.Dimension(tree.operate(op,
                    this.value, this.value * other.value * 0.01),
                this.unit);
        }

        //here the operands are either the same (% or undefined or px), or one is undefined and the other is px
        return new tree.Dimension(tree.operate(op, this.value, other.value),
            this.unit || other.unit);
    }
};

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":50,"underscore":80}],56:[function(require,module,exports){
(function(tree) {

// An element is an id or class selector
tree.Element = function Element(value) {
    this.value = value.trim();
    if (this.value[0] === '#') {
        this.type = 'id';
        this.clean = this.value.replace(/^#/, '');
    }
    if (this.value[0] === '.') {
        this.type = 'class';
        this.clean = this.value.replace(/^\./, '');
    }
    if (this.value.indexOf('*') !== -1) {
        this.type = 'wildcard';
    }
};

// Determine the 'specificity matrix' of this
// specific selector
tree.Element.prototype.specificity = function() {
    return [
        (this.type === 'id') ? 1 : 0, // a
        (this.type === 'class') ? 1 : 0  // b
    ];
};

tree.Element.prototype.toString = function() { return this.value; };

})(require('../tree'));

},{"../tree":50}],57:[function(require,module,exports){
(function(tree) {

tree.Expression = function Expression(value) {
    this.value = value;
};

tree.Expression.prototype = {
    is: 'expression',
    ev: function(env) {
        if (this.value.length > 1) {
            return new tree.Expression(this.value.map(function(e) {
                return e.ev(env);
            }));
        } else {
            return this.value[0].ev(env);
        }
    },

    toString: function(env) {
        return this.value.map(function(e) {
            return e.toString(env);
        }).join(' ');
    }
};

})(require('../tree'));

},{"../tree":50}],58:[function(require,module,exports){
(function(tree) {

tree.Field = function Field(content) {
    this.value = content || '';
};

tree.Field.prototype = {
    is: 'field',
    toString: function() {
        return '[' + this.value + ']';
    },
    'ev': function() {
        return this;
    }
};

})(require('../tree'));

},{"../tree":50}],59:[function(require,module,exports){
(function(tree) {

tree.Filter = function Filter(key, op, val, index, filename) {
    this.key = key;
    this.op = op;
    this.val = val;
    this.index = index;
    this.filename = filename;

    this.id = this.key + this.op + this.val;
};

// xmlsafe, numeric, suffix
var ops = {
    '<': [' &lt; ', 'numeric'],
    '>': [' &gt; ', 'numeric'],
    '=': [' = ', 'both'],
    '!=': [' != ', 'both'],
    '<=': [' &lt;= ', 'numeric'],
    '>=': [' &gt;= ', 'numeric'],
    '=~': ['.match(', 'string', ')']
};

tree.Filter.prototype.ev = function(env) {
    this.key = this.key.ev(env);
    this.val = this.val.ev(env);
    return this;
};

tree.Filter.prototype.toXML = function(env) {
    if (tree.Reference.data.filter) {
        if (this.key.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.key.toString())) {
            env.error({
                message: this.key.toString() + ' is not a valid keyword in a filter expression',
                index: this.index,
                filename: this.filename
            });
        }
        if (this.val.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.val.toString())) {
            env.error({
                message: this.val.toString() + ' is not a valid keyword in a filter expression',
                index: this.index,
                filename: this.filename
            });
        }
    }
    var key = this.key.toString(false);
    var val = this.val.toString(this.val.is == 'string');

    if (
        (ops[this.op][1] == 'numeric' && isNaN(val) && this.val.is !== 'field') ||
        (ops[this.op][1] == 'string' && (val)[0] != "'")
    ) {
        env.error({
            message: 'Cannot use operator "' + this.op + '" with value ' + this.val,
            index: this.index,
            filename: this.filename
        });
    }

    return key + ops[this.op][0] + val + (ops[this.op][2] || '');
};

tree.Filter.prototype.toString = function() {
    return '[' + this.id + ']';
};

})(require('../tree'));

},{"../tree":50}],60:[function(require,module,exports){
(function (global){
var tree = require('../tree');
var _ = global._ || require('underscore');

tree.Filterset = function Filterset() {
    this.filters = {};
};

tree.Filterset.prototype.toXML = function(env) {
    var filters = [];
    for (var id in this.filters) {
        filters.push('(' + this.filters[id].toXML(env).trim() + ')');
    }
    if (filters.length) {
        return '    <Filter>' + filters.join(' and ') + '</Filter>\n';
    } else {
        return '';
    }
};

tree.Filterset.prototype.toString = function() {
    var arr = [];
    for (var id in this.filters) arr.push(this.filters[id].id);
    return arr.sort().join('\t');
};

tree.Filterset.prototype.ev = function(env) {
    for (var i in this.filters) {
        this.filters[i].ev(env);
    }
    return this;
};

tree.Filterset.prototype.clone = function() {
    var clone = new tree.Filterset();
    for (var id in this.filters) {
        clone.filters[id] = this.filters[id];
    }
    return clone;
};

// Note: other has to be a tree.Filterset.
tree.Filterset.prototype.cloneWith = function(other) {
    var additions = [];
    for (var id in other.filters) {
        var status = this.addable(other.filters[id]);
        // status is true, false or null. if it's null we don't fail this
        // clone nor do we add the filter.
        if (status === false) {
            return false;
        }
        if (status === true) {
            // Adding the filter will override another value.
            additions.push(other.filters[id]);
        }
    }

    // Adding the other filters doesn't make this filterset invalid, but it
    // doesn't add anything to it either.
    if (!additions.length) {
        return null;
    }

    // We can successfully add all filters. Now clone the filterset and add the
    // new rules.
    var clone = new tree.Filterset();

    // We can add the rules that are already present without going through the
    // add function as a Filterset is always in it's simplest canonical form.
    for (id in this.filters) {
        clone.filters[id] = this.filters[id];
    }

    // Only add new filters that actually change the filter.
    while (id = additions.shift()) {
        clone.add(id);
    }

    return clone;
};

tree.Filterset.prototype.toJS = function(env) {
  var opMap = {
    '=': '==='
  };
  return _.map(this.filters, function(filter) {
    var op = filter.op;
    if(op in opMap) {
      op = opMap[op];
    }
    var val = filter.val;
    if(filter._val !== undefined) {
      val = filter._val.toString(true);
    }
    var attrs = "data";
    return attrs + "." + filter.key.value  + " " + op + " " + (val.is === 'string' ? "'"+ val +"'" : val);
  }).join(' && ');
};

// Returns true when the new filter can be added, false otherwise.
// It can also return null, and on the other side we test for === true or
// false
tree.Filterset.prototype.addable = function(filter) {
    var key = filter.key.toString(),
        value = filter.val.toString();

    if (value.match(/^[0-9]+(\.[0-9]*)?$/)) value = parseFloat(value);

    switch (filter.op) {
        case '=':
            // if there is already foo= and we're adding foo=
            if (this.filters[key + '='] !== undefined) {
                if (this.filters[key + '='].val.toString() != value) {
                    return false;
                } else {
                    return null;
                }
            }
            if (this.filters[key + '!=' + value] !== undefined) return false;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return false;
            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val < value) return false;
            return true;

        case '=~':
            return true;

        case '!=':
            if (this.filters[key + '='] !== undefined) return (this.filters[key + '='].val == value) ? false : null;
            if (this.filters[key + '!=' + value] !== undefined) return null;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;
            return true;

        case '>':
            if (key + '=' in this.filters) {
                if (this.filters[key + '='].val <= value) {
                    return false;
                } else {
                    return null;
                }
            }
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val <= value) return false;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return null;
            return true;

        case '>=':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val < value) ? false : null;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return false;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return null;
            return true;

        case '<':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val >= value) ? false : null;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return false;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;
            return true;

        case '<=':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val > value) ? false : null;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return false;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) return null;
            return true;
    }
};

// Does the new filter constitute a conflict?
tree.Filterset.prototype.conflict = function(filter) {
    var key = filter.key.toString(),
        value = filter.val.toString();

    if (!isNaN(parseFloat(value))) value = parseFloat(value);

    // if (a=b) && (a=c)
    // if (a=b) && (a!=b)
    // or (a!=b) && (a=b)
    if ((filter.op === '=' && this.filters[key + '='] !== undefined &&
        value != this.filters[key + '='].val.toString()) ||
        (filter.op === '!=' && this.filters[key + '='] !== undefined &&
        value == this.filters[key + '='].val.toString()) ||
        (filter.op === '=' && this.filters[key + '!='] !== undefined &&
        value == this.filters[key + '!='].val.toString())) {
        return filter.toString() + ' added to ' + this.toString() + ' produces an invalid filter';
    }

    return false;
};

// Only call this function for filters that have been cleared by .addable().
tree.Filterset.prototype.add = function(filter, env) {
    var key = filter.key.toString(),
        id,
        op = filter.op,
        conflict = this.conflict(filter),
        numval;

    if (conflict) return conflict;

    if (op === '=') {
        for (var i in this.filters) {
            if (this.filters[i].key == key) delete this.filters[i];
        }
        this.filters[key + '='] = filter;
    } else if (op === '!=') {
        this.filters[key + '!=' + filter.val] = filter;
    } else if (op === '=~') {
        this.filters[key + '=~' + filter.val] = filter;
    } else if (op === '>') {
        // If there are other filters that are also >
        // but are less than this one, they don't matter, so
        // remove them.
        for (var j in this.filters) {
            if (this.filters[j].key == key && this.filters[j].val <= filter.val) {
                delete this.filters[j];
            }
        }
        this.filters[key + '>'] = filter;
    } else if (op === '>=') {
        for (var k in this.filters) {
            numval = (+this.filters[k].val.toString());
            if (this.filters[k].key == key && numval < filter.val) {
                delete this.filters[k];
            }
        }
        if (this.filters[key + '!=' + filter.val] !== undefined) {
            delete this.filters[key + '!=' + filter.val];
            filter.op = '>';
            this.filters[key + '>'] = filter;
        }
        else {
            this.filters[key + '>='] = filter;
        }
    } else if (op === '<') {
        for (var l in this.filters) {
            numval = (+this.filters[l].val.toString());
            if (this.filters[l].key == key && numval >= filter.val) {
                delete this.filters[l];
            }
        }
        this.filters[key + '<'] = filter;
    } else if (op === '<=') {
        for (var m in this.filters) {
            numval = (+this.filters[m].val.toString());
            if (this.filters[m].key == key && numval > filter.val) {
                delete this.filters[m];
            }
        }
        if (this.filters[key + '!=' + filter.val] !== undefined) {
            delete this.filters[key + '!=' + filter.val];
            filter.op = '<';
            this.filters[key + '<'] = filter;
        }
        else {
            this.filters[key + '<='] = filter;
        }
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":50,"underscore":80}],61:[function(require,module,exports){
(function(tree) {

tree._getFontSet = function(env, fonts) {
    var fontKey = fonts.join('');
    if (env._fontMap && env._fontMap[fontKey]) {
        return env._fontMap[fontKey];
    }

    var new_fontset = new tree.FontSet(env, fonts);
    env.effects.push(new_fontset);
    if (!env._fontMap) env._fontMap = {};
    env._fontMap[fontKey] = new_fontset;
    return new_fontset;
};

tree.FontSet = function FontSet(env, fonts) {
    this.fonts = fonts;
    this.name = 'fontset-' + env.effects.length;
};

tree.FontSet.prototype.toXML = function(env) {
    return '<FontSet name="' +
        this.name +
        '">\n' +
        this.fonts.map(function(f) {
            return '  <Font face-name="' + f +'"/>';
        }).join('\n') +
        '\n</FontSet>';
};

})(require('../tree'));

},{"../tree":50}],62:[function(require,module,exports){
var tree = require('../tree');

// Storage for Frame offset value
// and stores them as bit-sequences so that they can be combined,
// inverted, and compared quickly.
tree.FrameOffset = function(op, value, index) {
    value = parseInt(value, 10);
    if (value > tree.FrameOffset.max || value <= 0) {
        throw {
            message: 'Only frame-offset levels between 1 and ' +
                tree.FrameOffset.max + ' supported.',
            index: index
        };
    }

    if (op !== '=') {
        throw {
            message: 'only = operator is supported for frame-offset',
            index: index
        };
    }
    return value;
};

tree.FrameOffset.max = 32;
tree.FrameOffset.none = 0;


},{"../tree":50}],63:[function(require,module,exports){
(function(tree) {

tree.ImageFilter = function ImageFilter(filter, args) {
    this.filter = filter;
    this.args = args || null;
};

tree.ImageFilter.prototype = {
    is: 'imagefilter',
    ev: function() { return this; },

    toString: function() {
        if (this.args) {
            return this.filter + '(' + this.args.join(',') + ')';
        } else {
            return this.filter;
        }
    }
};


})(require('../tree'));

},{"../tree":50}],64:[function(require,module,exports){
(function (tree) {
tree.Invalid = function Invalid(chunk, index, message) {
    this.chunk = chunk;
    this.index = index;
    this.type = 'syntax';
    this.message = message || "Invalid code: " + this.chunk;
};

tree.Invalid.prototype.is = 'invalid';

tree.Invalid.prototype.ev = function(env) {
    env.error({
        chunk: this.chunk,
        index: this.index,
        type: 'syntax',
        message: this.message || "Invalid code: " + this.chunk
    });
    return {
        is: 'undefined'
    };
};
})(require('../tree'));

},{"../tree":50}],65:[function(require,module,exports){
(function(tree) {

tree.Keyword = function Keyword(value) {
    this.value = value;
    var special = {
        'transparent': 'color',
        'true': 'boolean',
        'false': 'boolean'
    };
    this.is = special[value] ? special[value] : 'keyword';
};
tree.Keyword.prototype = {
    ev: function() { return this; },
    toString: function() { return this.value; }
};

})(require('../tree'));

},{"../tree":50}],66:[function(require,module,exports){
(function(tree) {

tree.LayerXML = function(obj, styles) {
    var dsoptions = [];
    for (var i in obj.Datasource) {
        dsoptions.push('<Parameter name="' + i + '"><![CDATA[' +
            obj.Datasource[i] + ']]></Parameter>');
    }

    var prop_string = '';
    for (var prop in obj.properties) {
        if (prop === 'minzoom') {
            prop_string += '  maxzoom="' + tree.Zoom.ranges[obj.properties[prop]] + '"\n';
        } else if (prop === 'maxzoom') {
            prop_string += '  minzoom="' + tree.Zoom.ranges[obj.properties[prop]+1] + '"\n';
        } else {
            prop_string += '  ' + prop + '="' + obj.properties[prop] + '"\n';
        }
    }

    return '<Layer' +
        ' name="' + obj.name + '"\n' +
        prop_string +
        ((typeof obj.status === 'undefined') ? '' : '  status="' + obj.status + '"\n') +
        ((typeof obj.srs === 'undefined') ? '' : '  srs="' + obj.srs + '"') + '>\n    ' +
        styles.reverse().map(function(s) {
            return '<StyleName>' + s + '</StyleName>';
        }).join('\n    ') +
        (dsoptions.length ?
        '\n    <Datasource>\n       ' +
        dsoptions.join('\n       ') +
        '\n    </Datasource>\n'
        : '') +
        '  </Layer>\n';
};

})(require('../tree'));

},{"../tree":50}],67:[function(require,module,exports){
// A literal is a literal string for Mapnik - the
// result of the combination of a `tree.Field` with any
// other type.
(function(tree) {

tree.Literal = function Field(content) {
    this.value = content || '';
    this.is = 'field';
};

tree.Literal.prototype = {
    toString: function() {
        return this.value;
    },
    'ev': function() {
        return this;
    }
};

})(require('../tree'));

},{"../tree":50}],68:[function(require,module,exports){
// An operation is an expression with an op in between two operands,
// like 2 + 1.
(function(tree) {

tree.Operation = function Operation(op, operands, index) {
    this.op = op.trim();
    this.operands = operands;
    this.index = index;
};

tree.Operation.prototype.is = 'operation';

tree.Operation.prototype.ev = function(env) {
    var a = this.operands[0].ev(env),
        b = this.operands[1].ev(env),
        temp;

    if (a.is === 'undefined' || b.is === 'undefined') {
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    if (a instanceof tree.Dimension && b instanceof tree.Color) {
        if (this.op === '*' || this.op === '+') {
            temp = b, b = a, a = temp;
        } else {
            env.error({
                name: "OperationError",
                message: "Can't substract or divide a color from a number",
                index: this.index
            });
        }
    }

    // Only concatenate plain strings, because this is easily
    // pre-processed
    if (a instanceof tree.Quoted && b instanceof tree.Quoted && this.op !== '+') {
        env.error({
           message: "Can't subtract, divide, or multiply strings.",
           index: this.index,
           type: 'runtime',
           filename: this.filename
        });
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    // Fields, literals, dimensions, and quoted strings can be combined.
    if (a instanceof tree.Field || b instanceof tree.Field ||
        a instanceof tree.Literal || b instanceof tree.Literal) {
        if (a.is === 'color' || b.is === 'color') {
            env.error({
               message: "Can't subtract, divide, or multiply colors in expressions.",
               index: this.index,
               type: 'runtime',
               filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        } else {
            return new tree.Literal(a.ev(env).toString(true) + this.op + b.ev(env).toString(true));
        }
    }

    if (a.operate === undefined) {
        env.error({
           message: 'Cannot do math with type ' + a.is + '.',
           index: this.index,
           type: 'runtime',
           filename: this.filename
        });
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    return a.operate(env, this.op, b);
};

tree.operate = function(op, a, b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '%': return a % b;
        case '/': return a / b;
    }
};

})(require('../tree'));

},{"../tree":50}],69:[function(require,module,exports){
(function(tree) {

tree.Quoted = function Quoted(content) {
    this.value = content || '';
};

tree.Quoted.prototype = {
    is: 'string',

    toString: function(quotes) {
        var escapedValue = this.value
            .replace(/&/g, '&amp;')
        var xmlvalue = escapedValue
            .replace(/\'/g, '\\\'')
            .replace(/\"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/\>/g, '&gt;');
        return (quotes === true) ? "'" + xmlvalue + "'" : escapedValue;
    },

    'ev': function() {
        return this;
    },

    operate: function(env, op, other) {
        return new tree.Quoted(tree.operate(op, this.toString(), other.toString(this.contains_field)));
    }
};

})(require('../tree'));

},{"../tree":50}],70:[function(require,module,exports){
(function (global){
// Carto pulls in a reference from the `mapnik-reference`
// module. This file builds indexes from that file for its various
// options, and provides validation methods for property: value
// combinations.
(function(tree) {

var _ = global._ || require('underscore'),
    ref = {};

ref.setData = function(data) {
    ref.data = data;
    ref.selector_cache = generateSelectorCache(data);
    ref.mapnikFunctions = generateMapnikFunctions(data);

    ref.mapnikFunctions.matrix = [6];
    ref.mapnikFunctions.translate = [1, 2];
    ref.mapnikFunctions.scale = [1, 2];
    ref.mapnikFunctions.rotate = [1, 3];
    ref.mapnikFunctions.skewX = [1];
    ref.mapnikFunctions.skewY = [1];

    ref.required_cache = generateRequiredProperties(data);
};

ref.setVersion = function(version) {
    var mapnik_reference = require('mapnik-reference');
    if (mapnik_reference.version.hasOwnProperty(version)) {
        ref.setData(mapnik_reference.version[version]);
        return true;
    } else {
        return false;
    }
};

ref.selectorData = function(selector, i) {
    if (ref.selector_cache[selector]) return ref.selector_cache[selector][i];
};

ref.validSelector = function(selector) { return !!ref.selector_cache[selector]; };
ref.selectorName = function(selector) { return ref.selectorData(selector, 2); };
ref.selector = function(selector) { return ref.selectorData(selector, 0); };
ref.symbolizer = function(selector) { return ref.selectorData(selector, 1); };

function generateSelectorCache(data) {
    var index = {};
    for (var i in data.symbolizers) {
        for (var j in data.symbolizers[i]) {
            if (data.symbolizers[i][j].hasOwnProperty('css')) {
                index[data.symbolizers[i][j].css] = [data.symbolizers[i][j], i, j];
            }
        }
    }
    return index;
}

function generateMapnikFunctions(data) {
    var functions = {};
    for (var i in data.symbolizers) {
        for (var j in data.symbolizers[i]) {
            if (data.symbolizers[i][j].type === 'functions') {
                for (var k = 0; k < data.symbolizers[i][j].functions.length; k++) {
                    var fn = data.symbolizers[i][j].functions[k];
                    functions[fn[0]] = fn[1];
                }
            }
        }
    }
    return functions;
}

function generateRequiredProperties(data) {
    var cache = {};
    for (var symbolizer_name in data.symbolizers) {
        cache[symbolizer_name] = [];
        for (var j in data.symbolizers[symbolizer_name]) {
            if (data.symbolizers[symbolizer_name][j].required) {
                cache[symbolizer_name].push(data.symbolizers[symbolizer_name][j].css);
            }
        }
    }
    return cache;
}

ref.requiredProperties = function(symbolizer_name, rules) {
    var req = ref.required_cache[symbolizer_name];
    for (var i in req) {
        if (!(req[i] in rules)) {
            return 'Property ' + req[i] + ' required for defining ' +
                symbolizer_name + ' styles.';
        }
    }
};

// TODO: finish implementation - this is dead code
ref._validateValue = {
    'font': function(env, value) {
        if (env.validation_data && env.validation_data.fonts) {
            return env.validation_data.fonts.indexOf(value) != -1;
        } else {
            return true;
        }
    }
};

ref.isFont = function(selector) {
    return ref.selector(selector).validate == 'font';
};

// https://gist.github.com/982927
ref.editDistance = function(a, b){
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    var matrix = [];
    for (var i = 0; i <= b.length; i++) { matrix[i] = [i]; }
    for (var j = 0; j <= a.length; j++) { matrix[0][j] = j; }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i-1) == a.charAt(j-1)) {
                matrix[i][j] = matrix[i-1][j-1];
            } else {
                matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution
                    Math.min(matrix[i][j-1] + 1, // insertion
                    matrix[i-1][j] + 1)); // deletion
            }
        }
    }
    return matrix[b.length][a.length];
};

function validateFunctions(value, selector) {
    if (value.value[0].is === 'string') return true;
    for (var i in value.value) {
        for (var j in value.value[i].value) {
            if (value.value[i].value[j].is !== 'call') return false;
            var f = _.find(ref
                .selector(selector).functions, function(x) {
                    return x[0] == value.value[i].value[j].name;
                });
            if (!(f && f[1] == -1)) {
                // This filter is unknown or given an incorrect number of arguments
                if (!f || f[1] !== value.value[i].value[j].args.length) return false;
            }
        }
    }
    return true;
}

function validateKeyword(value, selector) {
    if (typeof ref.selector(selector).type === 'object') {
        return ref.selector(selector).type
            .indexOf(value.value[0].value) !== -1;
    } else {
        // allow unquoted keywords as strings
        return ref.selector(selector).type === 'string';
    }
}

ref.validValue = function(env, selector, value) {
    var i, j;
    // TODO: handle in reusable way
    if (!ref.selector(selector)) {
        return false;
    } else if (value.value[0].is == 'keyword') {
        return validateKeyword(value, selector);
    } else if (value.value[0].is == 'undefined') {
        // caught earlier in the chain - ignore here so that
        // error is not overridden
        return true;
    } else if (ref.selector(selector).type == 'numbers') {
        for (i in value.value) {
            if (value.value[i].is !== 'float') {
                return false;
            }
        }
        return true;
    } else if (ref.selector(selector).type == 'tags') {
        if (!value.value) return false;
        if (!value.value[0].value) {
            return value.value[0].is === 'tag';
        }
        for (i = 0; i < value.value[0].value.length; i++) {
            if (value.value[0].value[i].is !== 'tag') return false;
        }
        return true;
    } else if (ref.selector(selector).type == 'functions') {
        // For backwards compatibility, you can specify a string for `functions`-compatible
        // values, though they will not be validated.
        return validateFunctions(value, selector);
    } else if (ref.selector(selector).type === 'unsigned') {
        if (value.value[0].is === 'float') {
            value.value[0].round();
            return true;
        } else {
            return false;
        }
    } else if ((ref.selector(selector).expression)) {
        return true;
    } else {
        if (ref.selector(selector).validate) {
            var valid = false;
            for (i = 0; i < value.value.length; i++) {
                if (ref.selector(selector).type == value.value[i].is &&
                    ref
                        ._validateValue
                            [ref.selector(selector).validate]
                            (env, value.value[i].value)) {
                    return true;
                }
            }
            return valid;
        } else {
            return ref.selector(selector).type == value.value[0].is;
        }
    }
};

tree.Reference = ref;

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":50,"mapnik-reference":79,"underscore":80}],71:[function(require,module,exports){
(function(tree) {
// a rule is a single property and value combination, or variable
// name and value combination, like
// polygon-opacity: 1.0; or @opacity: 1.0;
tree.Rule = function Rule(name, value, index, filename) {
    var parts = name.split('/');
    this.name = parts.pop();
    this.instance = parts.length ? parts[0] : '__default__';
    this.value = (value instanceof tree.Value) ?
        value : new tree.Value([value]);
    this.index = index;
    this.symbolizer = tree.Reference.symbolizer(this.name);
    this.filename = filename;
    this.variable = (name.charAt(0) === '@');
};

tree.Rule.prototype.is = 'rule';

tree.Rule.prototype.clone = function() {
    var clone = Object.create(tree.Rule.prototype);
    clone.name = this.name;
    clone.value = this.value;
    clone.index = this.index;
    clone.instance = this.instance;
    clone.symbolizer = this.symbolizer;
    clone.filename = this.filename;
    clone.variable = this.variable;
    return clone;
};

tree.Rule.prototype.updateID = function() {
    return this.id = this.zoom + '#' + this.instance + '#' + this.name;
};

tree.Rule.prototype.toString = function() {
    return '[' + tree.Zoom.toString(this.zoom) + '] ' + this.name + ': ' + this.value;
};

function getMean(name) {
    return Object.keys(tree.Reference.selector_cache).map(function(f) {
        return [f, tree.Reference.editDistance(name, f)];
    }).sort(function(a, b) { return a[1] - b[1]; });
}

// second argument, if true, outputs the value of this
// rule without the usual attribute="content" wrapping. Right
// now this is just for the TextSymbolizer, but applies to other
// properties in reference.json which specify serialization=content
tree.Rule.prototype.toXML = function(env, content, sep, format) {
    if (!tree.Reference.validSelector(this.name)) {
        var mean = getMean(this.name);
        var mean_message = '';
        if (mean[0][1] < 3) {
            mean_message = '. Did you mean ' + mean[0][0] + '?';
        }
        return env.error({
            message: "Unrecognized rule: " + this.name + mean_message,
            index: this.index,
            type: 'syntax',
            filename: this.filename
        });
    }

    if ((this.value instanceof tree.Value) &&
        !tree.Reference.validValue(env, this.name, this.value)) {
        if (!tree.Reference.selector(this.name)) {
            return env.error({
                message: 'Unrecognized property: ' +
                    this.name,
                index: this.index,
                type: 'syntax',
                filename: this.filename
            });
        } else {
            var typename;
            if (tree.Reference.selector(this.name).validate) {
                typename = tree.Reference.selector(this.name).validate;
            } else if (typeof tree.Reference.selector(this.name).type === 'object') {
                typename = 'keyword (options: ' + tree.Reference.selector(this.name).type.join(', ') + ')';
            } else {
                typename = tree.Reference.selector(this.name).type;
            }
            return env.error({
                message: 'Invalid value for ' +
                    this.name +
                    ', the type ' + typename +
                    ' is expected. ' + this.value +
                    ' (of type ' + this.value.value[0].is + ') ' +
                    ' was given.',
                index: this.index,
                type: 'syntax',
                filename: this.filename
            });
        }
    }

    if (this.variable) {
        return '';
    } else if (tree.Reference.isFont(this.name) && this.value.value.length > 1) {
        var f = tree._getFontSet(env, this.value.value);
        return 'fontset-name="' + f.name + '"';
    } else if (content) {
        return this.value.toString(env, this.name, sep);
    } else {
        return tree.Reference.selectorName(this.name) +
            '="' +
            this.value.toString(env, this.name) +
            '"';
    }
};

// TODO: Rule ev chain should add fontsets to env.frames
tree.Rule.prototype.ev = function(context) {
    return new tree.Rule(this.name,
        this.value.ev(context),
        this.index,
        this.filename);
};

})(require('../tree'));

},{"../tree":50}],72:[function(require,module,exports){
(function(tree) {

tree.Ruleset = function Ruleset(selectors, rules) {
    this.selectors = selectors;
    this.rules = rules;
    // static cache of find() function
    this._lookups = {};
};
tree.Ruleset.prototype = {
    is: 'ruleset',
    'ev': function(env) {
        var i,
            ruleset = new tree.Ruleset(this.selectors, this.rules.slice(0));
        ruleset.root = this.root;

        // push the current ruleset to the frames stack
        env.frames.unshift(ruleset);

        // Evaluate everything else
        for (i = 0, rule; i < ruleset.rules.length; i++) {
            rule = ruleset.rules[i];
            ruleset.rules[i] = rule.ev ? rule.ev(env) : rule;
        }

        // Pop the stack
        env.frames.shift();

        return ruleset;
    },
    match: function(args) {
        return !args || args.length === 0;
    },
    variables: function() {
        if (this._variables) { return this._variables; }
        else {
            return this._variables = this.rules.reduce(function(hash, r) {
                if (r instanceof tree.Rule && r.variable === true) {
                    hash[r.name] = r;
                }
                return hash;
            }, {});
        }
    },
    variable: function(name) {
        return this.variables()[name];
    },
    rulesets: function() {
        if (this._rulesets) { return this._rulesets; }
        else {
            return this._rulesets = this.rules.filter(function(r) {
                return (r instanceof tree.Ruleset);
            });
        }
    },
    find: function(selector, self) {
        self = self || this;
        var rules = [], rule, match,
            key = selector.toString();

        if (key in this._lookups) { return this._lookups[key]; }

        this.rulesets().forEach(function(rule) {
            if (rule !== self) {
                for (var j = 0; j < rule.selectors.length; j++) {
                    match = selector.match(rule.selectors[j]);
                    if (match) {
                        if (selector.elements.length > 1) {
                            Array.prototype.push.apply(rules, rule.find(
                                new tree.Selector(null, null, null, selector.elements.slice(1)), self));
                        } else {
                            rules.push(rule);
                        }
                        break;
                    }
                }
            }
        });
        return this._lookups[key] = rules;
    },
    // Zooms can use variables. This replaces tree.Zoom objects on selectors
    // with simple bit-arrays that we can compare easily.
    evZooms: function(env) {
        for (var i = 0; i < this.selectors.length; i++) {
            var zval = tree.Zoom.all;
            for (var z = 0; z < this.selectors[i].zoom.length; z++) {
                zval = zval & this.selectors[i].zoom[z].ev(env).zoom;
            }
            this.selectors[i].zoom = zval;
        }
    },
    flatten: function(result, parents, env) {
        var selectors = [], i, j;
        if (this.selectors.length === 0) {
            env.frames = env.frames.concat(this.rules);
        }
        // evaluate zoom variables on this object.
        this.evZooms(env);
        for (i = 0; i < this.selectors.length; i++) {
            var child = this.selectors[i];

            if (!child.filters) {
                // TODO: is this internal inconsistency?
                // This is an invalid filterset.
                continue;
            }

            if (parents.length) {
                for (j = 0; j < parents.length; j++) {
                    var parent = parents[j];

                    var mergedFilters = parent.filters.cloneWith(child.filters);
                    if (mergedFilters === null) {
                        // Filters could be added, but they didn't change the
                        // filters. This means that we only have to clone when
                        // the zoom levels or the attachment is different too.
                        if (parent.zoom === (parent.zoom & child.zoom) &&
                            parent.frame_offset === child.frame_offset &&
                            parent.attachment === child.attachment &&
                            parent.elements.join() === child.elements.join()) {
                            selectors.push(parent);
                            continue;
                        } else {
                            mergedFilters = parent.filters;
                        }
                    } else if (!mergedFilters) {
                        // The merged filters are invalid, that means we don't
                        // have to clone.
                        continue;
                    }

                    var clone = Object.create(tree.Selector.prototype);
                    clone.filters = mergedFilters;
                    clone.zoom = parent.zoom & child.zoom;
                    clone.frame_offset = child.frame_offset;
                    clone.elements = parent.elements.concat(child.elements);
                    if (parent.attachment && child.attachment) {
                        clone.attachment = parent.attachment + '/' + child.attachment;
                    }
                    else clone.attachment = child.attachment || parent.attachment;
                    clone.conditions = parent.conditions + child.conditions;
                    clone.index = child.index;
                    selectors.push(clone);
                }
            } else {
                selectors.push(child);
            }
        }

        var rules = [];
        for (i = 0; i < this.rules.length; i++) {
            var rule = this.rules[i];

            // Recursively flatten any nested rulesets
            if (rule instanceof tree.Ruleset) {
                rule.flatten(result, selectors, env);
            } else if (rule instanceof tree.Rule) {
                rules.push(rule);
            } else if (rule instanceof tree.Invalid) {
                env.error(rule);
            }
        }

        var index = rules.length ? rules[0].index : false;
        for (i = 0; i < selectors.length; i++) {
            // For specificity sort, use the position of the first rule to allow
            // defining attachments that are under current element as a descendant
            // selector.
            if (index !== false) {
                selectors[i].index = index;
            }
            result.push(new tree.Definition(selectors[i], rules.slice()));
        }

        return result;
    }
};
})(require('../tree'));

},{"../tree":50}],73:[function(require,module,exports){
(function(tree) {

tree.Selector = function Selector(filters, zoom, frame_offset, elements, attachment, conditions, index) {
    this.elements = elements || [];
    this.attachment = attachment;
    this.filters = filters || {};
    this.frame_offset = frame_offset;
    this.zoom = typeof zoom !== 'undefined' ? zoom : tree.Zoom.all;
    this.conditions = conditions;
    this.index = index;
};

// Determine the specificity of this selector
// based on the specificity of its elements - calling
// Element.specificity() in order to do so
//
// [ID, Class, Filters, Position in document]
tree.Selector.prototype.specificity = function() {
    return this.elements.reduce(function(memo, e) {
        var spec = e.specificity();
        memo[0] += spec[0];
        memo[1] += spec[1];
        return memo;
    }, [0, 0, this.conditions, this.index]);
};

})(require('../tree'));

},{"../tree":50}],74:[function(require,module,exports){
(function (global){
(function(tree) {
var _ = global._ || require('underscore');

// Given a style's name, attachment, definitions, and an environment object,
// return a stringified style for Mapnik
tree.StyleXML = function(name, attachment, definitions, env) {
    var existing = {};
    var image_filters = [], image_filters_inflate = [], direct_image_filters = [], comp_op = [], opacity = [];

    for (var i = 0; i < definitions.length; i++) {
        for (var j = 0; j < definitions[i].rules.length; j++) {
            if (definitions[i].rules[j].name === 'image-filters') {
                image_filters.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'image-filters-inflate') {
                image_filters_inflate.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'direct-image-filters') {
                direct_image_filters.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'comp-op') {
                comp_op.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'opacity') {
                opacity.push(definitions[i].rules[j]);
            }
        }
    }

    var rules = definitions.map(function(definition) {
        return definition.toXML(env, existing);
    });

    var attrs_xml = '';

    if (image_filters.length) {
        attrs_xml += ' image-filters="' + _.chain(image_filters)
            // prevent identical filters from being duplicated in the style
            .uniq(function(i) { return i.id; }).map(function(f) {
            return f.ev(env).toXML(env, true, ',', 'image-filter');
        }).value().join(',') + '"';
    }

    if (image_filters_inflate.length) {
        attrs_xml += ' image-filters-inflate="' + image_filters_inflate[0].value.ev(env).toString() + '"';
    }

    if (direct_image_filters.length) {
        attrs_xml += ' direct-image-filters="' + _.chain(direct_image_filters)
            // prevent identical filters from being duplicated in the style
            .uniq(function(i) { return i.id; }).map(function(f) {
            return f.ev(env).toXML(env, true, ',', 'direct-image-filter');
        }).value().join(',') + '"';
    }

    if (comp_op.length && comp_op[0].value.ev(env).value != 'src-over') {
        attrs_xml += ' comp-op="' + comp_op[0].value.ev(env).toString() + '"';
    }

    if (opacity.length && opacity[0].value.ev(env).value != 1) {
        attrs_xml += ' opacity="' + opacity[0].value.ev(env).toString() + '"';
    }
    var rule_string = rules.join('');
    if (!attrs_xml && !rule_string) return '';
    return '<Style name="' + name + '" filter-mode="first"' + attrs_xml + '>\n' + rule_string + '</Style>';
};

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":50,"underscore":80}],75:[function(require,module,exports){
(function(tree) {

tree.URL = function URL(val, paths) {
    this.value = val;
    this.paths = paths;
};

tree.URL.prototype = {
    is: 'uri',
    toString: function() {
        return this.value.toString();
    },
    ev: function(ctx) {
        return new tree.URL(this.value.ev(ctx), this.paths);
    }
};

})(require('../tree'));

},{"../tree":50}],76:[function(require,module,exports){
(function(tree) {

tree.Value = function Value(value) {
    this.value = value;
};

tree.Value.prototype = {
    is: 'value',
    ev: function(env) {
        if (this.value.length === 1) {
            return this.value[0].ev(env);
        } else {
            return new tree.Value(this.value.map(function(v) {
                return v.ev(env);
            }));
        }
    },
    toString: function(env, selector, sep, format) {
        return this.value.map(function(e) {
            return e.toString(env, format);
        }).join(sep || ', ');
    },
    clone: function() {
        var obj = Object.create(tree.Value.prototype);
        if (Array.isArray(obj)) obj.value = this.value.slice();
        else obj.value = this.value;
        obj.is = this.is;
        return obj;
    },

    toJS: function(env) {
      //var v = this.value[0].value[0];
      var val = this.ev(env);
      var v = val.toString();
      if(val.is === "color" || val.is === 'uri' || val.is === 'string' || val.is === 'keyword') {
        v = "'" + v + "'";
      } else if (val.is === 'field') {
        // replace [variable] by ctx['variable']
        v = v.replace(/\[(.*)\]/g, "data['$1']");
      }else if (val.is === 'call') {
        v = JSON.stringify({
            name: val.name,
            args: val.args
        })
      }
      return "_value = " + v + ";";
    }

};

})(require('../tree'));

},{"../tree":50}],77:[function(require,module,exports){
(function(tree) {

tree.Variable = function Variable(name, index, filename) {
    this.name = name;
    this.index = index;
    this.filename = filename;
};

tree.Variable.prototype = {
    is: 'variable',
    toString: function() {
        return this.name;
    },
    ev: function(env) {
        var variable,
            v,
            name = this.name;

        if (this._css) return this._css;

        var thisframe = env.frames.filter(function(f) {
            return f.name == this.name;
        }.bind(this));
        if (thisframe.length) {
            return thisframe[0].value.ev(env);
        } else {
            env.error({
                message: 'variable ' + this.name + ' is undefined',
                index: this.index,
                type: 'runtime',
                filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }
    }
};

})(require('../tree'));

},{"../tree":50}],78:[function(require,module,exports){
var tree = require('../tree');

// Storage for zoom ranges. Only supports continuous ranges,
// and stores them as bit-sequences so that they can be combined,
// inverted, and compared quickly.
tree.Zoom = function(op, value, index) {
    this.op = op;
    this.value = value;
    this.index = index;
};

tree.Zoom.prototype.setZoom = function(zoom) {
    this.zoom = zoom;
    return this;
};

tree.Zoom.prototype.ev = function(env) {
    var start = 0,
        end = Infinity,
        value = parseInt(this.value.ev(env).toString(), 10),
        zoom = 0;

    if (value > tree.Zoom.maxZoom || value < 0) {
        env.error({
            message: 'Only zoom levels between 0 and ' +
                tree.Zoom.maxZoom + ' supported.',
            index: this.index
        });
    }

    switch (this.op) {
        case '=':
            this.zoom = 1 << value;
            return this;
        case '>':
            start = value + 1;
            break;
        case '>=':
            start = value;
            break;
        case '<':
            end = value - 1;
            break;
        case '<=':
            end = value;
            break;
    }
    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
        if (i >= start && i <= end) {
            zoom |= (1 << i);
        }
    }
    this.zoom = zoom;
    return this;
};

tree.Zoom.prototype.toString = function() {
    return this.zoom;
};

// Covers all zoomlevels from 0 to 22
tree.Zoom.all = 0x7FFFFF;

tree.Zoom.maxZoom = 22;

tree.Zoom.ranges = {
     0: 1000000000,
     1: 500000000,
     2: 200000000,
     3: 100000000,
     4: 50000000,
     5: 25000000,
     6: 12500000,
     7: 6500000,
     8: 3000000,
     9: 1500000,
    10: 750000,
    11: 400000,
    12: 200000,
    13: 100000,
    14: 50000,
    15: 25000,
    16: 12500,
    17: 5000,
    18: 2500,
    19: 1500,
    20: 750,
    21: 500,
    22: 250,
    23: 100
};

// Only works for single range zooms. `[XXX....XXXXX.........]` is invalid.
tree.Zoom.prototype.toXML = function() {
    var conditions = [];
    if (this.zoom != tree.Zoom.all) {
        var start = null, end = null;
        for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
            if (this.zoom & (1 << i)) {
                if (start === null) start = i;
                end = i;
            }
        }
        if (start > 0) conditions.push('    <MaxScaleDenominator>' +
            tree.Zoom.ranges[start] + '</MaxScaleDenominator>\n');
        if (end < 22) conditions.push('    <MinScaleDenominator>' +
            tree.Zoom.ranges[end + 1] + '</MinScaleDenominator>\n');
    }
    return conditions;
};

tree.Zoom.prototype.toString = function() {
    var str = '';
    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
        str += (this.zoom & (1 << i)) ? 'X' : '.';
    }
    return str;
};

},{"../tree":50}],79:[function(require,module,exports){
(function (__dirname){
var fs = require('fs'),
    path = require('path'),
    existsSync = require('fs').existsSync || require('path').existsSync;

// Load all stated versions into the module exports
module.exports.version = {};

var refs = [
 '2.0.0',
 '2.0.1',
 '2.0.2',
 '2.1.0',
 '2.1.1',
 '2.2.0',
 '2.3.0',
 '3.0.0'
];

refs.map(function(version) {
    module.exports.version[version] = require(path.join(__dirname, version, 'reference.json'));
    var ds_path = path.join(__dirname, version, 'datasources.json');
    if (existsSync(ds_path)) {
        module.exports.version[version].datasources = require(ds_path).datasources;
    }
});

}).call(this,"/../../viz/torque/node_modules/carto/node_modules/mapnik-reference")

},{"fs":2,"path":5}],80:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],81:[function(require,module,exports){
module.exports={
  "name": "carto",
  "version": "0.15.1-cdb1",
  "description": "CartoCSS Stylesheet Compiler",
  "url": "https://github.com/cartodb/carto",
  "repository": {
    "type": "git",
    "url": "http://github.com/cartodb/carto.git"
  },
  "author": {
    "name": "CartoDB",
    "url": "http://cartodb.com/"
  },
  "keywords": [
    "maps",
    "css",
    "stylesheets"
  ],
  "contributors": [
    {
      "name": "Tom MacWright",
      "email": "macwright@gmail.com"
    },
    {
      "name": "Konstantin Käfer"
    },
    {
      "name": "Alexis Sellier",
      "email": "self@cloudhead.net"
    },
    {
      "name": "Raul Ochoa",
      "email": "rochoa@cartodb.com"
    },
    {
      "name": "Javi Santana",
      "email": "jsantana@cartodb.com"
    }
  ],
  "licenses": [
    {
      "type": "Apache"
    }
  ],
  "bin": {
    "carto": "./bin/carto"
  },
  "man": [
    "./man/carto.1"
  ],
  "main": "./lib/carto/index",
  "engines": {
    "node": ">=0.4.x"
  },
  "dependencies": {
    "underscore": "~1.6.0",
    "mapnik-reference": "~6.0.2",
    "optimist": "~0.6.0"
  },
  "devDependencies": {
    "mocha": "1.12.x",
    "jshint": "0.2.x",
    "sax": "0.1.x",
    "istanbul": "~0.2.14",
    "coveralls": "~2.10.1",
    "browserify": "~7.0.0",
    "uglify-js": "1.3.3"
  },
  "scripts": {
    "pretest": "npm install",
    "test": "mocha -R spec",
    "coverage": "istanbul cover ./node_modules/.bin/_mocha && coveralls < ./coverage/lcov.info"
  },
  "readme": "# CartoCSS\n\n[![Build Status](https://secure.travis-ci.org/mapbox/carto.png)](http://travis-ci.org/mapbox/carto)\n\nIs as stylesheet renderer for javascript, It's an evolution of the Mapnik renderer from Mapbox.\nPlease, see original [Mapbox repo](http://github.com/mapbox/carto) for more information and credits\n\n## Quick Start\n\n```javascript\n// shader is a CartoCSS object\n\nvar cartocss = [\n    '#layer {',\n    ' marker-width: [property]',\n    ' marker-fill: red',\n    '}'\n].join('')\nvar shader = new carto.RendererJS().render(cartocss);\nvar layers = shader.getLayers()\nfor (var i = 0; i < layers.length; ++i) {\n    var layer = layers[i];\n    console.log(\"layer name: \", layer.fullName())\n    console.log(\"- frames: \", layer.frames())\n    console.log(\"- attachment: \", layer.attachment())\n\n    var layerShader = layer.getStyle({ property: 1 }, { zoom: 10 })\n    console.log(layerShader['marker-width']) // 1\n    console.log(layerShader['marker-fill']) // #FF0000\n}\n\n```\n\n# API\n\n## RendererJS\n\n### render(cartocss)\n\n## CartoCSS\n\ncompiled cartocss object\n\n### getLayers\n\nreturn the layers, an array of ``CartoCSS.Layer`` object\n\n### getDefault\n\nreturn the default layer (``CartoCSS.Layer``), usually the Map layer\n\n\n### findLayer(where)\n\nfind a layer using where object.\n\n```\nshader.findLayer({ name: 'test' })\n```\n\n## CartoCSS.Layer\n\n### getStyle(props, context)\n\nreturn the evaluated style:\n    - props: object containing properties needed to render the style. If the cartocss style uses\n      some variables they should be passed in this object\n    - context: rendering context variables like ``zoom`` or animation ``frame``\n\n\n\n\n\n\n\n\n\n\n## Reference Documentation\n\n* [mapbox.com/carto](http://mapbox.com/carto/)\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cartodb/carto/issues"
  },
  "homepage": "https://github.com/cartodb/carto",
  "_id": "carto@0.15.1-cdb1",
  "_shasum": "62534c2975cbee073f10c6c14a0c7e889c9469e7",
  "_resolved": "https://github.com/CartoDB/carto/archive/master.tar.gz",
  "_from": "https://github.com/CartoDB/carto/archive/master.tar.gz"
}

},{}]},{},[14])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsInNyYy9nZW8vZ21hcHMvZ21hcHMtbGF5ZXItdmlldy5qcyIsInNyYy9nZW8vZ21hcHMvZ21hcHMtdG9ycXVlLWxheWVyLXZpZXcuanMiLCJzcmMvZ2VvL2xlYWZsZXQvbGVhZmxldC1sYXllci12aWV3LmpzIiwic3JjL2dlby9sZWFmbGV0L2xlYWZsZXQtdG9ycXVlLWxheWVyLmpzIiwic3JjL3RvcnF1ZS5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9hbmltYXRvci1zdGVwcy1yYW5nZS5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9hbmltYXRvci5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9jYXJ0b2Nzc19yZWZlcmVuY2UuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvY29tbW9uLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL2NvcmUuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvZ21hcHMvQ2FudmFzTGF5ZXIuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvZ21hcHMvY2FudmFzX3RpbGVfbGF5ZXIuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvZ21hcHMvZ21hcHNfdGlsZWxvYWRlcl9taXhpbi5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9nbWFwcy9pbmRleC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9nbWFwcy90b3JxdWUuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvaW5kZXguanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvbGVhZmxldC9jYW52YXNfbGF5ZXIuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvbGVhZmxldC9pbmRleC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9sZWFmbGV0L2xlYWZsZXRfdGlsZWxvYWRlcl9taXhpbi5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9sZWFmbGV0L3RvcnF1ZS5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9tYXRoLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL21lcmNhdG9yLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3Byb2ZpbGVyLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3Byb3ZpZGVyL2luZGV4LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3Byb3ZpZGVyL2pzb24uanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvcHJvdmlkZXIvanNvbmFycmF5LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3Byb3ZpZGVyL3RpbGVqc29uLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3Byb3ZpZGVyL3dpbmRzaGFmdC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbGliL3RvcnF1ZS9yZW5kZXJlci9jYXJ0b2Nzc19yZW5kZXIuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvcmVuZGVyZXIvaW5kZXguanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvcmVuZGVyZXIvcG9pbnQuanMiLCIuLi8uLi92aXovdG9ycXVlL2xpYi90b3JxdWUvcmVuZGVyZXIvcmVjdGFuZ2xlLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3JlbmRlcmVyL3RvcnF1ZV9maWx0ZXJzLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9saWIvdG9ycXVlL3JlcXVlc3QuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vZnVuY3Rpb25zLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL2luZGV4LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3BhcnNlci5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by9yZW5kZXJlci5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by9yZW5kZXJlcl9qcy5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90b3JxdWUtcmVmZXJlbmNlLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9jYWxsLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvY29sb3IuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9jb21tZW50LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZGVmaW5pdGlvbi5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2RpbWVuc2lvbi5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2VsZW1lbnQuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9leHByZXNzaW9uLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZmllbGQuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9maWx0ZXIuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9maWx0ZXJzZXQuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9mb250c2V0LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZnJhbWVfb2Zmc2V0LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvaW1hZ2VmaWx0ZXIuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9pbnZhbGlkLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUva2V5d29yZC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2xheWVyLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvbGl0ZXJhbC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL29wZXJhdGlvbi5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3F1b3RlZC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3JlZmVyZW5jZS5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3J1bGUuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9ydWxlc2V0LmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvc2VsZWN0b3IuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9zdHlsZS5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3VybC5qcyIsIi4uLy4uL3Zpei90b3JxdWUvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3ZhbHVlLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvdmFyaWFibGUuanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS96b29tLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vbm9kZV9tb2R1bGVzL21hcG5pay1yZWZlcmVuY2UvaW5kZXguanMiLCIuLi8uLi92aXovdG9ycXVlL25vZGVfbW9kdWxlcy9jYXJ0by9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwiLi4vLi4vdml6L3RvcnF1ZS9ub2RlX21vZHVsZXMvY2FydG8vcGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0MkRBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzd3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeDNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy96Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNhcnRvZGIuanMgdmVyc2lvbjogXG4vLyB1bmNvbXByZXNzZWQgdmVyc2lvbjogY2FydG9kYi5tb2QudG9ycXVlLnVuY29tcHJlc3NlZC5qc1xuLy8gc2hhOiBkMDgyZGZjMzRhNWFkMTVkMmIxNzY5NzA3NTYyY2M4NDM1NDc3ZjhiXG4oZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vICAgICBCYWNrYm9uZS5qcyAxLjIuM1xuXG4vLyAgICAgKGMpIDIwMTAtMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgLy8gV2UgdXNlIGBzZWxmYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICB2YXIgcm9vdCA9ICh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PSBnbG9iYWwgJiYgZ2xvYmFsKTtcblxuICAvLyBTZXQgdXAgQmFja2JvbmUgYXBwcm9wcmlhdGVseSBmb3IgdGhlIGVudmlyb25tZW50LiBTdGFydCB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xuICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICB9KTtcblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksICQ7XG4gICAgdHJ5IHsgJCA9IHJlcXVpcmUoJ2pxdWVyeScpOyB9IGNhdGNoKGUpIHt9XG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIHt9LCByb290Ll8sIChyb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKSk7XG4gIH1cblxufShmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYSBjb21tb24gYXJyYXkgbWV0aG9kIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LiBLZWVwIGluIHN5bmMgd2l0aCBgcGFja2FnZS5qc29uYC5cbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjIuMyc7XG5cbiAgLy8gRm9yIEJhY2tib25lJ3MgcHVycG9zZXMsIGpRdWVyeSwgWmVwdG8sIEVuZGVyLCBvciBNeSBMaWJyYXJ5IChraWRkaW5nKSBvd25zXG4gIC8vIHRoZSBgJGAgdmFyaWFibGUuXG4gIEJhY2tib25lLiQgPSAkO1xuXG4gIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxuICAvLyB0byBpdHMgcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBCYWNrYm9uZSBvYmplY3QuXG4gIEJhY2tib25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSFRUUGAgdG8gc3VwcG9ydCBsZWdhY3kgSFRUUCBzZXJ2ZXJzLiBTZXR0aW5nIHRoaXMgb3B0aW9uXG4gIC8vIHdpbGwgZmFrZSBgXCJQQVRDSFwiYCwgYFwiUFVUXCJgIGFuZCBgXCJERUxFVEVcImAgcmVxdWVzdHMgdmlhIHRoZSBgX21ldGhvZGAgcGFyYW1ldGVyIGFuZFxuICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICBCYWNrYm9uZS5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxuICAvLyBgYXBwbGljYXRpb24vanNvbmAgcmVxdWVzdHMgLi4uIHRoaXMgd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBQcm94eSBCYWNrYm9uZSBjbGFzcyBtZXRob2RzIHRvIFVuZGVyc2NvcmUgZnVuY3Rpb25zLCB3cmFwcGluZyB0aGUgbW9kZWwnc1xuICAvLyBgYXR0cmlidXRlc2Agb2JqZWN0IG9yIGNvbGxlY3Rpb24ncyBgbW9kZWxzYCBhcnJheSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAgLy9cbiAgLy8gY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldCgnYWdlJykgPiAxMCB9KTtcbiAgLy8gY29sbGVjdGlvbi5lYWNoKHRoaXMuYWRkVmlldyk7XG4gIC8vXG4gIC8vIGBGdW5jdGlvbiNhcHBseWAgY2FuIGJlIHNsb3cgc28gd2UgdXNlIHRoZSBtZXRob2QncyBhcmcgY291bnQsIGlmIHdlIGtub3cgaXQuXG4gIHZhciBhZGRNZXRob2QgPSBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBkZWZhdWx0VmFsLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB2YXIgYWRkVW5kZXJzY29yZU1ldGhvZHMgPSBmdW5jdGlvbihDbGFzcywgbWV0aG9kcywgYXR0cmlidXRlKSB7XG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKGxlbmd0aCwgbWV0aG9kKSB7XG4gICAgICBpZiAoX1ttZXRob2RdKSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGFkZE1ldGhvZChsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGBjb2xsZWN0aW9uLnNvcnRCeSgnYXR0cicpYCBhbmQgYGNvbGxlY3Rpb24uZmluZFdoZXJlKHtpZDogMX0pYC5cbiAgdmFyIGNiID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGluc3RhbmNlKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHJldHVybiBpdGVyYXRlZTtcbiAgICBpZiAoXy5pc09iamVjdChpdGVyYXRlZSkgJiYgIWluc3RhbmNlLl9pc01vZGVsKGl0ZXJhdGVlKSkgcmV0dXJuIG1vZGVsTWF0Y2hlcihpdGVyYXRlZSk7XG4gICAgaWYgKF8uaXNTdHJpbmcoaXRlcmF0ZWUpKSByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldChpdGVyYXRlZSk7IH07XG4gICAgcmV0dXJuIGl0ZXJhdGVlO1xuICB9O1xuICB2YXIgbW9kZWxNYXRjaGVyID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGEgY3VzdG9tIGV2ZW50IGNoYW5uZWwuIFlvdSBtYXkgYmluZCBhIGNhbGxiYWNrIHRvIGFuIGV2ZW50IHdpdGggYG9uYCBvclxuICAvLyByZW1vdmUgd2l0aCBgb2ZmYDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHt9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGBcImNoYW5nZSBibHVyXCIsIGNhbGxiYWNrYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50XG4gIC8vIG1hcHMgYHtldmVudDogY2FsbGJhY2t9YCkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG4gICAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdm9pZCAwICYmICdjb250ZXh0JyBpbiBvcHRzICYmIG9wdHMuY29udGV4dCA9PT0gdm9pZCAwKSBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgIGZvciAobmFtZXMgPSBfLmtleXMobmFtZSk7IGkgPCBuYW1lcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzQXBpKGl0ZXJhdGVlLCBldmVudHMsIG5hbWVzW2ldLCBuYW1lW25hbWVzW2ldXSwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICYmIGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcyBieSBkZWxlZ2F0aW5nIHRoZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgZm9yIChuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWVzW2ldLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmFsbHksIHN0YW5kYXJkIGV2ZW50cy5cbiAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgLy8gdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGludGVybmFsT24odGhpcywgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEd1YXJkIHRoZSBgbGlzdGVuaW5nYCBhcmd1bWVudCBmcm9tIHRoZSBwdWJsaWMgQVBJLlxuICB2YXIgaW50ZXJuYWxPbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQsIGxpc3RlbmluZykge1xuICAgIG9iai5fZXZlbnRzID0gZXZlbnRzQXBpKG9uQXBpLCBvYmouX2V2ZW50cyB8fCB7fSwgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgY3R4OiBvYmosXG4gICAgICAgIGxpc3RlbmluZzogbGlzdGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gb2JqLl9saXN0ZW5lcnMgfHwgKG9iai5fbGlzdGVuZXJzID0ge30pO1xuICAgICAgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF0gPSBsaXN0ZW5pbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gLiBUZWxsICp0aGlzKiBvYmplY3QgdG8gbGlzdGVuIHRvXG4gIC8vIGFuIGV2ZW50IGluIGFub3RoZXIgb2JqZWN0Li4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzIGxpc3RlbmluZyB0b1xuICAvLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbiAgRXZlbnRzLmxpc3RlblRvID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGlkID0gb2JqLl9saXN0ZW5JZCB8fCAob2JqLl9saXN0ZW5JZCA9IF8udW5pcXVlSWQoJ2wnKSk7XG4gICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG8gfHwgKHRoaXMuX2xpc3RlbmluZ1RvID0ge30pO1xuICAgIHZhciBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF07XG5cbiAgICAvLyBUaGlzIG9iamVjdCBpcyBub3QgbGlzdGVuaW5nIHRvIGFueSBvdGhlciBldmVudHMgb24gYG9iamAgeWV0LlxuICAgIC8vIFNldHVwIHRoZSBuZWNlc3NhcnkgcmVmZXJlbmNlcyB0byB0cmFjayB0aGUgbGlzdGVuaW5nIGNhbGxiYWNrcy5cbiAgICBpZiAoIWxpc3RlbmluZykge1xuICAgICAgdmFyIHRoaXNJZCA9IHRoaXMuX2xpc3RlbklkIHx8ICh0aGlzLl9saXN0ZW5JZCA9IF8udW5pcXVlSWQoJ2wnKSk7XG4gICAgICBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF0gPSB7b2JqOiBvYmosIG9iaklkOiBpZCwgaWQ6IHRoaXNJZCwgbGlzdGVuaW5nVG86IGxpc3RlbmluZ1RvLCBjb3VudDogMH07XG4gICAgfVxuXG4gICAgLy8gQmluZCBjYWxsYmFja3Mgb24gb2JqLCBhbmQga2VlcCB0cmFjayBvZiB0aGVtIG9uIGxpc3RlbmluZy5cbiAgICBpbnRlcm5hbE9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIHRoaXMsIGxpc3RlbmluZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IGFkZHMgYSBjYWxsYmFjayB0byB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb25BcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV0gfHwgKGV2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBjdHggPSBvcHRpb25zLmN0eCwgbGlzdGVuaW5nID0gb3B0aW9ucy5saXN0ZW5pbmc7XG4gICAgICBpZiAobGlzdGVuaW5nKSBsaXN0ZW5pbmcuY291bnQrKztcblxuICAgICAgaGFuZGxlcnMucHVzaCh7IGNhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IGN0eCwgbGlzdGVuaW5nOiBsaXN0ZW5pbmcgfSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gIEV2ZW50cy5vZmYgPSAgZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzQXBpKG9mZkFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywge1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBsaXN0ZW5lcnM6IHRoaXMuX2xpc3RlbmVyc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRlbGwgdGhpcyBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZWl0aGVyIHNwZWNpZmljIGV2ZW50cyAuLi4gb3JcbiAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgRXZlbnRzLnN0b3BMaXN0ZW5pbmcgPSAgZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvO1xuICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGlkcyA9IG9iaiA/IFtvYmouX2xpc3RlbklkXSA6IF8ua2V5cyhsaXN0ZW5pbmdUbyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkc1tpXV07XG5cbiAgICAgIC8vIElmIGxpc3RlbmluZyBkb2Vzbid0IGV4aXN0LCB0aGlzIG9iamVjdCBpcyBub3QgY3VycmVudGx5XG4gICAgICAvLyBsaXN0ZW5pbmcgdG8gb2JqLiBCcmVhayBvdXQgZWFybHkuXG4gICAgICBpZiAoIWxpc3RlbmluZykgYnJlYWs7XG5cbiAgICAgIGxpc3RlbmluZy5vYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKF8uaXNFbXB0eShsaXN0ZW5pbmdUbykpIHRoaXMuX2xpc3RlbmluZ1RvID0gdm9pZCAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IHJlbW92ZXMgYSBjYWxsYmFjayBmcm9tIHRoZSBgZXZlbnRzYCBvYmplY3QuXG4gIHZhciBvZmZBcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFldmVudHMpIHJldHVybjtcblxuICAgIHZhciBpID0gMCwgbGlzdGVuaW5nO1xuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBsaXN0ZW5lcnMgPSBvcHRpb25zLmxpc3RlbmVycztcblxuICAgIC8vIERlbGV0ZSBhbGwgZXZlbnRzIGxpc3RlbmVycyBhbmQgXCJkcm9wXCIgZXZlbnRzLlxuICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgIHZhciBpZHMgPSBfLmtleXMobGlzdGVuZXJzKTtcbiAgICAgIGZvciAoOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmluZyA9IGxpc3RlbmVyc1tpZHNbaV1dO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5pbmcubGlzdGVuaW5nVG9bbGlzdGVuaW5nLm9iaklkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogXy5rZXlzKGV2ZW50cyk7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuXG4gICAgICAvLyBCYWlsIG91dCBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIHN0b3JlZC5cbiAgICAgIGlmICghaGFuZGxlcnMpIGJyZWFrO1xuXG4gICAgICAvLyBSZXBsYWNlIGV2ZW50cyBpZiB0aGVyZSBhcmUgYW55IHJlbWFpbmluZy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbal07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjayAmJlxuICAgICAgICAgICAgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2suX2NhbGxiYWNrIHx8XG4gICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dCAhPT0gaGFuZGxlci5jb250ZXh0XG4gICAgICAgICkge1xuICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RlbmluZyA9IGhhbmRsZXIubGlzdGVuaW5nO1xuICAgICAgICAgIGlmIChsaXN0ZW5pbmcgJiYgLS1saXN0ZW5pbmcuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbGlzdGVuaW5nLmlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5pbmcubGlzdGVuaW5nVG9bbGlzdGVuaW5nLm9iaklkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRhaWwgZXZlbnQgaWYgdGhlIGxpc3QgaGFzIGFueSBldmVudHMuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGgpIHtcbiAgICAgICAgZXZlbnRzW25hbWVdID0gcmVtYWluaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF8uc2l6ZShldmVudHMpKSByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0cyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuIElmIG11bHRpcGxlIGV2ZW50c1xuICAvLyBhcmUgcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgaGFuZGxlciB3aWxsIGZpcmVcbiAgLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbiAgRXZlbnRzLm9uY2UgPSAgZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5vZmYsIHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIHZvaWQgMCwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uY2VgLlxuICBFdmVudHMubGlzdGVuVG9PbmNlID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5zdG9wTGlzdGVuaW5nLCB0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG4gIH07XG5cbiAgLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbiAgLy8gYG9mZmVyYCB1bmJpbmRzIHRoZSBgb25jZVdyYXBwZXJgIGFmdGVyIGl0IGhhcyBiZWVuIGNhbGxlZC5cbiAgdmFyIG9uY2VNYXAgPSBmdW5jdGlvbihtYXAsIG5hbWUsIGNhbGxiYWNrLCBvZmZlcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIG9uY2UgPSBtYXBbbmFtZV0gPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9mZmVyKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4gIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICBFdmVudHMudHJpZ2dlciA9ICBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2IsIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gVGhlIHByZWZpeCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY2xpZW50IGlkIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgbW9kZWxzIGxvY2FsbHkuXG4gICAgLy8gWW91IG1heSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3JlIGV4cGVyaWVuY2luZyBuYW1lIGNsYXNoZXMgd2l0aCBtb2RlbCBpZHMuXG4gICAgY2lkUHJlZml4OiAnYycsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNwZWNpYWwtY2FzZWQgcHJveHkgdG8gdW5kZXJzY29yZSdzIGBfLm1hdGNoZXNgIG1ldGhvZC5cbiAgICBtYXRjaGVzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuICEhXy5pdGVyYXRlZShhdHRycywgdGhpcykodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QsIGZpcmluZyBgXCJjaGFuZ2VcImAuIFRoaXMgaXNcbiAgICAvLyB0aGUgY29yZSBwcmltaXRpdmUgb3BlcmF0aW9uIG9mIGEgbW9kZWwsIHVwZGF0aW5nIHRoZSBkYXRhIGFuZCBub3RpZnlpbmdcbiAgICAvLyBhbnlvbmUgd2hvIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBpbiBzdGF0ZS4gVGhlIGhlYXJ0IG9mIHRoZSBiZWFzdC5cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdmFyIHVuc2V0ICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgdmFyIHNpbGVudCAgICAgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgIHZhciBjaGFuZ2VzICAgID0gW107XG4gICAgICB2YXIgY2hhbmdpbmcgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICB2YXIgcHJldiAgICA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gRm9yIGVhY2ggYHNldGAgYXR0cmlidXRlLCB1cGRhdGUgb3IgZGVsZXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgY2hhbmdlZFthdHRyXTtcbiAgICAgICAgfVxuICAgICAgICB1bnNldCA/IGRlbGV0ZSBjdXJyZW50W2F0dHJdIDogY3VycmVudFthdHRyXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBgaWRgLlxuICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0KHRoaXMuaWRBdHRyaWJ1dGUpO1xuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRpZmZbYXR0cl07XG4gICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCB2YWwpKSBjb250aW51ZTtcbiAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfLnNpemUoY2hhbmdlZCkgPyBjaGFuZ2VkIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudCB3YXMgZmlyZWQuXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCBhdCB0aGUgdGltZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIsIG1lcmdpbmcgdGhlIHJlc3BvbnNlIHdpdGggdGhlIG1vZGVsJ3NcbiAgICAvLyBsb2NhbCBhdHRyaWJ1dGVzLiBBbnkgY2hhbmdlZCBhdHRyaWJ1dGVzIHdpbGwgdHJpZ2dlciBhIFwiY2hhbmdlXCIgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7cGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKCFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZSwgcGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YWl0ID0gb3B0aW9ucy53YWl0O1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgaWYgKGF0dHJzICYmICF3YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgc2VydmVyLXNpZGUgc2F2ZSwgdGhlIGNsaWVudCBpcyAob3B0aW9uYWxseSlcbiAgICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgc2VydmVyLXNpZGUgc3RhdGUuXG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgLy8gRW5zdXJlIGF0dHJpYnV0ZXMgYXJlIHJlc3RvcmVkIGR1cmluZyBzeW5jaHJvbm91cyBzYXZlcy5cbiAgICAgICAgbW9kZWwuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG9wdGlvbnMucGFyc2UgPyBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSA6IHJlc3A7XG4gICAgICAgIGlmICh3YWl0KSBzZXJ2ZXJBdHRycyA9IF8uZXh0ZW5kKHt9LCBhdHRycywgc2VydmVyQXR0cnMpO1xuICAgICAgICBpZiAoc2VydmVyQXR0cnMgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YCB0byBwcm9wZXJseSBmaW5kIG5ldyBpZHMuXG4gICAgICBpZiAoYXR0cnMgJiYgd2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcblxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJyAmJiAhb3B0aW9ucy5hdHRycykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgdmFyIHhociA9IHRoaXMuc3luYyhtZXRob2QsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBSZXN0b3JlIGF0dHJpYnV0ZXMuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgcmVtb3ZlcyB0aGUgbW9kZWwgZnJvbSBpdHMgY29sbGVjdGlvbiwgaWYgaXQgaGFzIG9uZS5cbiAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHdhaXQpIGRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHhociA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBfLmRlZmVyKG9wdGlvbnMuc3VjY2Vzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIXdhaXQpIGRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxuICAgIC8vIHVzaW5nIEJhY2tib25lJ3MgcmVzdGZ1bCBtZXRob2RzLCBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgY2FsbGVkLlxuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmFzZSA9XG4gICAgICAgIF8ucmVzdWx0KHRoaXMsICd1cmxSb290JykgfHxcbiAgICAgICAgXy5yZXN1bHQodGhpcy5jb2xsZWN0aW9uLCAndXJsJykgfHxcbiAgICAgICAgdXJsRXJyb3IoKTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHJldHVybiBiYXNlO1xuICAgICAgdmFyIGlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmRlZmF1bHRzKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmV4dCBjb21wbGV0ZSBzZXQgb2YgbW9kZWwgYXR0cmlidXRlcyxcbiAgICAvLyByZXR1cm5pbmcgYHRydWVgIGlmIGFsbCBpcyB3ZWxsLiBPdGhlcndpc2UsIGZpcmUgYW4gYFwiaW52YWxpZFwiYCBldmVudC5cbiAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudmFsaWRhdGUgfHwgIXRoaXMudmFsaWRhdGUpIHJldHVybiB0cnVlO1xuICAgICAgYXR0cnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHRoaXMudmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpIHx8IG51bGw7XG4gICAgICBpZiAoIWVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGVycm9yLCBfLmV4dGVuZChvcHRpb25zLCB7dmFsaWRhdGlvbkVycm9yOiBlcnJvcn0pKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLCBtYXBwZWQgdG8gdGhlXG4gIC8vIG51bWJlciBvZiBhcmd1bWVudHMgdGhleSB0YWtlLlxuICB2YXIgbW9kZWxNZXRob2RzID0geyBrZXlzOiAxLCB2YWx1ZXM6IDEsIHBhaXJzOiAxLCBpbnZlcnQ6IDEsIHBpY2s6IDAsXG4gICAgICBvbWl0OiAwLCBjaGFpbjogMSwgaXNFbXB0eTogMSB9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBhZGRVbmRlcnNjb3JlTWV0aG9kcyhNb2RlbCwgbW9kZWxNZXRob2RzLCAnYXR0cmlidXRlcycpO1xuXG4gIC8vIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBCYWNrYm9uZSBDb2xsZWN0aW9uIGlzXG4gIC8vIG1vcmUgYW5hbG9nb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuICAvLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cbiAgLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuICAvLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuICAvLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cblxuICAvLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbiAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4gIC8vIGl0cyBtb2RlbHMgaW4gc29ydCBvcmRlciwgYXMgdGhleSdyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgdmFyIENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG4gIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZX07XG5cbiAgLy8gU3BsaWNlcyBgaW5zZXJ0YCBpbnRvIGBhcnJheWAgYXQgaW5kZXggYGF0YC5cbiAgdmFyIHNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LCBpbnNlcnQsIGF0KSB7XG4gICAgYXQgPSBNYXRoLm1pbihNYXRoLm1heChhdCwgMCksIGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIHRhaWwgPSBBcnJheShhcnJheS5sZW5ndGggLSBhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGluc2VydC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB0YWlsW2ldID0gYXJyYXlbaSArIGF0XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFycmF5W2kgKyBhdF0gPSBpbnNlcnRbaV07XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIGFycmF5W2kgKyBsZW5ndGggKyBhdF0gPSB0YWlsW2ldO1xuICB9O1xuXG4gIC8vIERlZmluZSB0aGUgQ29sbGVjdGlvbidzIGluaGVyaXRhYmxlIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgbW9kZWw6IE1vZGVsLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCkgeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC4gYG1vZGVsc2AgbWF5IGJlIEJhY2tib25lXG4gICAgLy8gTW9kZWxzIG9yIHJhdyBKYXZhU2NyaXB0IG9iamVjdHMgdG8gYmUgY29udmVydGVkIHRvIE1vZGVscywgb3IgYW55XG4gICAgLy8gY29tYmluYXRpb24gb2YgdGhlIHR3by5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xuICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlTW9kZWxzKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50ICYmIHJlbW92ZWQpIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2luZ3VsYXIgPyByZW1vdmVkWzBdIDogcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RlbHMgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0T3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSAmJiAhdGhpcy5faXNNb2RlbChtb2RlbHMpKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBtb2RlbHMuc2xpY2UoKTtcblxuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIGlmIChhdCAhPSBudWxsKSBhdCA9ICthdDtcbiAgICAgIGlmIChhdCA8IDApIGF0ICs9IHRoaXMubGVuZ3RoICsgMTtcblxuICAgICAgdmFyIHNldCA9IFtdO1xuICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgIHZhciBtb2RlbE1hcCA9IHt9O1xuXG4gICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQ7XG4gICAgICB2YXIgbWVyZ2UgPSBvcHRpb25zLm1lcmdlO1xuICAgICAgdmFyIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuXG4gICAgICB2YXIgc29ydCA9IGZhbHNlO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIChhdCA9PSBudWxsKSAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIHZhciBtb2RlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldO1xuXG4gICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KG1vZGVsKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgaWYgKG1lcmdlICYmIG1vZGVsICE9PSBleGlzdGluZykge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5faXNNb2RlbChtb2RlbCkgPyBtb2RlbC5hdHRyaWJ1dGVzIDogbW9kZWw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0KSBzb3J0ID0gZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSkge1xuICAgICAgICAgICAgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChleGlzdGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kZWxNYXBbbW9kZWwuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChtb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBzdGFsZSBtb2RlbHMuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tpXTtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwW21vZGVsLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciByZXBsYWNlID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmU7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCAmJiByZXBsYWNlKSB7XG4gICAgICAgIG9yZGVyQ2hhbmdlZCA9IHRoaXMubGVuZ3RoICE9IHNldC5sZW5ndGggfHwgXy5zb21lKHRoaXMubW9kZWxzLCBmdW5jdGlvbihtb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWwgIT09IHNldFtpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICBzcGxpY2UodGhpcy5tb2RlbHMsIHNldCwgMCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCB0b0FkZCwgYXQgPT0gbnVsbCA/IHRoaXMubGVuZ3RoIDogYXQpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhdCAhPSBudWxsKSBvcHRpb25zLmluZGV4ID0gYXQgKyBpO1xuICAgICAgICAgIG1vZGVsID0gdG9BZGRbaV07XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0IHx8IG9yZGVyQ2hhbmdlZCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgdG9SZW1vdmUubGVuZ3RoKSB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICB1bnNoaWZ0OiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IDB9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBzaGlmdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCgwKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcy5tb2RlbHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhIG1vZGVsIGZyb20gdGhlIHNldCBieSBpZC5cbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKHRoaXMuX2lzTW9kZWwob2JqKSA/IG9iai5hdHRyaWJ1dGVzIDogb2JqKTtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHwgdGhpcy5fYnlJZFtpZF0gfHwgdGhpcy5fYnlJZFtvYmouY2lkXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCArPSB0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBtb2RlbHMgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlcyBvZlxuICAgIC8vIGBmaWx0ZXJgLlxuICAgIHdoZXJlOiBmdW5jdGlvbihhdHRycywgZmlyc3QpIHtcbiAgICAgIHJldHVybiB0aGlzW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKGF0dHJzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuY29tcGFyYXRvcjtcbiAgICAgIGlmICghY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbXBhcmF0b3IubGVuZ3RoO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb21wYXJhdG9yKSkgY29tcGFyYXRvciA9IF8uYmluZChjb21wYXJhdG9yLCB0aGlzKTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAobGVuZ3RoID09PSAxIHx8IF8uaXNTdHJpbmcoY29tcGFyYXRvcikpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeShjb21wYXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kZWxzLnNvcnQoY29tcGFyYXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQbHVjayBhbiBhdHRyaWJ1dGUgZnJvbSBlYWNoIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBsdWNrOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5pbnZva2UodGhpcy5tb2RlbHMsICdnZXQnLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIGRlZmF1bHQgc2V0IG9mIG1vZGVscyBmb3IgdGhpcyBjb2xsZWN0aW9uLCByZXNldHRpbmcgdGhlXG4gICAgLy8gY29sbGVjdGlvbiB3aGVuIHRoZXkgYXJyaXZlLiBJZiBgcmVzZXQ6IHRydWVgIGlzIHBhc3NlZCwgdGhlIHJlc3BvbnNlXG4gICAgLy8gZGF0YSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBgcmVzZXRgIG1ldGhvZCBpbnN0ZWFkIG9mIGBzZXRgLlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3BhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBjb2xsZWN0aW9uLnRyaWdnZXIoJ3N5bmMnLCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIGltbWVkaWF0ZWx5LCB1bmxlc3MgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gICAgY3JlYXRlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcbiAgICAgIG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghd2FpdCkgdGhpcy5hZGQobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihtb2RlbCwgcmVzcCwgY2FsbGJhY2tPcHRzKSB7XG4gICAgICAgIGlmICh3YWl0KSBjb2xsZWN0aW9uLmFkZChtb2RlbCwgY2FsbGJhY2tPcHRzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChjYWxsYmFja09wdHMuY29udGV4dCwgbW9kZWwsIHJlc3AsIGNhbGxiYWNrT3B0cyk7XG4gICAgICB9O1xuICAgICAgbW9kZWwuc2F2ZShudWxsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byBhIGxpc3Qgb2YgbW9kZWxzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyBpdCB0aHJvdWdoLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzLCB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBjb21wYXJhdG9yOiB0aGlzLmNvbXBhcmF0b3JcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEZWZpbmUgaG93IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IG1vZGVscyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBtb2RlbElkOiBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRyc1t0aGlzLm1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gUHJlcGFyZSBhIGhhc2ggb2YgYXR0cmlidXRlcyAob3Igb3RoZXIgbW9kZWwpIHRvIGJlIGFkZGVkIHRvIHRoaXNcbiAgICAvLyBjb2xsZWN0aW9uLlxuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5faXNNb2RlbChhdHRycykpIHtcbiAgICAgICAgaWYgKCFhdHRycy5jb2xsZWN0aW9uKSBhdHRycy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgYnkgYm90aCByZW1vdmUgYW5kIHNldC5cbiAgICBfcmVtb3ZlTW9kZWxzOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcigncmVtb3ZlJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkLmxlbmd0aCA/IHJlbW92ZWQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gTWV0aG9kIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhIG1vZGVsIGZvclxuICAgIC8vIHRoZSBwdXJwb3NlcyBvZiBhZGRpbmcgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgX2lzTW9kZWw6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsIGluc3RhbmNlb2YgTW9kZWw7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9ieUlkW21vZGVsLmNpZF0gPSBtb2RlbDtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX3JlbW92ZVJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbaWRdO1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgICAgIHZhciBwcmV2SWQgPSB0aGlzLm1vZGVsSWQobW9kZWwucHJldmlvdXNBdHRyaWJ1dGVzKCkpO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChwcmV2SWQgIT09IGlkKSB7XG4gICAgICAgICAgaWYgKHByZXZJZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtwcmV2SWRdO1xuICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4gIC8vIHJpZ2h0IGhlcmU6XG4gIHZhciBjb2xsZWN0aW9uTWV0aG9kcyA9IHsgZm9yRWFjaDogMywgZWFjaDogMywgbWFwOiAzLCBjb2xsZWN0OiAzLCByZWR1Y2U6IDQsXG4gICAgICBmb2xkbDogNCwgaW5qZWN0OiA0LCByZWR1Y2VSaWdodDogNCwgZm9sZHI6IDQsIGZpbmQ6IDMsIGRldGVjdDogMywgZmlsdGVyOiAzLFxuICAgICAgc2VsZWN0OiAzLCByZWplY3Q6IDMsIGV2ZXJ5OiAzLCBhbGw6IDMsIHNvbWU6IDMsIGFueTogMywgaW5jbHVkZTogMywgaW5jbHVkZXM6IDMsXG4gICAgICBjb250YWluczogMywgaW52b2tlOiAwLCBtYXg6IDMsIG1pbjogMywgdG9BcnJheTogMSwgc2l6ZTogMSwgZmlyc3Q6IDMsXG4gICAgICBoZWFkOiAzLCB0YWtlOiAzLCBpbml0aWFsOiAzLCByZXN0OiAzLCB0YWlsOiAzLCBkcm9wOiAzLCBsYXN0OiAzLFxuICAgICAgd2l0aG91dDogMCwgZGlmZmVyZW5jZTogMCwgaW5kZXhPZjogMywgc2h1ZmZsZTogMSwgbGFzdEluZGV4T2Y6IDMsXG4gICAgICBpc0VtcHR5OiAxLCBjaGFpbjogMSwgc2FtcGxlOiAzLCBwYXJ0aXRpb246IDMsIGdyb3VwQnk6IDMsIGNvdW50Qnk6IDMsXG4gICAgICBzb3J0Qnk6IDMsIGluZGV4Qnk6IDN9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cbiAgYWRkVW5kZXJzY29yZU1ldGhvZHMoQ29sbGVjdGlvbiwgY29sbGVjdGlvbk1ldGhvZHMsICdtb2RlbHMnKTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIHNldCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIF8uYmluZChtZXRob2QsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogICdQQVRDSCcsXG4gICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxuICAgICdyZWFkJzogICAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgLy8gICAgICAgLi4uXG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkgcm91dGUgPSB0aGlzLl9yb3V0ZVRvUmVnRXhwKHJvdXRlKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB2YXIgcm91dGVyID0gdGhpcztcbiAgICAgIEJhY2tib25lLmhpc3Rvcnkucm91dGUocm91dGUsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAocm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MsIG5hbWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAvLyBleGNlbGxlbnQgcGxhY2UgdG8gZG8gcHJlLXJvdXRlIHNldHVwIG9yIHBvc3Qtcm91dGUgY2xlYW51cC5cbiAgICBleGVjdXRlOiBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgbmFtZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgdGhpcy5jaGVja1VybCA9IF8uYmluZCh0aGlzLmNoZWNrVXJsLCB0aGlzKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxuICB2YXIgcGF0aFN0cmlwcGVyID0gLyMuKiQvO1xuXG4gIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cbiAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLkhpc3RvcnkqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChIaXN0b3J5LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcbiAgICAvLyB0d2VudHkgdGltZXMgYSBzZWNvbmQuXG4gICAgaW50ZXJ2YWw6IDUwLFxuXG4gICAgLy8gQXJlIHdlIGF0IHRoZSBhcHAgcm9vdD9cbiAgICBhdFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJyk7XG4gICAgICByZXR1cm4gcGF0aCA9PT0gdGhpcy5yb290ICYmICF0aGlzLmdldFNlYXJjaCgpO1xuICAgIH0sXG5cbiAgICAvLyBEb2VzIHRoZSBwYXRobmFtZSBtYXRjaCB0aGUgcm9vdD9cbiAgICBtYXRjaFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KHRoaXMubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgdmFyIHJvb3QgPSBwYXRoLnNsaWNlKDAsIHRoaXMucm9vdC5sZW5ndGggLSAxKSArICcvJztcbiAgICAgIHJldHVybiByb290ID09PSB0aGlzLnJvb3Q7XG4gICAgfSxcblxuICAgIC8vIFVuaWNvZGUgY2hhcmFjdGVycyBpbiBgbG9jYXRpb24ucGF0aG5hbWVgIGFyZSBwZXJjZW50IGVuY29kZWQgc28gdGhleSdyZVxuICAgIC8vIGRlY29kZWQgZm9yIGNvbXBhcmlzb24uIGAlMjVgIHNob3VsZCBub3QgYmUgZGVjb2RlZCBzaW5jZSBpdCBtYXkgYmUgcGFydFxuICAgIC8vIG9mIGFuIGVuY29kZWQgcGFyYW1ldGVyLlxuICAgIGRlY29kZUZyYWdtZW50OiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSShmcmFnbWVudC5yZXBsYWNlKC8lMjUvZywgJyUyNTI1JykpO1xuICAgIH0sXG5cbiAgICAvLyBJbiBJRTYsIHRoZSBoYXNoIGZyYWdtZW50IGFuZCBzZWFyY2ggcGFyYW1zIGFyZSBpbmNvcnJlY3QgaWYgdGhlXG4gICAgLy8gZnJhZ21lbnQgY29udGFpbnMgYD9gLlxuICAgIGdldFNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qLywgJycpLm1hdGNoKC9cXD8uKy8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0cyB0aGUgdHJ1ZSBoYXNoIHZhbHVlLiBDYW5ub3QgdXNlIGxvY2F0aW9uLmhhc2ggZGlyZWN0bHkgZHVlIHRvIGJ1Z1xuICAgIC8vIGluIEZpcmVmb3ggd2hlcmUgbG9jYXRpb24uaGFzaCB3aWxsIGFsd2F5cyBiZSBkZWNvZGVkLlxuICAgIGdldEhhc2g6IGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICAgdmFyIG1hdGNoID0gKHdpbmRvdyB8fCB0aGlzKS5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcGF0aG5hbWUgYW5kIHNlYXJjaCBwYXJhbXMsIHdpdGhvdXQgdGhlIHJvb3QuXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZGVjb2RlRnJhZ21lbnQoXG4gICAgICAgIHRoaXMubG9jYXRpb24ucGF0aG5hbWUgKyB0aGlzLmdldFNlYXJjaCgpXG4gICAgICApLnNsaWNlKHRoaXMucm9vdC5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zbGljZSgxKSA6IHBhdGg7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgY3Jvc3MtYnJvd3NlciBub3JtYWxpemVkIFVSTCBmcmFnbWVudCBmcm9tIHRoZSBwYXRoIG9yIGhhc2guXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0UGF0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlKHJvdXRlU3RyaXBwZXIsICcnKTtcbiAgICB9LFxuXG4gICAgLy8gU3RhcnQgdGhlIGhhc2ggY2hhbmdlIGhhbmRsaW5nLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBjdXJyZW50IFVSTCBtYXRjaGVzXG4gICAgLy8gYW4gZXhpc3Rpbmcgcm91dGUsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKEhpc3Rvcnkuc3RhcnRlZCkgdGhyb3cgbmV3IEVycm9yKCdCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uLiBEbyB3ZSBuZWVkIGFuIGlmcmFtZT9cbiAgICAgIC8vIElzIHB1c2hTdGF0ZSBkZXNpcmVkIC4uLiBpcyBpdCBhdmFpbGFibGU/XG4gICAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgPSBfLmV4dGVuZCh7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMucm9vdCAgICAgICAgICAgICA9IHRoaXMub3B0aW9ucy5yb290O1xuICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xuICAgICAgdGhpcy5faGFzSGFzaENoYW5nZSAgID0gJ29uaGFzaGNoYW5nZScgaW4gd2luZG93ICYmIChkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IHZvaWQgMCB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA3KTtcbiAgICAgIHRoaXMuX3VzZUhhc2hDaGFuZ2UgICA9IHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl9oYXNIYXNoQ2hhbmdlO1xuICAgICAgdGhpcy5fd2FudHNQdXNoU3RhdGUgID0gISF0aGlzLm9wdGlvbnMucHVzaFN0YXRlO1xuICAgICAgdGhpcy5faGFzUHVzaFN0YXRlICAgID0gISEodGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgdGhpcy5fdXNlUHVzaFN0YXRlICAgID0gdGhpcy5fd2FudHNQdXNoU3RhdGUgJiYgdGhpcy5faGFzUHVzaFN0YXRlO1xuICAgICAgdGhpcy5mcmFnbWVudCAgICAgICAgID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgcm9vdCB0byBhbHdheXMgaW5jbHVkZSBhIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgdGhpcy5yb290ID0gKCcvJyArIHRoaXMucm9vdCArICcvJykucmVwbGFjZShyb290U3RyaXBwZXIsICcvJyk7XG5cbiAgICAgIC8vIFRyYW5zaXRpb24gZnJvbSBoYXNoQ2hhbmdlIHRvIHB1c2hTdGF0ZSBvciB2aWNlIHZlcnNhIGlmIGJvdGggYXJlXG4gICAgICAvLyByZXF1ZXN0ZWQuXG4gICAgICBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzUHVzaFN0YXRlKSB7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgc3RhcnRlZCBvZmYgd2l0aCBhIHJvdXRlIGZyb20gYSBgcHVzaFN0YXRlYC1lbmFibGVkXG4gICAgICAgIC8vIGJyb3dzZXIsIGJ1dCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0Li4uXG4gICAgICAgIGlmICghdGhpcy5faGFzUHVzaFN0YXRlICYmICF0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2Uocm9vdCArICcjJyArIHRoaXMuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0ZSh0aGlzLmdldEhhc2goKSwge3JlcGxhY2U6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFByb3h5IGFuIGlmcmFtZSB0byBoYW5kbGUgbG9jYXRpb24gZXZlbnRzIGlmIHRoZSBicm93c2VyIGRvZXNuJ3RcbiAgICAgIC8vIHN1cHBvcnQgdGhlIGBoYXNoY2hhbmdlYCBldmVudCwgSFRNTDUgaGlzdG9yeSwgb3IgdGhlIHVzZXIgd2FudHNcbiAgICAgIC8vIGBoYXNoQ2hhbmdlYCBidXQgbm90IGBwdXNoU3RhdGVgLlxuICAgICAgaWYgKCF0aGlzLl9oYXNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiAhdGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIHRoaXMuaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgICAgICB0aGlzLmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIC8vIFVzaW5nIGBhcHBlbmRDaGlsZGAgd2lsbCB0aHJvdyBvbiBJRSA8IDkgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCByZWFkeS5cbiAgICAgICAgdmFyIGlXaW5kb3cgPSBib2R5Lmluc2VydEJlZm9yZSh0aGlzLmlmcmFtZSwgYm9keS5maXJzdENoaWxkKS5jb250ZW50V2luZG93O1xuICAgICAgICBpV2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICBpV2luZG93LmxvY2F0aW9uLmhhc2ggPSAnIycgKyB0aGlzLmZyYWdtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgYWRkRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gRGlzYWJsZSBCYWNrYm9uZS5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXG4gICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBkZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBSZW1vdmUgd2luZG93IGxpc3RlbmVycy5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZUhhc2hDaGFuZ2UgJiYgIXRoaXMuaWZyYW1lKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFuIHVwIHRoZSBpZnJhbWUgaWYgbmVjZXNzYXJ5LlxuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5pZnJhbWUpO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHdpbGwgdGhyb3cgd2hlbiBjbGVhcmluZyBhbiB1bmRlZmluZWQgaW50ZXJ2YWwuXG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcblxuICAgICAgLy8gSWYgdGhlIHVzZXIgcHJlc3NlZCB0aGUgYmFjayBidXR0b24sIHRoZSBpZnJhbWUncyBoYXNoIHdpbGwgaGF2ZVxuICAgICAgLy8gY2hhbmdlZCBhbmQgd2Ugc2hvdWxkIHVzZSB0aGF0IGZvciBjb21wYXJpc29uLlxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcbiAgICAgIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIGN1cnJlbnQgVVJMIGZyYWdtZW50LiBJZiBhIHJvdXRlIHN1Y2NlZWRzIHdpdGggYVxuICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgIGxvYWRVcmw6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAvLyBJZiB0aGUgcm9vdCBkb2Vzbid0IG1hdGNoLCBubyByb3V0ZXMgY2FuIG1hdGNoIGVpdGhlci5cbiAgICAgIGlmICghdGhpcy5tYXRjaFJvb3QoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCk7XG4gICAgICByZXR1cm4gXy5zb21lKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoYXNoIGhpc3RvcnksIG9yIHJlcGxhY2UgdGhlIFVSTCBzdGF0ZSBpZiB0aGVcbiAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgLy9cbiAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAvLyB5b3Ugd2lzaCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgYWRkaW5nIGFuIGVudHJ5IHRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSBvcHRpb25zID0ge3RyaWdnZXI6ICEhb3B0aW9uc307XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZnJhZ21lbnQuXG4gICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQgfHwgJycpO1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdCA9IHJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciB1cmwgPSByb290ICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGFuZCBkZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmRlY29kZUZyYWdtZW50KGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJykpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykpKSB7XG4gICAgICAgICAgdmFyIGlXaW5kb3cgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuICAgICAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2goaVdpbmRvdy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBmb3Igc3ViY2xhc3Nlcy5cbiAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKXsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAvLyBpZiBzdXBwbGllZC5cbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcblxufSkpO1xuIixudWxsLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4vKipcbiAqIGJhc2UgbGF5ZXIgZm9yIGFsbCBnb29nbGUgbWFwc1xuICovXG52YXIgR01hcHNMYXllclZpZXcgPSBmdW5jdGlvbihsYXllck1vZGVsLCBnbWFwc0xheWVyLCBnbWFwc01hcCkge1xuICB0aGlzLmdtYXBzTGF5ZXIgPSBnbWFwc0xheWVyO1xuICB0aGlzLm1hcCA9IHRoaXMuZ21hcHNNYXAgPSBnbWFwc01hcDtcbiAgdGhpcy5tb2RlbCA9IGxheWVyTW9kZWw7XG4gIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuICB0aGlzLnR5cGUgPSBsYXllck1vZGVsLmdldCgndHlwZScpIHx8IGxheWVyTW9kZWwuZ2V0KCdraW5kJyk7XG4gIHRoaXMudHlwZSA9IHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpO1xufTtcblxuXy5leHRlbmQoR01hcHNMYXllclZpZXcucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMpO1xuXy5leHRlbmQoR01hcHNMYXllclZpZXcucHJvdG90eXBlLCB7XG5cbiAgLy8gaGFjayBmdW5jdGlvbiB0byBzZWFyY2ggbGF5ZXIgaW5zaWRlIGdvb2dsZSBtYXBzIGxheWVyc1xuICBfc2VhcmNoTGF5ZXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHRoaXMuZ21hcHNNYXAub3ZlcmxheU1hcFR5cGVzLmZvckVhY2goXG4gICAgICBmdW5jdGlvbihsYXllciwgaSkge1xuICAgICAgICBpZiAobGF5ZXIgPT0gc2VsZikge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZW1vdmUgbGF5ZXIgZnJvbSB0aGUgbWFwIGFuZCB1bmJpbmQgZXZlbnRzXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmKCF0aGlzLmlzQmFzZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkeCA9IHRoaXMuX3NlYXJjaExheWVySW5kZXgoKTtcbiAgICAgIGlmKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuZ21hcHNNYXAub3ZlcmxheU1hcFR5cGVzLnJlbW92ZUF0KGlkeCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZ21hcHNMYXllci5zZXRNYXApe1xuICAgICAgICB0aGlzLmdtYXBzTGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbC51bmJpbmQobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAgICB0aGlzLnVuYmluZCgpO1xuICAgIH1cbiAgfSxcblxuICByZWZyZXNoVmlldzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vcmVzZXQgdG8gdXBkYXRlXG4gICAgaWYodGhpcy5pc0Jhc2UpIHtcbiAgICAgIHZhciBhID0gJ19iYXNlTGF5ZXInO1xuICAgICAgdGhpcy5nbWFwc01hcC5zZXRNYXBUeXBlSWQobnVsbCk7XG4gICAgICB0aGlzLmdtYXBzTWFwLm1hcFR5cGVzLnNldChhLCB0aGlzLmdtYXBzTGF5ZXIpO1xuICAgICAgdGhpcy5nbWFwc01hcC5zZXRNYXBUeXBlSWQoYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLl9zZWFyY2hMYXllckluZGV4KCk7XG4gICAgICBpZihpZHggPj0gMCkge1xuICAgICAgICB0aGlzLmdtYXBzTWFwLm92ZXJsYXlNYXBUeXBlcy5zZXRBdChpZHgsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWxvYWQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnJlZnJlc2hWaWV3KCkgOyB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbigpIHsgdGhpcy5yZWZyZXNoVmlldygpOyB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdNYXBzTGF5ZXJWaWV3O1xuIiwiLy8gRGVwZW5kcyBvbiBjYXJ0b2RiIHN0YW5kYXJkIGJ1bmRsZSBiZWluZyBsb2FkZWQgYW5kIHByZXNlbnQgaW4gZ2xvYmFsIG5hbWVzcGFjZVxudmFyIHRvcnF1ZSA9IHJlcXVpcmUoJ3RvcnF1ZS5qcycpO1xudmFyIGNkYiA9IHdpbmRvdy5jZGI7XG52YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xuXG52YXIgR01hcHNMYXllclZpZXcgPSByZXF1aXJlKCdjZGIvZ2VvL2dtYXBzL2dtYXBzLWxheWVyLXZpZXcnKTtcbnZhciBDYXJ0b0RCTG9nbyA9IGNkYi5nZW8uY29tbW9uLkNhcnRvREJMb2dvO1xuXG52YXIgR01hcHNUb3JxdWVMYXllclZpZXcgPSBmdW5jdGlvbihsYXllck1vZGVsLCBnbWFwc01hcCkge1xuXG4gIHZhciBleHRyYSA9IGxheWVyTW9kZWwuZ2V0KCdleHRyYV9wYXJhbXMnKTtcbiAgR01hcHNMYXllclZpZXcuY2FsbCh0aGlzLCBsYXllck1vZGVsLCB0aGlzLCBnbWFwc01hcCk7XG5cbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fZ2V0UXVlcnkobGF5ZXJNb2RlbCk7XG4gIHRvcnF1ZS5HTWFwc1RvcnF1ZUxheWVyLmNhbGwodGhpcywge1xuICAgICAgdGFibGU6IGxheWVyTW9kZWwuZ2V0KCd0YWJsZV9uYW1lJyksXG4gICAgICB1c2VyOiBsYXllck1vZGVsLmdldCgndXNlcl9uYW1lJyksXG4gICAgICBjb2x1bW46IGxheWVyTW9kZWwuZ2V0KCdwcm9wZXJ0eScpLFxuICAgICAgYmxlbmRtb2RlOiBsYXllck1vZGVsLmdldCgndG9ycXVlLWJsZW5kLW1vZGUnKSxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICAvL1RPRE86IG1hbmFnZSB0aW1lIGNvbHVtbnNcbiAgICAgIGNvdW50Ynk6ICdjb3VudChjYXJ0b2RiX2lkKScsXG4gICAgICBzcWxfYXBpX2RvbWFpbjogbGF5ZXJNb2RlbC5nZXQoJ3NxbF9hcGlfZG9tYWluJyksXG4gICAgICBzcWxfYXBpX3Byb3RvY29sOiBsYXllck1vZGVsLmdldCgnc3FsX2FwaV9wcm90b2NvbCcpLFxuICAgICAgc3FsX2FwaV9wb3J0OiBsYXllck1vZGVsLmdldCgnc3FsX2FwaV9wb3J0JyksXG4gICAgICB0aWxlcl9wcm90b2NvbDogbGF5ZXJNb2RlbC5nZXQoJ3RpbGVyX3Byb3RvY29sJyksXG4gICAgICB0aWxlcl9kb21haW46IGxheWVyTW9kZWwuZ2V0KCd0aWxlcl9kb21haW4nKSxcbiAgICAgIHRpbGVyX3BvcnQ6IGxheWVyTW9kZWwuZ2V0KCd0aWxlcl9wb3J0JyksXG4gICAgICBtYXBzX2FwaV90ZW1wbGF0ZTogbGF5ZXJNb2RlbC5nZXQoJ21hcHNfYXBpX3RlbXBsYXRlJyksXG4gICAgICBzdGF0X3RhZzogbGF5ZXJNb2RlbC5nZXQoJ3N0YXRfdGFnJyksXG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogbGF5ZXJNb2RlbC5nZXQoJ3RvcnF1ZS1kdXJhdGlvbicpLFxuICAgICAgc3RlcHM6IGxheWVyTW9kZWwuZ2V0KCd0b3JxdWUtc3RlcHMnKSxcbiAgICAgIHNxbDogcXVlcnksXG4gICAgICB2aXNpYmxlOiBsYXllck1vZGVsLmdldCgndmlzaWJsZScpLFxuICAgICAgZXh0cmFfcGFyYW1zOiB7XG4gICAgICAgIGFwaV9rZXk6IGV4dHJhID8gZXh0cmEubWFwX2tleTogJydcbiAgICAgIH0sXG4gICAgICBtYXA6IGdtYXBzTWFwLFxuICAgICAgY2FydG9kYl9sb2dvOiBsYXllck1vZGVsLmdldCgnY2FydG9kYl9sb2dvJyksXG4gICAgICBhdHRyaWJ1dGlvbjogbGF5ZXJNb2RlbC5nZXQoJ2F0dHJpYnV0aW9uJyksXG4gICAgICBjYXJ0b2NzczogbGF5ZXJNb2RlbC5nZXQoJ2NhcnRvY3NzJykgfHwgbGF5ZXJNb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSxcbiAgICAgIG5hbWVkX21hcDogbGF5ZXJNb2RlbC5nZXQoJ25hbWVkX21hcCcpLFxuICAgICAgYXV0aF90b2tlbjogbGF5ZXJNb2RlbC5nZXQoJ2F1dGhfdG9rZW4nKSxcbiAgICAgIG5vX2NkbjogbGF5ZXJNb2RlbC5nZXQoJ25vX2NkbicpLFxuICAgICAgbG9vcDogbGF5ZXJNb2RlbC5nZXQoJ2xvb3AnKSA9PT0gZmFsc2U/IGZhbHNlOiB0cnVlLFxuICB9KTtcblxuICAvL3RoaXMuc2V0Q2FydG9DU1ModGhpcy5tb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSk7XG4gIGlmIChsYXllck1vZGVsLmdldCgndmlzaWJsZScpKSB7XG4gICAgdGhpcy5wbGF5KCk7XG4gIH1cblxuICBsYXllck1vZGVsLmluaXRGb3JUb3JxdWVMYXllclZpZXcodGhpcyk7XG59O1xuXG5fLmV4dGVuZChcbiAgR01hcHNUb3JxdWVMYXllclZpZXcucHJvdG90eXBlLFxuICBHTWFwc0xheWVyVmlldy5wcm90b3R5cGUsXG4gIHRvcnF1ZS5HTWFwc1RvcnF1ZUxheWVyLnByb3RvdHlwZSxcbiAge1xuXG4gIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5tb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpO1xuICAgIGlmKGNoYW5nZWQgPT09IGZhbHNlKSByZXR1cm47XG4gICAgY2hhbmdlZC50aWxlX3N0eWxlICYmIHRoaXMuc2V0Q2FydG9DU1ModGhpcy5tb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSk7XG4gICAgaWYgKCdxdWVyeScgaW4gY2hhbmdlZCB8fCAncXVlcnlfd3JhcHBlcicgaW4gY2hhbmdlZCkge1xuICAgICAgdGhpcy5zZXRTUUwodGhpcy5fZ2V0UXVlcnkodGhpcy5tb2RlbCkpO1xuICAgIH1cbiAgICBpZiAoJ3Zpc2libGUnIGluIGNoYW5nZWQpXG4gICAgICB0aGlzLm1vZGVsLmdldCgndmlzaWJsZScpID8gdGhpcy5zaG93KCk6IHRoaXMuaGlkZSgpO1xuICB9LFxuXG4gIF9nZXRRdWVyeTogZnVuY3Rpb24obGF5ZXJNb2RlbCkge1xuICAgIHZhciBxdWVyeSA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeScpO1xuICAgIHZhciBxdyA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeV93cmFwcGVyJyk7XG4gICAgaWYocXcpIHtcbiAgICAgIHF1ZXJ5ID0gXy50ZW1wbGF0ZShxdykoeyBzcWw6IHF1ZXJ5IHx8ICgnc2VsZWN0ICogZnJvbSAnICsgbGF5ZXJNb2RlbC5nZXQoJ3RhYmxlX25hbWUnKSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfSxcblxuICByZWZyZXNoVmlldzogZnVuY3Rpb24oKSB7XG4gICAgLy9UT0RPOiB1cGRhdGUgc2NyZWVuXG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uKCkge1xuICAgIHRvcnF1ZS5HTWFwc1RvcnF1ZUxheWVyLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzKTtcbiAgICAvLyBBZGQgQ2FydG9EQiBsb2dvXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXJ0b2RiX2xvZ28gIT0gZmFsc2UpXG4gICAgICBDYXJ0b0RCTG9nby5hZGRXYWR1cyh7IGxlZnQ6IDc0LCBib3R0b206OCB9LCAyMDAwLCB0aGlzLm1hcC5nZXREaXYoKSlcbiAgfSxcblxuICBvblRpbGVzTG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAvL3RoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIEJhY2tib25lLkV2ZW50cy50cmlnZ2VyLmNhbGwodGhpcywgJ2xvYWQnKTtcbiAgfSxcblxuICBvblRpbGVzTG9hZGluZzogZnVuY3Rpb24oKSB7XG4gICAgQmFja2JvbmUuRXZlbnRzLnRyaWdnZXIuY2FsbCh0aGlzLCAnbG9hZGluZycpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdNYXBzVG9ycXVlTGF5ZXJWaWV3O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4vKipcbiAqIGJhc2UgbGF5ZXIgZm9yIGFsbCBsZWFmbGV0IGxheWVyc1xuICovXG52YXIgTGVhZmxldExheWVyVmlldyA9IGZ1bmN0aW9uKGxheWVyTW9kZWwsIGxlYWZsZXRMYXllciwgbGVhZmxldE1hcCkge1xuICB0aGlzLmxlYWZsZXRMYXllciA9IGxlYWZsZXRMYXllcjtcbiAgdGhpcy5sZWFmbGV0TWFwID0gbGVhZmxldE1hcDtcbiAgdGhpcy5tb2RlbCA9IGxheWVyTW9kZWw7XG5cbiAgdGhpcy5zZXRNb2RlbChsYXllck1vZGVsKTtcblxuICB0aGlzLnR5cGUgPSBsYXllck1vZGVsLmdldCgndHlwZScpIHx8IGxheWVyTW9kZWwuZ2V0KCdraW5kJyk7XG4gIHRoaXMudHlwZSA9IHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpO1xufTtcblxuXy5leHRlbmQoTGVhZmxldExheWVyVmlldy5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cyk7XG5fLmV4dGVuZChMZWFmbGV0TGF5ZXJWaWV3LnByb3RvdHlwZSwge1xuXG4gIHNldE1vZGVsOiBmdW5jdGlvbihtb2RlbCkge1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLnVuYmluZCgnY2hhbmdlJywgdGhpcy5fbW9kZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5fbW9kZWxVcGRhdGVkLCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogcmVtb3ZlIGxheWVyIGZyb20gdGhlIG1hcCBhbmQgdW5iaW5kIGV2ZW50c1xuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxlYWZsZXRNYXAucmVtb3ZlTGF5ZXIodGhpcy5sZWFmbGV0TGF5ZXIpO1xuICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlJywgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC51bmJpbmQobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgfSxcblxuICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVhZmxldExheWVyLnJlZHJhdygpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlYWZsZXRMYXllclZpZXc7XG4iLCIvLyBOT1RFIHRoaXMgaXMgT05MWSB1c2VkIGZvciB0b3JxdWUgYnVuZGxlIEFORCB0aGUgbGVhZmxldC5zcGVjLmpzLCB0aGF0IGFzc3VtZWQgdG9ycXVlIGxpYiB0byBiZSBsb2FkZWQpXG4vLyBEZXBlbmRzIG9uIGNhcnRvZGIgdG8gYmUgbG9hZGVkIGFuZCBwcmVzZW50IGluIGdsb2JhbCBuYW1lc3BhY2UuXG52YXIgY2RiID0gd2luZG93LmNkYjtcbnZhciBMID0gY2RiLkw7XG52YXIgXyA9IGNkYi5fO1xudmFyIHV0aWwgPSBjZGIuY29yZS51dGlsO1xudmFyIExlYWZsZXRMYXllclZpZXcgPSByZXF1aXJlKCdjZGIvZ2VvL2xlYWZsZXQvbGVhZmxldC1sYXllci12aWV3Jyk7XG52YXIgQ2FydG9EQkxvZ28gPSBjZGIuZ2VvLmNvbW1vbi5DYXJ0b0RCTG9nbztcblxuLyoqXG4gKiBsZWFmbGV0IHRvcnF1ZSBsYXllclxuICovXG52YXIgTGVhZmxldFRvcnF1ZUxheWVyID0gTC5Ub3JxdWVMYXllci5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxheWVyTW9kZWwsIGxlYWZsZXRNYXApIHtcbiAgICB2YXIgZXh0cmEgPSBsYXllck1vZGVsLmdldCgnZXh0cmFfcGFyYW1zJyk7XG5cbiAgICB2YXIgcXVlcnkgPSB0aGlzLl9nZXRRdWVyeShsYXllck1vZGVsKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGJhc2UgbGF5ZXJzXG4gICAgTC5Ub3JxdWVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHtcbiAgICAgIHRhYmxlOiBsYXllck1vZGVsLmdldCgndGFibGVfbmFtZScpLFxuICAgICAgdXNlcjogbGF5ZXJNb2RlbC5nZXQoJ3VzZXJfbmFtZScpLFxuICAgICAgY29sdW1uOiBsYXllck1vZGVsLmdldCgncHJvcGVydHknKSxcbiAgICAgIGJsZW5kbW9kZTogbGF5ZXJNb2RlbC5nZXQoJ3RvcnF1ZS1ibGVuZC1tb2RlJyksXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgLy9UT0RPOiBtYW5hZ2UgdGltZSBjb2x1bW5zXG4gICAgICBjb3VudGJ5OiAnY291bnQoY2FydG9kYl9pZCknLFxuICAgICAgc3FsX2FwaV9kb21haW46IGxheWVyTW9kZWwuZ2V0KCdzcWxfYXBpX2RvbWFpbicpLFxuICAgICAgc3FsX2FwaV9wcm90b2NvbDogbGF5ZXJNb2RlbC5nZXQoJ3NxbF9hcGlfcHJvdG9jb2wnKSxcbiAgICAgIHNxbF9hcGlfcG9ydDogbGF5ZXJNb2RlbC5nZXQoJ3NxbF9hcGlfcG9ydCcpLFxuICAgICAgdGlsZXJfcHJvdG9jb2w6IGxheWVyTW9kZWwuZ2V0KCd0aWxlcl9wcm90b2NvbCcpLFxuICAgICAgdGlsZXJfZG9tYWluOiBsYXllck1vZGVsLmdldCgndGlsZXJfZG9tYWluJyksXG4gICAgICB0aWxlcl9wb3J0OiBsYXllck1vZGVsLmdldCgndGlsZXJfcG9ydCcpLFxuICAgICAgbWFwc19hcGlfdGVtcGxhdGU6IGxheWVyTW9kZWwuZ2V0KCdtYXBzX2FwaV90ZW1wbGF0ZScpLFxuICAgICAgc3RhdF90YWc6IGxheWVyTW9kZWwuZ2V0KCdzdGF0X3RhZycpLFxuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGxheWVyTW9kZWwuZ2V0KCd0b3JxdWUtZHVyYXRpb24nKSxcbiAgICAgIHN0ZXBzOiBsYXllck1vZGVsLmdldCgndG9ycXVlLXN0ZXBzJyksXG4gICAgICBzcWw6IHF1ZXJ5LFxuICAgICAgdmlzaWJsZTogbGF5ZXJNb2RlbC5nZXQoJ3Zpc2libGUnKSxcbiAgICAgIGV4dHJhX3BhcmFtczoge1xuICAgICAgICBhcGlfa2V5OiBleHRyYSA/IGV4dHJhLm1hcF9rZXk6ICcnXG4gICAgICB9LFxuICAgICAgY2FydG9kYl9sb2dvOiBsYXllck1vZGVsLmdldCgnY2FydG9kYl9sb2dvJyksXG4gICAgICBhdHRyaWJ1dGlvbjogbGF5ZXJNb2RlbC5nZXQoJ2F0dHJpYnV0aW9uJyksXG4gICAgICBjYXJ0b2NzczogbGF5ZXJNb2RlbC5nZXQoJ2NhcnRvY3NzJykgfHwgbGF5ZXJNb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSxcbiAgICAgIG5hbWVkX21hcDogbGF5ZXJNb2RlbC5nZXQoJ25hbWVkX21hcCcpLFxuICAgICAgYXV0aF90b2tlbjogbGF5ZXJNb2RlbC5nZXQoJ2F1dGhfdG9rZW4nKSxcbiAgICAgIG5vX2NkbjogbGF5ZXJNb2RlbC5nZXQoJ25vX2NkbicpLFxuICAgICAgZHluYW1pY19jZG46IGxheWVyTW9kZWwuZ2V0KCdkeW5hbWljX2NkbicpLFxuICAgICAgbG9vcDogbGF5ZXJNb2RlbC5nZXQoJ2xvb3AnKSA9PT0gZmFsc2U/IGZhbHNlOiB0cnVlLFxuICAgICAgaW5zdGFuY2lhdGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXJ0b2NzcyA9IGxheWVyTW9kZWwuZ2V0KCdjYXJ0b2NzcycpIHx8IGxheWVyTW9kZWwuZ2V0KCd0aWxlX3N0eWxlJyk7XG5cbiAgICAgICAgcmV0dXJuICdfY2RiY3RfJyArIHV0aWwudW5pcXVlQ2FsbGJhY2tOYW1lKGNhcnRvY3NzICsgcXVlcnkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgTGVhZmxldExheWVyVmlldy5jYWxsKHRoaXMsIGxheWVyTW9kZWwsIHRoaXMsIGxlYWZsZXRNYXApO1xuXG4gICAgLy8gbWF0Y2ggbGVhZmxldCBldmVudHMgd2l0aCBiYWNrYm9uZSBldmVudHNcbiAgICB0aGlzLmZpcmUgPSB0aGlzLnRyaWdnZXI7XG5cbiAgICAvL3RoaXMuc2V0Q2FydG9DU1MobGF5ZXJNb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSk7XG4gICAgaWYgKGxheWVyTW9kZWwuZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cblxuICAgIHRoaXMuYmluZCgndGlsZXNMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kKCd0aWxlc0xvYWRpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGluZycpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgbGF5ZXJNb2RlbC5pbml0Rm9yVG9ycXVlTGF5ZXJWaWV3KHRoaXMpO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICBMLlRvcnF1ZUxheWVyLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzLCBbbWFwXSk7XG4gICAgLy8gQWRkIENhcnRvREIgbG9nb1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY2FydG9kYl9sb2dvICE9IGZhbHNlKVxuICAgICAgQ2FydG9EQkxvZ28uYWRkV2FkdXMoeyBsZWZ0OjgsIGJvdHRvbTo4IH0sIDAsIG1hcC5fY29udGFpbmVyKVxuICB9LFxuXG4gIF9nZXRRdWVyeTogZnVuY3Rpb24obGF5ZXJNb2RlbCkge1xuICAgIHZhciBxdWVyeSA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeScpO1xuICAgIHZhciBxdyA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeV93cmFwcGVyJyk7XG4gICAgaWYocXcpIHtcbiAgICAgIHF1ZXJ5ID0gXy50ZW1wbGF0ZShxdykoeyBzcWw6IHF1ZXJ5IHx8ICgnc2VsZWN0ICogZnJvbSAnICsgbGF5ZXJNb2RlbC5nZXQoJ3RhYmxlX25hbWUnKSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfSxcblxuICBfbW9kZWxVcGRhdGVkOiBmdW5jdGlvbihtb2RlbCkge1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5tb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpO1xuICAgIGlmKGNoYW5nZWQgPT09IGZhbHNlKSByZXR1cm47XG4gICAgLypcbiAgICBjaGFuZ2VkLnRpbGVfc3R5bGUgJiYgdGhpcy5zZXRDYXJ0b0NTUyh0aGlzLm1vZGVsLmdldCgndGlsZV9zdHlsZScpKTtcbiAgICBpZiAoJ3F1ZXJ5JyBpbiBjaGFuZ2VkIHx8ICdxdWVyeV93cmFwcGVyJyBpbiBjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldFNRTCh0aGlzLl9nZXRRdWVyeSh0aGlzLm1vZGVsKSk7XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAoJ3Zpc2libGUnIGluIGNoYW5nZWQpXG4gICAgICB0aGlzLm1vZGVsLmdldCgndmlzaWJsZScpID8gdGhpcy5zaG93KCk6IHRoaXMuaGlkZSgpO1xuXG4gICAgaWYgKCd1cmxzJyBpbiBjaGFuZ2VkKSB7XG4gICAgICAvLyBSRUFMIEhBQ0tcbiAgICAgIHRoaXMucHJvdmlkZXIudGVtcGxhdGVVcmwgPSB0aGlzLm1vZGVsLmdldCgndXJscycpLnRpbGVzWzBdO1xuICAgICAgdGhpcy5wcm92aWRlci5fc2V0UmVhZHkodHJ1ZSk7XG4gICAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICAgIH1cbiAgfVxufSk7XG5cbl8uZXh0ZW5kKExlYWZsZXRUb3JxdWVMYXllci5wcm90b3R5cGUsIExlYWZsZXRMYXllclZpZXcucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWFmbGV0VG9ycXVlTGF5ZXI7XG4iLCJ2YXIgdG9ycXVlID0gd2luZG93LnRvcnF1ZSA9IHJlcXVpcmUoJ3RvcnF1ZS5qcycpOyAvLyBzdGFuZGFsb25lIHRvcnF1ZSBsaWIsIHJlcXVpcmVkIGZvciBnbWFwcy9sZWFmbGV0IGxheWVyIHZpZXdcblxuLy8gR2V0IGFuZCBtdXRhdGUgdGhlIGdsb2JhbCBjZGIgb2JqZWN0LCBhZGQgZXhwZWN0ZWQgb2JqZWN0cyBmb3IgZ21hcHMvbGVhZmxldCBpZiBwcmVzZW50OlxudmFyIGNkYiA9IHdpbmRvdy5jZGI7XG5pZiAoIWNkYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NhcnRvZGIuanMgaXMgcmVxdWlyZWQgZm9yIHRoaXMgbGliIHRvIHdvcmssIGxvYWQgaXQgYmVmb3JlIHRoaXMgb25lJyk7XG59XG5cbmlmICh0eXBlb2YgZ29vZ2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ29vZ2xlLm1hcHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNkYi5nZW8uR01hcHNUb3JxdWVMYXllclZpZXcgPSByZXF1aXJlKCcuL2dlby9nbWFwcy9nbWFwcy10b3JxdWUtbGF5ZXItdmlldycpO1xufVxuXG5jZGIuZ2VvLkxlYWZsZXRUb3JxdWVMYXllciA9IHJlcXVpcmUoJy4vZ2VvL2xlYWZsZXQvbGVhZmxldC10b3JxdWUtbGF5ZXInKTtcblxuY2RiLm1vZHVsZUxvYWQoJ3RvcnF1ZScsIHRvcnF1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdG9ycXVlO1xuIiwiLyoqXG4gKiBBYnN0cmFjdCBoYW5kbGVyIGZvciBhbmltYXRvciBzdGVwc1xuICovXG52YXIgQW5pbWF0b3JTdGVwc1JhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgaWYgKHN0YXJ0ID49IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBlbmQnKTtcblxuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xufTtcblxuQW5pbWF0b3JTdGVwc1JhbmdlLnByb3RvdHlwZSA9IHtcblxuICBkaWZmOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xuICB9LFxuXG4gIGlzTGFzdDogZnVuY3Rpb24oc3RlcCkge1xuICAgIC8vIHJvdW5kIHN0ZXAgaW50byBhbiBpbnRlZ2VyLCB0byBiZSBhYmxlIHRvIGNvbXBhcmUgbnVtYmVyIGFzIGV4cGVjdGVkIChhbHNvIGNvbnZlcnRzIGJhZCBpbnB1dCB0byAwKVxuICAgIHJldHVybiAoc3RlcCB8IDApID09PSB0aGlzLmVuZDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvclN0ZXBzUmFuZ2U7XG4iLCJ2YXIgdG9ycXVlID0gcmVxdWlyZSgnLi8nKTtcbnZhciBBbmltYXRvclN0ZXBzUmFuZ2UgPSByZXF1aXJlKCcuL2FuaW1hdG9yLXN0ZXBzLXJhbmdlJyk7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgfHwgZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIHx8IGdsb2JhbC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB8fCBnbG9iYWwubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB8fCBmdW5jdGlvbihjYWxsYmFjaykgeyByZXR1cm4gZ2xvYmFsLnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XG5cbnZhciBjYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZVxuICAgIHx8IGdsb2JhbC5tb3pDYW5jZWxBbmltYXRpb25GcmFtZVxuICAgIHx8IGdsb2JhbC53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVxuICAgIHx8IGdsb2JhbC5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lXG4gICAgfHwgZnVuY3Rpb24oaWQpIHsgY2xlYXJUaW1lb3V0KGlkKTsgfTtcblxuICAvKipcbiAgICogb3B0aW9uczpcbiAgICogICAgYW5pbWF0aW9uRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiAgICBhbmltYXRpb25EZWxheSBpbiBzZWNvbmRzXG4gICAqL1xuICBmdW5jdGlvbiBBbmltYXRvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmKCFvcHRpb25zLnN0ZXBzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGVwcyBvcHRpb24gbWlzc2luZ1wiKVxuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3RpY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fdDAgPSArbmV3IERhdGUoKTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IDAuMDtcbiAgICB0aGlzLml0ZW1zUmVhZHkgPSBmYWxzZTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHRvcnF1ZS5leHRlbmQoe1xuICAgICAgICBhbmltYXRpb25EZWxheTogMCxcbiAgICAgICAgbWF4RGVsdGE6IDAuMixcbiAgICAgICAgbG9vcDogb3B0aW9ucy5sb29wID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5sb29wXG4gICAgfSwgdGhpcy5vcHRpb25zKTtcblxuICAgIHRoaXMuc3RlcHMob3B0aW9ucy5zdGVwcyk7XG4gIH1cblxuICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG5cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uU3RhcnQgJiYgdGhpcy5vcHRpb25zLm9uU3RhcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RlcHNSYW5nZSgpLmRpZmYoKSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMudGltZSh0aGlzLnN0ZXBzUmFuZ2UoKS5zdGFydCk7XG4gICAgICB0aGlzLm9wdGlvbnMub25TdG9wICYmIHRoaXMub3B0aW9ucy5vblN0b3AoKTtcbiAgICB9LFxuXG4gICAgLy8gcmVhbCBhbmltYXRpb24gdGltZVxuICAgIHRpbWU6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLl90aW1lID0gXztcbiAgICAgIHZhciB0ID0gdGhpcy5yYW5nZSh0aGlzLmRvbWFpbih0aGlzLl90aW1lKSk7XG4gICAgICB0aGlzLmNhbGxiYWNrKHQpO1xuICAgIH0sXG5cbiAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9tYWluSW52ID0gdG9ycXVlLm1hdGgubGluZWFyKHRoaXMub3B0aW9ucy5hbmltYXRpb25EZWxheSwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkRlbGF5ICsgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgIHRoaXMuZG9tYWluID0gdGhpcy5kb21haW5JbnYuaW52ZXJ0KCk7XG4gICAgICB0aGlzLnJhbmdlID0gdG9ycXVlLm1hdGgubGluZWFyKDAsIHRoaXMuX2RlZmF1bHRTdGVwc1JhbmdlLmVuZCk7XG4gICAgICB0aGlzLnJhbmdlSW52ID0gdGhpcy5yYW5nZS5pbnZlcnQoKTtcbiAgICAgIHRoaXMudGltZSh0aGlzLl90aW1lKTtcbiAgICAgIHRoaXMucnVubmluZz8gdGhpcy5zdGFydCgpOiB0aGlzLnBhdXNlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHVyYXRpb246IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgIHJldHVybiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb247XG4gICAgICB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gPSBfO1xuICAgICAgaWYgKHRoaXMudGltZSgpID4gXykge1xuICAgICAgICB0aGlzLnRpbWUoMCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2NhbGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdGVwczogZnVuY3Rpb24oXykge1xuICAgICAgdGhpcy5vcHRpb25zLnN0ZXBzID0gXztcbiAgICAgIHRoaXMuX2RlZmF1bHRTdGVwc1JhbmdlID0gbmV3IEFuaW1hdG9yU3RlcHNSYW5nZSgwLCBfKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc2NhbGUoKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBvciBzZXRzIGEgKGN1c3RvbSkgc3RlcHMgcmFuZ2VcbiAgICAvLyBTZXR0aW5nIGEgc3RlcHMgcmFuZ2UgbXVzdCBiZSB3aXRoaW4gdGhlIGZ1bGwgcmFuZ2VcbiAgICBzdGVwc1JhbmdlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLl9kZWZhdWx0U3RlcHNSYW5nZS5zdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIHdpdGhpbiBkZWZhdWx0IHN0ZXBzIHJhbmdlJyk7XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLl9kZWZhdWx0U3RlcHNSYW5nZS5lbmQpIHRocm93IG5ldyBFcnJvcignZW5kIG11c3QgYmUgd2l0aGluIGRlZmF1bHQgc3RlcHMgcmFuZ2UnKTtcblxuICAgICAgICB0aGlzLl9jdXN0b21TdGVwc1JhbmdlID0gbmV3IEFuaW1hdG9yU3RlcHNSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uU3RlcHNSYW5nZSAmJiB0aGlzLm9wdGlvbnMub25TdGVwc1JhbmdlKCk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIGN1cnJlbnQgc3RlcCBpZiBpdCdzIG91dHNpZGUgdGhlIG5ldyBjdXN0b20gcmFuZ2VcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXAoKSB8IDA7IC8vIHJvdW5kIHRvIGFuIGludGVnZXJcbiAgICAgICAgaWYgKHN0ZXAgPCBzdGFydCB8fCBzdGVwID4gZW5kKSB7XG4gICAgICAgICAgdGhpcy5zdGVwKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbVN0ZXBzUmFuZ2UgfHwgdGhpcy5fZGVmYXVsdFN0ZXBzUmFuZ2U7XG4gICAgfSxcblxuICAgIHJlbW92ZUN1c3RvbVN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VzdG9tU3RlcHNSYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub3B0aW9ucy5vblN0ZXBzUmFuZ2UgJiYgdGhpcy5vcHRpb25zLm9uU3RlcHNSYW5nZSgpO1xuICAgIH0sXG5cbiAgICBzdGVwOiBmdW5jdGlvbihzKSB7XG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5yYW5nZSh0aGlzLmRvbWFpbih0aGlzLl90aW1lKSk7XG4gICAgICB0aGlzLl90aW1lID0gdGhpcy5kb21haW5JbnYodGhpcy5yYW5nZUludihzKSk7XG4gICAgfSxcblxuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICB0aGlzLm9wdGlvbnMub25QYXVzZSAmJiB0aGlzLm9wdGlvbnMub25QYXVzZSgpO1xuICAgIH0sXG5cbiAgICBfdGljazogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdDEgPSArbmV3IERhdGUoKTtcbiAgICAgIHZhciBkZWx0YSA9ICh0MSAtIHRoaXMuX3QwKSowLjAwMTtcbiAgICAgIC8vIGlmIGRlbHRhIGlzIHJlYWxseSBiaWcgbWVhbnMgdGhlIHRhYiBsb3N0IHRoZSBmb2N1c1xuICAgICAgLy8gYXQgc29tZSBwb2ludCwgc28gbGltaXQgZGVsdGEgY2hhbmdlXG4gICAgICBkZWx0YSA9IE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXhEZWx0YSwgZGVsdGEpO1xuICAgICAgdGhpcy5fdDAgPSB0MTtcbiAgICAgIHRoaXMuX3RpbWUgKz0gZGVsdGE7XG5cbiAgICAgIHZhciBzdGVwc1JhbmdlID0gdGhpcy5zdGVwc1JhbmdlKCk7XG4gICAgICBpZiAoc3RlcHNSYW5nZS5pc0xhc3QodGhpcy5zdGVwKCkpKSB7XG4gICAgICAgIGlmKCF0aGlzLm9wdGlvbnMubG9vcCl7XG4gICAgICAgICAgLy8gc2V0IHRpbWUgdG8gbWF4IHRpbWVcbiAgICAgICAgICB0aGlzLnRpbWUodGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGVwKHN0ZXBzUmFuZ2Uuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy50aW1lKHRoaXMuX3RpbWUpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0b3I7XG4iLCJ2YXIgX3RvcnF1ZV9yZWZlcmVuY2VfbGF0ZXN0ID0ge1xuICAgIFwidmVyc2lvblwiOiBcIjEuMC4wXCIsXG4gICAgXCJzdHlsZVwiOiB7XG4gICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcImNvbXAtb3BcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBsYXllciBvbiB0b3Agb2Ygb3RoZXIgbGF5ZXJzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBsYXllciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIGxheWVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICBcInNyY1wiLCAvL1xuICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIiwgLy9cbiAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsIC8vXG4gICAgICAgICAgICAgICAgXCJzcmMtaW5cIiwgLy9cbiAgICAgICAgICAgICAgICBcImRzdC1pblwiLCAvL1xuICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLCAvL1xuICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLCAvL1xuICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIiwgLy9cbiAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsIC8vXG4gICAgICAgICAgICAgICAgXCJ4b3JcIiwgLy9cbiAgICAgICAgICAgICAgICBcImRhcmtlblwiLCAvL1xuICAgICAgICAgICAgICAgIFwibGlnaHRlblwiIC8vXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwibGF5ZXJcIiA6IHtcbiAgICAgICAgXCJidWZmZXItc2l6ZVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIwXCIsXG4gICAgICAgICAgICBcInR5cGVcIjpcImZsb2F0XCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGJ1ZmZlciB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiRXh0cmEgdG9sZXJhbmNlIGFyb3VuZCB0aGUgTGF5ZXIgZXh0ZW50IChpbiBwaXhlbHMpIHVzZWQgdG8gd2hlbiBxdWVyeWluZyBhbmQgKHBvdGVudGlhbGx5KSBjbGlwcGluZyB0aGUgbGF5ZXIgZGF0YSBkdXJpbmcgcmVuZGVyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCItdG9ycXVlLWNsZWFyLWNvbG9yXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1jbGVhci1jb2xvclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMClcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZnVsbCBjbGVhclwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJjb2xvciB1c2VkIHRvIGNsZWFyIGNhbnZhcyBvbiBlYWNoIGZyYW1lXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCItdG9ycXVlLWZyYW1lLWNvdW50XCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1mcmFtZS1jb3VudFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMTI4XCIsXG4gICAgICAgICAgICBcInR5cGVcIjpcIm51bWJlclwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0aGUgZGF0YSBpcyBicm9rZW4gaW50byAxMjggdGltZSBmcmFtZXNcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiTnVtYmVyIG9mIGFuaW1hdGlvbiBzdGVwcy9mcmFtZXMgdXNlZCBpbiB0aGUgYW5pbWF0aW9uLiBJZiB0aGUgZGF0YSBjb250YWlucyBhIGZld2VyZSBudW1iZXIgb2YgdG90YWwgZnJhbWVzLCB0aGUgbGVzc2VyIHZhbHVlIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICB9LFxuICAgICAgICBcIi10b3JxdWUtcmVzb2x1dGlvblwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtcmVzb2x1dGlvblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMlwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJudW1iZXJcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlNwYXRpYWwgcmVzb2x1dGlvbiBpbiBwaXhlbHMuIEEgcmVzb2x1dGlvbiBvZiAxIG1lYW5zIG5vIHNwYXRpYWwgYWdncmVnYXRpb24gb2YgdGhlIGRhdGEuIEFueSBvdGhlciByZXNvbHV0aW9uIG9mIE4gcmVzdWx0cyBpbiBzcGF0aWFsIGFnZ3JlZ2F0aW9uIGludG8gY2VsbHMgb2YgTnhOIHBpeGVscy4gVGhlIHZhbHVlIE4gbXVzdCBiZSBwb3dlciBvZiAyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCItdG9ycXVlLWFuaW1hdGlvbi1kdXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtYW5pbWF0aW9uLWR1cmF0aW9uXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIzMFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJudW1iZXJcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIGFuaW1hdGlvbiBsYXN0cyAzMCBzZWNvbmRzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkFuaW1hdGlvbiBkdXJhdGlvbiBpbiBzZWNvbmRzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCItdG9ycXVlLWFnZ3JlZ2F0aW9uLWZ1bmN0aW9uXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1hZ2dyZWdhdGlvbi1mdW5jdGlvblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiY291bnQoY2FydG9kYl9pZClcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0aGUgdmFsdWUgZm9yIGVhY2ggY2VsbCBpcyB0aGUgY291bnQgb2YgcG9pbnRzIGluIHRoYXQgY2VsbFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJBIGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIGEgdmFsdWUgZnJvbSB0aGUgYWdncmVnYXRlIGRhdGEgZm9yIGVhY2ggY2VsbC4gU2VlIC10b3JxdWUtcmVzb2x1dGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiLXRvcnF1ZS10aW1lLWF0dHJpYnV0ZVwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtdGltZS1hdHRyaWJ1dGVcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInRpbWVcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0aGUgZGF0YSBjb2x1bW4gaW4geW91ciB0YWJsZSB0aGF0IGlzIG9mIGEgdGltZSBiYXNlZCB0eXBlXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB0YWJsZSBjb2x1bW4gdGhhdCBjb250YWlucyB0aGUgdGltZSBpbmZvcm1hdGlvbiB1c2VkIGNyZWF0ZSB0aGUgYW5pbWF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCItdG9ycXVlLWRhdGEtYWdncmVnYXRpb25cIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLWRhdGEtYWdncmVnYXRpb25cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImxpbmVhclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgXCJjdW11bGF0aXZlXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInByZXZpb3VzIHZhbHVlcyBhcmUgZGlzY2FyZGVkXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkEgbGluZWFyIGFuaW1hdGlvbiB3aWxsIGRpc2NhcmQgcHJldmlvdXMgdmFsdWVzIHdoaWxlIGEgY3VtdWxhdGl2ZSBhbmltYXRpb24gd2lsbCBhY2N1bXVsYXRlIHRoZW0gdW50aWwgaXQgcmVzdGFydHNcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInN5bWJvbGl6ZXJzXCIgOiB7XG4gICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgbGF5ZXIgb24gdG9wIG9mIG90aGVyIGxheWVyc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIGxheWVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gbGF5ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwic3JjXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcInNyYy1pblwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIiwgLy9cbiAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsIC8vXG4gICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcInhvclwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIiwgLy9cbiAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiIC8vXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJvcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIGFscGhhIHZhbHVlIGZvciB0aGUgc3R5bGUgKHdoaWNoIG1lYW5zIGFuIGFscGhhIGFwcGxpZWQgdG8gYWxsIGZlYXR1cmVzIGluIHNlcGFyYXRlIGJ1ZmZlciBhbmQgdGhlbiBjb21wb3NpdGVkIGJhY2sgdG8gbWFpbiBidWZmZXIpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzZXBhcmF0ZSBidWZmZXIgd2lsbCBiZSB1c2VkIGFuZCBubyBhbHBoYSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHN0eWxlIGFmdGVyIHJlbmRlcmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidHJhaWxcIjoge1xuICAgICAgICAgIFwic3RlcHNcIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCJ0cmFpbC1zdGVwc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyB0cmFpbCBzdGVwc1wiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJIb3cgbWFueSBzdGVwcyBvZiB0cmFpbHMgYXJlIGdvaW5nIHRvIGJlIHJlbmRlcmVkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9seWdvblwiOiB7XG4gICAgICAgICAgICBcImZpbGxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJyZ2JhKDEyOCwxMjgsMTI4LDEpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJncmF5IGFuZCBmdWxseSBvcGFxdWUgKGFscGhhID0gMSksIHNhbWUgYXMgcmdiKDEyOCwxMjgsMTI4KVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRmlsbCBjb2xvciB0byBhc3NpZ24gdG8gYSBwb2x5Z29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIHBvbHlnb25cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZVwiOiB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgwLDAsMCwxKVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJibGFjayBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigwLDAsMClcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiBhIGRyYXduIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHdpZHRoIG9mIGEgbGluZSBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWpvaW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJtaXRlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibWl0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcImJldmVsXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGJlaGF2aW9yIG9mIGxpbmVzIHdoZW4gam9pbmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWNhcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJ1dHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImJ1dHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNxdWFyZVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5nc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibWFya2Vyc1wiOiB7XG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWZpbGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIFNWRyBmaWxlIHRoYXQgdGhpcyBtYXJrZXIgc2hvd3MgYXQgZWFjaCBwbGFjZW1lbnQuIElmIG5vIGZpbGUgaXMgZ2l2ZW4sIHRoZSBtYXJrZXIgd2lsbCBzaG93IGFuIGVsbGlwc2UuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJBbiBlbGxpcHNlIG9yIGNpcmNsZSwgaWYgd2lkdGggZXF1YWxzIGhlaWdodFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVyaVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgb3ZlcmFsbCBvcGFjaXR5IG9mIHRoZSBtYXJrZXIsIGlmIHNldCwgb3ZlcnJpZGVzIGJvdGggdGhlIG9wYWNpdHkgb2YgYm90aCB0aGUgZmlsbCBhbmQgc3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgc3Ryb2tlLW9wYWNpdHkgYW5kIGZpbGwtb3BhY2l0eSB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWZpbGwtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGZpbGwgb3BhY2l0eSBvZiB0aGUgbWFya2VyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWxpbmUtY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgc3Ryb2tlIGFyb3VuZCBhIG1hcmtlciBzaGFwZS5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbGluZS13aWR0aFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UgYXJvdW5kIGEgbWFya2VyIHNoYXBlLCBpbiBwaXhlbHMuIFRoaXMgaXMgcG9zaXRpb25lZCBvbiB0aGUgYm91bmRhcnksIHNvIGhpZ2ggdmFsdWVzIGNhbiBjb3ZlciB0aGUgYXJlYSBpdHNlbGYuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWxpbmUtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwib3BhcXVlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiBhIGxpbmVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBhcmVhIG9mIHRoZSBtYXJrZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWFya2VyLXR5cGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXR5cGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcInJlY3RhbmdsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImVsbGlwc2VcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGRlZmF1bHQgbWFya2VyLXR5cGUuIElmIGEgU1ZHIGZpbGUgaXMgbm90IGdpdmVuIGFzIHRoZSBtYXJrZXItZmlsZSBwYXJhbWV0ZXIsIHRoZSByZW5kZXJlciBwcm92aWRlcyBlaXRoZXIgYW4gcmVjdGFuZ2xlIG9yIGFuIGVsbGlwc2UgKGEgY2lyY2xlIGlmIGhlaWdodCBpcyBlcXVhbCB0byB3aWR0aClcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBcIndpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci13aWR0aFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiB0aGUgbWFya2VyLCBpZiB1c2luZyBvbmUgb2YgdGhlIGRlZmF1bHQgdHlwZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50XCI6IHtcbiAgICAgICAgICAgIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2ludC1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJJbWFnZSBmaWxlIHRvIHJlcHJlc2VudCBhIHBvaW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEuMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkZ1bGx5IG9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSB2YWx1ZSBmcm9tIDAgdG8gMSB0byBjb250cm9sIHRoZSBvcGFjaXR5IG9mIHRoZSBwb2ludFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiY29sb3JzXCI6IHtcbiAgICAgICAgXCJhbGljZWJsdWVcIjogIFsyNDAsIDI0OCwgMjU1XSxcbiAgICAgICAgXCJhbnRpcXVld2hpdGVcIjogIFsyNTAsIDIzNSwgMjE1XSxcbiAgICAgICAgXCJhcXVhXCI6ICBbMCwgMjU1LCAyNTVdLFxuICAgICAgICBcImFxdWFtYXJpbmVcIjogIFsxMjcsIDI1NSwgMjEyXSxcbiAgICAgICAgXCJhenVyZVwiOiAgWzI0MCwgMjU1LCAyNTVdLFxuICAgICAgICBcImJlaWdlXCI6ICBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgICAgIFwiYmlzcXVlXCI6ICBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgICAgIFwiYmxhY2tcIjogIFswLCAwLCAwXSxcbiAgICAgICAgXCJibGFuY2hlZGFsbW9uZFwiOiAgWzI1NSwyMzUsMjA1XSxcbiAgICAgICAgXCJibHVlXCI6ICBbMCwgMCwgMjU1XSxcbiAgICAgICAgXCJibHVldmlvbGV0XCI6ICBbMTM4LCA0MywgMjI2XSxcbiAgICAgICAgXCJicm93blwiOiAgWzE2NSwgNDIsIDQyXSxcbiAgICAgICAgXCJidXJseXdvb2RcIjogIFsyMjIsIDE4NCwgMTM1XSxcbiAgICAgICAgXCJjYWRldGJsdWVcIjogIFs5NSwgMTU4LCAxNjBdLFxuICAgICAgICBcImNoYXJ0cmV1c2VcIjogIFsxMjcsIDI1NSwgMF0sXG4gICAgICAgIFwiY2hvY29sYXRlXCI6ICBbMjEwLCAxMDUsIDMwXSxcbiAgICAgICAgXCJjb3JhbFwiOiAgWzI1NSwgMTI3LCA4MF0sXG4gICAgICAgIFwiY29ybmZsb3dlcmJsdWVcIjogIFsxMDAsIDE0OSwgMjM3XSxcbiAgICAgICAgXCJjb3Juc2lsa1wiOiAgWzI1NSwgMjQ4LCAyMjBdLFxuICAgICAgICBcImNyaW1zb25cIjogIFsyMjAsIDIwLCA2MF0sXG4gICAgICAgIFwiY3lhblwiOiAgWzAsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJkYXJrYmx1ZVwiOiAgWzAsIDAsIDEzOV0sXG4gICAgICAgIFwiZGFya2N5YW5cIjogIFswLCAxMzksIDEzOV0sXG4gICAgICAgIFwiZGFya2dvbGRlbnJvZFwiOiAgWzE4NCwgMTM0LCAxMV0sXG4gICAgICAgIFwiZGFya2dyYXlcIjogIFsxNjksIDE2OSwgMTY5XSxcbiAgICAgICAgXCJkYXJrZ3JlZW5cIjogIFswLCAxMDAsIDBdLFxuICAgICAgICBcImRhcmtncmV5XCI6ICBbMTY5LCAxNjksIDE2OV0sXG4gICAgICAgIFwiZGFya2toYWtpXCI6ICBbMTg5LCAxODMsIDEwN10sXG4gICAgICAgIFwiZGFya21hZ2VudGFcIjogIFsxMzksIDAsIDEzOV0sXG4gICAgICAgIFwiZGFya29saXZlZ3JlZW5cIjogIFs4NSwgMTA3LCA0N10sXG4gICAgICAgIFwiZGFya29yYW5nZVwiOiAgWzI1NSwgMTQwLCAwXSxcbiAgICAgICAgXCJkYXJrb3JjaGlkXCI6ICBbMTUzLCA1MCwgMjA0XSxcbiAgICAgICAgXCJkYXJrcmVkXCI6ICBbMTM5LCAwLCAwXSxcbiAgICAgICAgXCJkYXJrc2FsbW9uXCI6ICBbMjMzLCAxNTAsIDEyMl0sXG4gICAgICAgIFwiZGFya3NlYWdyZWVuXCI6ICBbMTQzLCAxODgsIDE0M10sXG4gICAgICAgIFwiZGFya3NsYXRlYmx1ZVwiOiAgWzcyLCA2MSwgMTM5XSxcbiAgICAgICAgXCJkYXJrc2xhdGVncmV5XCI6ICBbNDcsIDc5LCA3OV0sXG4gICAgICAgIFwiZGFya3R1cnF1b2lzZVwiOiAgWzAsIDIwNiwgMjA5XSxcbiAgICAgICAgXCJkYXJrdmlvbGV0XCI6ICBbMTQ4LCAwLCAyMTFdLFxuICAgICAgICBcImRlZXBwaW5rXCI6ICBbMjU1LCAyMCwgMTQ3XSxcbiAgICAgICAgXCJkZWVwc2t5Ymx1ZVwiOiAgWzAsIDE5MSwgMjU1XSxcbiAgICAgICAgXCJkaW1ncmF5XCI6ICBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICAgIFwiZGltZ3JleVwiOiAgWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICBcImRvZGdlcmJsdWVcIjogIFszMCwgMTQ0LCAyNTVdLFxuICAgICAgICBcImZpcmVicmlja1wiOiAgWzE3OCwgMzQsIDM0XSxcbiAgICAgICAgXCJmbG9yYWx3aGl0ZVwiOiAgWzI1NSwgMjUwLCAyNDBdLFxuICAgICAgICBcImZvcmVzdGdyZWVuXCI6ICBbMzQsIDEzOSwgMzRdLFxuICAgICAgICBcImZ1Y2hzaWFcIjogIFsyNTUsIDAsIDI1NV0sXG4gICAgICAgIFwiZ2FpbnNib3JvXCI6ICBbMjIwLCAyMjAsIDIyMF0sXG4gICAgICAgIFwiZ2hvc3R3aGl0ZVwiOiAgWzI0OCwgMjQ4LCAyNTVdLFxuICAgICAgICBcImdvbGRcIjogIFsyNTUsIDIxNSwgMF0sXG4gICAgICAgIFwiZ29sZGVucm9kXCI6ICBbMjE4LCAxNjUsIDMyXSxcbiAgICAgICAgXCJncmF5XCI6ICBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICAgIFwiZ3JleVwiOiAgWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgICBcImdyZWVuXCI6ICBbMCwgMTI4LCAwXSxcbiAgICAgICAgXCJncmVlbnllbGxvd1wiOiAgWzE3MywgMjU1LCA0N10sXG4gICAgICAgIFwiaG9uZXlkZXdcIjogIFsyNDAsIDI1NSwgMjQwXSxcbiAgICAgICAgXCJob3RwaW5rXCI6ICBbMjU1LCAxMDUsIDE4MF0sXG4gICAgICAgIFwiaW5kaWFucmVkXCI6ICBbMjA1LCA5MiwgOTJdLFxuICAgICAgICBcImluZGlnb1wiOiAgWzc1LCAwLCAxMzBdLFxuICAgICAgICBcIml2b3J5XCI6ICBbMjU1LCAyNTUsIDI0MF0sXG4gICAgICAgIFwia2hha2lcIjogIFsyNDAsIDIzMCwgMTQwXSxcbiAgICAgICAgXCJsYXZlbmRlclwiOiAgWzIzMCwgMjMwLCAyNTBdLFxuICAgICAgICBcImxhdmVuZGVyYmx1c2hcIjogIFsyNTUsIDI0MCwgMjQ1XSxcbiAgICAgICAgXCJsYXduZ3JlZW5cIjogIFsxMjQsIDI1MiwgMF0sXG4gICAgICAgIFwibGVtb25jaGlmZm9uXCI6ICBbMjU1LCAyNTAsIDIwNV0sXG4gICAgICAgIFwibGlnaHRibHVlXCI6ICBbMTczLCAyMTYsIDIzMF0sXG4gICAgICAgIFwibGlnaHRjb3JhbFwiOiAgWzI0MCwgMTI4LCAxMjhdLFxuICAgICAgICBcImxpZ2h0Y3lhblwiOiAgWzIyNCwgMjU1LCAyNTVdLFxuICAgICAgICBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6ICBbMjUwLCAyNTAsIDIxMF0sXG4gICAgICAgIFwibGlnaHRncmF5XCI6ICBbMjExLCAyMTEsIDIxMV0sXG4gICAgICAgIFwibGlnaHRncmVlblwiOiAgWzE0NCwgMjM4LCAxNDRdLFxuICAgICAgICBcImxpZ2h0Z3JleVwiOiAgWzIxMSwgMjExLCAyMTFdLFxuICAgICAgICBcImxpZ2h0cGlua1wiOiAgWzI1NSwgMTgyLCAxOTNdLFxuICAgICAgICBcImxpZ2h0c2FsbW9uXCI6ICBbMjU1LCAxNjAsIDEyMl0sXG4gICAgICAgIFwibGlnaHRzZWFncmVlblwiOiAgWzMyLCAxNzgsIDE3MF0sXG4gICAgICAgIFwibGlnaHRza3libHVlXCI6ICBbMTM1LCAyMDYsIDI1MF0sXG4gICAgICAgIFwibGlnaHRzbGF0ZWdyYXlcIjogIFsxMTksIDEzNiwgMTUzXSxcbiAgICAgICAgXCJsaWdodHNsYXRlZ3JleVwiOiAgWzExOSwgMTM2LCAxNTNdLFxuICAgICAgICBcImxpZ2h0c3RlZWxibHVlXCI6ICBbMTc2LCAxOTYsIDIyMl0sXG4gICAgICAgIFwibGlnaHR5ZWxsb3dcIjogIFsyNTUsIDI1NSwgMjI0XSxcbiAgICAgICAgXCJsaW1lXCI6ICBbMCwgMjU1LCAwXSxcbiAgICAgICAgXCJsaW1lZ3JlZW5cIjogIFs1MCwgMjA1LCA1MF0sXG4gICAgICAgIFwibGluZW5cIjogIFsyNTAsIDI0MCwgMjMwXSxcbiAgICAgICAgXCJtYWdlbnRhXCI6ICBbMjU1LCAwLCAyNTVdLFxuICAgICAgICBcIm1hcm9vblwiOiAgWzEyOCwgMCwgMF0sXG4gICAgICAgIFwibWVkaXVtYXF1YW1hcmluZVwiOiAgWzEwMiwgMjA1LCAxNzBdLFxuICAgICAgICBcIm1lZGl1bWJsdWVcIjogIFswLCAwLCAyMDVdLFxuICAgICAgICBcIm1lZGl1bW9yY2hpZFwiOiAgWzE4NiwgODUsIDIxMV0sXG4gICAgICAgIFwibWVkaXVtcHVycGxlXCI6ICBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogIFs2MCwgMTc5LCAxMTNdLFxuICAgICAgICBcIm1lZGl1bXNsYXRlYmx1ZVwiOiAgWzEyMywgMTA0LCAyMzhdLFxuICAgICAgICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6ICBbMCwgMjUwLCAxNTRdLFxuICAgICAgICBcIm1lZGl1bXR1cnF1b2lzZVwiOiAgWzcyLCAyMDksIDIwNF0sXG4gICAgICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6ICBbMTk5LCAyMSwgMTMzXSxcbiAgICAgICAgXCJtaWRuaWdodGJsdWVcIjogIFsyNSwgMjUsIDExMl0sXG4gICAgICAgIFwibWludGNyZWFtXCI6ICBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgICAgIFwibWlzdHlyb3NlXCI6ICBbMjU1LCAyMjgsIDIyNV0sXG4gICAgICAgIFwibW9jY2FzaW5cIjogIFsyNTUsIDIyOCwgMTgxXSxcbiAgICAgICAgXCJuYXZham93aGl0ZVwiOiAgWzI1NSwgMjIyLCAxNzNdLFxuICAgICAgICBcIm5hdnlcIjogIFswLCAwLCAxMjhdLFxuICAgICAgICBcIm9sZGxhY2VcIjogIFsyNTMsIDI0NSwgMjMwXSxcbiAgICAgICAgXCJvbGl2ZVwiOiAgWzEyOCwgMTI4LCAwXSxcbiAgICAgICAgXCJvbGl2ZWRyYWJcIjogIFsxMDcsIDE0MiwgMzVdLFxuICAgICAgICBcIm9yYW5nZVwiOiAgWzI1NSwgMTY1LCAwXSxcbiAgICAgICAgXCJvcmFuZ2VyZWRcIjogIFsyNTUsIDY5LCAwXSxcbiAgICAgICAgXCJvcmNoaWRcIjogIFsyMTgsIDExMiwgMjE0XSxcbiAgICAgICAgXCJwYWxlZ29sZGVucm9kXCI6ICBbMjM4LCAyMzIsIDE3MF0sXG4gICAgICAgIFwicGFsZWdyZWVuXCI6ICBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgICAgIFwicGFsZXR1cnF1b2lzZVwiOiAgWzE3NSwgMjM4LCAyMzhdLFxuICAgICAgICBcInBhbGV2aW9sZXRyZWRcIjogIFsyMTksIDExMiwgMTQ3XSxcbiAgICAgICAgXCJwYXBheWF3aGlwXCI6ICBbMjU1LCAyMzksIDIxM10sXG4gICAgICAgIFwicGVhY2hwdWZmXCI6ICBbMjU1LCAyMTgsIDE4NV0sXG4gICAgICAgIFwicGVydVwiOiAgWzIwNSwgMTMzLCA2M10sXG4gICAgICAgIFwicGlua1wiOiAgWzI1NSwgMTkyLCAyMDNdLFxuICAgICAgICBcInBsdW1cIjogIFsyMjEsIDE2MCwgMjIxXSxcbiAgICAgICAgXCJwb3dkZXJibHVlXCI6ICBbMTc2LCAyMjQsIDIzMF0sXG4gICAgICAgIFwicHVycGxlXCI6ICBbMTI4LCAwLCAxMjhdLFxuICAgICAgICBcInJlZFwiOiAgWzI1NSwgMCwgMF0sXG4gICAgICAgIFwicm9zeWJyb3duXCI6ICBbMTg4LCAxNDMsIDE0M10sXG4gICAgICAgIFwicm95YWxibHVlXCI6ICBbNjUsIDEwNSwgMjI1XSxcbiAgICAgICAgXCJzYWRkbGVicm93blwiOiAgWzEzOSwgNjksIDE5XSxcbiAgICAgICAgXCJzYWxtb25cIjogIFsyNTAsIDEyOCwgMTE0XSxcbiAgICAgICAgXCJzYW5keWJyb3duXCI6ICBbMjQ0LCAxNjQsIDk2XSxcbiAgICAgICAgXCJzZWFncmVlblwiOiAgWzQ2LCAxMzksIDg3XSxcbiAgICAgICAgXCJzZWFzaGVsbFwiOiAgWzI1NSwgMjQ1LCAyMzhdLFxuICAgICAgICBcInNpZW5uYVwiOiAgWzE2MCwgODIsIDQ1XSxcbiAgICAgICAgXCJzaWx2ZXJcIjogIFsxOTIsIDE5MiwgMTkyXSxcbiAgICAgICAgXCJza3libHVlXCI6ICBbMTM1LCAyMDYsIDIzNV0sXG4gICAgICAgIFwic2xhdGVibHVlXCI6ICBbMTA2LCA5MCwgMjA1XSxcbiAgICAgICAgXCJzbGF0ZWdyYXlcIjogIFsxMTIsIDEyOCwgMTQ0XSxcbiAgICAgICAgXCJzbGF0ZWdyZXlcIjogIFsxMTIsIDEyOCwgMTQ0XSxcbiAgICAgICAgXCJzbm93XCI6ICBbMjU1LCAyNTAsIDI1MF0sXG4gICAgICAgIFwic3ByaW5nZ3JlZW5cIjogIFswLCAyNTUsIDEyN10sXG4gICAgICAgIFwic3RlZWxibHVlXCI6ICBbNzAsIDEzMCwgMTgwXSxcbiAgICAgICAgXCJ0YW5cIjogIFsyMTAsIDE4MCwgMTQwXSxcbiAgICAgICAgXCJ0ZWFsXCI6ICBbMCwgMTI4LCAxMjhdLFxuICAgICAgICBcInRoaXN0bGVcIjogIFsyMTYsIDE5MSwgMjE2XSxcbiAgICAgICAgXCJ0b21hdG9cIjogIFsyNTUsIDk5LCA3MV0sXG4gICAgICAgIFwidHVycXVvaXNlXCI6ICBbNjQsIDIyNCwgMjA4XSxcbiAgICAgICAgXCJ2aW9sZXRcIjogIFsyMzgsIDEzMCwgMjM4XSxcbiAgICAgICAgXCJ3aGVhdFwiOiAgWzI0NSwgMjIyLCAxNzldLFxuICAgICAgICBcIndoaXRlXCI6ICBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICAgIFwid2hpdGVzbW9rZVwiOiAgWzI0NSwgMjQ1LCAyNDVdLFxuICAgICAgICBcInllbGxvd1wiOiAgWzI1NSwgMjU1LCAwXSxcbiAgICAgICAgXCJ5ZWxsb3dncmVlblwiOiAgWzE1NCwgMjA1LCA1MF0sXG4gICAgICAgIFwidHJhbnNwYXJlbnRcIjogIFswLCAwLCAwLCAwXVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJzaW9uOiB7XG4gICAgbGF0ZXN0OiBfdG9ycXVlX3JlZmVyZW5jZV9sYXRlc3QsXG4gICAgJzEuMC4wJzogX3RvcnF1ZV9yZWZlcmVuY2VfbGF0ZXN0XG4gIH1cbn07XG4iLCIvL1xuLy8gY29tbW9uIGZ1bmN0aW9uYWxsaXR5IGZvciB0b3JxdWUgbGF5ZXJzXG4vL1xudmFyIGNhcnRvID0gZ2xvYmFsLmNhcnRvIHx8IHJlcXVpcmUoJ2NhcnRvJyk7XG5cbmZ1bmN0aW9uIFRvcnF1ZUxheWVyKCkge31cblxuVG9ycXVlTGF5ZXIucHJvdG90eXBlID0ge1xufTtcblxuVG9ycXVlTGF5ZXIub3B0aW9uc0Zyb21MYXllciA9IGZ1bmN0aW9uKG1hcENvbmZpZykge1xuICB2YXIgb3B0cyA9IHt9O1xuICBpZiAoIW1hcENvbmZpZykgcmV0dXJuIG9wdHM7XG4gIHZhciBhdHRycyA9IHtcbiAgICAnYnVmZmVyLXNpemUnOiAnYnVmZmVyLXNpemUnLFxuICAgICctdG9ycXVlLWZyYW1lLWNvdW50JzogJ3N0ZXBzJyxcbiAgICAnLXRvcnF1ZS1yZXNvbHV0aW9uJzogJ3Jlc29sdXRpb24nLFxuICAgICctdG9ycXVlLWFuaW1hdGlvbi1kdXJhdGlvbic6ICdhbmltYXRpb25EdXJhdGlvbicsXG4gICAgJy10b3JxdWUtYWdncmVnYXRpb24tZnVuY3Rpb24nOiAnY291bnRieScsXG4gICAgJy10b3JxdWUtdGltZS1hdHRyaWJ1dGUnOiAnY29sdW1uJyxcbiAgICAnLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uJzogJ2RhdGFfYWdncmVnYXRpb24nXG4gIH07XG4gIGZvciAodmFyIGkgaW4gYXR0cnMpIHtcbiAgICB2YXIgdiA9IG1hcENvbmZpZy5ldmFsKGkpO1xuICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBhID0gYXR0cnNbaV07XG4gICAgICBvcHRzW2FdID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG5Ub3JxdWVMYXllci5vcHRpb25zRnJvbUNhcnRvQ1NTID0gZnVuY3Rpb24oY2FydG9jc3MpIHtcbiAgdmFyIHNoYWRlciA9IG5ldyBjYXJ0by5SZW5kZXJlckpTKCkucmVuZGVyKGNhcnRvY3NzKTtcbiAgdmFyIG1hcENvbmZpZyA9IHNoYWRlci5maW5kTGF5ZXIoeyBuYW1lOiAnTWFwJyB9KTtcbiAgcmV0dXJuIFRvcnF1ZUxheWVyLm9wdGlvbnNGcm9tTGF5ZXIobWFwQ29uZmlnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRvcnF1ZUxheWVyID0gVG9ycXVlTGF5ZXI7XG4iLCIgIHZhciBFdmVudCA9IHt9O1xuICBFdmVudC5vbiA9IGZ1bmN0aW9uKGV2dCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBjYiA9IHRoaXMuX2V2dF9jYWxsYmFja3MgPSB0aGlzLl9ldnRfY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgdmFyIGwgPSBjYltldnRdIHx8IChjYltldnRdID0gW10pO1xuICAgICAgbC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50LnRyaWdnZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBjID0gdGhpcy5fZXZ0X2NhbGxiYWNrcyAmJiB0aGlzLl9ldnRfY2FsbGJhY2tzW2V2dF07XG4gICAgICBmb3IodmFyIGkgPSAwOyBjICYmIGkgPCBjLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY1tpXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50LmZpcmUgPSBFdmVudC50cmlnZ2VyO1xuXG4gIEV2ZW50Lm9mZiA9IGZ1bmN0aW9uIChldnQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2V2dF9jYWxsYmFja3MgJiYgdGhpcy5fZXZ0X2NhbGxiYWNrc1tldnRdO1xuICAgICAgaWYgKGMgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldnRfY2FsbGJhY2tzW2V2dF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICB9XG4gICAgIHZhciByZW1vdmUgPSBbXTtcbiAgICAgZm9yKHZhciBpID0gMDsgYyAmJiBpIDwgYy5sZW5ndGg7ICsraSkge1xuICAgICAgIGlmKGNbaV0gPT09IGNhbGxiYWNrKSByZW1vdmUucHVzaChpKTtcbiAgICAgfVxuICAgICB3aGlsZSgoaSA9IHJlbW92ZS5wb3AoKSkgIT09IHVuZGVmaW5lZCkgYy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnQuY2FsbGJhY2tzID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgcmV0dXJuICh0aGlzLl9ldnRfY2FsbGJhY2tzICYmIHRoaXMuX2V2dF9jYWxsYmFja3NbZXZ0XSkgfHwgW107XG4gIH07XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgICAgdmFyIG9ianMgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYSA9IG9ianNbMF07XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9ianMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgYiA9IG9ianNbaV07XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBiKSB7XG4gICAgICAgICAgICAgIGFba10gPSBiW2tdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHJldHVybiBleHRlbmQoe30sIGEpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfVxuXG4gIC8vIHR5cGVzXG4gIHZhciB0eXBlcyA9IHtcbiAgICBVaW50OEFycmF5OiB0eXBlb2YoZ2xvYmFsWydVaW50OEFycmF5J10pICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC5VaW50OEFycmF5IDogQXJyYXksXG4gICAgVWludDhDbGFtcGVkQXJyYXk6IHR5cGVvZihnbG9iYWxbJ1VpbnQ4Q2xhbXBlZEFycmF5J10pICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTogQXJyYXksXG4gICAgVWludDMyQXJyYXk6IHR5cGVvZihnbG9iYWxbJ1VpbnQzMkFycmF5J10pICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC5VaW50MzJBcnJheSA6IEFycmF5LFxuICAgIEludDE2QXJyYXk6IHR5cGVvZihnbG9iYWxbJ0ludDE2QXJyYXknXSkgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsLkludDE2QXJyYXkgOiBBcnJheSxcbiAgICBJbnQzMkFycmF5OiB0eXBlb2YoZ2xvYmFsWydJbnQzMkFycmF5J10pICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC5JbnQzMkFycmF5OiBBcnJheVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZXJBZ2VudCgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAnJztcbiAgfVxuXG4gIHZhciBmbGFncyA9IHtcbiAgICBzcHJpdGVzX3RvX2ltYWdlczogdXNlckFnZW50KCkuaW5kZXhPZignU2FmYXJpJykgPT09IC0xICYmIHVzZXJBZ2VudCgpLmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTFcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXZlbnQ6IEV2ZW50LFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgdHlwZXM6IHR5cGVzLFxuICAgIGlzQnJvd3NlclN1cHBvcnRlZDogaXNCcm93c2VyU3VwcG9ydGVkLFxuICAgIGZsYWdzOiBmbGFnc1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlbmRzIE92ZXJsYXlWaWV3IHRvIHByb3ZpZGUgYSBjYW52YXMgXCJMYXllclwiLlxuICogQGF1dGhvciBCcmVuZGFuIEtlbm55XG4gKi9cblxuLyoqXG4gKiBBIG1hcCBsYXllciB0aGF0IHByb3ZpZGVzIGEgY2FudmFzIG92ZXIgdGhlIHNsaXBweSBtYXAgYW5kIGEgY2FsbGJhY2tcbiAqIHN5c3RlbSBmb3IgZWZmaWNpZW50IGFuaW1hdGlvbi4gUmVxdWlyZXMgY2FudmFzIGFuZCBDU1MgMkQgdHJhbnNmb3JtXG4gKiBzdXBwb3J0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBnb29nbGUubWFwcy5PdmVybGF5Vmlld1xuICogQHBhcmFtIHtDYW52YXNMYXllck9wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zIHRvIHNldCBpbiB0aGlzIENhbnZhc0xheWVyLlxuICovXG5cbmZ1bmN0aW9uIENhbnZhc0xheWVyKG9wdF9vcHRpb25zKSB7XG4gIC8qKlxuICAgKiBJZiB0cnVlLCBjYW52YXMgaXMgaW4gYSBtYXAgcGFuZSBhbmQgdGhlIE92ZXJsYXlWaWV3IGlzIGZ1bGx5IGZ1bmN0aW9uYWwuXG4gICAqIFNlZSBnb29nbGUubWFwcy5PdmVybGF5Vmlldy5vbkFkZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzQWRkZWRfID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGVhY2ggdXBkYXRlIHdpbGwgaW1tZWRpYXRlbHkgc2NoZWR1bGUgdGhlIG5leHQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc0FuaW1hdGVkXyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgTWFwUGFuZSBpbiB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wYW5lTmFtZV8gPSBDYW52YXNMYXllci5ERUZBVUxUX1BBTkVfTkFNRV87XG5cbiAgLyoqXG4gICAqIEEgdXNlci1zdXBwbGllZCBmdW5jdGlvbiBjYWxsZWQgd2hlbmV2ZXIgYW4gdXBkYXRlIGlzIHJlcXVpcmVkLiBOdWxsIG9yXG4gICAqIHVuZGVmaW5lZCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZC5cbiAgICogQHR5cGUgez9mdW5jdGlvbj19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gbnVsbDtcblxuICAvKipcbiAgICogQSB1c2VyLXN1cHBsaWVkIGZ1bmN0aW9uIGNhbGxlZCB3aGVuZXZlciBhbiB1cGRhdGUgaXMgcmVxdWlyZWQgYW5kIHRoZVxuICAgKiBtYXAgaGFzIGJlZW4gcmVzaXplZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuIE51bGwgb3IgdW5kZWZpbmVkIGlmIGFcbiAgICogY2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkLlxuICAgKiBAdHlwZSB7P2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZXNpemVIYW5kbGVyXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBMYXRMbmcgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgb2YgdGhlIGN1cnJlbnQgdmlldyBvZiB0aGUgbWFwLiBXaWxsXG4gICAqIGJlIG51bGwgd2hlbiB0aGlzLmlzQWRkZWRfIGlzIGZhbHNlLlxuICAgKiBAdHlwZSB7Z29vZ2xlLm1hcHMuTGF0TG5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50b3BMZWZ0XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXAtcGFuIGV2ZW50IGxpc3RlbmVyLiBXaWxsIGJlIG51bGwgd2hlbiB0aGlzLmlzQWRkZWRfIGlzIGZhbHNlLiBXaWxsXG4gICAqIGJlIG51bGwgd2hlbiB0aGlzLmlzQWRkZWRfIGlzIGZhbHNlLlxuICAgKiBAdHlwZSB7P2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jZW50ZXJMaXN0ZW5lcl8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWFwLXJlc2l6ZSBldmVudCBsaXN0ZW5lci4gV2lsbCBiZSBudWxsIHdoZW4gdGhpcy5pc0FkZGVkXyBpcyBmYWxzZS5cbiAgICogQHR5cGUgez9mdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVzaXplTGlzdGVuZXJfID0gbnVsbDtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIG1hcCBzaXplIGhhcyBjaGFuZ2VkIGFuZCB0aGlzLnJlc2l6ZUhhbmRsZXJfIG11c3QgYmUgY2FsbGVkXG4gICAqIG9uIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm5lZWRzUmVzaXplXyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEEgYnJvd3Nlci1kZWZpbmVkIGlkIGZvciB0aGUgY3VycmVudGx5IHJlcXVlc3RlZCBjYWxsYmFjay4gTnVsbCB3aGVuIG5vXG4gICAqIGNhbGxiYWNrIGlzIHF1ZXVlZC5cbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlkXyA9IG51bGw7XG5cbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBjYW52YXMuc3R5bGUudG9wID0gMDtcbiAgY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAvKipcbiAgICogVGhlIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAdHlwZSB7IUhUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBiaW5kIGZvciBmdW5jdGlvbnMgd2l0aCBubyBhcmdzIGZvciBiaW5kLWxlc3MgYnJvd3NlcnMgKFNhZmFyaSkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSB0aGlzIHZhbHVlIHVzZWQgZm9yIHRoZSB0YXJnZXQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJlIGJvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gc2ltcGxlQmluZFNoaW0odGhpc0FyZywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh0aGlzQXJnKTsgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGlzLnJlcG9zaXRpb25DYW52YXNfIHdpdGggdGhpcyBib3VuZCBhcyBpdHMgdGhpcyB2YWx1ZS5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZXBvc2l0aW9uRnVuY3Rpb25fID0gc2ltcGxlQmluZFNoaW0odGhpcywgdGhpcy5yZXBvc2l0aW9uQ2FudmFzXyk7XG5cbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoaXMucmVzaXplXyB3aXRoIHRoaXMgYm91bmQgYXMgaXRzIHRoaXMgdmFsdWUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVzaXplRnVuY3Rpb25fID0gc2ltcGxlQmluZFNoaW0odGhpcywgdGhpcy5yZXNpemVfKTtcblxuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdGhpcy51cGRhdGVfIHdpdGggdGhpcyBib3VuZCBhcyBpdHMgdGhpcyB2YWx1ZS5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZXF1ZXN0VXBkYXRlRnVuY3Rpb25fID0gc2ltcGxlQmluZFNoaW0odGhpcywgdGhpcy51cGRhdGVfKTtcblxuICAvLyBzZXQgcHJvdmlkZWQgb3B0aW9ucywgaWYgYW55XG4gIGlmIChvcHRfb3B0aW9ucykge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRfb3B0aW9ucyk7XG4gIH1cbn1cblxuQ2FudmFzTGF5ZXIucHJvdG90eXBlID0gbmV3IGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KCk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgTWFwUGFuZSB0byBjb250YWluIHRoZSBjYW52YXMuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNMYXllci5ERUZBVUxUX1BBTkVfTkFNRV8gPSAnb3ZlcmxheUxheWVyJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gQ1NTIHByb3BlcnR5IG5hbWUsIHdpdGggdmVuZG9yIHByZWZpeCBpZiByZXF1aXJlZC4gSWYgYnJvd3NlclxuICogZG9lcyBub3Qgc3VwcG9ydCB0cmFuc2Zvcm1zLCBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNMYXllci5DU1NfVFJBTlNGT1JNXyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgdHJhbnNmb3JtUHJvcHMgPSBbXG4gICAgJ3RyYW5zZm9ybScsXG4gICAgJ1dlYmtpdFRyYW5zZm9ybScsXG4gICAgJ01velRyYW5zZm9ybScsXG4gICAgJ09UcmFuc2Zvcm0nLFxuICAgICdtc1RyYW5zZm9ybSdcbiAgXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gdHJhbnNmb3JtUHJvcHNbaV07XG4gICAgaWYgKGRpdi5zdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdW5wcmVmaXhlZCB2ZXJzaW9uIGJ5IGRlZmF1bHRcbiAgcmV0dXJuIHRyYW5zZm9ybVByb3BzWzBdO1xufSkoKTtcblxuLyoqXG4gKiBUaGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9uLCB3aXRoIHZlbmRvci1wcmVmaXhlZCBvciBzZXRUaW1lb3V0LWJhc2VkXG4gKiBmYWxsYmFja3MuIE1VU1QgYmUgY2FsbGVkIHdpdGggd2luZG93IGFzIHRoaXNBcmcuXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gYWRkIHRvIHRoZSBmcmFtZSByZXF1ZXN0IHF1ZXVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYnJvd3Nlci1kZWZpbmVkIGlkIGZvciB0aGUgcmVxdWVzdGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnJlcXVlc3RBbmltRnJhbWVfID1cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgfTtcblxuLyoqXG4gKiBUaGUgY2FuY2VsQW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24sIHdpdGggdmVuZG9yLXByZWZpeGVkIGZhbGxiYWNrLiBEb2VzIG5vdFxuICogZmFsbCBiYWNrIHRvIGNsZWFyVGltZW91dCBhcyBzb21lIHBsYXRmb3JtcyBpbXBsZW1lbnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBidXQgbm90IGNhbmNlbEFuaW1hdGlvbkZyYW1lLCBhbmQgdGhlIGNvc3QgaXMgYW4gZXh0cmEgZnJhbWUgb24gb25SZW1vdmUuXG4gKiBNVVNUIGJlIGNhbGxlZCB3aXRoIHdpbmRvdyBhcyB0aGlzQXJnLlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtudW1iZXI9fSByZXF1ZXN0SWQgVGhlIGlkIG9mIHRoZSBmcmFtZSByZXF1ZXN0IHRvIGNhbmNlbC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5jYW5jZWxBbmltRnJhbWVfID1cbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihyZXF1ZXN0SWQpIHt9O1xuXG4vKipcbiAqIFNldHMgYW55IG9wdGlvbnMgcHJvdmlkZWQuIFNlZSBDYW52YXNMYXllck9wdGlvbnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge0NhbnZhc0xheWVyT3B0aW9uc30gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byBzZXQuXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldEFuaW1hdGUob3B0aW9ucy5hbmltYXRlKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnBhbmVOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFBhbmUob3B0aW9ucy5wYW5lTmFtZSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy51cGRhdGVIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFVwZGF0ZUhhbmRsZXIob3B0aW9ucy51cGRhdGVIYW5kbGVyKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlc2l6ZUhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2V0UmVzaXplSGFuZGxlcihvcHRpb25zLnJlc2l6ZUhhbmRsZXIpO1xuICB9XG5cbiAgaWYob3B0aW9ucy5yZWFkeUhhbmRsZXIpIHtcbiAgICB0aGlzLnJlYWR5SGFuZGxlciA9IG9wdGlvbnMucmVhZHlIYW5kbGVyO1xuICB9XG5cbn07XG5cbi8qKlxuICogU2V0IHRoZSBhbmltYXRlZCBzdGF0ZSBvZiB0aGUgbGF5ZXIuIElmIHRydWUsIHVwZGF0ZUhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcbiAqIHJlcGVhdGVkbHksIG9uY2UgcGVyIGZyYW1lLiBJZiBmYWxzZSwgdXBkYXRlSGFuZGxlciB3aWxsIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIGEgbWFwIHByb3BlcnR5IGNoYW5nZXMgdGhhdCBjb3VsZCByZXF1aXJlIHRoZSBjYW52YXMgY29udGVudCB0byBiZSByZWRyYXduLlxuICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIFdoZXRoZXIgdGhlIGNhbnZhcyBpcyBhbmltYXRlZC5cbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnNldEFuaW1hdGUgPSBmdW5jdGlvbihhbmltYXRlKSB7XG4gIHRoaXMuaXNBbmltYXRlZF8gPSAhIWFuaW1hdGU7XG5cbiAgaWYgKHRoaXMuaXNBbmltYXRlZF8pIHtcbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY2FudmFzIGlzIGFuaW1hdGVkLlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuaXNBbmltYXRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc0FuaW1hdGVkXztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBNYXBQYW5lIGluIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQsIGJ5IG5hbWUuIFNlZVxuICoge0Bjb2RlIGdvb2dsZS5tYXBzLk1hcFBhbmVzfSBmb3IgdGhlIHBhbmVzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYW5lTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVzaXJlZCBNYXBQYW5lLlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuc2V0UGFuZU5hbWUgPSBmdW5jdGlvbihwYW5lTmFtZSkge1xuICB0aGlzLnBhbmVOYW1lXyA9IHBhbmVOYW1lO1xuXG4gIHRoaXMuc2V0UGFuZV8oKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBvcGFjaXR5IGZvciB0aGUgY2FudmFzLlxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBUaGUgb3BhY2l0eSBvZiB0aGUgY2FudmFzXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgdGhpcy5jYW52YXMuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY2FudmFzZXMgb3BhY2l0eS5cbiAqIFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgb3BhY2l0eSBvZiB0aGUgY2FudmFzXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5nZXRPcGFjaXR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuc3R5bGUub3BhY2l0eTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBjb250YWluZXIgcGFuZS5cbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLmdldFBhbmVOYW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhbmVOYW1lXztcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyIHBhbmUuIFNpbmNlIHRoaXMgaXMgZ3VhcmFudGVlZCB0b1xuICogZXhlY3V0ZSBvbmx5IGFmdGVyIG9uQWRkIGlzIGNhbGxlZCwgdGhpcyBpcyB3aGVuIHBhbmVOYW1lJ3MgZXhpc3RlbmNlIGlzXG4gKiBjaGVja2VkIChhbmQgYW4gZXJyb3IgaXMgdGhyb3duIGlmIGl0IGRvZXNuJ3QgZXhpc3QpLlxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnNldFBhbmVfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc0FkZGVkXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG9uQWRkIGhhcyBiZWVuIGNhbGxlZCwgc28gcGFuZXMgY2FuIGJlIHVzZWRcbiAgdmFyIHBhbmVzID0gdGhpcy5nZXRQYW5lcygpO1xuICBpZiAoIXBhbmVzW3RoaXMucGFuZU5hbWVfXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgdGhpcy5wYW5lTmFtZV8gKyAnXCIgaXMgbm90IGEgdmFsaWQgTWFwUGFuZSBuYW1lLicpO1xuICB9XG5cbiAgcGFuZXNbdGhpcy5wYW5lTmFtZV9dLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbn07XG5cbi8qKlxuICogU2V0IGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgcGFyZW50IG1hcCBhbmQgdGhlIG92ZXJsYXknc1xuICogY2FudmFzIGhhdmUgYmVlbiByZXNpemVkLiBJZiBvcHRfcmVzaXplSGFuZGxlciBpcyBudWxsIG9yIHVuc3BlY2lmaWVkLCBhbnlcbiAqIGV4aXN0aW5nIGNhbGxiYWNrIGlzIHJlbW92ZWQuXG4gKiBAcGFyYW0gez9mdW5jdGlvbj19IG9wdF9yZXNpemVIYW5kbGVyIFRoZSByZXNpemUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5zZXRSZXNpemVIYW5kbGVyID0gZnVuY3Rpb24ob3B0X3Jlc2l6ZUhhbmRsZXIpIHtcbiAgdGhpcy5yZXNpemVIYW5kbGVyXyA9IG9wdF9yZXNpemVIYW5kbGVyO1xufTtcblxuLyoqXG4gKiBTZXQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSByZXBhaW50IG9mIHRoZSBjYW52YXMgaXMgcmVxdWlyZWQuXG4gKiBJZiBvcHRfdXBkYXRlSGFuZGxlciBpcyBudWxsIG9yIHVuc3BlY2lmaWVkLCBhbnkgZXhpc3RpbmcgY2FsbGJhY2sgaXNcbiAqIHJlbW92ZWQuXG4gKiBAcGFyYW0gez9mdW5jdGlvbj19IG9wdF91cGRhdGVIYW5kbGVyIFRoZSB1cGRhdGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5zZXRVcGRhdGVIYW5kbGVyID0gZnVuY3Rpb24ob3B0X3VwZGF0ZUhhbmRsZXIpIHtcbiAgdGhpcy51cGRhdGVIYW5kbGVyXyA9IG9wdF91cGRhdGVIYW5kbGVyO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNBZGRlZF8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzQWRkZWRfID0gdHJ1ZTtcbiAgdGhpcy5zZXRQYW5lXygpO1xuXG4gIHRoaXMucmVzaXplTGlzdGVuZXJfID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5nZXRNYXAoKSxcbiAgICAgICdyZXNpemUnLCB0aGlzLnJlc2l6ZUZ1bmN0aW9uXyk7XG4gIHRoaXMuY2VudGVyTGlzdGVuZXJfID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5nZXRNYXAoKSxcbiAgICAgICdjZW50ZXJfY2hhbmdlZCcsIHRoaXMucmVwb3NpdGlvbkZ1bmN0aW9uXyk7XG5cbiAgdGhpcy5yZXNpemVfKCk7XG4gIHRoaXMucmVwb3NpdGlvbkNhbnZhc18oKTtcbiAgdGhpcy5yZWFkeUhhbmRsZXIgJiYgdGhpcy5yZWFkeUhhbmRsZXIoKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc0FkZGVkXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuaXNBZGRlZF8gPSBmYWxzZTtcbiAgdGhpcy50b3BMZWZ0XyA9IG51bGw7XG5cbiAgLy8gcmVtb3ZlIGNhbnZhcyBhbmQgbGlzdGVuZXJzIGZvciBwYW4gYW5kIHJlc2l6ZSBmcm9tIG1hcFxuICB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgaWYgKHRoaXMuY2VudGVyTGlzdGVuZXJfKSB7XG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5jZW50ZXJMaXN0ZW5lcl8pO1xuICAgIHRoaXMuY2VudGVyTGlzdGVuZXJfID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5yZXNpemVMaXN0ZW5lcl8pIHtcbiAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlc2l6ZUxpc3RlbmVyXyk7XG4gICAgdGhpcy5yZXNpemVMaXN0ZW5lcl8gPSBudWxsO1xuICB9XG5cbiAgLy8gY2Vhc2UgY2FudmFzIHVwZGF0ZSBjYWxsYmFja3NcbiAgaWYgKHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSWRfKSB7XG4gICAgdGhpcy5jYW5jZWxBbmltRnJhbWVfLmNhbGwod2luZG93LCB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlkXyk7XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJZF8gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCBjYWxsYmFjayBmb3IgcmVzaXplIGV2ZW50cyB0aGF0IHJlc2l6ZXMgdGhlIGNhbnZhcyB0byBrZWVwIHRoZVxuICogbWFwIHByb3Blcmx5IGNvdmVyZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUucmVzaXplXyA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPKGJja2VubnkpOiBpdCdzIGNvbW1vbiB0byB1c2UgYSBzbWFsbGVyIGNhbnZhcyBidXQgdXNlIENTUyB0byBzY2FsZVxuICAvLyB3aGF0IGlzIGRyYXduIGJ5IHRoZSBicm93c2VyIHRvIHNhdmUgb24gZmlsbCByYXRlLiBBZGQgYW4gb3B0aW9uIHRvIGRvXG4gIC8vIHRoaXMuXG5cbiAgaWYgKCF0aGlzLmlzQWRkZWRfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gIHZhciB3aWR0aCA9IG1hcC5nZXREaXYoKS5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IG1hcC5nZXREaXYoKS5vZmZzZXRIZWlnaHQ7XG4gIHZhciBvbGRXaWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG4gIC8vIHJlc2l6aW5nIG1heSBhbGxvY2F0ZSBhIG5ldyBiYWNrIGJ1ZmZlciwgc28gZG8gc28gY29uc2VydmF0aXZlbHlcbiAgaWYgKG9sZFdpZHRoICE9PSB3aWR0aCB8fCBvbGRIZWlnaHQgIT09IGhlaWdodCkge1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICB0aGlzLm5lZWRzUmVzaXplXyA9IHRydWU7XG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVwb3NpdGlvbkNhbnZhc18oKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgY2FsbGJhY2sgZm9yIG1hcCB2aWV3IGNoYW5nZXMuIFNpbmNlIHRoZSBNYXBzIEFQSSBtb3ZlcyB0aGUgb3ZlcmxheVxuICogYWxvbmcgd2l0aCB0aGUgbWFwLCB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIG9wcG9zaXRlIHRyYW5zbGF0aW9uIHRvXG4gKiBrZWVwIHRoZSBjYW52YXMgaW4gcGxhY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUucmVwb3NpdGlvbkNhbnZhc18gPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETyhiY2tlbm55KTogKnNob3VsZCogb25seSBiZSBleGVjdXRlZCBvbiBSQUYsIGJ1dCBpbiBjdXJyZW50IGJyb3dzZXJzXG4gIC8vICAgICB0aGlzIGNhdXNlcyBub3RpY2VhYmxlIGhpdGNoZXMgaW4gbWFwIGFuZCBvdmVybGF5IHJlbGF0aXZlXG4gIC8vICAgICBwb3NpdGlvbmluZy5cblxuICB2YXIgYm91bmRzID0gdGhpcy5nZXRNYXAoKS5nZXRCb3VuZHMoKTtcbiAgdGhpcy50b3BMZWZ0XyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLmdldE5vcnRoRWFzdCgpLmxhdCgpLFxuICAgICAgYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZygpKTtcblxuICAvLyBjYW52YXMgcG9zaXRpb24gcmVsYXRpdmUgdG8gZHJhZ2dhYmxlIG1hcCdzIGNvbmF0YWluZXIgZGVwZW5kcyBvblxuICAvLyBvdmVybGF5VmlldydzIHByb2plY3Rpb24sIG5vdCB0aGUgbWFwJ3NcbiAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgdmFyIGRpdlRvcExlZnQgPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKHRoaXMudG9wTGVmdF8pO1xuXG4gIC8vIHdoZW4gdGhlIHpvb20gbGV2ZWwgaXMgbG93LCBtb3JlIHRoYW4gb25lIG1hcCBjYW4gYmUgc2hvd24gaW4gdGhlIHNjcmVlblxuICAvLyBzbyB0aGUgY2FudmFzIHNob3VsZCBiZSBhdHRhY2ggdG8gdGhlIG1hcCB3aXRoIG1vcmUgYXJlIGluIHRoZSBzY3JlZW5cbiAgdmFyIG1hcFNpemUgPSAoMSA8PCB0aGlzLmdldE1hcCgpLmdldFpvb20oKSkqMjU2O1xuICBpZiAoTWF0aC5hYnMoZGl2VG9wTGVmdC54KSA+IG1hcFNpemUpIHtcbiAgICBkaXZUb3BMZWZ0LnggLT0gbWFwU2l6ZTtcbiAgfVxuICB0aGlzLmNhbnZhcy5zdHlsZVtDYW52YXNMYXllci5DU1NfVFJBTlNGT1JNX10gPSAndHJhbnNsYXRlKCcgK1xuICAgICAgTWF0aC5yb3VuZChkaXZUb3BMZWZ0LngpICsgJ3B4LCcgKyBNYXRoLnJvdW5kKGRpdlRvcExlZnQueSkgKyAncHgpJztcblxuICB0aGlzLnNjaGVkdWxlVXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGNhbGxiYWNrIHRoYXQgc2VydmVzIGFzIG1haW4gYW5pbWF0aW9uIHNjaGVkdWxlciB2aWFcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gQ2FsbHMgcmVzaXplIGFuZCB1cGRhdGUgY2FsbGJhY2tzIGlmIHNldCwgYW5kXG4gKiBzY2hlZHVsZXMgdGhlIG5leHQgZnJhbWUgaWYgb3ZlcmxheSBpcyBhbmltYXRlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS51cGRhdGVfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSWRfID0gbnVsbDtcblxuICBpZiAoIXRoaXMuaXNBZGRlZF8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5pc0FuaW1hdGVkXykge1xuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLm5lZWRzUmVzaXplXyAmJiB0aGlzLnJlc2l6ZUhhbmRsZXJfKSB7XG4gICAgdGhpcy5uZWVkc1Jlc2l6ZV8gPSBmYWxzZTtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfKCk7XG4gIH1cblxuICBpZiAodGhpcy51cGRhdGVIYW5kbGVyXykge1xuICAgIHRoaXMudXBkYXRlSGFuZGxlcl8oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIGNvbnZlbmllbmNlIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgTGF0TG5nIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IG9mXG4gKiB0aGUgY3VycmVudCB2aWV3IG9mIHRoZSBtYXAuXG4gKiBAcmV0dXJuIHtnb29nbGUubWFwcy5MYXRMbmd9IFRoZSB0b3AgbGVmdCBjb29yZGluYXRlLlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuZ2V0VG9wTGVmdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b3BMZWZ0Xztcbn07XG5cbi8qKlxuICogU2NoZWR1bGUgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2sgdG8gdXBkYXRlSGFuZGxlci4gSWYgb25lIGlzXG4gKiBhbHJlYWR5IHNjaGVkdWxlZCwgdGhlcmUgaXMgbm8gZWZmZWN0LlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNBZGRlZF8gJiYgIXRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSWRfKSB7XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJZF8gPVxuICAgICAgICB0aGlzLnJlcXVlc3RBbmltRnJhbWVfLmNhbGwod2luZG93LCB0aGlzLnJlcXVlc3RVcGRhdGVGdW5jdGlvbl8pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0xheWVyO1xuIiwiLypcbiA9PT09PT09PT09PT09PT09PT09PVxuIGNhbnZhcyBzZXR1cCBmb3IgZHJhd2luZyB0aWxlc1xuID09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuZnVuY3Rpb24gQ2FudmFzVGlsZUxheWVyKGNhbnZhc19zZXR1cCwgcmVuZGVyKSB7XG4gIHRoaXMudGlsZVNpemUgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSgyNTYsIDI1Nik7XG4gIHRoaXMubWF4Wm9vbSA9IDE5O1xuICB0aGlzLm5hbWUgPSBcIlRpbGUgI3NcIjtcbiAgdGhpcy5hbHQgPSBcIkNhbnZhcyB0aWxlIGxheWVyXCI7XG4gIHRoaXMudGlsZXMgPSB7fTtcbiAgdGhpcy5jYW52YXNfc2V0dXAgPSBjYW52YXNfc2V0dXA7XG4gIHRoaXMucmVuZGVyID0gcmVuZGVyO1xuICBpZiAoIXJlbmRlcikge1xuICAgICAgdGhpcy5yZW5kZXIgPSBjYW52YXNfc2V0dXA7XG4gIH1cbn1cblxuXG4vLyBjcmVhdGUgYSB0aWxlIHdpdGggYSBjYW52YXMgZWxlbWVudFxuQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZS5jcmVhdGVfdGlsZV9jYW52YXMgPSBmdW5jdGlvbiAoY29vcmQsIHpvb20sIG93bmVyRG9jdW1lbnQpIHtcblxuICAvLyBjcmVhdGUgY2FudmFzIGFuZCByZXNldCBzdHlsZVxuICB2YXIgY2FudmFzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgdmFyIGhpdF9jYW52YXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMuc3R5bGUuYm9yZGVyID0gaGl0X2NhbnZhcy5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgY2FudmFzLnN0eWxlLm1hcmdpbiA9IGhpdF9jYW52YXMuc3R5bGUubWFyZ2luID0gXCIwXCI7XG4gIGNhbnZhcy5zdHlsZS5wYWRkaW5nID0gaGl0X2NhbnZhcy5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XG5cbiAgLy8gcHJlcGFyZSBjYW52YXMgYW5kIGNvbnRleHQgc2l6ZXNcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHgud2lkdGggPSBjYW52YXMud2lkdGggPSB0aGlzLnRpbGVTaXplLndpZHRoO1xuICBjdHguaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHRoaXMudGlsZVNpemUuaGVpZ2h0O1xuXG4gIHZhciBoaXRfY3R4ID0gaGl0X2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBoaXRfY2FudmFzLndpZHRoID0gaGl0X2N0eC53aWR0aCA9IHRoaXMudGlsZVNpemUud2lkdGg7XG4gIGhpdF9jYW52YXMuaGVpZ2h0ID0gaGl0X2N0eC5oZWlnaHQgPSB0aGlzLnRpbGVTaXplLmhlaWdodDtcblxuICAvL3NldCB1bmlxdWUgaWRcbiAgdmFyIHRpbGVfaWQgPSBjb29yZC54ICsgJ18nICsgY29vcmQueSArICdfJyArIHpvb207XG5cbiAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaWQnLCB0aWxlX2lkKTtcbiAgaGl0X2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlsZV9pZCk7XG5cbiAgaWYgKHRpbGVfaWQgaW4gdGhpcy50aWxlcylcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzW3RpbGVfaWRdO1xuXG4gIHRoaXMudGlsZXNbdGlsZV9pZF0gPSB7Y2FudmFzOmNhbnZhcywgY3R4OmN0eCwgaGl0X2NhbnZhczpoaXRfY2FudmFzLCBoaXRfY3R4OmhpdF9jdHgsIGNvb3JkOmNvb3JkLCB6b29tOnpvb20sIHByaW1pdGl2ZXM6bnVsbH07XG5cbiAgLy8gY3VzdG9tIHNldHVwXG4gIC8vaWYgKHRpbGVfaWQgPT0gJzE5Mjk1XzI0NjU0XzE2Jyl7XG4gIGlmICh0aGlzLmNhbnZhc19zZXR1cClcbiAgICAgIHRoaXMuY2FudmFzX3NldHVwKHRoaXMudGlsZXNbdGlsZV9pZF0sIGNvb3JkLCB6b29tKTtcbiAgLy99XG4gIHJldHVybiBjYW52YXM7XG5cbn1cblxuXG5DYW52YXNUaWxlTGF5ZXIucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICBjYWxsYmFjayh0aWxlKTtcbiAgfVxufVxuXG5DYW52YXNUaWxlTGF5ZXIucHJvdG90eXBlLnJlY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1t0XTtcbiAgICAgIHRoaXMuY2FudmFzX3NldHVwKHRpbGUsIHRpbGUuY29vcmQsIHRpbGUuem9vbSk7XG4gIH1cbn07XG5cbkNhbnZhc1RpbGVMYXllci5wcm90b3R5cGUucmVkcmF3X3RpbGUgPSBmdW5jdGlvbiAodGlsZSkge1xuICB0aGlzLnJlbmRlcih0aWxlLCB0aWxlLmNvb3JkLCB0aWxlLnpvb20pO1xufTtcblxuQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW3RdO1xuICAgICAgdGhpcy5yZW5kZXIodGlsZSwgdGlsZS5jb29yZCwgdGlsZS56b29tKTtcbiAgfVxufTtcblxuLy8gY291bGQgYmUgY2FsbGVkIGRpcmVjdGx5Li4uXG5DYW52YXNUaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAoY29vcmQsIHpvb20sIG93bmVyRG9jdW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlX3RpbGVfY2FudmFzKGNvb3JkLCB6b29tLCBvd25lckRvY3VtZW50KTtcbn07XG5cbkNhbnZhc1RpbGVMYXllci5wcm90b3R5cGUucmVsZWFzZVRpbGUgPSBmdW5jdGlvbiAodGlsZSkge1xuICB2YXIgaWQgPSB0aWxlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgZGVsZXRlIHRoaXMudGlsZXNbaWRdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNUaWxlTGF5ZXI7XG4iLCJmdW5jdGlvbiBHTWFwc1RpbGVMb2FkZXIoKSB7XG59XG5cblxuR01hcHNUaWxlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBfaW5pdFRpbGVMb2FkZXI6IGZ1bmN0aW9uKG1hcCwgcHJvamVjdGlvbikge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICB0aGlzLl90aWxlcyA9IHt9O1xuICAgIHRoaXMuX3RpbGVzTG9hZGluZyA9IHt9O1xuICAgIHRoaXMuX3RpbGVzVG9Mb2FkID0gMDtcbiAgICB0aGlzLl91cGRhdGVUaWxlcyA9IHRoaXMuX3VwZGF0ZVRpbGVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goXG4gICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLl9tYXAsICdkcmFnZW5kJywgdGhpcy5fdXBkYXRlVGlsZXMpLFxuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fbWFwLCAnem9vbV9jaGFuZ2VkJywgdGhpcy5fdXBkYXRlVGlsZXMpXG4gICAgKTtcbiAgICB0aGlzLnRpbGVTaXplID0gMjU2O1xuICAgIHRoaXMuX3VwZGF0ZVRpbGVzKCk7XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGVMb2FkZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuX3JlbW92ZVRpbGVzKCk7XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9yZWxvYWRUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVtb3ZlVGlsZXMoKTtcbiAgICB0aGlzLl91cGRhdGVUaWxlcygpO1xuICB9LFxuXG4gIF91cGRhdGVUaWxlczogZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcbiAgICAgIHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgIHZhciB0aWxlU2l6ZSA9IHRoaXMudGlsZVNpemU7XG4gICAgICB2YXIgbXpvb20gPSAoMSA8PCB6b29tKTtcblxuICAgICAgdmFyIHRvcExlZnQgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKFxuICAgICAgICBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubGF0KCksXG4gICAgICAgIGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sbmcoKVxuICAgICAgKTtcblxuICAgICAgdmFyIGJvdHRvbVJpZ3RoID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhcbiAgICAgICAgYm91bmRzLmdldFNvdXRoV2VzdCgpLmxhdCgpLFxuICAgICAgICBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubG5nKClcbiAgICAgICk7XG5cblxuICAgICAgdGhpcy5fcHJvamVjdGlvbiA9IHRoaXMuX21hcC5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICB2YXIgZGl2VG9wTGVmdCA9IHRoaXMuX3Byb2plY3Rpb24uZnJvbUxhdExuZ1RvUG9pbnQodG9wTGVmdCk7XG4gICAgICB2YXIgZGl2Qm90dG9tUmlnaHQgPSB0aGlzLl9wcm9qZWN0aW9uLmZyb21MYXRMbmdUb1BvaW50KGJvdHRvbVJpZ3RoKTtcblxuXG4gICAgICB2YXIgbndUaWxlUG9pbnQgPSBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoZGl2VG9wTGVmdC54Km16b29tIC8gdGlsZVNpemUpLFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKGRpdlRvcExlZnQueSptem9vbSAvIHRpbGVTaXplKSksXG4gICAgICAgICAgc2VUaWxlUG9pbnQgPSBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoZGl2Qm90dG9tUmlnaHQueCptem9vbSAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihkaXZCb3R0b21SaWdodC55Km16b29tIC8gdGlsZVNpemUpKTtcblxuXG4gICAgICB0aGlzLl9hZGRUaWxlc0Zyb21DZW50ZXJPdXQobndUaWxlUG9pbnQsIHNlVGlsZVBvaW50KTtcbiAgICAgIHRoaXMuX3JlbW92ZU90aGVyVGlsZXMobndUaWxlUG9pbnQsIHNlVGlsZVBvaW50KTtcbiAgfSxcblxuICBfcmVtb3ZlT3RoZXJUaWxlczogZnVuY3Rpb24gKG53VGlsZVBvaW50LCBzZVRpbGVQb2ludCkge1xuICAgICAgdmFyIGtBcnIsIHgsIHksIGtleTtcblxuICAgICAgdmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgZm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5fdGlsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBrQXJyID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgIHggPSBwYXJzZUludChrQXJyWzBdLCAxMCk7XG4gICAgICAgICAgICAgIHkgPSBwYXJzZUludChrQXJyWzFdLCAxMCk7XG4gICAgICAgICAgICAgIHogPSBwYXJzZUludChrQXJyWzJdLCAxMCk7XG5cbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzXG4gICAgICAgICAgICAgIGlmICh6ICE9PSB6b29tIHx8IHggPCBud1RpbGVQb2ludC54IHx8IHggPiBzZVRpbGVQb2ludC54IHx8IHkgPCBud1RpbGVQb2ludC55IHx8IHkgPiBzZVRpbGVQb2ludC55KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRoaXMub25UaWxlUmVtb3ZlZCAmJiB0aGlzLm9uVGlsZVJlbW92ZWQodGhpcy5fdGlsZXNba2V5XSk7IFxuICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG4gICAgICBkZWxldGUgdGhpcy5fdGlsZXNMb2FkaW5nW2tleV07XG4gIH0sXG5cbiAgX3RpbGVLZXk6IGZ1bmN0aW9uKHRpbGVQb2ludCkge1xuICAgIHJldHVybiB0aWxlUG9pbnQueCArICc6JyArIHRpbGVQb2ludC55ICsgJzonICsgdGlsZVBvaW50Lnpvb207XG4gIH0sXG5cbiAgX3RpbGVTaG91bGRCZUxvYWRlZDogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xuICAgICAgdmFyIGsgPSB0aGlzLl90aWxlS2V5KHRpbGVQb2ludCk7XG4gICAgICByZXR1cm4gIShrIGluIHRoaXMuX3RpbGVzKSAmJiAhKGsgaW4gdGhpcy5fdGlsZXNMb2FkaW5nKTtcbiAgfSxcblxuICBfdGlsZUxvYWRlZDogZnVuY3Rpb24odGlsZVBvaW50LCB0aWxlRGF0YSkge1xuICAgIHRoaXMuX3RpbGVzVG9Mb2FkLS07XG4gICAgdmFyIGsgPSB0aWxlUG9pbnQueCArICc6JyArIHRpbGVQb2ludC55ICsgJzonICsgdGlsZVBvaW50Lnpvb21cbiAgICB0aGlzLl90aWxlc1trXSA9IHRpbGVEYXRhO1xuICAgIGRlbGV0ZSB0aGlzLl90aWxlc0xvYWRpbmdba107XG4gICAgaWYodGhpcy5fdGlsZXNUb0xvYWQgPT09IDApIHtcbiAgICAgIHRoaXMub25UaWxlc0xvYWRlZCAmJiB0aGlzLm9uVGlsZXNMb2FkZWQoKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VGlsZVBvczogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xuICAgIHZhciBsaW1pdCA9ICgxIDw8IHRoaXMuX21hcC5nZXRab29tKCkpO1xuICAgIC8vIHdyYXAgdGlsZVxuICAgIHRpbGVQb2ludCA9IHtcbiAgICAgIHg6ICgodGlsZVBvaW50LnggJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCxcbiAgICAgIHk6IHRpbGVQb2ludC55XG4gICAgfTtcblxuICAgIHRpbGVQb2ludCA9IG5ldyBnb29nbGUubWFwcy5Qb2ludChcbiAgICAgIHRpbGVQb2ludC54ICogdGhpcy50aWxlU2l6ZSwgXG4gICAgICB0aWxlUG9pbnQueSAqIHRoaXMudGlsZVNpemVcbiAgICApO1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcbiAgICB2YXIgdG9wTGVmdCA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoXG4gICAgICBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubGF0KCksXG4gICAgICBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKClcbiAgICApO1xuXG4gICAgdmFyIGRpdlRvcExlZnQgPSB0aGlzLl9tYXAuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb1BvaW50KHRvcExlZnQpO1xuICAgIHpvb20gPSAoMSA8PCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICBkaXZUb3BMZWZ0LnggPSBkaXZUb3BMZWZ0LnggKiB6b29tO1xuICAgIGRpdlRvcExlZnQueSA9IGRpdlRvcExlZnQueSAqIHpvb207XG5cbiAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLlBvaW50KFxuICAgICAgdGlsZVBvaW50LnggLSBkaXZUb3BMZWZ0LngsXG4gICAgICB0aWxlUG9pbnQueSAtIGRpdlRvcExlZnQueVxuICAgICk7XG4gIH0sXG5cbiAgX2FkZFRpbGVzRnJvbUNlbnRlck91dDogZnVuY3Rpb24gKG53VGlsZVBvaW50LCBzZVRpbGVQb2ludCkge1xuICAgICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgICAgY2VudGVyID0gbmV3IGdvb2dsZS5tYXBzLlBvaW50KFxuICAgICAgICAgICAgKG53VGlsZVBvaW50LnggKyBzZVRpbGVQb2ludC54KSAqIDAuNSxcbiAgICAgICAgICAgIChud1RpbGVQb2ludC55ICsgc2VUaWxlUG9pbnQueSkgKiAwLjVcbiAgICAgICAgICApLFxuICAgICAgICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXG4gICAgICB2YXIgaiwgaSwgcG9pbnQ7XG5cbiAgICAgIGZvciAoaiA9IG53VGlsZVBvaW50Lnk7IGogPD0gc2VUaWxlUG9pbnQueTsgaisrKSB7XG4gICAgICAgICAgZm9yIChpID0gbndUaWxlUG9pbnQueDsgaSA8PSBzZVRpbGVQb2ludC54OyBpKyspIHtcbiAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQgKGksIGopO1xuICAgICAgICAgICAgICBwb2ludC56b29tID0gem9vbTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5fdGlsZVNob3VsZEJlTG9hZGVkKHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWxlc1RvTG9hZCA9IHF1ZXVlLmxlbmd0aDtcblxuICAgICAgaWYgKHRpbGVzVG9Mb2FkID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICBmdW5jdGlvbiBkaXN0YW5jZVRvQ2VudGVyU3EocG9pbnQpIHtcbiAgICAgICAgdmFyIGR4ID0gcG9pbnQueCAtIGNlbnRlci54O1xuICAgICAgICB2YXIgZHkgPSBwb2ludC55IC0gY2VudGVyLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIH1cblxuICAgICAgLy8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcbiAgICAgIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZGlzdGFuY2VUb0NlbnRlclNxKGEpIC0gZGlzdGFuY2VUb0NlbnRlclNxKGIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3RpbGVzVG9Mb2FkICs9IHRpbGVzVG9Mb2FkO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aWxlc1RvTG9hZDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHQgPSBxdWV1ZVtpXTtcbiAgICAgICAgICB2YXIgayA9IHRoaXMuX3RpbGVLZXkodCk7XG4gICAgICAgICAgdGhpcy5fdGlsZXNMb2FkaW5nW2tdID0gdDtcbiAgICAgICAgICAvLyBldmVudHNcbiAgICAgICAgICBpZiAodGhpcy5vblRpbGVBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vblRpbGVBZGRlZCh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgdGhpcy5vblRpbGVzTG9hZGluZyAmJiB0aGlzLm9uVGlsZXNMb2FkaW5nKCk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdNYXBzVGlsZUxvYWRlcjtcbiIsInZhciBnbWFwcyA9IHt9O1xuaWYgKHR5cGVvZiBnb29nbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnb29nbGUubWFwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbWFwcyA9IHJlcXVpcmUoJy4vdG9ycXVlJyk7XG4gICAgZ21hcHMuR01hcHNUaWxlTG9hZGVyID0gcmVxdWlyZSgnLi9nbWFwc190aWxlbG9hZGVyX21peGluJyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGdtYXBzO1xuIiwidmFyIGNhcnRvID0gZ2xvYmFsLmNhcnRvIHx8IHJlcXVpcmUoJ2NhcnRvJyk7XG52YXIgdG9ycXVlID0gcmVxdWlyZSgnLi4vJyk7XG52YXIgQ2FudmFzTGF5ZXIgPSByZXF1aXJlKCcuL0NhbnZhc0xheWVyJyk7XG52YXIgQ2FudmFzVGlsZUxheWVyID0gcmVxdWlyZSgnLi9jYW52YXNfdGlsZV9sYXllcicpO1xudmFyIEdNYXBzVGlsZUxvYWRlciA9IHJlcXVpcmUoJy4vZ21hcHNfdGlsZWxvYWRlcl9taXhpbicpO1xuXG5mdW5jdGlvbiBHTWFwc1RvcnF1ZUxheWVyKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIXRvcnF1ZS5pc0Jyb3dzZXJTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBieSB0b3JxdWVcIik7XG4gIH1cbiAgdGhpcy5rZXkgPSAwO1xuICB0aGlzLnNoYWRlciA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5vcHRpb25zID0gdG9ycXVlLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucyA9IHRvcnF1ZS5leHRlbmQoe1xuICAgIHByb3ZpZGVyOiAnd2luZHNoYWZ0JyxcbiAgICByZW5kZXJlcjogJ3BvaW50JyxcbiAgICByZXNvbHV0aW9uOiAyLFxuICAgIHN0ZXBzOiAxMDAsXG4gICAgdmlzaWJsZTogdHJ1ZVxuICB9LCB0aGlzLm9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5jYXJ0b2Nzcykge1xuICAgIHRvcnF1ZS5leHRlbmQodGhpcy5vcHRpb25zLFxuICAgICAgICB0b3JxdWUuY29tbW9uLlRvcnF1ZUxheWVyLm9wdGlvbnNGcm9tQ2FydG9DU1Mob3B0aW9ucy5jYXJ0b2NzcykpO1xuICB9XG5cbiAgaWYob3B0aW9ucy50aWxlSlNPTikgdGhpcy5vcHRpb25zLnByb3ZpZGVyID0gXCJ0aWxlSlNPTlwiO1xuXG4gIHRoaXMuaGlkZGVuID0gIXRoaXMub3B0aW9ucy52aXNpYmxlO1xuXG4gIHRoaXMuYW5pbWF0b3IgPSBuZXcgdG9ycXVlLkFuaW1hdG9yKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICB2YXIgayA9IHRpbWUgfCAwO1xuICAgIGlmKHNlbGYua2V5ICE9PSBrKSB7XG4gICAgICBzZWxmLnNldEtleShrKTtcbiAgICB9XG4gIH0sIHRvcnF1ZS5leHRlbmQodG9ycXVlLmNsb25lKHRoaXMub3B0aW9ucyksIHtcbiAgICBvblBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZmlyZSgncGF1c2UnKTtcbiAgICB9LFxuICAgIG9uU3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZpcmUoJ3N0b3AnKTtcbiAgICB9LFxuICAgIG9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5maXJlKCdwbGF5Jyk7XG4gICAgfSxcbiAgICBvblN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5maXJlKCdjaGFuZ2U6c3RlcHNSYW5nZScsIHNlbGYuYW5pbWF0b3Iuc3RlcHNSYW5nZSgpKTtcbiAgICB9XG4gIH0pKTtcblxuICB0aGlzLnBsYXkgPSB0aGlzLmFuaW1hdG9yLnN0YXJ0LmJpbmQodGhpcy5hbmltYXRvcik7XG4gIHRoaXMuc3RvcCA9IHRoaXMuYW5pbWF0b3Iuc3RvcC5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICB0aGlzLnBhdXNlID0gdGhpcy5hbmltYXRvci5wYXVzZS5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICB0aGlzLnRvZ2dsZSA9IHRoaXMuYW5pbWF0b3IudG9nZ2xlLmJpbmQodGhpcy5hbmltYXRvcik7XG4gIHRoaXMuc2V0RHVyYXRpb24gPSB0aGlzLmFuaW1hdG9yLmR1cmF0aW9uLmJpbmQodGhpcy5hbmltYXRvcik7XG4gIHRoaXMuaXNSdW5uaW5nID0gdGhpcy5hbmltYXRvci5pc1J1bm5pbmcuYmluZCh0aGlzLmFuaW1hdG9yKTtcblxuXG4gIENhbnZhc0xheWVyLmNhbGwodGhpcywge1xuICAgIG1hcDogdGhpcy5vcHRpb25zLm1hcCxcbiAgICAvL3Jlc2l6ZUhhbmRsZXI6IHRoaXMucmVkcmF3LFxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIHVwZGF0ZUhhbmRsZXI6IHRoaXMucmVuZGVyLFxuICAgIHJlYWR5SGFuZGxlcjogdGhpcy5pbml0aWFsaXplXG4gIH0pO1xuXG59XG5cbi8qKlxuICogdG9ycXVlIGxheWVyXG4gKi9cbkdNYXBzVG9ycXVlTGF5ZXIucHJvdG90eXBlID0gdG9ycXVlLmV4dGVuZCh7fSxcbiAgQ2FudmFzTGF5ZXIucHJvdG90eXBlLFxuICBHTWFwc1RpbGVMb2FkZXIucHJvdG90eXBlLFxuICB0b3JxdWUuRXZlbnQsXG4gIHtcblxuICBwcm92aWRlcnM6IHtcbiAgICAnc3FsX2FwaSc6IHRvcnF1ZS5wcm92aWRlcnMuanNvbixcbiAgICAndXJsX3RlbXBsYXRlJzogdG9ycXVlLnByb3ZpZGVycy5Kc29uQXJyYXksXG4gICAgJ3dpbmRzaGFmdCc6IHRvcnF1ZS5wcm92aWRlcnMud2luZHNoYWZ0LFxuICAgICd0aWxlSlNPTic6IHRvcnF1ZS5wcm92aWRlcnMudGlsZUpTT05cbiAgfSxcblxuICByZW5kZXJlcnM6IHtcbiAgICAncG9pbnQnOiB0b3JxdWUucmVuZGVyZXIuUG9pbnQsXG4gICAgJ3BpeGVsJzogdG9ycXVlLnJlbmRlcmVyLlJlY3RhbmdsZVxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMub25UaWxlQWRkZWQgPSB0aGlzLm9uVGlsZUFkZGVkLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9wdGlvbnMucmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZmlyZShcImNoYW5nZTpib3VuZHNcIiwge1xuICAgICAgICBib3VuZHM6IHNlbGYucHJvdmlkZXIuZ2V0Qm91bmRzKClcbiAgICAgIH0pO1xuICAgICAgc2VsZi5hbmltYXRvci5zdGVwcyhzZWxmLnByb3ZpZGVyLmdldFN0ZXBzKCkpO1xuICAgICAgc2VsZi5hbmltYXRvci5yZXNjYWxlKCk7XG4gICAgICBzZWxmLmZpcmUoJ2NoYW5nZTpzdGVwcycsIHtcbiAgICAgICAgc3RlcHM6IHNlbGYucHJvdmlkZXIuZ2V0U3RlcHMoKVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNldEtleShzZWxmLmtleSk7XG4gICAgfTtcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgdGhpcy5wcm92aWRlcnNbdGhpcy5vcHRpb25zLnByb3ZpZGVyXSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgdGhpcy5yZW5kZXJlcnNbdGhpcy5vcHRpb25zLnJlbmRlcmVyXSh0aGlzLmdldENhbnZhcygpLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucy5lcnJvckNhbGxiYWNrID0gdGhpcy5vcHRpb25zLmVycm9yQ2FsbGJhY2s7XG5cbiAgICAvLyB0aGlzIGxpc3RlbmVyIHNob3VsZCBiZSBiZWZvcmUgdGlsZSBsb2FkZXJcbiAgICB0aGlzLl9jYWNoZUxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5vcHRpb25zLm1hcCwgJ3pvb21fY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5yZW5kZXJlciAmJiBzZWxmLnJlbmRlcmVyLmNsZWFyU3ByaXRlQ2FjaGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2luaXRUaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYXAsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcblxuICAgIGlmICh0aGlzLnNoYWRlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaGFkZXIodGhpcy5zaGFkZXIpO1xuICAgIH1cblxuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuaGlkZGVuKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLnBhdXNlKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICBpZighdGhpcy5oaWRkZW4pIHJldHVybiB0aGlzO1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5wbGF5KCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwcyA9PT0gMSl7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRTUUw6IGZ1bmN0aW9uKHNxbCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVyLm9wdGlvbnMubmFtZWRfbWFwKSB0aHJvdyBuZXcgRXJyb3IoXCJTUUwgcXVlcmllcyBvbiBuYW1lZCBtYXBzIGFyZSByZWFkLW9ubHlcIik7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyIHx8ICF0aGlzLnByb3ZpZGVyLnNldFNRTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhpcyBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IFNRTFwiKTtcbiAgICB9XG4gICAgdGhpcy5wcm92aWRlci5zZXRTUUwoc3FsKTtcbiAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEJsZW5kTW9kZTogZnVuY3Rpb24oXykge1xuICAgIHRoaXMucmVuZGVyZXIgJiYgdGhpcy5yZW5kZXJlci5zZXRCbGVuZE1vZGUoXyk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfSxcblxuICBzZXRTdGVwczogZnVuY3Rpb24oc3RlcHMpIHtcbiAgICB0aGlzLnByb3ZpZGVyICYmIHRoaXMucHJvdmlkZXIuc2V0U3RlcHMoc3RlcHMpO1xuICAgIHRoaXMuYW5pbWF0b3IgJiYgdGhpcy5hbmltYXRvci5zdGVwcyhzdGVwcyk7XG4gICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgfSxcblxuICBzZXRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbiwgaXNUaW1lKSB7XG4gICAgdGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLnNldENvbHVtbihjb2x1bW4sIGlzVGltZSk7XG4gICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgfSxcblxuICBnZXRUaW1lQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLmdldEtleVNwYW4oKTtcbiAgfSxcblxuICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgfSxcblxuICAgIC8vIGZvciBlYWNoIHRpbGUgc2hvd24gb24gdGhlIG1hcCByZXF1ZXN0IHRoZSBkYXRhXG4gIG9uVGlsZUFkZGVkOiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvdmlkZXIuZ2V0VGlsZURhdGEodCwgdC56b29tLCBmdW5jdGlvbih0aWxlRGF0YSkge1xuICAgICAgLy8gZG9uJ3QgbG9hZCB0aWxlcyB0aGF0IGFyZSBub3QgYmVpbmcgc2hvd25cbiAgICAgIGlmICh0Lnpvb20gIT09IHNlbGYub3B0aW9ucy5tYXAuZ2V0Wm9vbSgpKSByZXR1cm47XG4gICAgICBzZWxmLl90aWxlTG9hZGVkKHQsIHRpbGVEYXRhKTtcbiAgICAgIHNlbGYuZmlyZSgndGlsZUxvYWRlZCcpO1xuICAgICAgaWYgKHRpbGVEYXRhKSB7XG4gICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlbmRlciB0aGUgc2VsZWN0ZWYga2V5XG4gICAqIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSwgaXQncyBjYWxsZWQgYnlcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBVc2UgcmVkcmF3IHRvIHJlZnJlc2ggaXRcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5oaWRkZW4pIHJldHVybjtcbiAgICB2YXIgdCwgdGlsZSwgcG9zO1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICB0aGlzLnJlbmRlcmVyLmNsZWFyQ2FudmFzKCk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gcmVuZGVycyBvbmx5IGEgXCJmcmFtZVwiXG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgIHBvcyA9IHRoaXMuZ2V0VGlsZVBvcyh0aWxlLmNvb3JkKTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBwb3MueCwgcG9zLnkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRpbGUodGlsZSwgdGhpcy5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLmFwcGx5RmlsdGVycygpO1xuICB9LFxuXG4gIGdldEFjdGl2ZVBvaW50c0JCb3g6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgdmFyIHRpbGVNYXggPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAqICgyNTYvdGhpcy5vcHRpb25zLnJlc29sdXRpb24gLSAxKTtcbiAgICBmb3IodmFyIHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuY29uY2F0KHRoaXMucmVuZGVyZXIuZ2V0QWN0aXZlUG9pbnRzQkJveCh0aWxlLCBzdGVwKSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCBrZXkgdG8gYmUgc2hvd24uIElmIGl0J3MgYSBzaW5nbGUgdmFsdWVcbiAgICogaXQgcmVuZGVycyBkaXJlY3RseSwgaWYgaXQncyBhbiBhcnJheSBpdCByZW5kZXJzXG4gICAqIGFjY3VtdWxhdGVkXG4gICAqL1xuICBzZXRLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuYW5pbWF0b3Iuc3RlcChrZXkpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2U6dGltZScsIHsgdGltZTogdGhpcy5nZXRUaW1lKCksIHN0ZXA6IHRoaXMua2V5IH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZnVuY3Rpb24sIGRvZXMgdGhlIHNhbWUgdGhhbiBgYHNldEtleWBgIGJ1dCBvbmx5XG4gICAqIGFjY2VwdHMgc2NhbGFycy5cbiAgICovXG4gIHNldFN0ZXA6IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICBpZih0aW1lID09PSB1bmRlZmluZWQgfHwgdGltZS5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0VGltZSBvbmx5IGFjY2VwdCBzY2FsYXJzXCIpO1xuICAgIH1cbiAgICB0aGlzLnNldEtleSh0aW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogdHJhbnNmb3JtIGZyb20gYW5pbWF0aW9uIHN0ZXAgdG8gRGF0ZSBvYmplY3RcbiAgICogdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRpbWVcbiAgICpcbiAgICogYGBzdGVwYGAgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgYGBzdGVwcyAtIDFgYFxuICAgKi9cbiAgc3RlcFRvVGltZTogZnVuY3Rpb24oc3RlcCkge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikgcmV0dXJuIDA7XG4gICAgdmFyIHRpbWVzID0gdGhpcy5wcm92aWRlci5nZXRLZXlTcGFuKCk7XG4gICAgdmFyIHRpbWUgPSB0aW1lcy5zdGFydCArICh0aW1lcy5lbmQgLSB0aW1lcy5zdGFydCkqKHN0ZXAvdGhpcy5wcm92aWRlci5nZXRTdGVwcygpKTtcbiAgICByZXR1cm4gbmV3IERhdGUodGltZSk7XG4gIH0sXG5cbiAgdGltZVRvU3RlcDogZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09IFwiRGF0ZVwiKSB0aW1lc3RhbXAgPSB0aW1lc3RhbXAuZ2V0VGltZSgpO1xuICAgIGlmICghdGhpcy5wcm92aWRlcikgcmV0dXJuIDA7XG4gICAgdmFyIHRpbWVzID0gdGhpcy5wcm92aWRlci5nZXRLZXlTcGFuKCk7XG4gICAgdmFyIHN0ZXAgPSAodGhpcy5wcm92aWRlci5nZXRTdGVwcygpICogKHRpbWVzdGFtcCAtIHRpbWVzLnN0YXJ0KSkgLyAodGltZXMuZW5kIC0gdGltZXMuc3RhcnQpO1xuICAgIHJldHVybiBzdGVwO1xuICB9LFxuXG4gIGdldFN0ZXA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmtleTtcbiAgfSxcblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgYW5pbWF0aW9uIHRpbWUgZGVmaW5lZCBieSB0aGUgZGF0YVxuICAgKiBpbiB0aGUgZGVmaW5lZCBjb2x1bW4uIERhdGUgb2JqZWN0XG4gICAqL1xuICBnZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwVG9UaW1lKHRoaXMua2V5KTtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IHRoZSBjYXJ0b2NzcyBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICovXG4gIHNldENhcnRvQ1NTOiBmdW5jdGlvbihjYXJ0b2Nzcykge1xuICAgIGlmICh0aGlzLnByb3ZpZGVyICYmIHRoaXMucHJvdmlkZXIub3B0aW9ucy5uYW1lZF9tYXApIHRocm93IG5ldyBFcnJvcihcIkNhcnRvQ1NTIHN0eWxlIG9uIG5hbWVkIG1hcHMgaXMgcmVhZC1vbmx5XCIpO1xuICAgIHZhciBzaGFkZXIgPSBuZXcgY2FydG8uUmVuZGVyZXJKUygpLnJlbmRlcihjYXJ0b2Nzcyk7XG4gICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2hhZGVyKHNoYWRlcik7XG4gICAgfVxuXG4gICAgLy8gcHJvdmlkZXIgb3B0aW9uc1xuICAgIHZhciBvcHRpb25zID0gdG9ycXVlLmNvbW1vbi5Ub3JxdWVMYXllci5vcHRpb25zRnJvbUxheWVyKHNoYWRlci5maW5kTGF5ZXIoeyBuYW1lOiAnTWFwJyB9KSk7XG4gICAgdGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLnNldENhcnRvQ1NTICYmIHRoaXMucHJvdmlkZXIuc2V0Q2FydG9DU1MoY2FydG9jc3MpO1xuICAgIGlmKHRoaXMucHJvdmlkZXIgJiYgdGhpcy5wcm92aWRlci5zZXRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICAgIH1cbiAgICB0b3JxdWUuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBhbmltYXRvciBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuYW5pbWF0b3IuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWRyYXc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgfSxcblxuICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maXJlKCdyZW1vdmUnKTtcbiAgICBDYW52YXNMYXllci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFuaW1hdG9yLnN0b3AoKTtcbiAgICB0aGlzLl9yZW1vdmVUaWxlTG9hZGVyKCk7XG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fY2FjaGVMaXN0ZW5lcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSB2YWx1ZXMgZm9yIGFsbCB0aGUgcGl4ZWxzIGFjdGl2ZSBmb3IgdGhlIHN0ZXBcbiAgICovXG4gIGdldFZhbHVlczogZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gdGhpcy5rZXk6IHN0ZXA7XG4gICAgdmFyIHQsIHRpbGU7XG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2V0VmFsdWVzKHRpbGUsIHN0ZXAsIHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG5cbiAgZ2V0VmFsdWVGb3JQb3M6IGZ1bmN0aW9uKHgsIHksIHN0ZXApIHtcbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gdGhpcy5rZXk6IHN0ZXA7XG4gICAgdmFyIHQsIHRpbGUsIHBvcywgdmFsdWUgPSBudWxsLCB4eCwgeXk7XG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIHBvcyA9IHRoaXMuZ2V0VGlsZVBvcyh0aWxlLmNvb3JkKTtcbiAgICAgIHh4ID0geCAtIHBvcy54O1xuICAgICAgeXkgPSB5IC0gcG9zLnk7XG4gICAgICBpZiAoeHggPj0gMCAmJiB5eSA+PSAwICYmIHh4IDwgdGhpcy5yZW5kZXJlci5USUxFX1NJWkUgJiYgeXkgPD0gdGhpcy5yZW5kZXJlci5USUxFX1NJWkUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnJlbmRlcmVyLmdldFZhbHVlRm9yKHRpbGUsIHN0ZXAsIHh4LCB5eSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZ2V0VmFsdWVGb3JCQm94OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdmFyIHhmID0geCArIHcsIHlmID0geSArIGg7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yKF95ID0geTsgeTx5ZjsgeSs9dGhpcy5vcHRpb25zLnJlc29sdXRpb24pe1xuICAgICAgZm9yKF94ID0geDsgeDx4ZjsgeCs9dGhpcy5vcHRpb25zLnJlc29sdXRpb24pe1xuICAgICAgICB2YXIgdGhpc1ZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvclBvcyhfeCxfeSk7XG4gICAgICAgIGlmICh0aGlzVmFsdWUpe1xuICAgICAgICAgIHZhciBiYiA9IHRoaXNWYWx1ZS5iYm94O1xuICAgICAgICAgIHZhciBwcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKClcbiAgICAgICAgICB2YXIgeHkgPSBwcm9qLmZyb21MYXRMbmdUb0NvbnRhaW5lclBpeGVsKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYmJbMV0ubGF0LCBiYlsxXS5sb24pKTtcbiAgICAgICAgICBpZih4eS54IDwgeGYgJiYgeHkueSA8IHlmKXtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzVmFsdWUudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH0sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMub3B0aW9ucy5lcnJvckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG5cblxuXG5mdW5jdGlvbiBHTWFwc1RpbGVkVG9ycXVlTGF5ZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB0b3JxdWUuZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgQ2FudmFzVGlsZUxheWVyLmNhbGwodGhpcywgdGhpcy5fbG9hZFRpbGUuYmluZCh0aGlzKSwgdGhpcy5kcmF3VGlsZS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xufVxuXG5HTWFwc1RpbGVkVG9ycXVlTGF5ZXIucHJvdG90eXBlID0gdG9ycXVlLmV4dGVuZCh7fSwgQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZSwge1xuXG4gIHByb3ZpZGVyczoge1xuICAgICdzcWxfYXBpJzogdG9ycXVlLnByb3ZpZGVycy5qc29uLFxuICAgICd1cmxfdGVtcGxhdGUnOiB0b3JxdWUucHJvdmlkZXJzLkpzb25BcnJheVxuICB9LFxuXG4gIHJlbmRlcmVyczoge1xuICAgICdwb2ludCc6IHRvcnF1ZS5yZW5kZXJlci5Qb2ludCxcbiAgICAncGl4ZWwnOiB0b3JxdWUucmVuZGVyZXIuUmVjdGFuZ2xlXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmtleSA9IDA7XG5cbiAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgJ3BpeGVsJztcbiAgICB0aGlzLm9wdGlvbnMucHJvdmlkZXIgPSB0aGlzLm9wdGlvbnMucHJvdmlkZXIgfHwgJ3NxbF9hcGknO1xuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyB0aGlzLnByb3ZpZGVyc1t0aGlzLm9wdGlvbnMucHJvdmlkZXJdKG9wdGlvbnMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgdGhpcy5yZW5kZXJlcnNbdGhpcy5vcHRpb25zLnJlbmRlcmVyXShudWxsLCBvcHRpb25zKTtcblxuICB9LFxuXG4gIF90aWxlTG9hZGVkOiBmdW5jdGlvbih0aWxlLCB0aWxlRGF0YSkge1xuICAgIHRpbGUuZGF0YSA9IHRpbGVEYXRhO1xuICAgIHRoaXMuZHJhd1RpbGUodGlsZSk7XG4gIH0sXG5cbiAgX2xvYWRUaWxlOiBmdW5jdGlvbih0aWxlLCBjb29yZCwgem9vbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGltaXQgPSAxIDw8IHpvb207XG4gICAgLy8gd3JhcCB0aWxlXG4gICAgdmFyIHdyYXBwZWRDb29yZCA9IHtcbiAgICAgIHg6ICgoY29vcmQueCAlIGxpbWl0KSArIGxpbWl0KSAlIGxpbWl0LFxuICAgICAgeTogY29vcmQueVxuICAgIH07XG5cbiAgICB0aGlzLnByb3ZpZGVyLmdldFRpbGVEYXRhKHdyYXBwZWRDb29yZCwgem9vbSwgZnVuY3Rpb24odGlsZURhdGEpIHtcbiAgICAgIHNlbGYuX3RpbGVMb2FkZWQodGlsZSwgdGlsZURhdGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIGRyYXdUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuICAgIHZhciBjYW52YXMgPSB0aWxlLmNhbnZhcztcbiAgICBpZighdGlsZS5kYXRhKSByZXR1cm47XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRDYW52YXMoY2FudmFzKTtcblxuICAgIHZhciBhY2N1bSA9IHRoaXMucmVuZGVyZXIuYWNjdW11bGF0ZSh0aWxlLmRhdGEsIHRoaXMua2V5KTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRpbGVBY2N1bShhY2N1bSwgMCwgMCk7XG4gIH0sXG5cbiAgc2V0S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQgdGhlIGNhcnRvY3NzIGZvciB0aGUgY3VycmVudCByZW5kZXJlclxuICAgKi9cbiAgc2V0Q2FydG9DU1M6IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlcmVyIGlzIG5vdCB2YWxpZCcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNldENhcnRvQ1NTKGNhcnRvY3NzKTtcbiAgfSxcblxuICBzZXRTdGVwc1JhbmdlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5hbmltYXRvci5zdGVwc1JhbmdlKHN0YXJ0LCBlbmQpO1xuICB9LFxuXG4gIHJlbW92ZVN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYW5pbWF0b3IucmVtb3ZlQ3VzdG9tU3RlcHNSYW5nZSgpO1xuICB9LFxuXG4gIGdldFN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdG9yLnN0ZXBzUmFuZ2UoKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgR01hcHNUaWxlZFRvcnF1ZUxheWVyOiBHTWFwc1RpbGVkVG9ycXVlTGF5ZXIsXG4gICAgR01hcHNUb3JxdWVMYXllcjogR01hcHNUb3JxdWVMYXllclxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzLkFuaW1hdG9yID0gcmVxdWlyZSgnLi9hbmltYXRvcicpO1xubW9kdWxlLmV4cG9ydHMuY2FydG9jc3NfcmVmZXJlbmNlID0gcmVxdWlyZSgnLi9jYXJ0b2Nzc19yZWZlcmVuY2UnKTtcbm1vZHVsZS5leHBvcnRzLmNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5tb2R1bGUuZXhwb3J0cy5tYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5tb2R1bGUuZXhwb3J0cy5NZXJjYXRvciA9IHJlcXVpcmUoJy4vbWVyY2F0b3InKTtcbm1vZHVsZS5leHBvcnRzLm5ldCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xubW9kdWxlLmV4cG9ydHMucmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG5tb2R1bGUuZXhwb3J0cy5wcm92aWRlcnMgPSByZXF1aXJlKCcuL3Byb3ZpZGVyJyk7XG5cbnJlcXVpcmUoJy4vbGVhZmxldCcpO1xuXG52YXIgZ21hcHMgPSByZXF1aXJlKCcuL2dtYXBzJyk7XG5tb2R1bGUuZXhwb3J0cy5HTWFwc1RpbGVMb2FkZXIgPSBnbWFwcy5HTWFwc1RpbGVMb2FkZXI7XG5tb2R1bGUuZXhwb3J0cy5HTWFwc1RvcnF1ZUxheWVyID0gZ21hcHMuR01hcHNUb3JxdWVMYXllcjtcbm1vZHVsZS5leHBvcnRzLkdNYXBzVGlsZWRUb3JxdWVMYXllciA9IGdtYXBzLkdNYXBzVGlsZWRUb3JxdWVMYXllcjtcbiIsInJlcXVpcmUoJy4vbGVhZmxldF90aWxlbG9hZGVyX21peGluJyk7XG5cbi8qKlxuICogZnVsbCBjYW52YXMgbGF5ZXIgaW1wbGVtZW50YXRpb24gZm9yIExlYWZsZXRcbiAqL1xuXG5MLkNhbnZhc0xheWVyID0gTC5DbGFzcy5leHRlbmQoe1xuXG4gIGluY2x1ZGVzOiBbTC5NaXhpbi5FdmVudHMsIEwuTWl4aW4uVGlsZUxvYWRlcl0sXG5cbiAgb3B0aW9uczoge1xuICAgICAgbWluWm9vbTogMCxcbiAgICAgIG1heFpvb206IDI4LFxuICAgICAgdGlsZVNpemU6IDI1NixcbiAgICAgIHN1YmRvbWFpbnM6ICdhYmMnLFxuICAgICAgZXJyb3JUaWxlVXJsOiAnJyxcbiAgICAgIGF0dHJpYnV0aW9uOiAnJyxcbiAgICAgIHpvb21PZmZzZXQ6IDAsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdW5sb2FkSW52aXNpYmxlVGlsZXM6IEwuQnJvd3Nlci5tb2JpbGUsXG4gICAgICB1cGRhdGVXaGVuSWRsZTogTC5Ccm93c2VyLm1vYmlsZSxcbiAgICAgIHRpbGVMb2FkZXI6IGZhbHNlLCAvLyBpbnN0YWxscyB0aWxlIGxvYWRpbmcgZXZlbnRzXG4gICAgICB6b29tQW5pbWF0aW9uOiB0cnVlXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLy90aGlzLnByb2plY3QgPSB0aGlzLl9wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcygpO1xuICAgIC8vIGJhY2tDYW52YXMgZm9yIHpvb20gYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLl9iYWNrQ2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gLTE7XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oaWQpIHsgY2xlYXJUaW1lb3V0KGlkKTsgfTtcbiAgfSxcblxuICBfY3JlYXRlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FudmFzO1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXggfHwgMDtcbiAgICB2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtdGlsZS1jb250YWluZXInO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuICAgICAgY2xhc3NOYW1lICs9ICcgbGVhZmxldC16b29tLWFuaW1hdGVkJztcbiAgICB9XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiBjYW52YXM7XG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAvLyBhZGQgY29udGFpbmVyIHdpdGggdGhlIGNhbnZhcyB0byB0aGUgdGlsZSBwYW5lXG4gICAgLy8gdGhlIGNvbnRhaW5lciBpcyBtb3ZlZCBpbiB0aGUgb3Bvc2l0ZSBkaXJlY3Rpb24gb2YgdGhlIFxuICAgIC8vIG1hcCBwYW5lIHRvIGtlZXAgdGhlIGNhbnZhcyBhbHdheXMgaW4gKDAsIDApXG4gICAgdmFyIHRpbGVQYW5lID0gdGhpcy5fbWFwLl9wYW5lcy50aWxlUGFuZTtcbiAgICB2YXIgX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyJyk7XG4gICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuICAgICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrQ2FudmFzKTtcbiAgICAgIHRoaXMuX2JhY2tDYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgdGlsZVBhbmUuYXBwZW5kQ2hpbGQoX2NvbnRhaW5lcik7XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBfY29udGFpbmVyO1xuXG4gICAgLy8gaGFjazogbGlzdGVuIHRvIHByZWRyYWcgZXZlbnQgbGF1bmNoZWQgYnkgZHJhZ2dpbmcgdG9cbiAgICAvLyBzZXQgY29udGFpbmVyIGluIHBvc2l0aW9uICgwLCAwKSBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICBtYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGQgPSBtYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZTtcbiAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jYW52YXMsIHsgeDogLWQuX25ld1Bvcy54LCB5OiAtZC5fbmV3UG9zLnkgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBtYXAub24oeyAndmlld3Jlc2V0JzogdGhpcy5fcmVzZXQgfSwgdGhpcyk7XG4gICAgbWFwLm9uKCdtb3ZlJywgdGhpcy5yZWRyYXcsIHRoaXMpO1xuICAgIG1hcC5vbigncmVzaXplJywgdGhpcy5fcmVzZXQsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG4gICAgICBtYXAub24oe1xuICAgICAgICAnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcbiAgICAgICAgJ3pvb21lbmQnOiB0aGlzLl9lbmRab29tQW5pbSxcbiAgICAgICAgJ21vdmVlbmQnOiB0aGlzLl9yZXNldFxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYodGhpcy5vcHRpb25zLnRpbGVMb2FkZXIpIHtcbiAgICAgIHRoaXMuX2luaXRUaWxlTG9hZGVyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgfSxcblxuICBfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGJhY2sgPSB0aGlzLl9iYWNrQ2FudmFzO1xuXG4gICAgYmFjay53aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgICBiYWNrLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQ7XG5cbiAgICAvLyBwYWludCBjdXJyZW50IGNhbnZhcyBpbiBiYWNrIGNhbnZhcyB3aXRoIHRyYXNuZm9ybWF0aW9uXG4gICAgdmFyIHBvcyA9IHRoaXMuX2NhbnZhcy5fbGVhZmxldF9wb3MgfHwgeyB4OiAwLCB5OiAwIH07XG4gICAgYmFjay5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0aGlzLl9jYW52YXMsIDAsIDApO1xuXG4gICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKGJhY2ssIEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jYW52YXMpKTtcblxuICAgIC8vIGhpZGUgb3JpZ2luYWxcbiAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBiYWNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgdmFyIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShlLnpvb20pO1xuICAgIHZhciBuZXdDZW50ZXIgPSBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludChtYXAuZ2V0Q2VudGVyKCksIGUuem9vbSwgZS5jZW50ZXIpO1xuICAgIHZhciBvbGRDZW50ZXIgPSBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludChlLmNlbnRlciwgZS56b29tLCBlLmNlbnRlcik7XG5cbiAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgeDogIG5ld0NlbnRlci54IC0gb2xkQ2VudGVyLnggKyBwb3MueCxcbiAgICAgIHk6ICBuZXdDZW50ZXIueSAtIG9sZENlbnRlci55ICsgcG9zLnksXG4gICAgfTtcblxuICAgIHZhciBiZyA9IGJhY2s7XG4gICAgdmFyIHRyYW5zZm9ybSA9IEwuRG9tVXRpbC5UUkFOU0ZPUk07XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGJnLnN0eWxlW3RyYW5zZm9ybV0gPSBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbikgKyAnIHNjYWxlKCcgKyBlLnNjYWxlICsgJykgJztcbiAgICB9LCAwKVxuICB9LFxuXG4gIF9lbmRab29tQW5pbTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLl9iYWNrQ2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5fYmFja0NhbnZhcy5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9ICcnO1xuICB9LFxuXG4gIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfSxcblxuICBnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzZXQoKTtcbiAgfSxcblxuICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgbWFwLm9mZih7XG4gICAgICAndmlld3Jlc2V0JzogdGhpcy5fcmVzZXQsXG4gICAgICAnbW92ZSc6IHRoaXMuX3JlbmRlcixcbiAgICAgICdtb3ZlZW5kJzogdGhpcy5fcmVzZXQsXG4gICAgICAncmVzaXplJzogdGhpcy5fcmVzZXQsXG4gICAgICAnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcbiAgICAgICd6b29tZW5kJzogdGhpcy5fZW5kWm9vbUFuaW1cbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuICAgIG1hcC5hZGRMYXllcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlcnJvcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcm92aWRlci5vcHRpb25zLmVycm9yQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0WkluZGV4OiBmdW5jdGlvbih6SW5kZXgpIHtcbiAgICB0aGlzLl9jYW52YXMuc3R5bGUuekluZGV4ID0gekluZGV4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fYmFja0NhbnZhcy5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG4gICAgfVxuICB9LFxuXG4gIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHNpemUueDtcbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gc2l6ZS55O1xuXG4gICAgLy8gZml4IHBvc2l0aW9uXG4gICAgdmFyIHBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXAuZ2V0UGFuZXMoKS5tYXBQYW5lKTtcbiAgICBpZiAocG9zKSB7XG4gICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY2FudmFzLCB7IHg6IC1wb3MueCwgeTogLXBvcy55IH0pO1xuICAgIH1cbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH0sXG5cbiAgLypcbiAgX3Byb2plY3Q6IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KG5ldyBMLkxhdExuZyh4WzFdLCB4WzBdKSk7XG4gICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgfSxcbiAgKi9cblxuICBfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkgeyB9LFxuXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA+PSAwKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIHRoaXMucmVuZGVyKTtcbiAgfSxcblxuICAvLyB1c2UgZGlyZWN0OiB0cnVlIGlmIHlvdSBhcmUgaW5zaWRlIGFuIGFuaW1hdGlvbiBmcmFtZSBjYWxsXG4gIHJlZHJhdzogZnVuY3Rpb24oZGlyZWN0KSB7XG4gICAgdmFyIGRvbVBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcC5nZXRQYW5lcygpLm1hcFBhbmUpO1xuICAgIGlmIChkb21Qb3NpdGlvbikge1xuICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NhbnZhcywgeyB4OiAtZG9tUG9zaXRpb24ueCwgeTogLWRvbVBvc2l0aW9uLnkgfSk7XG4gICAgfVxuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICBvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlciBmdW5jdGlvbiBzaG91bGQgYmUgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG59KTtcbiIsImlmICh0eXBlb2YgTCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXF1aXJlKCcuL3RvcnF1ZScpO1xufVxuIiwiTC5NaXhpbi5UaWxlTG9hZGVyID0ge1xuXG4gIF9pbml0VGlsZUxvYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlsZXMgPSB7fVxuICAgIHRoaXMuX3RpbGVzTG9hZGluZyA9IHt9O1xuICAgIHRoaXMuX3RpbGVzVG9Mb2FkID0gMDtcbiAgICB0aGlzLl9tYXAub24oe1xuICAgICAgICAnbW92ZWVuZCc6IHRoaXMuX3VwZGF0ZVRpbGVzXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlVGlsZXMoKTtcbiAgfSxcblxuICBfcmVtb3ZlVGlsZUxvYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbWFwLm9mZih7XG4gICAgICAgICdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlVGlsZXNcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9yZW1vdmVUaWxlcygpO1xuICB9LFxuXG4gIHZpc2libGVUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuIFtdOyB9XG4gICAgdmFyIGosIGksIHBvaW50LCB0aWxlcyA9IFtdO1xuICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgIHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXG4gICAgdmFyIG53VGlsZVBvaW50ID0gbmV3IEwuUG9pbnQoXG4gICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1pbi55IC8gdGlsZVNpemUpKSxcblxuICAgICAgICBzZVRpbGVQb2ludCA9IG5ldyBMLlBvaW50KFxuICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAvIHRpbGVTaXplKSksXG5cbiAgICAgICAgdGlsZUJvdW5kcyA9IG5ldyBMLkJvdW5kcyhud1RpbGVQb2ludCwgc2VUaWxlUG9pbnQpO1xuXG4gICAgZm9yIChqID0gdGlsZUJvdW5kcy5taW4ueTsgaiA8PSB0aWxlQm91bmRzLm1heC55OyBqKyspIHtcbiAgICAgICAgZm9yIChpID0gdGlsZUJvdW5kcy5taW4ueDsgaSA8PSB0aWxlQm91bmRzLm1heC54OyBpKyspIHtcbiAgICAgICAgICAgIHRpbGVzLnB1c2goeyB4OiBpLCB5OiBqLCB6OiB6b29tIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWxlcztcbiAgfSxcblxuICBfdXBkYXRlVGlsZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblxuICAgICAgaWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBud1RpbGVQb2ludCA9IG5ldyBMLlBvaW50KFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWluLnkgLyB0aWxlU2l6ZSkpLFxuXG4gICAgICAgICAgc2VUaWxlUG9pbnQgPSBuZXcgTC5Qb2ludChcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1heC55IC8gdGlsZVNpemUpKSxcblxuICAgICAgICAgIHRpbGVCb3VuZHMgPSBuZXcgTC5Cb3VuZHMobndUaWxlUG9pbnQsIHNlVGlsZVBvaW50KTtcblxuICAgICAgdGhpcy5fYWRkVGlsZXNGcm9tQ2VudGVyT3V0KHRpbGVCb3VuZHMpO1xuICAgICAgdGhpcy5fcmVzYW1wbGVPbGRUaWxlcyh0aWxlQm91bmRzKTtcbiAgICAgIHRoaXMuX3JlbW92ZU90aGVyVGlsZXModGlsZUJvdW5kcyk7XG4gIH0sXG5cbiAgX2lzUGFyZW50OiBmdW5jdGlvbiAocCwgdGlsZSkge1xuICAgIHJldHVybiBwLnogPT0gdGlsZS56IC0gMSAmJlxuICAgICAgICAgICAgKHRpbGUueCA+PiAxKSA9PSBwLnggJiZcbiAgICAgICAgICAgICh0aWxlLnkgPj4gMSkgPT0gcC55O1xuICB9LFxuXG4gIC8vIGFmdGVyIGFkZGluZyBuZXcgdGlsZXMgdG8gbG9hZCBhbmQgX2JlZm9yZV8gcmVtb3Zpbmcgb2xkXG4gIC8vIHRpbGVzIHdlIGdldCB0aGlzIG9uZXMgdG8gc2VlIGlmIHdlIGNhbiBvdmVyc2FtcGxlIG8gdW5kZXJzYW1wbGUgdXNpbmcgY3VycmVudCB0aWxlc1xuICAvLyBzYW1wbGluZyB0aGUgdGlsZXMgc2hvdWxkIGJlIGRvbmUgYXQgYSBkaWZmZXJlbnQgbGV2ZWwgYmVjYXVzZSBuZWVkcyB0byBrbm93IGhvdyB0byBzYW1wbGUgdGhlbVxuICBfcmVzYW1wbGVPbGRUaWxlczogZnVuY3Rpb24odGlsZUJvdW5kcykge1xuICAgIGZvciAodmFyIHQgaW4gdGhpcy5fdGlsZXNMb2FkaW5nKSB7XG4gICAgICAvLyBjaGVjayBmb3IgcGFyZW50IG9uZVxuICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlRnJvbUtleSh0KTtcbiAgICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgICBmb3IgKHZhciBwIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5fdGlsZUZyb21LZXkocCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1BhcmVudCh0aWxlLCBjKSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUgYXJlIHBhcmVudHMgYSBwYXJlbnQgbGV2ZWwgaXMgYmVpbmcgbG9hZGVkXG4gICAgICAvLyBzbyBubyBsb29rIGZvciBjaGlsZHJlblxuICAgICAgaWYgKCFwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBjaGVjayBjaGlsZHJlblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5fdGlsZUZyb21LZXkocCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzUGFyZW50KGMsIHRpbGUpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGVzOiBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICAgICAgfVxuICB9LFxuXG4gIF9yZWxvYWRUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVtb3ZlVGlsZXMoKTtcbiAgICB0aGlzLl91cGRhdGVUaWxlcygpO1xuICB9LFxuXG4gIF9yZW1vdmVPdGhlclRpbGVzOiBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIga0FyciwgeCwgeSwgeiwga2V5O1xuICAgICAgdmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBjaGVja1RpbGUoYywga2V5KSB7XG4gICAgICAgICAgaWYgKGMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBrQXJyID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgIHggPSBwYXJzZUludChrQXJyWzBdLCAxMCk7XG4gICAgICAgICAgICAgIHkgPSBwYXJzZUludChrQXJyWzFdLCAxMCk7XG4gICAgICAgICAgICAgIHogPSBwYXJzZUludChrQXJyWzJdLCAxMCk7XG5cbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzXG4gICAgICAgICAgICAgIGlmICh6b29tICE9PSB6IHx8IHggPCBib3VuZHMubWluLnggfHwgeCA+IGJvdW5kcy5tYXgueCB8fCB5IDwgYm91bmRzLm1pbi55IHx8IHkgPiBib3VuZHMubWF4LnkpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZVRpbGUoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgY2hlY2tUaWxlKHRoaXMuX3RpbGVzLCBrZXkpO1xuICAgICAgfVxuICAgICAgZm9yIChrZXkgaW4gdGhpcy5fdGlsZXNMb2FkaW5nKSB7XG4gICAgICAgIGNoZWNrVGlsZSh0aGlzLl90aWxlc0xvYWRpbmcsIGtleSk7XG4gICAgICB9XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRoaXMuZmlyZSgndGlsZVJlbW92ZWQnLCB0aGlzLl90aWxlc1trZXldKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgaWYgKHRoaXMuX3RpbGVzTG9hZGluZ1trZXldKSB7XG4gICAgICAgIC0tdGhpcy5fdGlsZXNUb0xvYWQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc0xvYWRpbmdba2V5XTtcbiAgICAgIH1cbiAgfSxcblxuICBfdGlsZUtleTogZnVuY3Rpb24odGlsZVBvaW50KSB7XG4gICAgcmV0dXJuIHRpbGVQb2ludC54ICsgJzonICsgdGlsZVBvaW50LnkgKyAnOicgKyB0aWxlUG9pbnQuem9vbTtcbiAgfSxcblxuICBfdGlsZUZyb21LZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGtBcnIgPSBrZXkuc3BsaXQoJzonKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBhcnNlSW50KGtBcnJbMF0sIDEwKSxcbiAgICAgICAgeTogcGFyc2VJbnQoa0FyclsxXSwgMTApLFxuICAgICAgICB6OiBwYXJzZUludChrQXJyWzJdLCAxMClcbiAgICAgIH1cbiAgfSxcblxuICBfdGlsZVNob3VsZEJlTG9hZGVkOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XG4gICAgICB2YXIgayA9IHRoaXMuX3RpbGVLZXkodGlsZVBvaW50KTtcbiAgICAgIHJldHVybiAhKGsgaW4gdGhpcy5fdGlsZXMpICYmICEoayBpbiB0aGlzLl90aWxlc0xvYWRpbmcpO1xuICB9LFxuXG4gIF90aWxlTG9hZGVkOiBmdW5jdGlvbih0aWxlUG9pbnQsIHRpbGVEYXRhKSB7XG4gICAgdGhpcy5fdGlsZXNUb0xvYWQtLTtcbiAgICB2YXIgayA9IHRpbGVQb2ludC54ICsgJzonICsgdGlsZVBvaW50LnkgKyAnOicgKyB0aWxlUG9pbnQuem9vbVxuICAgIHRoaXMuX3RpbGVzW2tdID0gdGlsZURhdGE7XG4gICAgZGVsZXRlIHRoaXMuX3RpbGVzTG9hZGluZ1trXTtcbiAgICBpZih0aGlzLl90aWxlc1RvTG9hZCA9PT0gMCkge1xuICAgICAgdGhpcy5maXJlKFwidGlsZXNMb2FkZWRcIik7XG4gICAgfVxuICB9LFxuXG4gIGdldFRpbGVQb3M6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcbiAgICB0aWxlUG9pbnQgPSBuZXcgTC5Qb2ludCh0aWxlUG9pbnQueCwgdGlsZVBvaW50LnkpO1xuICAgIHZhciBvcmlnaW4gPSB0aGlzLl9tYXAuX2dldE5ld1RvcExlZnRQb2ludCh0aGlzLl9tYXAuZ2V0Q2VudGVyKCkpLFxuICAgICAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblxuICAgIHJldHVybiB0aWxlUG9pbnQubXVsdGlwbHlCeSh0aWxlU2l6ZSkuc3VidHJhY3Qob3JpZ2luKTtcbiAgfSxcblxuICBfYWRkVGlsZXNGcm9tQ2VudGVyT3V0OiBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgICBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgIHZhciBqLCBpLCBwb2ludDtcblxuICAgICAgZm9yIChqID0gYm91bmRzLm1pbi55OyBqIDw9IGJvdW5kcy5tYXgueTsgaisrKSB7XG4gICAgICAgICAgZm9yIChpID0gYm91bmRzLm1pbi54OyBpIDw9IGJvdW5kcy5tYXgueDsgaSsrKSB7XG4gICAgICAgICAgICAgIHBvaW50ID0gbmV3IEwuUG9pbnQoaSwgaik7XG4gICAgICAgICAgICAgIHBvaW50Lnpvb20gPSAgem9vbTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5fdGlsZVNob3VsZEJlTG9hZGVkKHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWxlc1RvTG9hZCA9IHF1ZXVlLmxlbmd0aDtcblxuICAgICAgaWYgKHRpbGVzVG9Mb2FkID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICAvLyBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuICAgICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLmRpc3RhbmNlVG8oY2VudGVyKSAtIGIuZGlzdGFuY2VUbyhjZW50ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3RpbGVzVG9Mb2FkICs9IHRpbGVzVG9Mb2FkO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGlsZXNUb0xvYWQ7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgayA9IHRoaXMuX3RpbGVLZXkodCk7XG4gICAgICAgIHRoaXMuX3RpbGVzTG9hZGluZ1trXSA9IHQ7XG4gICAgICAgIHRoaXMuZmlyZSgndGlsZUFkZGVkJywgdCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoXCJ0aWxlc0xvYWRpbmdcIik7XG5cbiAgfVxuXG59XG4iLCJ2YXIgY2FydG8gPSBnbG9iYWwuY2FydG8gfHwgcmVxdWlyZSgnY2FydG8nKTtcbnZhciB0b3JxdWUgPSByZXF1aXJlKCcuLi8nKTtcblxucmVxdWlyZSgnLi9jYW52YXNfbGF5ZXInKTtcblxuLyoqXG4gKiB0b3JxdWUgbGF5ZXJcbiAqL1xuTC5Ub3JxdWVMYXllciA9IEwuQ2FudmFzTGF5ZXIuZXh0ZW5kKHtcblxuICBwcm92aWRlcnM6IHtcbiAgICAnc3FsX2FwaSc6IHRvcnF1ZS5wcm92aWRlcnMuanNvbixcbiAgICAndXJsX3RlbXBsYXRlJzogdG9ycXVlLnByb3ZpZGVycy5Kc29uQXJyYXksXG4gICAgJ3dpbmRzaGFmdCc6IHRvcnF1ZS5wcm92aWRlcnMud2luZHNoYWZ0LFxuICAgICd0aWxlSlNPTic6IHRvcnF1ZS5wcm92aWRlcnMudGlsZUpTT05cbiAgfSxcblxuICByZW5kZXJlcnM6IHtcbiAgICAncG9pbnQnOiB0b3JxdWUucmVuZGVyZXIuUG9pbnQsXG4gICAgJ3BpeGVsJzogdG9ycXVlLnJlbmRlcmVyLlJlY3RhbmdsZVxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCF0b3JxdWUuaXNCcm93c2VyU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBieSB0b3JxdWVcIik7XG4gICAgfVxuICAgIG9wdGlvbnMudGlsZUxvYWRlciA9IHRydWU7XG4gICAgdGhpcy5rZXkgPSAwO1xuICAgIHRoaXMucHJldlJlbmRlcmVkS2V5ID0gMDtcbiAgICBpZiAob3B0aW9ucy5jYXJ0b2Nzcykge1xuICAgICAgdG9ycXVlLmV4dGVuZChvcHRpb25zLCB0b3JxdWUuY29tbW9uLlRvcnF1ZUxheWVyLm9wdGlvbnNGcm9tQ2FydG9DU1Mob3B0aW9ucy5jYXJ0b2NzcykpO1xuICAgIH1cblxuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbiB8fCAyO1xuICAgIG9wdGlvbnMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzIHx8IDEwMDtcbiAgICBvcHRpb25zLnZpc2libGUgPSBvcHRpb25zLnZpc2libGUgPT09IHVuZGVmaW5lZCA/IHRydWU6IG9wdGlvbnMudmlzaWJsZTtcbiAgICB0aGlzLmhpZGRlbiA9ICFvcHRpb25zLnZpc2libGU7XG5cbiAgICB0aGlzLmFuaW1hdG9yID0gbmV3IHRvcnF1ZS5BbmltYXRvcihmdW5jdGlvbih0aW1lKSB7XG4gICAgICB2YXIgayA9IHRpbWUgfCAwO1xuICAgICAgaWYoc2VsZi5rZXkgIT09IGspIHtcbiAgICAgICAgc2VsZi5zZXRLZXkoaywgeyBkaXJlY3Q6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSwgdG9ycXVlLmV4dGVuZCh0b3JxdWUuY2xvbmUob3B0aW9ucyksIHtcbiAgICAgIG9uUGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmZpcmUoJ3BhdXNlJyk7XG4gICAgICB9LFxuICAgICAgb25TdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5maXJlKCdzdG9wJyk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZmlyZSgncGxheScpO1xuICAgICAgfSxcbiAgICAgIG9uU3RlcHNSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZmlyZSgnY2hhbmdlOnN0ZXBzUmFuZ2UnLCBzZWxmLmFuaW1hdG9yLnN0ZXBzUmFuZ2UoKSk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgdGhpcy5wbGF5ID0gdGhpcy5hbmltYXRvci5zdGFydC5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICAgIHRoaXMuc3RvcCA9IHRoaXMuYW5pbWF0b3Iuc3RvcC5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICAgIHRoaXMucGF1c2UgPSB0aGlzLmFuaW1hdG9yLnBhdXNlLmJpbmQodGhpcy5hbmltYXRvcik7XG4gICAgdGhpcy50b2dnbGUgPSB0aGlzLmFuaW1hdG9yLnRvZ2dsZS5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICAgIHRoaXMuc2V0RHVyYXRpb24gPSB0aGlzLmFuaW1hdG9yLmR1cmF0aW9uLmJpbmQodGhpcy5hbmltYXRvcik7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSB0aGlzLmFuaW1hdG9yLmlzUnVubmluZy5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuXG5cbiAgICBMLkNhbnZhc0xheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgJ3BvaW50JztcbiAgICB0aGlzLm9wdGlvbnMucHJvdmlkZXIgPSB0aGlzLm9wdGlvbnMucHJvdmlkZXIgfHwgJ3dpbmRzaGFmdCc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbGVKU09OKSB0aGlzLm9wdGlvbnMucHJvdmlkZXIgPSAndGlsZUpTT04nO1xuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyB0aGlzLnByb3ZpZGVyc1t0aGlzLm9wdGlvbnMucHJvdmlkZXJdKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyB0aGlzLnJlbmRlcmVyc1t0aGlzLm9wdGlvbnMucmVuZGVyZXJdKHRoaXMuZ2V0Q2FudmFzKCksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBvcHRpb25zLnJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZpcmUoXCJjaGFuZ2U6Ym91bmRzXCIsIHtcbiAgICAgICAgYm91bmRzOiBzZWxmLnByb3ZpZGVyLmdldEJvdW5kcygpXG4gICAgICB9KTtcbiAgICAgIHNlbGYuYW5pbWF0b3Iuc3RlcHMoc2VsZi5wcm92aWRlci5nZXRTdGVwcygpKTtcbiAgICAgIHNlbGYuYW5pbWF0b3IucmVzY2FsZSgpO1xuICAgICAgc2VsZi5maXJlKCdjaGFuZ2U6c3RlcHMnLCB7XG4gICAgICAgIHN0ZXBzOiBzZWxmLnByb3ZpZGVyLmdldFN0ZXBzKClcbiAgICAgIH0pO1xuICAgICAgc2VsZi5zZXRLZXkoc2VsZi5rZXkpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbmRlcmVyLm9uKFwiYWxsSWNvbnNMb2FkZWRcIiwgdGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG5cblxuICAgIC8vIGZvciBlYWNoIHRpbGUgc2hvd24gb24gdGhlIG1hcCByZXF1ZXN0IHRoZSBkYXRhXG4gICAgdGhpcy5vbigndGlsZUFkZGVkJywgZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHRpbGVEYXRhID0gdGhpcy5wcm92aWRlci5nZXRUaWxlRGF0YSh0LCB0Lnpvb20sIGZ1bmN0aW9uKHRpbGVEYXRhKSB7XG4gICAgICAgIC8vIGRvbid0IGxvYWQgdGlsZXMgdGhhdCBhcmUgbm90IGJlaW5nIHNob3duXG4gICAgICAgIGlmICh0Lnpvb20gIT09IHNlbGYuX21hcC5nZXRab29tKCkpIHJldHVybjtcbiAgICAgICAgc2VsZi5fdGlsZUxvYWRlZCh0LCB0aWxlRGF0YSk7XG4gICAgICAgIHNlbGYuX2NsZWFyVGlsZUNhY2hlcygpO1xuICAgICAgICBpZiAodGlsZURhdGEpIHtcbiAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmlyZSgndGlsZUxvYWRlZCcpO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgfSxcblxuICBfY2xlYXJUaWxlQ2FjaGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgdGlsZTtcbiAgICBmb3IodCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5fdGlsZUNhY2hlKSB7XG4gICAgICAgIHRpbGUuX3RpbGVDYWNoZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9jbGVhckNhY2hlczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW5kZXJlciAmJiB0aGlzLnJlbmRlcmVyLmNsZWFyU3ByaXRlQ2FjaGUoKTtcbiAgICB0aGlzLl9jbGVhclRpbGVDYWNoZXMoKTtcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgIG1hcC5vbih7XG4gICAgICAnem9vbWVuZCc6IHRoaXMuX2NsZWFyQ2FjaGVzLFxuICAgICAgJ3pvb21zdGFydCc6IHRoaXMuX3BhdXNlT25ab29tLFxuICAgIH0sIHRoaXMpO1xuXG4gICAgbWFwLm9uKHtcbiAgICAgICd6b29tZW5kJzogdGhpcy5fcmVzdW1lT25ab29tXG4gICAgfSwgdGhpcyk7XG4gICAgTC5DYW52YXNMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICB9LFxuXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICB0aGlzLmZpcmUoJ3JlbW92ZScpO1xuICAgIHRoaXMuX3JlbW92ZVRpbGVMb2FkZXIoKTtcbiAgICBtYXAub2ZmKHtcbiAgICAgICd6b29tZW5kJzogdGhpcy5fY2xlYXJDYWNoZXMsXG4gICAgICAnem9vbXN0YXJ0JzogdGhpcy5fcGF1c2VPblpvb20sXG4gICAgfSwgdGhpcyk7XG4gICAgbWFwLm9mZih7XG4gICAgICAnem9vbWVuZCc6IHRoaXMuX3Jlc3VtZU9uWm9vbVxuICAgIH0sIHRoaXMpO1xuICAgIEwuQ2FudmFzTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgfSxcblxuICBfcGF1c2VPblpvb206IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMud2FzUnVubmluZyA9IHRoaXMuaXNSdW5uaW5nKCk7XG4gICAgaWYgKHRoaXMud2FzUnVubmluZykge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgfSxcblxuICBfcmVzdW1lT25ab29tOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy53YXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5oaWRkZW4pIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIGlmKCF0aGlzLmhpZGRlbikgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLnBsYXkoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnN0ZXBzID09PSAxKXtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldFNRTDogZnVuY3Rpb24oc3FsKSB7XG4gICAgaWYgKHRoaXMucHJvdmlkZXIub3B0aW9ucy5uYW1lZF9tYXApIHRocm93IG5ldyBFcnJvcihcIlNRTCBxdWVyaWVzIG9uIG5hbWVkIG1hcHMgYXJlIHJlYWQtb25seVwiKTtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIgfHwgIXRoaXMucHJvdmlkZXIuc2V0U1FMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aGlzIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgU1FMXCIpO1xuICAgIH1cbiAgICB0aGlzLnByb3ZpZGVyLnNldFNRTChzcWwpO1xuICAgIHRoaXMuX3JlbG9hZFRpbGVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbihfKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRCbGVuZE1vZGUoXyk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfSxcblxuICBzZXRTdGVwczogZnVuY3Rpb24oc3RlcHMpIHtcbiAgICB0aGlzLnByb3ZpZGVyLnNldFN0ZXBzKHN0ZXBzKTtcbiAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICB9LFxuXG4gIHNldENvbHVtbjogZnVuY3Rpb24oY29sdW1uLCBpc1RpbWUpIHtcbiAgICB0aGlzLnByb3ZpZGVyLnNldENvbHVtbihjb2x1bW4sIGlzVGltZSk7XG4gICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgfSxcblxuICBnZXRUaW1lQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLmdldEtleVNwYW4oKTtcbiAgfSxcblxuICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZW5kZXIgdGhlIHNlbGVjdGVmIGtleVxuICAgKiBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHksIGl0J3MgY2FsbGVkIGJ5XG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVXNlIHJlZHJhdyB0byByZWZyZXNoIGl0XG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuaGlkZGVuKSByZXR1cm47XG4gICAgdmFyIHQsIHRpbGUsIHBvcztcbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICB0aGlzLnJlbmRlcmVyLmNsZWFyQ2FudmFzKCk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgIC8vIGNsZWFyIGNhY2hlXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdG9yLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgdGlsZS5fdGlsZUNhY2hlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IHRoaXMuZ2V0VGlsZVBvcyh0aWxlLmNvb3JkKTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBwb3MueCwgcG9zLnkpO1xuXG4gICAgICAgIGlmICh0aWxlLl90aWxlQ2FjaGUpIHtcbiAgICAgICAgICAvLyB3aGVuIHRoZSB0aWxlIGhhcyBhIGNhY2hlZCBpbWFnZSBqdXN0IHJlbmRlciBpdCBhbmQgYXZvaWQgdG8gcmVuZGVyXG4gICAgICAgICAgLy8gYWxsIHRoZSBwb2ludHNcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9jdHguZHJhd0ltYWdlKHRpbGUuX3RpbGVDYWNoZSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUaWxlKHRpbGUsIHRoaXMua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZXIuYXBwbHlGaWx0ZXJzKCk7XG5cbiAgICAvLyBwcmVwYXJlIGNhY2hlcyBpZiB0aGUgYW5pbWF0aW9uIGlzIG5vdCBydW5uaW5nXG4gICAgLy8gZG9uJ3QgY2FjaGUgaWYgdGhlIGtleSBoYXMganVzdCBjaGFuZ2VkLCB0aGlzIGF2b2lkcyB0byBjYWNoZVxuICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgZHJhZ2dpbmcsIGl0IG9ubHkgY2FjaGUgd2hlbiB0aGUgbWFwIGlzIHN0aWxsXG4gICAgaWYgKCF0aGlzLmFuaW1hdG9yLmlzUnVubmluZygpICYmIHRoaXMua2V5ID09PSB0aGlzLnByZXZSZW5kZXJlZEtleSkge1xuICAgICAgdmFyIHRpbGVfc2l6ZSA9IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFO1xuICAgICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgICBpZiAodGlsZSAmJiAhdGlsZS5fdGlsZUNhY2hlKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aWxlLl90aWxlQ2FjaGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBjLndpZHRoID0gYy5oZWlnaHQgPSB0aWxlX3NpemU7XG4gICAgICAgICAgcG9zID0gdGhpcy5nZXRUaWxlUG9zKHRpbGUuY29vcmQpO1xuICAgICAgICAgIC8vIGNsaXAgYm91bmRzLCBmaXJlZm94IHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGVuIHRyeSB0byBnZXQgZGF0YSBmcm9tIG91dHNpZGUgY2FudmFzXG4gICAgICAgICAgdmFyIHggPSBNYXRoLm1heCgwLCBwb3MueClcbiAgICAgICAgICB2YXIgeSA9IE1hdGgubWF4KDAsIHBvcy55KVxuICAgICAgICAgIHZhciB3ID0gTWF0aC5taW4odGlsZV9zaXplLCB0aGlzLmdldENhbnZhcygpLndpZHRoIC0geCk7XG4gICAgICAgICAgdmFyIGggPSBNYXRoLm1pbih0aWxlX3NpemUsIHRoaXMuZ2V0Q2FudmFzKCkuaGVpZ2h0IC0geSk7XG4gICAgICAgICAgaWYgKHcgPiAwICYmIGggPiAwKSB7XG4gICAgICAgICAgICBjLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHRoaXMuZ2V0Q2FudmFzKCksIHgsIHksIHcsIGgsIHggLSBwb3MueCwgeSAtIHBvcy55LCB3LCBoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByZXZSZW5kZXJlZEtleSA9IHRoaXMua2V5O1xuXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCBrZXkgdG8gYmUgc2hvd24uIElmIGl0J3MgYSBzaW5nbGUgdmFsdWVcbiAgICogaXQgcmVuZGVycyBkaXJlY3RseSwgaWYgaXQncyBhbiBhcnJheSBpdCByZW5kZXJzXG4gICAqIGFjY3VtdWxhdGVkXG4gICAqL1xuICBzZXRLZXk6IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuYW5pbWF0b3Iuc3RlcChrZXkpO1xuICAgIHRoaXMuX2NsZWFyVGlsZUNhY2hlcygpO1xuICAgIHRoaXMucmVkcmF3KG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3QpO1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlOnRpbWUnLCB7IHRpbWU6IHRoaXMuZ2V0VGltZSgpLCBzdGVwOiB0aGlzLmtleSB9KTtcbiAgfSxcblxuICAvKipcbiAgICogaGVscGVyIGZ1bmN0aW9uLCBkb2VzIHRoZSBzYW1lIHRoYW4gYGBzZXRLZXlgYCBidXQgb25seVxuICAgKiBhY2NlcHRzIHNjYWxhcnMuXG4gICAqL1xuICBzZXRTdGVwOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgaWYodGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFRpbWUgb25seSBhY2NlcHQgc2NhbGFyc1wiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRLZXkodGltZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRyYW5zZm9ybSBmcm9tIGFuaW1hdGlvbiBzdGVwIHRvIERhdGUgb2JqZWN0XG4gICAqIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aW1lXG4gICAqXG4gICAqIGBgc3RlcGBgIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIGBgc3RlcHMgLSAxYGBcbiAgICovXG4gIHN0ZXBUb1RpbWU6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdGltZXMgPSB0aGlzLnByb3ZpZGVyLmdldEtleVNwYW4oKTtcbiAgICB2YXIgdGltZSA9IHRpbWVzLnN0YXJ0ICsgKHRpbWVzLmVuZCAtIHRpbWVzLnN0YXJ0KSooc3RlcC90aGlzLnByb3ZpZGVyLmdldFN0ZXBzKCkpO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lKTtcbiAgfSxcblxuICB0aW1lVG9TdGVwOiBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gXCJEYXRlXCIpIHRpbWVzdGFtcCA9IHRpbWVzdGFtcC5nZXRUaW1lKCk7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSByZXR1cm4gMDtcbiAgICB2YXIgdGltZXMgPSB0aGlzLnByb3ZpZGVyLmdldEtleVNwYW4oKTtcbiAgICB2YXIgc3RlcCA9ICh0aGlzLnByb3ZpZGVyLmdldFN0ZXBzKCkgKiAodGltZXN0YW1wIC0gdGltZXMuc3RhcnQpKSAvICh0aW1lcy5lbmQgLSB0aW1lcy5zdGFydCk7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH0sXG5cbiAgZ2V0U3RlcDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBhbmltYXRpb24gdGltZSBkZWZpbmVkIGJ5IHRoZSBkYXRhXG4gICAqIGluIHRoZSBkZWZpbmVkIGNvbHVtbi4gRGF0ZSBvYmplY3RcbiAgICovXG4gIGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBUb1RpbWUodGhpcy5rZXkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBzdGFydCBhbmQgZW5kIHRpbWVzXG4gICAqL1xuICBnZXRUaW1lU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0S2V5U3BhbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQgdGhlIGNhcnRvY3NzIGZvciB0aGUgY3VycmVudCByZW5kZXJlclxuICAgKi9cbiAgc2V0Q2FydG9DU1M6IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gICAgaWYgKHRoaXMucHJvdmlkZXIub3B0aW9ucy5uYW1lZF9tYXApIHRocm93IG5ldyBFcnJvcihcIkNhcnRvQ1NTIHN0eWxlIG9uIG5hbWVkIG1hcHMgaXMgcmVhZC1vbmx5XCIpO1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikgdGhyb3cgbmV3IEVycm9yKCdyZW5kZXJlciBpcyBub3QgdmFsaWQnKTtcbiAgICB0aGlzLm9wdGlvbnMuY2FydG9jc3MgPSBjYXJ0b2NzcztcbiAgICB2YXIgc2hhZGVyID0gbmV3IGNhcnRvLlJlbmRlcmVySlMoKS5yZW5kZXIoY2FydG9jc3MpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2hhZGVyKHNoYWRlcik7XG5cbiAgICAvLyBwcm92aWRlciBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSB0b3JxdWUuY29tbW9uLlRvcnF1ZUxheWVyLm9wdGlvbnNGcm9tTGF5ZXIoc2hhZGVyLmZpbmRMYXllcih7IG5hbWU6ICdNYXAnIH0pKTtcbiAgICB0aGlzLnByb3ZpZGVyLnNldENhcnRvQ1NTICYmIHRoaXMucHJvdmlkZXIuc2V0Q2FydG9DU1MoY2FydG9jc3MpO1xuICAgIGlmKHRoaXMucHJvdmlkZXIuc2V0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgICB9XG5cbiAgICB0b3JxdWUuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBhbmltYXRvciBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuYW5pbWF0b3IuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQ2FjaGVzKCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogZ2V0IGFjdGl2ZSBwb2ludHMgZm9yIGEgc3RlcCBpbiBhY3RpdmUgem9vbVxuICAgKiByZXR1cm5zIGEgbGlzdCBvZiBib3VuZGluZyBib3hlcyBbW10gLCBbXSwgW11dXG4gICAqIGVtcHR5IGxpc3QgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIHBpeGVsc1xuICAgKi9cbiAgZ2V0QWN0aXZlUG9pbnRzQkJveDogZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICBmb3IodmFyIHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuY29uY2F0KHRoaXMucmVuZGVyZXIuZ2V0QWN0aXZlUG9pbnRzQkJveCh0aWxlLCBzdGVwKSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSB2YWx1ZXMgZm9yIGFsbCB0aGUgcGl4ZWxzIGFjdGl2ZSBmb3IgdGhlIHN0ZXBcbiAgICovXG4gIGdldFZhbHVlczogZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gdGhpcy5rZXk6IHN0ZXA7XG4gICAgdmFyIHQsIHRpbGU7XG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2V0VmFsdWVzKHRpbGUsIHN0ZXAsIHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgdmFsdWUgZm9yIHBvc2l0aW9uIHJlbGF0aXZlIHRvIG1hcCBjb29yZGluYXRlcy4gbnVsbCBmb3Igbm8gdmFsdWVcbiAgICovXG4gIGdldFZhbHVlRm9yUG9zOiBmdW5jdGlvbih4LCB5LCBzdGVwKSB7XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5OiBzdGVwO1xuICAgIHZhciB0LCB0aWxlLCBwb3MsIHZhbHVlID0gbnVsbCwgeHgsIHl5O1xuICAgIGZvcih0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBpZiAodGlsZSkge1xuICAgICAgICBwb3MgPSB0aGlzLmdldFRpbGVQb3ModGlsZS5jb29yZCk7XG4gICAgICAgIHh4ID0geCAtIHBvcy54O1xuICAgICAgICB5eSA9IHkgLSBwb3MueTtcbiAgICAgICAgaWYgKHh4ID49IDAgJiYgeXkgPj0gMCAmJiB4eCA8IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFICYmIHl5IDw9IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFKSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnJlbmRlcmVyLmdldFZhbHVlRm9yKHRpbGUsIHN0ZXAsIHh4LCB5eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGlsZSBwb3MgZ2l2ZW4gc2NyZWVuIHgseSBjb29yZGluYXRlc1xuICAgKi9cbiAgZ2V0VGlsZVBvc0ZvclBpeGVsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHQsIHRpbGUsIHBvcywgeHgsIHl5O1xuICAgIGZvcih0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBpZiAodGlsZSkge1xuICAgICAgICBwb3MgPSB0aGlzLmdldFRpbGVQb3ModGlsZS5jb29yZCk7XG4gICAgICAgIHh4ID0geCAtIHBvcy54O1xuICAgICAgICB5eSA9IHkgLSBwb3MueTtcbiAgICAgICAgaWYgKHh4ID49IDAgJiYgeXkgPj0gMCAmJiB4eCA8IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFICYmIHl5IDw9IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHh4LFxuICAgICAgICAgICAgeTogeXksXG4gICAgICAgICAgICB0aWxlOiB0aWxlLmNvb3JkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm4gYSBsaXN0IG9mIHRoZSBjbG9zZXN0IHZhbHVlcyBmb3IgYSBnaXZlbiBjb29yZC5cbiAgICogcmV0dXJuZWQgZm9ybWF0IGlzIFt7IHg6IC4uLCB5OiAuLiwgdmFsdWU6IC4uLn0sIC4uIF1cbiAgICovXG4gIGdldENsb3Nlc3RWYWx1ZXNGb3I6IGZ1bmN0aW9uKHgsIHksIGRpc3QsIHN0ZXApIHtcbiAgICB2YXIgeGYgPSB4ICsgZGlzdCxcbiAgICAgICAgeWYgPSB5ICsgZGlzdCxcbiAgICAgICAgX3ggPSB4O1xuICAgIHZhciB2YWx1ZXMgPSBbXVxuICAgIGZvcihfeSA9IHk7IF95IDwgeWY7IF95ICs9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgIGZvcihfeCA9IHg7IF94IDwgeGY7IF94ICs9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgICAgdmFyIHRoaXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JQb3MoX3gsX3kpO1xuICAgICAgICBpZiAodGhpc1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGJiID0gdGhpc1ZhbHVlLmJib3g7XG4gICAgICAgICAgdmFyIHh5ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoW2JiWzBdLmxhdCwgYmJbMF0ubG9uXSk7XG4gICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgeDogeHkueCxcbiAgICAgICAgICAgIHk6IHh5LnksXG4gICAgICAgICAgICB2YWx1ZTogdGhpc1ZhbHVlLnZhbHVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuXG4gIGdldFZhbHVlRm9yQkJveDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgIHZhciB4ZiA9IHggKyB3LCB5ZiA9IHkgKyBoLCBfeD14O1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvcihfeSA9IHk7IF95IDwgeWY7IF95ICs9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgIGZvcihfeCA9IHg7IF94IDwgeGY7IF94ICs9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgICAgdmFyIHRoaXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JQb3MoX3gsX3kpO1xuICAgICAgICBpZiAodGhpc1ZhbHVlKSB7XG4gICAgICAgICAgdmFyIGJiID0gdGhpc1ZhbHVlLmJib3g7XG4gICAgICAgICAgdmFyIHh5ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoW2JiWzFdLmxhdCwgYmJbMV0ubG9uXSk7XG4gICAgICAgICAgaWYoeHkueCA8IHhmICYmIHh5LnkgPCB5Zil7XG4gICAgICAgICAgICBzdW0gKz0gdGhpc1ZhbHVlLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9LFxuXG4gIC8qKiByZXR1cm4gdGhlIG51bWJlciBvZiBwb2ludHMgZm9yIGEgc3RlcCAqL1xuICBwb2ludENvdW50OiBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIHQsIHRpbGU7XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5OiBzdGVwO1xuICAgIHZhciBjID0gMDtcbiAgICBmb3IodCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgYyArPSB0aWxlLnRpbWVDb3VudFtzdGVwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sXG5cbiAgaW52YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wcm92aWRlci5yZWxvYWQoKTtcbiAgfSxcblxuICBzZXRTdGVwc1JhbmdlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5hbmltYXRvci5zdGVwc1JhbmdlKHN0YXJ0LCBlbmQpO1xuICB9LFxuXG4gIHJlbW92ZVN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYW5pbWF0b3IucmVtb3ZlQ3VzdG9tU3RlcHNSYW5nZSgpO1xuICB9LFxuXG4gIGdldFN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdG9yLnN0ZXBzUmFuZ2UoKTtcbiAgfVxufSk7XG4iLCIgIGZ1bmN0aW9uIGNsYW1wKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHQsIGIpLCBhKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW52TGluZWFyKGEsIGIpIHtcbiAgICB2YXIgYyA9IGNsYW1wKDAsIDEuMCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBjKCh0IC0gYSkvKGIgLSBhKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVhcihhLCBiKSB7XG4gICAgdmFyIGMgPSBjbGFtcChhLCBiKTtcbiAgICBmdW5jdGlvbiBfbGluZWFyKHQpIHtcbiAgICAgIHJldHVybiBjKGEqKDEuMCAtIHQpICsgdCpiKTtcbiAgICB9XG5cbiAgICBfbGluZWFyLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGludkxpbmVhcihhLCBiKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9saW5lYXI7XG4gIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2xhbXA6IGNsYW1wLFxuICAgIGxpbmVhcjogbGluZWFyLFxuICAgIGludkxpbmVhcjogaW52TGluZWFyXG59O1xuIiwidmFyIFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbn07XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBvcHRNaW4sIG9wdE1heCkge1xuICBpZiAob3B0TWluICE9PSBudWxsKSB2YWx1ZSA9IE1hdGgubWF4KHZhbHVlLCBvcHRNaW4pO1xuICBpZiAob3B0TWF4ICE9PSBudWxsKSB2YWx1ZSA9IE1hdGgubWluKHZhbHVlLCBvcHRNYXgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZGVnKSB7XG4gIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MCk7XG59XG5cbmZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocmFkKSB7XG4gIHJldHVybiByYWQgLyAoTWF0aC5QSSAvIDE4MCk7XG59XG5cblxudmFyIE1lcmNhdG9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuLy8gIHRoaXMuX3RpbGVTaXplID0gTC5Ccm93c2VyLnJldGluYSA/IDUxMiA6IDI1NjtcbiAgdGhpcy5fdGlsZVNpemUgPSAyNTY7XG4gIHRoaXMuX3BpeGVsT3JpZ2luID0gbmV3IFBvaW50KHRoaXMuX3RpbGVTaXplIC8gMiwgdGhpcy5fdGlsZVNpemUgLyAyKTtcbiAgdGhpcy5fcGl4ZWxzUGVyTG9uRGVncmVlID0gdGhpcy5fdGlsZVNpemUgLyAzNjA7XG4gIHRoaXMuX3BpeGVsc1BlckxvblJhZGlhbiA9IHRoaXMuX3RpbGVTaXplIC8gKDIgKiBNYXRoLlBJKTtcbn07XG5cbk1lcmNhdG9yUHJvamVjdGlvbi5wcm90b3R5cGUuX2Zyb21MYXRMb25Ub1BvaW50ID0gZnVuY3Rpb24obGF0LCBsb24pIHtcbiAgdmFyIHBvaW50ID0gbmV3IFBvaW50KDAsIDApO1xuICB2YXIgb3JpZ2luID0gdGhpcy5fcGl4ZWxPcmlnaW47XG5cbiAgcG9pbnQueCA9IG9yaWdpbi54ICsgbG9uICogdGhpcy5fcGl4ZWxzUGVyTG9uRGVncmVlO1xuXG4gIC8vIE5PVEUoYXBwbGV0b24pOiBUcnVuY2F0aW5nIHRvIDAuOTk5OSBlZmZlY3RpdmVseSBsaW1pdHMgbGF0aXR1ZGUgdG9cbiAgLy8gODkuMTg5LiAgVGhpcyBpcyBhYm91dCBhIHRoaXJkIG9mIGEgdGlsZSBwYXN0IHRoZSBlZGdlIG9mIHRoZSB3b3JsZFxuICAvLyB0aWxlLlxuICB2YXIgc2lueSA9IGNsYW1wKE1hdGguc2luKGRlZ3JlZXNUb1JhZGlhbnMobGF0KSksIC0wLjk5OTksIDAuOTk5OSk7XG4gIHBvaW50LnkgPSBvcmlnaW4ueSArIDAuNSAqIE1hdGgubG9nKCgxICsgc2lueSkgLyAoMSAtIHNpbnkpKSAqIC10aGlzLl9waXhlbHNQZXJMb25SYWRpYW47XG4gIHJldHVybiBwb2ludDtcbn07XG5cbk1lcmNhdG9yUHJvamVjdGlvbi5wcm90b3R5cGUuX2Zyb21Qb2ludFRvTGF0TG9uID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIG9yaWdpbiA9IG1lLl9waXhlbE9yaWdpbjtcbiAgdmFyIGxvbiA9IChwb2ludC54IC0gb3JpZ2luLngpIC8gbWUuX3BpeGVsc1BlckxvbkRlZ3JlZTtcbiAgdmFyIGxhdFJhZGlhbnMgPSAocG9pbnQueSAtIG9yaWdpbi55KSAvIC1tZS5fcGl4ZWxzUGVyTG9uUmFkaWFuO1xuICB2YXIgbGF0ID0gcmFkaWFuc1RvRGVncmVlcygyICogTWF0aC5hdGFuKE1hdGguZXhwKGxhdFJhZGlhbnMpKSAtIE1hdGguUEkgLyAyKTtcbiAgcmV0dXJuIHsgbGF0OmxhdCwgbG9uOmxvbiB9O1xufTtcblxuTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS5fdGlsZVBpeGVsUG9zID0gZnVuY3Rpb24odGlsZVgsIHRpbGVZKSB7XG4gIHJldHVybiB7XG4gICAgeDogdGlsZVgqdGhpcy5fdGlsZVNpemUsXG4gICAgeTogdGlsZVkqdGhpcy5fdGlsZVNpemVcbiAgfTtcbn07XG5cbk1lcmNhdG9yUHJvamVjdGlvbi5wcm90b3R5cGUudGlsZVBpeGVsQkJveCA9IGZ1bmN0aW9uKHgsIHksIHpvb20sIHB4LCBweSwgcmVzKSB7XG4gIHJlcyA9IHJlcyB8fCAxLjA7XG4gIHZhciBudW1UaWxlcyA9IDEgPDx6b29tO1xuICB2YXIgaW5jID0gcmVzL251bVRpbGVzO1xuICBweCA9ICh4KnRoaXMuX3RpbGVTaXplICsgcHgpL251bVRpbGVzO1xuICBweSA9ICh5KnRoaXMuX3RpbGVTaXplICsgcHkpL251bVRpbGVzO1xuICByZXR1cm4gW1xuICAgIHRoaXMuX2Zyb21Qb2ludFRvTGF0TG9uKG5ldyBQb2ludChweCwgcHkgKyBpbmMpKSxcbiAgICB0aGlzLl9mcm9tUG9pbnRUb0xhdExvbihuZXcgUG9pbnQocHggKyBpbmMsIHB5KSlcbiAgXTtcbn07XG5cbk1lcmNhdG9yUHJvamVjdGlvbi5wcm90b3R5cGUudGlsZUJCb3ggPSBmdW5jdGlvbih4LCB5LCB6b29tLCBidWZmZXJTaXplKSB7XG4gIHZhciBudW1UaWxlcyA9IDEgPDx6b29tO1xuICBidWZmZXJTaXplID0gYnVmZmVyU2l6ZSB8fCAwO1xuICB2YXIgaW5jID0gICh0aGlzLl90aWxlU2l6ZSArIGJ1ZmZlclNpemUqMikvbnVtVGlsZXM7XG4gIHZhciBweCA9ICh4KnRoaXMuX3RpbGVTaXplIC0gYnVmZmVyU2l6ZSAgKS9udW1UaWxlcztcbiAgdmFyIHB5ID0gKHkqdGhpcy5fdGlsZVNpemUgLSBidWZmZXJTaXplICApL251bVRpbGVzO1xuICByZXR1cm4gW1xuICAgIHRoaXMuX2Zyb21Qb2ludFRvTGF0TG9uKG5ldyBQb2ludChweCwgcHkgKyBpbmMpKSxcbiAgICB0aGlzLl9mcm9tUG9pbnRUb0xhdExvbihuZXcgUG9pbnQocHggKyBpbmMsIHB5KSlcbiAgXTtcbn07XG5cbk1lcmNhdG9yUHJvamVjdGlvbi5wcm90b3R5cGUubGF0TG9uVG9UaWxlUG9pbnQgPSBmdW5jdGlvbihsYXQsIGxvbiwgdGlsZVgsIHRpbGVZLCB6b29tKSB7XG4gIHZhciBudW1UaWxlcyA9IDEgPDx6b29tO1xuICB2YXIgd29ybGRDb29yZGluYXRlID0gdGhpcy5fZnJvbUxhdExvblRvUG9pbnQobGF0LCBsb24pO1xuICB2YXIgcGl4ZWxDb29yZGluYXRlID0gbmV3IFBvaW50KHdvcmxkQ29vcmRpbmF0ZS54Km51bVRpbGVzLCB3b3JsZENvb3JkaW5hdGUueSpudW1UaWxlcyk7XG4gIHZhciB0aWxlUGl4ZWxQb3MgICAgPSB0aGlzLl90aWxlUGl4ZWxQb3ModGlsZVgsIHRpbGVZKTtcbiAgcmV0dXJuIG5ldyBQb2ludChNYXRoLnJvdW5kKHBpeGVsQ29vcmRpbmF0ZS54LXRpbGVQaXhlbFBvcy54KSwgTWF0aC5yb3VuZChwaXhlbENvb3JkaW5hdGUueS10aWxlUGl4ZWxQb3MueSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXJjYXRvclByb2plY3Rpb247XG4iLCIvKlxuIyBtZXRyaWNzIHByb2ZpbGVyXG5cbiMjIHRpbWluZ1xuXG5gYGBcbiB2YXIgdGltZXIgPSBQcm9maWxlci5tZXRyaWMoJ3Jlc291cmNlOmxvYWQnKVxuIHRpbWUuc3RhcnQoKTtcbiAuLi5cbiB0aW1lLmVuZCgpO1xuYGBgXG5cbiMjIGNvdW50ZXJzXG5cbmBgYFxuIHZhciBjb3VudGVyID0gUHJvZmlsZXIubWV0cmljKCdyZXF1ZXN0cycpXG4gY291bnRlci5pbmMoKTsgICAvLyAxXG4gY291bnRlci5pbmMoMTApOyAvLyAxMVxuIGNvdW50ZXIuZGVjKCkgICAgLy8gMTBcbiBjb3VudGVyLmRlYygxMCkgIC8vIDBcbmBgYFxuXG4jIyBDYWxscyBwZXIgc2Vjb25kXG5gYGBcbiAgdmFyIGZwcyA9IFByb2ZpbGVyLm1ldHJpYygnZnBzJylcbiAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGZwcy5tYXJrKCk7XG4gIH1cbmBgYFxuKi9cbnZhciBNQVhfSElTVE9SWSA9IDEwMjQ7XG5mdW5jdGlvbiBQcm9maWxlcigpIHt9XG5Qcm9maWxlci5tZXRyaWNzID0ge307XG5cblByb2ZpbGVyLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIFByb2ZpbGVyLm1ldHJpY3NbbmFtZV0gfHwge1xuICAgIG1heDogMCxcbiAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgYXZnOiAwLFxuICAgIHRvdGFsOiAwLFxuICAgIGNvdW50OiAwLFxuICAgIGhpc3Rvcnk6IHR5cGVvZihGbG9hdDMyQXJyYXkpICE9PSAndW5kZWZpbmVkJyA/IG5ldyBGbG9hdDMyQXJyYXkoTUFYX0hJU1RPUlkpIDogW11cbiAgfTtcbn07XG5cblByb2ZpbGVyLm5ld192YWx1ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgdCA9IFByb2ZpbGVyLm1ldHJpY3NbbmFtZV0gPSBQcm9maWxlci5nZXQobmFtZSk7XG5cbiAgdC5tYXggPSBNYXRoLm1heCh0Lm1heCwgdmFsdWUpO1xuICB0Lm1pbiA9IE1hdGgubWluKHQubWluLCB2YWx1ZSk7XG4gIHQudG90YWwgKz0gdmFsdWU7XG4gICsrdC5jb3VudDtcbiAgdC5hdmcgPSB0LnRvdGFsIC8gdC5jb3VudDtcbiAgdC5oaXN0b3J5W3QuY291bnQlTUFYX0hJU1RPUlldID0gdmFsdWU7XG59O1xuXG5Qcm9maWxlci5wcmludF9zdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yIChrIGluIFByb2ZpbGVyLm1ldHJpY3MpIHtcbiAgICB2YXIgdCA9IFByb2ZpbGVyLm1ldHJpY3Nba107XG4gICAgY29uc29sZS5sb2coXCIgPT09IFwiICsgayArIFwiID09PSBcIik7XG4gICAgY29uc29sZS5sb2coXCIgbWF4OiBcIiArIHQubWF4KTtcbiAgICBjb25zb2xlLmxvZyhcIiBtaW46IFwiICsgdC5taW4pO1xuICAgIGNvbnNvbGUubG9nKFwiIGF2ZzogXCIgKyB0LmF2Zyk7XG4gICAgY29uc29sZS5sb2coXCIgY291bnQ6IFwiICsgdC5jb3VudCk7XG4gICAgY29uc29sZS5sb2coXCIgdG90YWw6IFwiICsgdC50b3RhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIE1ldHJpYyhuYW1lKSB7XG4gIHRoaXMudDAgPSBudWxsO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmNvdW50ID0gMDtcbn1cblxuTWV0cmljLnByb3RvdHlwZSA9IHtcblxuICAvL1xuICAvLyBzdGFydCBhIHRpbWUgbWVhc3VyZW1lbnRcbiAgLy9cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudDAgPSArbmV3IERhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBlbGFwc2VkIHRpbWUgc2luY2Ugc3RhcnQgd2FzIGNhbGxlZFxuICBfZWxhcHNlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZSgpIC0gdGhpcy50MDtcbiAgfSxcblxuICAvL1xuICAvLyBmaW5pc2ggYSB0aW1lIG1lYXN1cmVtZW50IGFuZCByZWdpc3RlciBpdFxuICAvLyBgYHN0YXJ0YGAgc2hvdWxkIGJlIGNhbGxlZCBmaXJzdCwgaWYgbm90IHRoaXMgXG4gIC8vIGZ1bmN0aW9uIGRvZXMgbm90IHRha2UgZWZmZWN0XG4gIC8vXG4gIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudDAgIT09IG51bGwpIHtcbiAgICAgIFByb2ZpbGVyLm5ld192YWx1ZSh0aGlzLm5hbWUsIHRoaXMuX2VsYXBzZWQoKSk7XG4gICAgICB0aGlzLnQwID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLy9cbiAgLy8gaW5jcmVtZW50cyB0aGUgdmFsdWUgXG4gIC8vIHF0eTogaG93IG1hbnksIGRlZmF1bHQgPSAxXG4gIC8vXG4gIGluYzogZnVuY3Rpb24ocXR5KSB7XG4gICAgcXR5ID0gcXR5ID09PSB1bmRlZmluZWQgPyAxOiBxdHk7XG4gICAgUHJvZmlsZXIubmV3X3ZhbHVlKHRoaXMubmFtZSwgUHJvZmlsZXIuZ2V0KHRoaXMubmFtZSkuY291bnQgKyAocXR5ID8gcXR5OiAwKSk7XG4gIH0sXG5cbiAgLy9cbiAgLy8gZGVjcmVtZW50cyB0aGUgdmFsdWUgXG4gIC8vIHF0eTogaG93IG1hbnksIGRlZmF1bHQgPSAxXG4gIC8vXG4gIGRlYzogZnVuY3Rpb24ocXR5KSB7XG4gICAgcXR5ID0gcXR5ID09PSB1bmRlZmluZWQgPyAxOiBxdHk7XG4gICAgdGhpcy5pbmMoLXF0eSk7XG4gIH0sXG5cbiAgLy9cbiAgLy8gbWVhc3VyZXMgaG93IG1hbnkgdGltZXMgcGVyIHNlY29uZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAvL1xuICBtYXJrOiBmdW5jdGlvbigpIHtcbiAgICArK3RoaXMuY291bnQ7XG4gICAgaWYodGhpcy50MCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWxhcHNlZCA9IHRoaXMuX2VsYXBzZWQoKTtcbiAgICBpZihlbGFwc2VkID4gMSkge1xuICAgICAgUHJvZmlsZXIubmV3X3ZhbHVlKHRoaXMubmFtZSwgdGhpcy5jb3VudCk7XG4gICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbn07XG5cblByb2ZpbGVyLm1ldHJpYyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBNZXRyaWMobmFtZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAganNvbjogcmVxdWlyZSgnLi9qc29uJyksXG4gICAgSnNvbkFycmF5OiByZXF1aXJlKCcuL2pzb25hcnJheScpLFxuICAgIHdpbmRzaGFmdDogcmVxdWlyZSgnLi93aW5kc2hhZnQnKSxcbiAgICB0aWxlSlNPTjogcmVxdWlyZSgnLi90aWxlanNvbicpXG59O1xuIiwidmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4uLycpO1xudmFyIFByb2ZpbGVyID0gcmVxdWlyZSgnLi4vcHJvZmlsZXInKTtcblxuICB2YXIgVWludDhBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50OEFycmF5O1xuICB2YXIgSW50MzJBcnJheSA9IHRvcnF1ZS50eXBlcy5JbnQzMkFycmF5O1xuICB2YXIgVWludDMyQXJyYXkgPSB0b3JxdWUudHlwZXMuVWludDMyQXJyYXk7XG5cbiAgLy8gZm9ybWF0KCdoZWxsbywgezB9JywgJ3JhbWJvJykgLT4gXCJoZWxsbywgcmFtYm9cIlxuICBmdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFJlZ0V4cCgnXFxcXHsnICsgYXR0ciArICdcXFxcfScsICdnJyksIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBqc29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3RpbGVRdWV1ZSA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLm9wdGlvbnMuaXNfdGltZSA9IHRoaXMub3B0aW9ucy5pc190aW1lID09PSB1bmRlZmluZWQgPyB0cnVlOiB0aGlzLm9wdGlvbnMuaXNfdGltZTtcbiAgICB0aGlzLm9wdGlvbnMudGlsZXJfcHJvdG9jb2wgPSBvcHRpb25zLnRpbGVyX3Byb3RvY29sIHx8ICdodHRwJztcbiAgICB0aGlzLm9wdGlvbnMudGlsZXJfZG9tYWluID0gb3B0aW9ucy50aWxlcl9kb21haW4gfHwgJ2NhcnRvZGIuY29tJztcbiAgICB0aGlzLm9wdGlvbnMudGlsZXJfcG9ydCA9IG9wdGlvbnMudGlsZXJfcG9ydCB8fCA4MDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YV9hZ2dyZWdhdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPSB0aGlzLm9wdGlvbnMuZGF0YV9hZ2dyZWdhdGlvbiA9PT0gJ2N1bXVsYXRpdmUnO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHV0aW9uIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcbiAgICBpZiAob3B0aW9ucy5zdGVwcyA9PT0gdW5kZWZpbmVkICkgdGhyb3cgbmV3IEVycm9yKFwic3RlcHMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICAgIGlmKG9wdGlvbnMuc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fZmV0Y2hLZXlTcGFuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFJlYWR5KHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBqc29uLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgdG9ycXVlIHRpbGUgZW5jb2RlZCBpbiBhbiBlZmZpY2llbnQgamF2YXNjcmlwdFxuICAgICAqIHN0cnVjdHVyZTpcbiAgICAgKiB7XG4gICAgICogICB4OlVpbnQ4QXJyYXkgeCBjb29yZGluYXRlcyBpbiB0aWxlIHJlZmVyZW5jZSBzeXN0ZW0sIG5vcm1hbGx5IGZyb20gMC0yNTVcbiAgICAgKiAgIHk6VWludDhBcnJheSB5IGNvb3JkaW5hdGVzIGluIHRpbGUgcmVmZXJlbmNlIHN5c3RlbVxuICAgICAqICAgSW5kZXg6IEFycmF5IGluZGV4IHRvIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogfVxuICAgICAqL1xuICAgIHByb2NjZXNzVGlsZTogZnVuY3Rpb24ocm93cywgY29vcmQsIHpvb20pIHtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIHggPSBuZXcgVWludDhBcnJheShyb3dzLmxlbmd0aCk7XG4gICAgICB2YXIgeSA9IG5ldyBVaW50OEFycmF5KHJvd3MubGVuZ3RoKTtcblxuICAgICAgdmFyIHByb2ZfbWVtID0gUHJvZmlsZXIubWV0cmljKCdQcm92aWRlckpTT046bWVtJyk7XG4gICAgICB2YXIgcHJvZl9wb2ludF9jb3VudCA9IFByb2ZpbGVyLm1ldHJpYygnUHJvdmlkZXJKU09OOnBvaW50X2NvdW50Jyk7XG4gICAgICB2YXIgcHJvZl9wcm9jZXNzX3RpbWUgPSBQcm9maWxlci5tZXRyaWMoJ1Byb3ZpZGVySlNPTjpwcm9jZXNzX3RpbWUnKS5zdGFydCgpXG5cbiAgICAgIC8vIGNvdW50IG51bWJlciBvZiBkYXRlc1xuICAgICAgdmFyIGRhdGVzID0gMDtcbiAgICAgIHZhciBtYXhEYXRlU2xvdHMgPSAtMTtcbiAgICAgIGZvciAociA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICBkYXRlcyArPSByb3cuZGF0ZXNfX3VpbnQxNi5sZW5ndGg7XG4gICAgICAgIGZvcih2YXIgZCA9IDA7IGQgPCByb3cuZGF0ZXNfX3VpbnQxNi5sZW5ndGg7ICsrZCkge1xuICAgICAgICAgIG1heERhdGVTbG90cyA9IE1hdGgubWF4KG1heERhdGVTbG90cywgcm93LmRhdGVzX191aW50MTZbZF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgIGRhdGVzID0gKDEgKyBtYXhEYXRlU2xvdHMpICogcm93cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPyBVaW50MzJBcnJheTogVWludDhBcnJheTtcblxuICAgICAgLy8gcmVzZXJ2ZSBtZW1vcnkgZm9yIGFsbCB0aGUgZGF0ZXNcbiAgICAgIHZhciB0aW1lSW5kZXggPSBuZXcgSW50MzJBcnJheShtYXhEYXRlU2xvdHMgKyAxKTsgLy9pbmRleC1zaXplXG4gICAgICB2YXIgdGltZUNvdW50ID0gbmV3IEludDMyQXJyYXkobWF4RGF0ZVNsb3RzICsgMSk7XG4gICAgICB2YXIgcmVuZGVyRGF0YSA9IG5ldyAodGhpcy5vcHRpb25zLnZhbHVlRGF0YVR5cGUgfHwgdHlwZSkoZGF0ZXMpO1xuICAgICAgdmFyIHJlbmRlckRhdGFQb3MgPSBuZXcgVWludDMyQXJyYXkoZGF0ZXMpO1xuXG4gICAgICBwcm9mX21lbS5pbmMoXG4gICAgICAgIDQgKiBtYXhEYXRlU2xvdHMgKyAvLyB0aW1lSW5kZXhcbiAgICAgICAgNCAqIG1heERhdGVTbG90cyArIC8vIHRpbWVDb3VudFxuICAgICAgICBkYXRlcyArIC8vcmVuZGVyRGF0YVxuICAgICAgICBkYXRlcyAqIDRcbiAgICAgICk7IC8vcmVuZGVyRGF0YVBvc1xuXG4gICAgICBwcm9mX3BvaW50X2NvdW50LmluYyhyb3dzLmxlbmd0aCk7XG5cbiAgICAgIHZhciByb3dzUGVyU2xvdCA9IHt9O1xuXG4gICAgICAvLyBwcmVjYWNoZSBwaXhlbCBwb3NpdGlvbnNcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICB2YXIgcm93ID0gcm93c1tyXTtcbiAgICAgICAgeFtyXSA9IHJvdy54X191aW50OCAqIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICAvLyBmaXggdmFsdWUgd2hlbiBpdCdzIGluIHRoZSB0aWxlIEVER0VcbiAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgZml4ZWQgaW4gU1FMIHF1ZXJ5XG4gICAgICAgIGlmIChyb3cueV9fdWludDggPT09IC0xKSB7XG4gICAgICAgICAgeVtyXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeVtyXSA9IHJvdy55X191aW50OCAqIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGVzID0gcm93LmRhdGVzX191aW50MTY7XG4gICAgICAgIHZhciB2YWxzID0gcm93LnZhbHNfX3VpbnQ4O1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciByciA9IHJvd3NQZXJTbG90W2RhdGVzW2pdXSB8fCAocm93c1BlclNsb3RbZGF0ZXNbal1dID0gW10pO1xuICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdmFsc1tqXSArPSBwcmV2X3ZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmV2X3ZhbCA9IHZhbHNbal07XG4gICAgICAgICAgICAgIHJyLnB1c2goW3IsIHZhbHNbal1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbEJ5RGF0ZSA9IHt9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICB2YWxCeURhdGVbZGF0ZXNbal1dID0gdmFsc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFjY3VtID0gMDtcblxuICAgICAgICAgIC8vIGV4dGVuZCB0aGUgbGF0ZXN0IHRvIHRoZSBlbmRcbiAgICAgICAgICBmb3IgKHZhciBqID0gZGF0ZXNbMF07IGogPD0gbWF4RGF0ZVNsb3RzOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIHJyID0gcm93c1BlclNsb3Rbal0gfHwgKHJvd3NQZXJTbG90W2pdID0gW10pO1xuICAgICAgICAgICAgICB2YXIgdiA9IHZhbEJ5RGF0ZVtqXTtcbiAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICBhY2N1bSArPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJyLnB1c2goW3IsIGFjY3VtXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyp2YXIgbGFzdERhdGVTbG90ID0gZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGxhc3REYXRlU2xvdCArIDE7IGogPD0gbWF4RGF0ZVNsb3RzOyArK2opIHtcbiAgICAgICAgICAgIHZhciByciA9IHJvd3NQZXJTbG90W2pdIHx8IChyb3dzUGVyU2xvdFtqXSA9IFtdKTtcbiAgICAgICAgICAgIHJyLnB1c2goW3IsIHByZXZfdmFsXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICovXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZWFjaCB0aW1lc2xvdCBzZWFyY2ggYWN0aXZlIGJ1Y2tldHNcbiAgICAgIHZhciByZW5kZXJEYXRhSW5kZXggPSAwO1xuICAgICAgdmFyIHRpbWVTbG90SW5kZXggPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSBtYXhEYXRlU2xvdHM7ICsraSkge1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBzbG90Um93cyA9IHJvd3NQZXJTbG90W2ldXG4gICAgICAgIGlmKHNsb3RSb3dzKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzbG90Um93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgdmFyIHJyID0gc2xvdFJvd3Nbcl07XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICByZW5kZXJEYXRhUG9zW3JlbmRlckRhdGFJbmRleF0gPSByclswXVxuICAgICAgICAgICAgcmVuZGVyRGF0YVtyZW5kZXJEYXRhSW5kZXhdID0gcnJbMV07XG4gICAgICAgICAgICArK3JlbmRlckRhdGFJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGltZUluZGV4W2ldID0gdGltZVNsb3RJbmRleDtcbiAgICAgICAgdGltZUNvdW50W2ldID0gYztcbiAgICAgICAgdGltZVNsb3RJbmRleCArPSBjO1xuICAgICAgfVxuXG4gICAgICBwcm9mX3Byb2Nlc3NfdGltZS5lbmQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgejogem9vbSxcbiAgICAgICAgY29vcmQ6IHtcbiAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgejogem9vbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lQ291bnQ6IHRpbWVDb3VudCxcbiAgICAgICAgdGltZUluZGV4OiB0aW1lSW5kZXgsXG4gICAgICAgIHJlbmRlckRhdGFQb3M6IHJlbmRlckRhdGFQb3MsXG4gICAgICAgIHJlbmRlckRhdGE6IHJlbmRlckRhdGEsXG4gICAgICAgIG1heERhdGU6IG1heERhdGVTbG90c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2hvc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgcG9ydCA9IG9wdHMuc3FsX2FwaV9wb3J0O1xuICAgICAgdmFyIGRvbWFpbiA9ICgob3B0cy51c2VyX25hbWUgfHwgb3B0cy51c2VyKSArICcuJyArIChvcHRzLnNxbF9hcGlfZG9tYWluIHx8ICdjYXJ0b2RiLmNvbScpKSArIChwb3J0ID8gJzonICsgcG9ydDogJycpO1xuICAgICAgdmFyIHByb3RvY29sID0gb3B0cy5zcWxfYXBpX3Byb3RvY29sIHx8ICdodHRwJztcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXJsIHx8IHByb3RvY29sICsgJzovLycgKyBkb21haW4gKyAnL2FwaS92Mi9zcWwnO1xuICAgIH0sXG5cbiAgICB1cmw6IGZ1bmN0aW9uKHN1Ymhvc3QpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHByb3RvY29sID0gb3B0cy5zcWxfYXBpX3Byb3RvY29sIHx8ICdodHRwJztcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmNkbl91cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3QoKTtcbiAgICAgIH1cbiAgICAgIHZhciBoID0gcHJvdG9jb2wrIFwiOi8vXCI7XG4gICAgICBpZiAoc3ViaG9zdCkge1xuICAgICAgICBoICs9IHN1Ymhvc3QgKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBjZG5faG9zdCA9IG9wdHMuY2RuX3VybDtcbiAgICAgIGlmKCFjZG5faG9zdC5odHRwICYmICFjZG5faG9zdC5odHRwcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjZG5faG9zdCBzaG91bGQgY29udGFpbiBodHRwIGFuZC9vciBodHRwcyBlbnRyaWVzXCIpO1xuICAgICAgfVxuICAgICAgaCArPSBjZG5faG9zdFtwcm90b2NvbF0gKyBcIi9cIiArIChvcHRzLnVzZXJfbmFtZSB8fCBvcHRzLnVzZXIpICsgJy9hcGkvdjIvc3FsJztcbiAgICAgIHJldHVybiBoO1xuICAgIH0sXG5cbiAgICBfaGFzaDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgaGFzaCA9IDA7XG4gICAgICBpZiAoIXN0ciB8fCBzdHIubGVuZ3RoID09IDApIHJldHVybiBoYXNoO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgaGFzaCA9ICgoIChoYXNoIDw8IDUgKSAtIGhhc2ggKSArIHN0ci5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9LFxuXG4gICAgX2V4dHJhUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zKSB7XG4gICAgICAgIHZhciBwID0gW107XG4gICAgICAgIGZvcih2YXIgayBpbiB0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zKSB7XG4gICAgICAgICAgdmFyIHYgPSB0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zW2tdO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBwLnB1c2goayArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAuam9pbignJicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGlzSHR0cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zcWxfYXBpX3Byb3RvY29sICYmIHRoaXMub3B0aW9ucy5zcWxfYXBpX3Byb3RvY29sID09PSAnaHR0cHMnO1xuICAgIH0sXG5cbiAgICAvLyBleGVjdXRlIGFjdHVhbCBxdWVyeVxuICAgIHNxbDogZnVuY3Rpb24oc3FsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc3ViZG9tYWlucyA9IHRoaXMub3B0aW9ucy5zdWJkb21haW5zIHx8ICcwMTIzJztcbiAgICAgIGlmKHRoaXMuaXNIdHRwcygpKSB7XG4gICAgICAgIHN1YmRvbWFpbnMgPSBbbnVsbF07IC8vIG5vIHN1YmRvbWFpblxuICAgICAgfVxuXG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAob3B0aW9ucy5ub19jZG4pIHtcbiAgICAgICAgdXJsID0gdGhpcy5faG9zdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gdGhpcy51cmwoc3ViZG9tYWluc1tNYXRoLmFicyh0aGlzLl9oYXNoKHNxbCkpJXN1YmRvbWFpbnMubGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICB2YXIgZXh0cmEgPSB0aGlzLl9leHRyYVBhcmFtcygpO1xuICAgICAgdG9ycXVlLm5ldC5nZXQoIHVybCArIFwiP3E9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3FsKSArIChleHRyYSA/IFwiJlwiICsgZXh0cmE6ICcnKSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBpZihvcHRpb25zLnBhcnNlSlNPTikge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSAmJiBkYXRhLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIGlmKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aGlzLl90aWxlUXVldWUucHVzaChbY29vcmQsIHpvb20sIGNhbGxiYWNrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9nZXRUaWxlRGF0YShjb29yZCwgem9vbSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0UmVhZHk6IGZ1bmN0aW9uKHJlYWR5KSB7XG4gICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgIHRoaXMub3B0aW9ucy5yZWFkeSAmJiB0aGlzLm9wdGlvbnMucmVhZHkoKTtcbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbTtcbiAgICAgIHdoaWxlIChpdGVtID0gdGhpcy5fdGlsZVF1ZXVlLnBvcCgpKSB7XG4gICAgICAgIHRoaXMuX2dldFRpbGVEYXRhLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBgY29vcmRgIG9iamVjdCBsaWtlIHt4IDogdGlsZXgsIHk6IHRpbGV5IH1cbiAgICAgKiBgem9vbWAgcXVhZHRyZWUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIF9nZXRUaWxlRGF0YTogZnVuY3Rpb24oY29vcmQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcHJvZl9mZXRjaF90aW1lID0gUHJvZmlsZXIubWV0cmljKCdQcm92aWRlckpTT046dGlsZV9mZXRjaF90aW1lJykuc3RhcnQoKVxuICAgICAgdGhpcy50YWJsZSA9IHRoaXMub3B0aW9ucy50YWJsZTtcbiAgICAgIHZhciBudW1UaWxlcyA9IDEgPDwgem9vbTtcblxuICAgICAgdmFyIGNvbHVtbl9jb252ID0gdGhpcy5vcHRpb25zLmNvbHVtbjtcblxuICAgICAgaWYodGhpcy5vcHRpb25zLmlzX3RpbWUpIHtcbiAgICAgICAgY29sdW1uX2NvbnYgPSBmb3JtYXQoXCJkYXRlX3BhcnQoJ2Vwb2NoJywge2NvbHVtbn0pXCIsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcWwgPSBcIlwiICtcbiAgICAgICAgXCJXSVRIIFwiICtcbiAgICAgICAgXCJwYXIgQVMgKFwiICtcbiAgICAgICAgXCIgIFNFTEVDVCBDREJfWFlaX1Jlc29sdXRpb24oe3pvb219KSp7cmVzb2x1dGlvbn0gYXMgcmVzXCIgK1xuICAgICAgICBcIiwgIDI1Ni97cmVzb2x1dGlvbn0gYXMgdGlsZV9zaXplXCIgK1xuICAgICAgICBcIiwgQ0RCX1hZWl9FeHRlbnQoe3h9LCB7eX0sIHt6b29tfSkgYXMgZXh0IFwiICArXG4gICAgICAgIFwiKSxcIiArXG4gICAgICAgIFwiY3RlIEFTICggXCIrXG4gICAgICAgIFwiICBTRUxFQ1QgU1RfU25hcFRvR3JpZChpLnRoZV9nZW9tX3dlYm1lcmNhdG9yLCBwLnJlcykgZ1wiICtcbiAgICAgICAgXCIsIHtjb3VudGJ5fSBjXCIgK1xuICAgICAgICBcIiwgZmxvb3IoKHtjb2x1bW5fY29udn0gLSB7c3RhcnR9KS97c3RlcH0pIGRcIiArXG4gICAgICAgIFwiICBGUk9NICh7X3NxbH0pIGksIHBhciBwIFwiICtcbiAgICAgICAgXCIgIFdIRVJFIGkudGhlX2dlb21fd2VibWVyY2F0b3IgJiYgcC5leHQgXCIgK1xuICAgICAgICBcIiAgR1JPVVAgQlkgZywgZFwiICtcbiAgICAgICAgXCIpIFwiICtcbiAgICAgICAgXCJcIiArXG4gICAgICAgIFwiU0VMRUNUIChzdF94KGcpLXN0X3htaW4ocC5leHQpKS9wLnJlcyB4X191aW50OCwgXCIgK1xuICAgICAgICBcIiAgICAgICAoc3RfeShnKS1zdF95bWluKHAuZXh0KSkvcC5yZXMgeV9fdWludDgsXCIgK1xuICAgICAgICBcIiBhcnJheV9hZ2coYykgdmFsc19fdWludDgsXCIgK1xuICAgICAgICBcIiBhcnJheV9hZ2coZCkgZGF0ZXNfX3VpbnQxNlwiICtcbiAgICAgICAgLy8gdGhlIHRpbGVfc2l6ZSB3aGVyZSBhcmUgbmVlZGVkIGJlY2F1c2UgdGhlIG92ZXJsYXBzIHF1ZXJ5IGluIGN0ZSBzdWJxdWVyeSBpbmNsdWRlcyB0aGUgcG9pbnRzXG4gICAgICAgIC8vIGluIHRoZSBsZWZ0IGFuZCBib3R0b20gYm9yZGVycyBvZiB0aGUgdGlsZVxuICAgICAgICBcIiBGUk9NIGN0ZSwgcGFyIHAgd2hlcmUgKHN0X3koZyktc3RfeW1pbihwLmV4dCkpL3AucmVzIDwgdGlsZV9zaXplIGFuZCAoc3RfeChnKS1zdF94bWluKHAuZXh0KSkvcC5yZXMgPCB0aWxlX3NpemUgR1JPVVAgQlkgeF9fdWludDgsIHlfX3VpbnQ4XCI7XG5cblxuICAgICAgdmFyIHF1ZXJ5ID0gZm9ybWF0KHNxbCwgdGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgIGNvbHVtbl9jb252OiBjb2x1bW5fY29udixcbiAgICAgICAgX3NxbDogdGhpcy5nZXRTUUwoKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuc3FsKHF1ZXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHZhciByb3dzID0gSlNPTi5wYXJzZShkYXRhLnJlc3BvbnNlVGV4dCkucm93cztcbiAgICAgICAgICBjYWxsYmFjayhzZWxmLnByb2NjZXNzVGlsZShyb3dzLCBjb29yZCwgem9vbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHByb2ZfZmV0Y2hfdGltZS5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRLZXlTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLm9wdGlvbnMuc3RhcnQgKiAxMDAwLFxuICAgICAgICBlbmQ6IHRoaXMub3B0aW9ucy5lbmQgKiAxMDAwLFxuICAgICAgICBzdGVwOiB0aGlzLm9wdGlvbnMuc3RlcCxcbiAgICAgICAgc3RlcHM6IHRoaXMub3B0aW9ucy5zdGVwcyxcbiAgICAgICAgY29sdW1uVHlwZTogdGhpcy5vcHRpb25zLmlzX3RpbWUgPyAnZGF0ZSc6ICdudW1iZXInXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbiwgaXNUaW1lKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy5vcHRpb25zLmlzX3RpbWUgPSBpc1RpbWUgPT09IHVuZGVmaW5lZCA/IHRydWU6IGZhbHNlO1xuICAgICAgdGhpcy5yZWxvYWQoKTtcbiAgICB9LFxuXG4gICAgc2V0UmVzb2x1dGlvbjogZnVuY3Rpb24ocmVzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiA9IHJlcztcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRydWUgaWYgdGlsZXMgaGFzIGJlZW4gY2hhbmdlZFxuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBmYWxzZTtcblxuICAgICAgaWYob3B0LnJlc29sdXRpb24gIT09IHVuZGVmaW5lZCAmJiBvcHQucmVzb2x1dGlvbiAhPT0gdGhpcy5vcHRpb25zLnJlc29sdXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlc29sdXRpb24gPSBvcHQucmVzb2x1dGlvbjtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKG9wdC5zdGVwcyAhPT0gdW5kZWZpbmVkICYmIG9wdC5zdGVwcyAhPT0gdGhpcy5vcHRpb25zLnN0ZXBzKSB7XG4gICAgICAgIHRoaXMuc2V0U3RlcHMob3B0LnN0ZXBzLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKG9wdC5jb2x1bW4gIT09IHVuZGVmaW5lZCAmJiBvcHQuY29sdW1uICE9PSB0aGlzLm9wdGlvbnMuY29sdW1uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW4gPSBvcHQuY29sdW1uO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmNvdW50YnkgIT09IHVuZGVmaW5lZCAmJiBvcHQuY291bnRieSAhPT0gdGhpcy5vcHRpb25zLmNvdW50YnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvdW50YnkgPSBvcHQuY291bnRieTtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKG9wdC5kYXRhX2FnZ3JlZ2F0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGMgPSBvcHQuZGF0YV9hZ2dyZWdhdGlvbiA9PT0gJ2N1bXVsYXRpdmUnO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgIT09IGMpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA9IGM7XG4gICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlZnJlc2gpIHRoaXMucmVsb2FkKCk7XG4gICAgICByZXR1cm4gcmVmcmVzaDtcblxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2ZldGNoS2V5U3BhbigpO1xuICAgIH0sXG5cbiAgICBzZXRTUUw6IGZ1bmN0aW9uKHNxbCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zcWwgIT0gc3FsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zcWwgPSBzcWw7XG4gICAgICAgIHRoaXMucmVsb2FkKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFN0ZXBzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLm9wdGlvbnMuc3RlcHMsIHRoaXMub3B0aW9ucy5kYXRhX3N0ZXBzKTtcbiAgICB9LFxuXG4gICAgc2V0U3RlcHM6IGZ1bmN0aW9uKHN0ZXBzLCBvcHQpIHtcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcHMgIT09IHN0ZXBzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcCA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KS90aGlzLmdldFN0ZXBzKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAgfHwgMTtcbiAgICAgICAgaWYgKCFvcHQuc2lsZW50KSB0aGlzLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib3VuZHM7XG4gICAgfSxcblxuICAgIGdldFNRTDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNxbCB8fCBcInNlbGVjdCAqIGZyb20gXCIgKyB0aGlzLm9wdGlvbnMudGFibGU7XG4gICAgfSxcblxuICAgIF90aWxlckhvc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdXNlciA9IChvcHRzLnVzZXJfbmFtZSB8fCBvcHRzLnVzZXIpO1xuICAgICAgcmV0dXJuIG9wdHMudGlsZXJfcHJvdG9jb2wgK1xuICAgICAgICAgICBcIjovL1wiICsgKHVzZXIgPyB1c2VyICsgXCIuXCIgOiBcIlwiKSAgK1xuICAgICAgICAgICBvcHRzLnRpbGVyX2RvbWFpbiArXG4gICAgICAgICAgICgob3B0cy50aWxlcl9wb3J0ICE9IFwiXCIpID8gKFwiOlwiICsgb3B0cy50aWxlcl9wb3J0KSA6IFwiXCIpO1xuICAgIH0sXG5cbiAgICBfZmV0Y2hVcGRhdGVBdDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBsYXllcmdyb3VwID0ge1xuICAgICAgICBcInZlcnNpb25cIjogXCIxLjAuMVwiLFxuICAgICAgICBcInN0YXRfdGFnXCI6IHRoaXMub3B0aW9ucy5zdGF0X3RhZyB8fCAndG9ycXVlJyxcbiAgICAgICAgXCJsYXllcnNcIjogW3tcbiAgICAgICAgICBcInR5cGVcIjogXCJjYXJ0b2RiXCIsXG4gICAgICAgICAgXCJvcHRpb25zXCI6IHtcbiAgICAgICAgICAgIFwiY2FydG9jc3NfdmVyc2lvblwiOiBcIjIuMS4xXCIsIFxuICAgICAgICAgICAgXCJjYXJ0b2Nzc1wiOiBcIiNsYXllciB7fVwiLFxuICAgICAgICAgICAgXCJzcWxcIjogdGhpcy5nZXRTUUwoKVxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgICB2YXIgdXJsID0gdGhpcy5fdGlsZXJIb3N0KCkgKyBcIi90aWxlcy9sYXllcmdyb3VwXCI7XG4gICAgICB2YXIgZXh0cmEgPSB0aGlzLl9leHRyYVBhcmFtcygpO1xuXG4gICAgICAvLyB0aWxlciBuZWVkcyBtYXBfa2V5IGluc3RlYWQgb2YgYXBpX2tleVxuICAgICAgLy8gc28gcmVwbGFjZSBpdFxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIGV4dHJhID0gZXh0cmEucmVwbGFjZSgnYXBpX2tleT0nLCAnbWFwX2tleT0nKTtcbiAgICAgIH1cblxuICAgICAgdXJsID0gdXJsICtcbiAgICAgICAgXCI/Y29uZmlnPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGxheWVyZ3JvdXApKSArXG4gICAgICAgIFwiJmNhbGxiYWNrPT9cIiArIChleHRyYSA/IFwiJlwiICsgZXh0cmE6ICcnKTtcblxuICAgICAgdG9ycXVlLm5ldC5qc29ucCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IGZvcm1hdChcInNlbGVjdCAqIGZyb20gKHtzcWx9KSBfX3RvcnF1ZV93cmFwX3NxbCBsaW1pdCAwXCIsIHsgc3FsOiBzZWxmLmdldFNRTCgpIH0pO1xuICAgICAgICBzZWxmLnNxbChxdWVyeSwgZnVuY3Rpb24gKHF1ZXJ5RGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhICYmIHF1ZXJ5RGF0YSkge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBkYXRhLmxhc3RfdXBkYXRlZCxcbiAgICAgICAgICAgICAgZmllbGRzOiBxdWVyeURhdGEuZmllbGRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHsgcGFyc2VKU09OOiB0cnVlIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vXG4gICAgLy8gdGhlIGRhdGEgcmFuZ2UgY291bGQgYmUgc2V0IGJ5IHRoZSB1c2VyIHRob3VnaCBgYHN0YXJ0YGBcbiAgICAvLyBvcHRpb24uIEl0IGNhbiBiZSBmZWN0aGVkIGZyb20gdGhlIHRhYmxlIHdoZW4gdGhlIHN0YXJ0XG4gICAgLy8gaXMgbm90IHNwZWNpZmllZC5cbiAgICAvL1xuICAgIF9mZXRjaEtleVNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG1heF9jb2wsIG1pbl9jb2wsIG1heF90bXBsLCBtaW5fdG1wbDtcblxuICAgICAgdGhpcy5fZmV0Y2hVcGRhdGVBdChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuICAgICAgICBzZWxmLm9wdGlvbnMuZXh0cmFfcGFyYW1zID0gc2VsZi5vcHRpb25zLmV4dHJhX3BhcmFtcyB8fCB7fTtcbiAgICAgICAgc2VsZi5vcHRpb25zLmV4dHJhX3BhcmFtcy5sYXN0X3VwZGF0ZWQgPSBkYXRhLnVwZGF0ZWRfYXQgfHwgMDtcbiAgICAgICAgc2VsZi5vcHRpb25zLmV4dHJhX3BhcmFtcy5jYWNoZV9wb2xpY3kgPSAncGVyc2lzdCc7XG4gICAgICAgIHNlbGYub3B0aW9ucy5pc190aW1lID0gZGF0YS5maWVsZHNbc2VsZi5vcHRpb25zLmNvbHVtbl0udHlwZSA9PT0gJ2RhdGUnO1xuXG4gICAgICAgIHZhciBjb2x1bW5fY29udiA9IHNlbGYub3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuaXNfdGltZSl7XG4gICAgICAgICAgbWF4X3RtcGwgPSBcImRhdGVfcGFydCgnZXBvY2gnLCBtYXgoe2NvbHVtbn0pKVwiO1xuICAgICAgICAgIG1pbl90bXBsID0gXCJkYXRlX3BhcnQoJ2Vwb2NoJywgbWluKHtjb2x1bW59KSlcIjtcbiAgICAgICAgICBjb2x1bW5fY29udiA9IGZvcm1hdChcImRhdGVfcGFydCgnZXBvY2gnLCB7Y29sdW1ufSlcIiwgc2VsZi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhfdG1wbCA9IFwibWF4KHtjb2x1bW59KVwiO1xuICAgICAgICAgIG1pbl90bXBsID0gXCJtaW4oe2NvbHVtbn0pXCI7XG4gICAgICAgIH1cblxuICAgICAgICBtYXhfY29sID0gZm9ybWF0KG1heF90bXBsLCB7IGNvbHVtbjogc2VsZi5vcHRpb25zLmNvbHVtbiB9KTtcbiAgICAgICAgbWluX2NvbCA9IGZvcm1hdChtaW5fdG1wbCwgeyBjb2x1bW46IHNlbGYub3B0aW9ucy5jb2x1bW4gfSk7XG5cbiAgICAgICAgLyp2YXIgc3FsX3N0YXRzID0gXCJcIiArXG4gICAgICAgIFwiV0lUSCBzdW1tYXJ5X2dyb3VwcyBhcyAoIFwiICtcbiAgICAgICAgICBcIldJVEggc3VtbWFyeSBhcyAoIFwiICtcbiAgICAgICAgICAgXCJzZWxlY3QgICAocm93X251bWJlcigpIG92ZXIgKG9yZGVyIGJ5IF9fdGltZV9jb2wgYXNjIG51bGxzIGxhc3QpKzEpLzIgYXMgcm93bnVtLCBfX3RpbWVfY29sIFwiICtcbiAgICAgICAgICAgIFwiZnJvbSAoc2VsZWN0ICosIHtjb2x1bW59IGFzIF9fdGltZV9jb2wgZnJvbSAoe3NxbH0pIF9fcykgX190b3JxdWVfd3JhcF9zcWwgXCIgK1xuICAgICAgICAgICAgXCJvcmRlciBieSBfX3RpbWVfY29sIGFzYyBcIiArXG4gICAgICAgICAgXCIpIFwiICtcbiAgICAgICAgICBcIlNFTEVDVCBcIiArXG4gICAgICAgICAgXCJtYXgoX190aW1lX2NvbCkgT1ZFUihQQVJUSVRJT04gQlkgcm93bnVtKSAtICBcIiArXG4gICAgICAgICAgXCJtaW4oX190aW1lX2NvbCkgT1ZFUihQQVJUSVRJT04gQlkgcm93bnVtKSBkaWZmIFwiICtcbiAgICAgICAgICBcIkZST00gc3VtbWFyeSBcIiArXG4gICAgICAgIFwiKSwgc3VicSBhcyAoIFwiICtcbiAgICAgICAgXCIgU0VMRUNUIFwiICtcbiAgICAgICAgICAgIFwic3RfeG1heChzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHhtYXgsIFwiICtcbiAgICAgICAgICAgIFwic3RfeW1heChzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHltYXgsIFwiICtcbiAgICAgICAgICAgIFwic3RfeG1pbihzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHhtaW4sIFwiICtcbiAgICAgICAgICAgIFwic3RfeW1pbihzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHltaW4sIFwiICtcbiAgICAgICAgICAgIFwie21heF9jb2x9IG1heCwgXCIgK1xuICAgICAgICAgICAgXCJ7bWluX2NvbH0gbWluIEZST00gICh7c3FsfSkgX190b3JxdWVfd3JhcF9zcWwgXCIgK1xuICAgICAgICBcIilcIiArXG4gICAgICAgIFwiU0VMRUNUIFwiICtcbiAgICAgICAgXCJ4bWF4LCB4bWluLCB5bWF4LCB5bWluLCBhLm1heCBhcyBtYXhfZGF0ZSwgYS5taW4gYXMgbWluX2RhdGUsIFwiICtcbiAgICAgICAgXCJhdmcoZGlmZikgYXMgZGlmZmF2ZyxcIiArXG4gICAgICAgIFwiKGEubWF4IC0gYS5taW4pL2F2ZyhkaWZmKSBhcyBudW1fc3RlcHMgXCIgK1xuICAgICAgICBcIkZST00gc3VtbWFyeV9ncm91cHMsIHN1YnEgYSAgXCIgK1xuICAgICAgICBcIldIRVJFIGRpZmYgPiAwIGdyb3VwIGJ5IHhtYXgsIHhtaW4sIHltYXgsIHltaW4sIG1heF9kYXRlLCBtaW5fZGF0ZVwiO1xuICAgICAgICAqL1xuICAgICAgICB2YXIgc3FsX3N0YXRzID0gXCIgU0VMRUNUIFwiICtcbiAgICAgICAgICAgIFwic3RfeG1heChzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHhtYXgsIFwiICtcbiAgICAgICAgICAgIFwic3RfeW1heChzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHltYXgsIFwiICtcbiAgICAgICAgICAgIFwic3RfeG1pbihzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHhtaW4sIFwiICtcbiAgICAgICAgICAgIFwic3RfeW1pbihzdF9lbnZlbG9wZShzdF9jb2xsZWN0KHRoZV9nZW9tKSkpIHltaW4sIFwiICtcbiAgICAgICAgICAgIFwiY291bnQoKikgYXMgbnVtX3N0ZXBzLCBcIiArXG4gICAgICAgICAgICBcInttYXhfY29sfSBtYXhfZGF0ZSwgXCIgK1xuICAgICAgICAgICAgXCJ7bWluX2NvbH0gbWluX2RhdGUgRlJPTSAgKHtzcWx9KSBfX3RvcnF1ZV93cmFwX3NxbCBcIjtcblxuICAgICAgICB2YXIgc3FsID0gZm9ybWF0KHNxbF9zdGF0cywge1xuICAgICAgICAgIG1heF9jb2w6IG1heF9jb2wsXG4gICAgICAgICAgbWluX2NvbDogbWluX2NvbCxcbiAgICAgICAgICBjb2x1bW46IGNvbHVtbl9jb252LFxuICAgICAgICAgIHNxbDogc2VsZi5nZXRTUUwoKVxuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLnNxbChzcWwsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAvL1RPRE86IG1hbmFnZSBib3VuZHNcbiAgICAgICAgICBkYXRhID0gZGF0YS5yb3dzWzBdO1xuICAgICAgICAgIHNlbGYub3B0aW9ucy5zdGFydCA9IGRhdGEubWluX2RhdGU7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLmVuZCA9IGRhdGEubWF4X2RhdGU7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLnN0ZXAgPSAoZGF0YS5tYXhfZGF0ZSAtIGRhdGEubWluX2RhdGUpL01hdGgubWluKHNlbGYub3B0aW9ucy5zdGVwcywgZGF0YS5udW1fc3RlcHM+PjApO1xuICAgICAgICAgIHNlbGYub3B0aW9ucy5kYXRhX3N0ZXBzID0gZGF0YS5udW1fc3RlcHMgPj4gMDtcbiAgICAgICAgICAvLyBzdGVwIGNhbid0IGJlIDBcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuc3RlcCA9IHNlbGYub3B0aW9ucy5zdGVwIHx8IDE7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLmJvdW5kcyA9IFtcbiAgICAgICAgICAgIFtkYXRhLnltaW4sIGRhdGEueG1pbl0sXG4gICAgICAgICAgICBbZGF0YS55bWF4LCBkYXRhLnhtYXhdXG4gICAgICAgICAgXTtcbiAgICAgICAgICBzZWxmLl9zZXRSZWFkeSh0cnVlKTtcbiAgICAgICAgfSwgeyBwYXJzZUpTT046IHRydWUsIG5vX2NkbjogdHJ1ZSB9KTtcbiAgICAgIH0sIHsgcGFyc2VKU09OOiB0cnVlLCBub19jZG46IHRydWV9KVxuICAgIH1cblxuICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb247XG4iLCJ2YXIgdG9ycXVlID0gcmVxdWlyZSgnLi4vJyk7XG52YXIgUHJvZmlsZXIgPSByZXF1aXJlKCcuLi9wcm9maWxlcicpO1xuXG4gIHZhciBVaW50OEFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQ4QXJyYXk7XG4gIHZhciBJbnQzMkFycmF5ID0gdG9ycXVlLnR5cGVzLkludDMyQXJyYXk7XG4gIHZhciBVaW50MzJBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50MzJBcnJheTtcblxuICAvLyBmb3JtYXQoJ2hlbGxvLCB7MH0nLCAncmFtYm8nKSAtPiBcImhlbGxvLCByYW1ib1wiXG4gIGZ1bmN0aW9uIGZvcm1hdChzdHIsIGF0dHJzKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFJlZ0V4cCgnXFxcXHsnICsgYXR0ciArICdcXFxcfScsICdnJyksIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBqc29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBjaGVjayBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfTtcblxuXG4gIGpzb24ucHJvdG90eXBlID0ge1xuXG4gICAgLy9cbiAgICAvLyByZXR1cm4gdGhlIGRhdGEgYWdncmVnYXRlZCBieSBrZXk6XG4gICAgLy8ge1xuICAgIC8vICBrZXkwOiAxMixcbiAgICAvLyAga2V5MTogMzJcbiAgICAvLyAga2V5MjogMjVcbiAgICAvLyB9XG4gICAgLy9cbiAgICBhZ2dyZWdhdGVCeUtleTogZnVuY3Rpb24ocm93cykge1xuICAgICAgZnVuY3Rpb24gZ2V0S2V5cyhyb3cpIHtcbiAgICAgICAgdmFyIEhFQURFUl9TSVpFID0gMztcbiAgICAgICAgdmFyIHZhbHVlc0NvdW50ID0gcm93LmRhdGFbMl07XG4gICAgICAgIHZhciBrZXlzID0ge307XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdmFsdWVzQ291bnQ7ICsrcykge1xuICAgICAgICAgIGtleXNbcm93LmRhdGFbSEVBREVSX1NJWkUgKyBzXV0gPSByb3cuZGF0YVtIRUFERVJfU0laRSArIHZhbHVlc0NvdW50ICsgc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IHt9O1xuICAgICAgZm9yIChyID0gMDsgciA8IHJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgdmFyIHJvd0tleXMgPSBnZXRLZXlzKHJvd3Nbcl0pO1xuICAgICAgICBmb3IodmFyIGsgaW4gcm93S2V5cykge1xuICAgICAgICAgIGtleXNba10gPSBrZXlzW2tdIHx8IDA7XG4gICAgICAgICAga2V5c1trXSArPSByb3dLZXlzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9LFxuICAgIFxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcHJvY2Nlc3NUaWxlOiBmdW5jdGlvbihyb3dzLCBjb29yZCwgem9vbSkge1xuICAgICAgdmFyIHI7XG4gICAgICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KHJvd3MubGVuZ3RoKTtcbiAgICAgIHZhciB5ID0gbmV3IFVpbnQ4QXJyYXkocm93cy5sZW5ndGgpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBkZWNvZGUgaW50byBhIGphdmFzY3JpcHQgc3RyY3V0dXJlIHRoZSBhcnJheVxuICAgICAgZnVuY3Rpb24gZGVjb2RlX3Jvdyhyb3cpIHtcbiAgICAgICAgdmFyIEhFQURFUl9TSVpFID0gMztcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgeDogcm93LmRhdGFbMF0gKiBzZWxmLm9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgICAgICB5OiByb3cuZGF0YVsxXSAqIHNlbGYub3B0aW9ucy5yZXNvbHV0aW9uLFxuICAgICAgICAgIHZhbHVlc0NvdW50OiByb3cuZGF0YVsyXSxcbiAgICAgICAgICB0aW1lczogW10sXG4gICAgICAgICAgdmFsdWVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IG8udmFsdWVzQ291bnQ7ICsrcykge1xuICAgICAgICAgICBvLnRpbWVzLnB1c2gocm93LmRhdGFbSEVBREVSX1NJWkUgKyBzXSk7XG4gICAgICAgICAgIG8udmFsdWVzLnB1c2gocm93LmRhdGFbSEVBREVSX1NJWkUgKyBvLnZhbHVlc0NvdW50ICsgc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNlbGYub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBvLnZhbHVlc0NvdW50OyArK3MpIHtcbiAgICAgICAgICAgby52YWx1ZXNbc10gKz0gby52YWx1ZXNbcyAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb1xuICAgICAgfVxuXG4gICAgICAvLyBkZWNvZGUgYWxsIHRoZSByb3dzXG4gICAgICBmb3IgKHIgPSAwOyByIDwgcm93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICByb3dzW3JdID0gZGVjb2RlX3Jvdyhyb3dzW3JdKTtcbiAgICAgIH1cblxuICAgICAgLy8gY291bnQgbnVtYmVyIG9mIGRhdGVzXG4gICAgICB2YXIgZGF0ZXMgPSAwO1xuICAgICAgdmFyIG1heERhdGVTbG90cyA9IDA7XG4gICAgICBmb3IgKHIgPSAwOyByIDwgcm93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICB2YXIgcm93ID0gcm93c1tyXTtcbiAgICAgICAgZGF0ZXMgKz0gcm93LnRpbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBkID0gMDsgZCA8IHJvdy50aW1lcy5sZW5ndGg7ICsrZCkge1xuICAgICAgICAgIG1heERhdGVTbG90cyA9IE1hdGgubWF4KG1heERhdGVTbG90cywgcm93LnRpbWVzW2RdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZXNlcnZlIG1lbW9yeSBmb3IgYWxsIHRoZSBkYXRlc1xuICAgICAgdmFyIHRpbWVJbmRleCA9IG5ldyBJbnQzMkFycmF5KG1heERhdGVTbG90cyArIDEpOyAvL2luZGV4LXNpemVcbiAgICAgIHZhciB0aW1lQ291bnQgPSBuZXcgSW50MzJBcnJheShtYXhEYXRlU2xvdHMgKyAxKTtcbiAgICAgIHZhciByZW5kZXJEYXRhID0gbmV3ICh0aGlzLm9wdGlvbnMudmFsdWVEYXRhVHlwZSB8fCBVaW50OEFycmF5KShkYXRlcyk7XG4gICAgICB2YXIgcmVuZGVyRGF0YVBvcyA9IG5ldyBVaW50MzJBcnJheShkYXRlcyk7XG5cbiAgICAgIHZhciByb3dzUGVyU2xvdCA9IHt9O1xuXG4gICAgICAvLyBwcmVjYWNoZSBwaXhlbCBwb3NpdGlvbnNcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICB2YXIgcm93ID0gcm93c1tyXTtcbiAgICAgICAgeFtyXSA9IHJvdy54O1xuICAgICAgICB5W3JdID0gcm93Lnk7XG5cbiAgICAgICAgdmFyIGRhdGVzID0gcm93LnRpbWVzO1xuICAgICAgICB2YXIgdmFscyA9IHJvdy52YWx1ZXM7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkYXRlcy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgdmFyIHJyID0gcm93c1BlclNsb3RbZGF0ZXNbal1dIHx8IChyb3dzUGVyU2xvdFtkYXRlc1tqXV0gPSBbXSk7XG4gICAgICAgICAgICByci5wdXNoKFtyLCB2YWxzW2pdXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggdGltZXNsb3Qgc2VhcmNoIGFjdGl2ZSBidWNrZXRzXG4gICAgICB2YXIgcmVuZGVyRGF0YUluZGV4ID0gMDtcbiAgICAgIHZhciB0aW1lU2xvdEluZGV4ID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPD0gbWF4RGF0ZVNsb3RzOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgc2xvdFJvd3MgPSByb3dzUGVyU2xvdFtpXVxuICAgICAgICBpZihzbG90Um93cykge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgc2xvdFJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByciA9IHNsb3RSb3dzW3JdO1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgcmVuZGVyRGF0YVBvc1tyZW5kZXJEYXRhSW5kZXhdID0gcnJbMF1cbiAgICAgICAgICAgIHJlbmRlckRhdGFbcmVuZGVyRGF0YUluZGV4XSA9IHJyWzFdO1xuICAgICAgICAgICAgKytyZW5kZXJEYXRhSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbWVJbmRleFtpXSA9IHRpbWVTbG90SW5kZXg7XG4gICAgICAgIHRpbWVDb3VudFtpXSA9IGM7XG4gICAgICAgIHRpbWVTbG90SW5kZXggKz0gYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgY29vcmQ6IHtcbiAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgejogem9vbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lQ291bnQ6IHRpbWVDb3VudCxcbiAgICAgICAgdGltZUluZGV4OiB0aW1lSW5kZXgsXG4gICAgICAgIHJlbmRlckRhdGFQb3M6IHJlbmRlckRhdGFQb3MsXG4gICAgICAgIHJlbmRlckRhdGE6IHJlbmRlckRhdGFcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVybDtcbiAgICB9LFxuXG5cbiAgICB0aWxlVXJsOiBmdW5jdGlvbihjb29yZCwgem9vbSkge1xuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy51cmwoKTtcbiAgICAgIHZhciBzID0gKHRoaXMub3B0aW9ucy5zdWJkb21haW5zIHx8ICdhYmNkJylbKGNvb3JkLnggKyBjb29yZC55ICsgem9vbSkgJSA0XTtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZVxuICAgICAgICAucmVwbGFjZSgne3h9JywgY29vcmQueClcbiAgICAgICAgLnJlcGxhY2UoJ3t5fScsIGNvb3JkLnkpXG4gICAgICAgIC5yZXBsYWNlKCd7en0nLCB6b29tKVxuICAgICAgICAucmVwbGFjZSgne3N9Jywgcyk7XG4gICAgfSxcblxuICAgIGdldFRpbGU6IGZ1bmN0aW9uKGNvb3JkLCB6b29tLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy50aWxlVXJsKGNvb3JkLCB6b29tKTtcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGZldGNoVGltZSA9IFByb2ZpbGVyLm1ldHJpYygnanNvbmFycmF5OmZldGNoIHRpbWUnKTtcbiAgICAgIGZldGNoVGltZS5zdGFydCgpO1xuICAgICAgdG9ycXVlLm5ldC5nZXQodGVtcGxhdGUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGZldGNoVGltZS5lbmQoKTtcbiAgICAgICAgaWYoZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBgY29vcmRgIG9iamVjdCBsaWtlIHt4IDogdGlsZXgsIHk6IHRpbGV5IH0gXG4gICAgICogYHpvb21gIHF1YWR0cmVlIHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRUaWxlRGF0YTogZnVuY3Rpb24oY29vcmQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnRpbGVVcmwoY29vcmQsIHpvb20pO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZmV0Y2hUaW1lID0gUHJvZmlsZXIubWV0cmljKCdqc29uYXJyYXk6ZmV0Y2ggdGltZScpO1xuICAgICAgZmV0Y2hUaW1lLnN0YXJ0KCk7XG4gICAgICB0b3JxdWUubmV0LmdldCh0ZW1wbGF0ZSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZmV0Y2hUaW1lLmVuZCgpO1xuICAgICAgICB2YXIgcHJvY2Vzc2VkID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIHZhciBwcm9jZXNzaW5nVGltZSA9IFByb2ZpbGVyLm1ldHJpYygnanNvbmFycmF5OnByb2Nlc3NpbmcgdGltZScpO1xuICAgICAgICB2YXIgcGFyc2luZ1RpbWUgPSBQcm9maWxlci5tZXRyaWMoJ2pzb25hcnJheTpwYXJzaW5nIHRpbWUnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9jZXNzaW5nVGltZS5zdGFydCgpO1xuICAgICAgICAgIHBhcnNpbmdUaW1lLnN0YXJ0KCk7XG4gICAgICAgICAgdmFyIHJvd3MgPSBKU09OLnBhcnNlKGRhdGEucmVzcG9uc2VUZXh0IHx8IGRhdGEucmVzcG9uc2UpLnJvd3M7XG4gICAgICAgICAgcGFyc2luZ1RpbWUuZW5kKCk7XG4gICAgICAgICAgcHJvY2Vzc2VkID0gc2VsZi5wcm9jY2Vzc1RpbGUocm93cywgY29vcmQsIHpvb20pO1xuICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLmVuZCgpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwicHJvYmxlbSBwYXJzaW5nIEpTT04gb24gXCIsIGNvb3JkLCB6b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKHByb2Nlc3NlZCk7XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0ganNvbjtcbiIsIiAgdmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4uLycpO1xuXG4gIHZhciBVaW50OEFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQ4QXJyYXk7XG4gIHZhciBJbnQzMkFycmF5ID0gdG9ycXVlLnR5cGVzLkludDMyQXJyYXk7XG4gIHZhciBVaW50MzJBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50MzJBcnJheTtcbiAgdmFyIFVpbnQ4Q2xhbXBlZEFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQ4Q2xhbXBlZEFycmF5O1xuXG4gIC8vIGZvcm1hdCgnaGVsbG8sIHswfScsICdyYW1ibycpIC0+IFwiaGVsbG8sIHJhbWJvXCJcbiAgZnVuY3Rpb24gZm9ybWF0KHN0cikge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvcih2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoJ1xcXFx7JyArIGF0dHIgKyAnXFxcXH0nLCAnZycpLCBhdHRyc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgdGlsZUpTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdGlsZVF1ZXVlID0gW107XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMub3B0aW9ucy5jb29yZGluYXRlc19kYXRhX3R5cGUgPSB0aGlzLm9wdGlvbnMuY29vcmRpbmF0ZXNfZGF0YV90eXBlIHx8IFVpbnQ4QXJyYXk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRhdGFfYWdncmVnYXRpb24pIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jdW11bGF0aXZlID0gdGhpcy5vcHRpb25zLmRhdGFfYWdncmVnYXRpb24gPT09ICdjdW11bGF0aXZlJztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoX3Rva2VuKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXMgfHwgKHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXMgPSB7fSk7XG4gICAgICBlLmF1dGhfdG9rZW4gPSB0aGlzLm9wdGlvbnMuYXV0aF90b2tlbjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubm9fZmV0Y2hfbWFwKSB7XG4gICAgICB0aGlzLl9mZXRjaE1hcCgpO1xuICAgIH1cbiAgfTtcblxuICB0aWxlSlNPTi5wcm90b3R5cGUgPSB7XG5cbiAgICBOQU1FOiBcInRpbGVKU09OXCIsXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHRvcnF1ZSB0aWxlIGVuY29kZWQgaW4gYW4gZWZmaWNpZW50IGphdmFzY3JpcHRcbiAgICAgKiBzdHJ1Y3R1cmU6XG4gICAgICoge1xuICAgICAqICAgeDpVaW50OEFycmF5IHggY29vcmRpbmF0ZXMgaW4gdGlsZSByZWZlcmVuY2Ugc3lzdGVtLCBub3JtYWxseSBmcm9tIDAtMjU1XG4gICAgICogICB5OlVpbnQ4QXJyYXkgeSBjb29yZGluYXRlcyBpbiB0aWxlIHJlZmVyZW5jZSBzeXN0ZW1cbiAgICAgKiAgIEluZGV4OiBBcnJheSBpbmRleCB0byB0aGUgcHJvcGVydGllc1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBwcm9jY2Vzc1RpbGU6IGZ1bmN0aW9uKHJvd3MsIGNvb3JkLCB6b29tKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciB4ID0gbmV3IHRoaXMub3B0aW9ucy5jb29yZGluYXRlc19kYXRhX3R5cGUocm93cy5sZW5ndGgpO1xuICAgICAgdmFyIHkgPSBuZXcgdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZShyb3dzLmxlbmd0aCk7XG5cbiAgICAgIC8vIGNvdW50IG51bWJlciBvZiBkYXRlc1xuICAgICAgdmFyIGRhdGVzID0gMDtcbiAgICAgIHZhciBtYXhEYXRlU2xvdHMgPSAtMTtcbiAgICAgIGZvciAociA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICBkYXRlcyArPSByb3cuZGF0ZXNfX3VpbnQxNi5sZW5ndGg7XG4gICAgICAgIGZvcih2YXIgZCA9IDA7IGQgPCByb3cuZGF0ZXNfX3VpbnQxNi5sZW5ndGg7ICsrZCkge1xuICAgICAgICAgIG1heERhdGVTbG90cyA9IE1hdGgubWF4KG1heERhdGVTbG90cywgcm93LmRhdGVzX191aW50MTZbZF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgIGRhdGVzID0gKDEgKyBtYXhEYXRlU2xvdHMpICogcm93cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPyBVaW50MzJBcnJheTogVWludDhDbGFtcGVkQXJyYXk7XG5cbiAgICAgIC8vIHJlc2VydmUgbWVtb3J5IGZvciBhbGwgdGhlIGRhdGVzXG4gICAgICB2YXIgdGltZUluZGV4ID0gbmV3IEludDMyQXJyYXkobWF4RGF0ZVNsb3RzICsgMSk7IC8vaW5kZXgtc2l6ZVxuICAgICAgdmFyIHRpbWVDb3VudCA9IG5ldyBJbnQzMkFycmF5KG1heERhdGVTbG90cyArIDEpO1xuICAgICAgdmFyIHJlbmRlckRhdGEgPSBuZXcgKHRoaXMub3B0aW9ucy52YWx1ZURhdGFUeXBlIHx8IHR5cGUpKGRhdGVzKTtcbiAgICAgIHZhciByZW5kZXJEYXRhUG9zID0gbmV3IFVpbnQzMkFycmF5KGRhdGVzKTtcblxuICAgICAgdmFyIHJvd3NQZXJTbG90ID0ge307XG5cbiAgICAgIC8vIHByZWNhY2hlIHBpeGVsIHBvc2l0aW9uc1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICB4W3JdID0gcm93LnhfX3VpbnQ4ICogdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG4gICAgICAgIHlbcl0gPSByb3cueV9fdWludDggKiB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbjtcblxuICAgICAgICB2YXIgZGF0ZXMgPSByb3cuZGF0ZXNfX3VpbnQxNjtcbiAgICAgICAgdmFyIHZhbHMgPSByb3cudmFsc19fdWludDg7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gZGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIHJyID0gcm93c1BlclNsb3RbZGF0ZXNbal1dIHx8IChyb3dzUGVyU2xvdFtkYXRlc1tqXV0gPSBbXSk7XG4gICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICB2YWxzW2pdICs9IHByZXZfdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXZfdmFsID0gdmFsc1tqXTtcbiAgICAgICAgICAgICAgcnIucHVzaChbciwgdmFsc1tqXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsQnlEYXRlID0ge31cbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gZGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgIHZhbEJ5RGF0ZVtkYXRlc1tqXV0gPSB2YWxzW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYWNjdW0gPSAwO1xuXG4gICAgICAgICAgLy8gZXh0ZW5kIHRoZSBsYXRlc3QgdG8gdGhlIGVuZFxuICAgICAgICAgIGZvciAodmFyIGogPSBkYXRlc1swXTsgaiA8PSBtYXhEYXRlU2xvdHM7ICsraikge1xuICAgICAgICAgICAgICB2YXIgcnIgPSByb3dzUGVyU2xvdFtqXSB8fCAocm93c1BlclNsb3Rbal0gPSBbXSk7XG4gICAgICAgICAgICAgIHZhciB2ID0gdmFsQnlEYXRlW2pdO1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIGFjY3VtICs9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnIucHVzaChbciwgYWNjdW1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggdGltZXNsb3Qgc2VhcmNoIGFjdGl2ZSBidWNrZXRzXG4gICAgICB2YXIgcmVuZGVyRGF0YUluZGV4ID0gMDtcbiAgICAgIHZhciB0aW1lU2xvdEluZGV4ID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPD0gbWF4RGF0ZVNsb3RzOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgc2xvdFJvd3MgPSByb3dzUGVyU2xvdFtpXVxuICAgICAgICBpZihzbG90Um93cykge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgc2xvdFJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByciA9IHNsb3RSb3dzW3JdO1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgcmVuZGVyRGF0YVBvc1tyZW5kZXJEYXRhSW5kZXhdID0gcnJbMF1cbiAgICAgICAgICAgIHJlbmRlckRhdGFbcmVuZGVyRGF0YUluZGV4XSA9IHJyWzFdO1xuICAgICAgICAgICAgKytyZW5kZXJEYXRhSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbWVJbmRleFtpXSA9IHRpbWVTbG90SW5kZXg7XG4gICAgICAgIHRpbWVDb3VudFtpXSA9IGM7XG4gICAgICAgIHRpbWVTbG90SW5kZXggKz0gYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgejogem9vbSxcbiAgICAgICAgY29vcmQ6IHtcbiAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgejogem9vbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lQ291bnQ6IHRpbWVDb3VudCxcbiAgICAgICAgdGltZUluZGV4OiB0aW1lSW5kZXgsXG4gICAgICAgIHJlbmRlckRhdGFQb3M6IHJlbmRlckRhdGFQb3MsXG4gICAgICAgIHJlbmRlckRhdGE6IHJlbmRlckRhdGEsXG4gICAgICAgIG1heERhdGU6IG1heERhdGVTbG90c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0U3RlcHM6IGZ1bmN0aW9uKHN0ZXBzLCBvcHQpIHsgXG4gICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZXBzICE9PSBzdGVwcykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAgPSAodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkvdGhpcy5nZXRTdGVwcygpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwIHx8IDE7XG4gICAgICAgIGlmICghb3B0LnNpbGVudCkgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0KSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IGZhbHNlO1xuXG4gICAgICBpZihvcHQucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkICYmIG9wdC5yZXNvbHV0aW9uICE9PSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiA9IG9wdC5yZXNvbHV0aW9uO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LnN0ZXBzICE9PSB1bmRlZmluZWQgJiYgb3B0LnN0ZXBzICE9PSB0aGlzLm9wdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgdGhpcy5zZXRTdGVwcyhvcHQuc3RlcHMsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIG9wdC5jb2x1bW4gIT09IHRoaXMub3B0aW9ucy5jb2x1bW4pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbiA9IG9wdC5jb2x1bW47XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuY291bnRieSAhPT0gdW5kZWZpbmVkICYmIG9wdC5jb3VudGJ5ICE9PSB0aGlzLm9wdGlvbnMuY291bnRieSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnRieSA9IG9wdC5jb3VudGJ5O1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmRhdGFfYWdncmVnYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYyA9IG9wdC5kYXRhX2FnZ3JlZ2F0aW9uID09PSAnY3VtdWxhdGl2ZSc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSAhPT0gYykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jdW11bGF0aXZlID0gYztcbiAgICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVmcmVzaCkgdGhpcy5yZWxvYWQoKTtcbiAgICAgIHJldHVybiByZWZyZXNoO1xuICAgIH0sXG5cbiAgICBfZXh0cmFQYXJhbXM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUgPSB0b3JxdWUuZXh0ZW5kKHRvcnF1ZS5leHRlbmQoe30sIGUpLCB0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zKTtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciBwID0gW107XG4gICAgICAgIGZvcih2YXIgayBpbiBlKSB7XG4gICAgICAgICAgdmFyIHYgPSBlW2tdO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBpZiAodG9ycXVlLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwLnB1c2goayArIFwiW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQodltpXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnB1c2goayArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAuam9pbignJicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIGlmKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aGlzLl90aWxlUXVldWUucHVzaChbY29vcmQsIHpvb20sIGNhbGxiYWNrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9nZXRUaWxlRGF0YShjb29yZCwgem9vbSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0UmVhZHk6IGZ1bmN0aW9uKHJlYWR5KSB7XG4gICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgIHRoaXMub3B0aW9ucy5yZWFkeSAmJiB0aGlzLm9wdGlvbnMucmVhZHkoKTtcbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbTtcbiAgICAgIHdoaWxlIChpdGVtID0gdGhpcy5fdGlsZVF1ZXVlLnBvcCgpKSB7XG4gICAgICAgIHRoaXMuX2dldFRpbGVEYXRhLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBgY29vcmRgIG9iamVjdCBsaWtlIHt4IDogdGlsZXgsIHk6IHRpbGV5IH1cbiAgICAgKiBgem9vbWAgcXVhZHRyZWUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIF9nZXRUaWxlRGF0YTogZnVuY3Rpb24oY29vcmQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc3ViZG9tYWlucyA9IHRoaXMub3B0aW9ucy5zdWJkb21haW5zIHx8ICcwMTIzJztcbiAgICAgIHZhciBsaW1pdF94ID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgICB2YXIgY29ycmVjdGVkX3ggPSAoKGNvb3JkLnggJSBsaW1pdF94KSArIGxpbWl0X3gpICUgbGltaXRfeDtcbiAgICAgIHZhciBpbmRleCA9IE1hdGguYWJzKGNvcnJlY3RlZF94ICsgY29vcmQueSkgJSBzdWJkb21haW5zLmxlbmd0aDtcbiAgICAgIHZhciBleHRyYSA9IHRoaXMuX2V4dHJhUGFyYW1zKCk7XG4gICAgICB2YXIgdXJsID0gdGhpcy50ZW1wbGF0ZVVybFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb3JyZWN0ZWRfeClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3l9JywgY29vcmQueSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3p9Jywgem9vbSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3N9Jywgc3ViZG9tYWluc1tpbmRleF0pXG4gICAgICB1cmwgKz0gZXh0cmE7XG4gICAgICB0b3JxdWUubmV0LmdldCggdXJsICwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB2YXIgcm93cyA9IEpTT04ucGFyc2UoZGF0YS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIGNhbGxiYWNrKHNlbGYucHJvY2Nlc3NUaWxlKHJvd3MsIGNvb3JkLCB6b29tKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRLZXlTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLm9wdGlvbnMuc3RhcnQsXG4gICAgICAgIGVuZDogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICAgc3RlcDogdGhpcy5vcHRpb25zLnN0ZXAsXG4gICAgICAgIHN0ZXBzOiB0aGlzLm9wdGlvbnMuc3RlcHMsXG4gICAgICAgIGNvbHVtblR5cGU6IHRoaXMub3B0aW9ucy5jb2x1bW5fdHlwZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uOiBmdW5jdGlvbihjb2x1bW4sIGlzVGltZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMub3B0aW9ucy5pc190aW1lID0gaXNUaW1lID09PSB1bmRlZmluZWQgPyB0cnVlOiBmYWxzZTtcbiAgICAgIHRoaXMucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmV0Y2hNYXAoKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RlcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMub3B0aW9ucy5zdGVwcywgdGhpcy5vcHRpb25zLmRhdGFfc3RlcHMpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib3VuZHM7XG4gICAgfSxcblxuICAgIGdldFNRTDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNxbCB8fCBcInNlbGVjdCAqIGZyb20gXCIgKyB0aGlzLm9wdGlvbnMudGFibGU7XG4gICAgfSxcblxuICAgIHNldFNRTDogZnVuY3Rpb24oc3FsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNxbCAhPSBzcWwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNxbCA9IHNxbDtcbiAgICAgICAgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2lzVXNlclRlbXBsYXRlVXJsOiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCAmJiB0LmluZGV4T2YoJ3t1c2VyfScpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgaXNIdHRwczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1hcHNfYXBpX3RlbXBsYXRlLmluZGV4T2YoJ2h0dHBzJykgPT09IDA7XG4gICAgfSxcblxuICAgIF9mZXRjaE1hcDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRvcnF1ZS5uZXQuZ2V0KHRoaXMub3B0aW9ucy50aWxlSlNPTiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5yZXNwb25zZSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3JzKXtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5lcnJvckNhbGxiYWNrICYmIHNlbGYub3B0aW9ucy5lcnJvckNhbGxiYWNrKGRhdGEuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgICAgIHNlbGYub3B0aW9uc1trXSA9IGRhdGFba107XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYudGVtcGxhdGVVcmwgPSBkYXRhLnRpbGVzWzBdO1xuICAgICAgICAgIGlmIChzZWxmLnRlbXBsYXRlVXJsLmluZGV4T2YoXCJodHRwXCIpICE9PSAwKXtcbiAgICAgICAgICAgIHNlbGYudGVtcGxhdGVVcmwgPSBzZWxmLm9wdGlvbnMudGlsZUpTT04uc3Vic3RyaW5nKDAsIHNlbGYub3B0aW9ucy50aWxlSlNPTi5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHNlbGYudGVtcGxhdGVVcmw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuX3NldFJlYWR5KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB0aWxlSlNPTjsiLCIgIHZhciB0b3JxdWUgPSByZXF1aXJlKCcuLi8nKTtcbiAgdmFyIFByb2ZpbGVyID0gcmVxdWlyZSgnLi4vcHJvZmlsZXInKTtcblxuICB2YXIgVWludDhBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50OEFycmF5O1xuICB2YXIgSW50MzJBcnJheSA9IHRvcnF1ZS50eXBlcy5JbnQzMkFycmF5O1xuICB2YXIgVWludDMyQXJyYXkgPSB0b3JxdWUudHlwZXMuVWludDMyQXJyYXk7XG4gIHZhciBVaW50OENsYW1wZWRBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50OENsYW1wZWRBcnJheTtcblxuICAvLyBmb3JtYXQoJ2hlbGxvLCB7MH0nLCAncmFtYm8nKSAtPiBcImhlbGxvLCByYW1ib1wiXG4gIGZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKCdcXFxceycgKyBhdHRyICsgJ1xcXFx9JywgJ2cnKSwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIHdpbmRzaGFmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl90aWxlUXVldWUgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5vcHRpb25zLmlzX3RpbWUgPSB0aGlzLm9wdGlvbnMuaXNfdGltZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZTogdGhpcy5vcHRpb25zLmlzX3RpbWU7XG4gICAgdGhpcy5vcHRpb25zLnRpbGVyX3Byb3RvY29sID0gb3B0aW9ucy50aWxlcl9wcm90b2NvbCB8fCAnaHR0cCc7XG4gICAgdGhpcy5vcHRpb25zLnRpbGVyX2RvbWFpbiA9IG9wdGlvbnMudGlsZXJfZG9tYWluIHx8ICdjYXJ0b2RiLmNvbSc7XG4gICAgdGhpcy5vcHRpb25zLnRpbGVyX3BvcnQgPSBvcHRpb25zLnRpbGVyX3BvcnQgfHwgODA7XG5cbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuICAgIGlmICghb3B0aW9ucy5tYXBzX2FwaV90ZW1wbGF0ZSkge1xuICAgICAgdGhpcy5fYnVpbGRNYXBzQXBpVGVtcGxhdGUodGhpcy5vcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLm1hcHNfYXBpX3RlbXBsYXRlID0gIG9wdGlvbnMubWFwc19hcGlfdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZSA9IHRoaXMub3B0aW9ucy5jb29yZGluYXRlc19kYXRhX3R5cGUgfHwgVWludDhBcnJheTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YV9hZ2dyZWdhdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPSB0aGlzLm9wdGlvbnMuZGF0YV9hZ2dyZWdhdGlvbiA9PT0gJ2N1bXVsYXRpdmUnO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dGhfdG9rZW4pIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLmV4dHJhX3BhcmFtcyB8fCAodGhpcy5vcHRpb25zLmV4dHJhX3BhcmFtcyA9IHt9KTtcbiAgICAgIGUuYXV0aF90b2tlbiA9IHRoaXMub3B0aW9ucy5hdXRoX3Rva2VuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ub19mZXRjaF9tYXApIHtcbiAgICAgIHRoaXMuX2ZldGNoTWFwKCk7XG4gICAgfVxuICB9O1xuXG4gIHdpbmRzaGFmdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHRvcnF1ZSB0aWxlIGVuY29kZWQgaW4gYW4gZWZmaWNpZW50IGphdmFzY3JpcHRcbiAgICAgKiBzdHJ1Y3R1cmU6XG4gICAgICoge1xuICAgICAqICAgeDpVaW50OEFycmF5IHggY29vcmRpbmF0ZXMgaW4gdGlsZSByZWZlcmVuY2Ugc3lzdGVtLCBub3JtYWxseSBmcm9tIDAtMjU1XG4gICAgICogICB5OlVpbnQ4QXJyYXkgeSBjb29yZGluYXRlcyBpbiB0aWxlIHJlZmVyZW5jZSBzeXN0ZW1cbiAgICAgKiAgIEluZGV4OiBBcnJheSBpbmRleCB0byB0aGUgcHJvcGVydGllc1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBwcm9jY2Vzc1RpbGU6IGZ1bmN0aW9uKHJvd3MsIGNvb3JkLCB6b29tKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciB4ID0gbmV3IHRoaXMub3B0aW9ucy5jb29yZGluYXRlc19kYXRhX3R5cGUocm93cy5sZW5ndGgpO1xuICAgICAgdmFyIHkgPSBuZXcgdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZShyb3dzLmxlbmd0aCk7XG5cbiAgICAgIHZhciBwcm9mX21lbSA9IFByb2ZpbGVyLm1ldHJpYygndG9ycXVlLnByb3ZpZGVyLndpbmRzaGFmdC5tZW0nKTtcbiAgICAgIHZhciBwcm9mX3BvaW50X2NvdW50ID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0LnBvaW50cycpO1xuICAgICAgdmFyIHByb2ZfcHJvY2Vzc190aW1lID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0LnByb2Nlc3NfdGltZScpLnN0YXJ0KCk7XG5cbiAgICAgIC8vIGNvdW50IG51bWJlciBvZiBkYXRlc1xuICAgICAgdmFyIGRhdGVzID0gMDtcbiAgICAgIHZhciBtYXhEYXRlU2xvdHMgPSAtMTtcbiAgICAgIGZvciAociA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICBkYXRlcyArPSByb3cuZGF0ZXNfX3VpbnQxNi5sZW5ndGg7XG4gICAgICAgIGZvcih2YXIgZCA9IDA7IGQgPCByb3cuZGF0ZXNfX3VpbnQxNi5sZW5ndGg7ICsrZCkge1xuICAgICAgICAgIG1heERhdGVTbG90cyA9IE1hdGgubWF4KG1heERhdGVTbG90cywgcm93LmRhdGVzX191aW50MTZbZF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgIGRhdGVzID0gKDEgKyBtYXhEYXRlU2xvdHMpICogcm93cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPyBVaW50MzJBcnJheTogVWludDhDbGFtcGVkQXJyYXk7XG5cbiAgICAgIC8vIHJlc2VydmUgbWVtb3J5IGZvciBhbGwgdGhlIGRhdGVzXG4gICAgICB2YXIgdGltZUluZGV4ID0gbmV3IEludDMyQXJyYXkobWF4RGF0ZVNsb3RzICsgMSk7IC8vaW5kZXgtc2l6ZVxuICAgICAgdmFyIHRpbWVDb3VudCA9IG5ldyBJbnQzMkFycmF5KG1heERhdGVTbG90cyArIDEpO1xuICAgICAgdmFyIHJlbmRlckRhdGEgPSBuZXcgKHRoaXMub3B0aW9ucy52YWx1ZURhdGFUeXBlIHx8IHR5cGUpKGRhdGVzKTtcbiAgICAgIHZhciByZW5kZXJEYXRhUG9zID0gbmV3IFVpbnQzMkFycmF5KGRhdGVzKTtcblxuICAgICAgcHJvZl9tZW0uaW5jKFxuICAgICAgICA0ICogbWF4RGF0ZVNsb3RzICsgLy8gdGltZUluZGV4XG4gICAgICAgIDQgKiBtYXhEYXRlU2xvdHMgKyAvLyB0aW1lQ291bnRcbiAgICAgICAgZGF0ZXMgKyAvL3JlbmRlckRhdGFcbiAgICAgICAgZGF0ZXMgKiA0XG4gICAgICApOyAvL3JlbmRlckRhdGFQb3NcblxuICAgICAgcHJvZl9wb2ludF9jb3VudC5pbmMocm93cy5sZW5ndGgpO1xuXG4gICAgICB2YXIgcm93c1BlclNsb3QgPSB7fTtcblxuICAgICAgLy8gcHJlY2FjaGUgcGl4ZWwgcG9zaXRpb25zXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcl07XG4gICAgICAgIHhbcl0gPSByb3cueF9fdWludDggKiB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgICAgeVtyXSA9IHJvdy55X191aW50OCAqIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHZhciBkYXRlcyA9IHJvdy5kYXRlc19fdWludDE2O1xuICAgICAgICB2YXIgdmFscyA9IHJvdy52YWxzX191aW50ODtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkYXRlcy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgICB2YXIgcnIgPSByb3dzUGVyU2xvdFtkYXRlc1tqXV0gfHwgKHJvd3NQZXJTbG90W2RhdGVzW2pdXSA9IFtdKTtcbiAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHNbal0gKz0gcHJldl92YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJldl92YWwgPSB2YWxzW2pdO1xuICAgICAgICAgICAgICByci5wdXNoKFtyLCB2YWxzW2pdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWxCeURhdGUgPSB7fVxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkYXRlcy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgdmFsQnlEYXRlW2RhdGVzW2pdXSA9IHZhbHNbal07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhY2N1bSA9IDA7XG5cbiAgICAgICAgICAvLyBleHRlbmQgdGhlIGxhdGVzdCB0byB0aGUgZW5kXG4gICAgICAgICAgZm9yICh2YXIgaiA9IGRhdGVzWzBdOyBqIDw9IG1heERhdGVTbG90czsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciByciA9IHJvd3NQZXJTbG90W2pdIHx8IChyb3dzUGVyU2xvdFtqXSA9IFtdKTtcbiAgICAgICAgICAgICAgdmFyIHYgPSB2YWxCeURhdGVbal07XG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByci5wdXNoKFtyLCBhY2N1bV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qdmFyIGxhc3REYXRlU2xvdCA9IGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGZvciAodmFyIGogPSBsYXN0RGF0ZVNsb3QgKyAxOyBqIDw9IG1heERhdGVTbG90czsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcnIgPSByb3dzUGVyU2xvdFtqXSB8fCAocm93c1BlclNsb3Rbal0gPSBbXSk7XG4gICAgICAgICAgICByci5wdXNoKFtyLCBwcmV2X3ZhbF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAqL1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggdGltZXNsb3Qgc2VhcmNoIGFjdGl2ZSBidWNrZXRzXG4gICAgICB2YXIgcmVuZGVyRGF0YUluZGV4ID0gMDtcbiAgICAgIHZhciB0aW1lU2xvdEluZGV4ID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPD0gbWF4RGF0ZVNsb3RzOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgc2xvdFJvd3MgPSByb3dzUGVyU2xvdFtpXVxuICAgICAgICBpZihzbG90Um93cykge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgc2xvdFJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByciA9IHNsb3RSb3dzW3JdO1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgcmVuZGVyRGF0YVBvc1tyZW5kZXJEYXRhSW5kZXhdID0gcnJbMF1cbiAgICAgICAgICAgIHJlbmRlckRhdGFbcmVuZGVyRGF0YUluZGV4XSA9IHJyWzFdO1xuICAgICAgICAgICAgKytyZW5kZXJEYXRhSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbWVJbmRleFtpXSA9IHRpbWVTbG90SW5kZXg7XG4gICAgICAgIHRpbWVDb3VudFtpXSA9IGM7XG4gICAgICAgIHRpbWVTbG90SW5kZXggKz0gYztcbiAgICAgIH1cblxuICAgICAgcHJvZl9wcm9jZXNzX3RpbWUuZW5kKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHo6IHpvb20sXG4gICAgICAgIGNvb3JkOiB7XG4gICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgIHo6IHpvb21cbiAgICAgICAgfSxcbiAgICAgICAgdGltZUNvdW50OiB0aW1lQ291bnQsXG4gICAgICAgIHRpbWVJbmRleDogdGltZUluZGV4LFxuICAgICAgICByZW5kZXJEYXRhUG9zOiByZW5kZXJEYXRhUG9zLFxuICAgICAgICByZW5kZXJEYXRhOiByZW5kZXJEYXRhLFxuICAgICAgICBtYXhEYXRlOiBtYXhEYXRlU2xvdHNcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qc2V0Q2FydG9DU1M6IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jYXJ0b2NzcyA9IGM7XG4gICAgfSwqL1xuXG4gICAgc2V0U3RlcHM6IGZ1bmN0aW9uKHN0ZXBzLCBvcHQpIHsgXG4gICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZXBzICE9PSBzdGVwcykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAgPSAodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkvdGhpcy5nZXRTdGVwcygpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwIHx8IDE7XG4gICAgICAgIGlmICghb3B0LnNpbGVudCkgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0KSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IGZhbHNlO1xuXG4gICAgICBpZihvcHQucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkICYmIG9wdC5yZXNvbHV0aW9uICE9PSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiA9IG9wdC5yZXNvbHV0aW9uO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LnN0ZXBzICE9PSB1bmRlZmluZWQgJiYgb3B0LnN0ZXBzICE9PSB0aGlzLm9wdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgdGhpcy5zZXRTdGVwcyhvcHQuc3RlcHMsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIG9wdC5jb2x1bW4gIT09IHRoaXMub3B0aW9ucy5jb2x1bW4pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbiA9IG9wdC5jb2x1bW47XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuY291bnRieSAhPT0gdW5kZWZpbmVkICYmIG9wdC5jb3VudGJ5ICE9PSB0aGlzLm9wdGlvbnMuY291bnRieSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnRieSA9IG9wdC5jb3VudGJ5O1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmRhdGFfYWdncmVnYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYyA9IG9wdC5kYXRhX2FnZ3JlZ2F0aW9uID09PSAnY3VtdWxhdGl2ZSc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSAhPT0gYykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jdW11bGF0aXZlID0gYztcbiAgICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVmcmVzaCkgdGhpcy5yZWxvYWQoKTtcbiAgICAgIHJldHVybiByZWZyZXNoO1xuICAgIH0sXG5cbiAgICBfZXh0cmFQYXJhbXM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUgPSB0b3JxdWUuZXh0ZW5kKHRvcnF1ZS5leHRlbmQoe30sIGUpLCB0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zKTtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciBwID0gW107XG4gICAgICAgIGZvcih2YXIgayBpbiBlKSB7XG4gICAgICAgICAgdmFyIHYgPSBlW2tdO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBpZiAodG9ycXVlLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwLnB1c2goayArIFwiW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQodltpXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnB1c2goayArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAuam9pbignJicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIGlmKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aGlzLl90aWxlUXVldWUucHVzaChbY29vcmQsIHpvb20sIGNhbGxiYWNrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9nZXRUaWxlRGF0YShjb29yZCwgem9vbSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0UmVhZHk6IGZ1bmN0aW9uKHJlYWR5KSB7XG4gICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgIHRoaXMub3B0aW9ucy5yZWFkeSAmJiB0aGlzLm9wdGlvbnMucmVhZHkoKTtcbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbTtcbiAgICAgIHdoaWxlIChpdGVtID0gdGhpcy5fdGlsZVF1ZXVlLnBvcCgpKSB7XG4gICAgICAgIHRoaXMuX2dldFRpbGVEYXRhLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBgY29vcmRgIG9iamVjdCBsaWtlIHt4IDogdGlsZXgsIHk6IHRpbGV5IH1cbiAgICAgKiBgem9vbWAgcXVhZHRyZWUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIF9nZXRUaWxlRGF0YTogZnVuY3Rpb24oY29vcmQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcHJvZl9mZXRjaF90aW1lID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0LnRpbGUuZmV0Y2gnKS5zdGFydCgpO1xuICAgICAgdmFyIHN1YmRvbWFpbnMgPSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucyB8fCAnMDEyMyc7XG4gICAgICB2YXIgbGltaXRfeCA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgdmFyIGNvcnJlY3RlZF94ID0gKChjb29yZC54ICUgbGltaXRfeCkgKyBsaW1pdF94KSAlIGxpbWl0X3g7XG4gICAgICB2YXIgaW5kZXggPSBNYXRoLmFicyhjb3JyZWN0ZWRfeCArIGNvb3JkLnkpICUgc3ViZG9tYWlucy5sZW5ndGg7XG4gICAgICB2YXIgdXJsID0gdGhpcy50ZW1wbGF0ZVVybFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb3JyZWN0ZWRfeClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3l9JywgY29vcmQueSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3p9Jywgem9vbSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3N9Jywgc3ViZG9tYWluc1tpbmRleF0pXG5cbiAgICAgIHZhciBleHRyYSA9IHRoaXMuX2V4dHJhUGFyYW1zKCk7XG4gICAgICB0b3JxdWUubmV0LmdldCggdXJsICsgKGV4dHJhID8gXCI/XCIgKyBleHRyYTogJycpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBwcm9mX2ZldGNoX3RpbWUuZW5kKCk7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgdmFyIHJvd3MgPSBKU09OLnBhcnNlKGRhdGEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhzZWxmLnByb2NjZXNzVGlsZShyb3dzLCBjb29yZCwgem9vbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb2ZpbGVyLm1ldHJpYygndG9ycXVlLnByb3ZpZGVyLndpbmRzaGFmdC50aWxlLmVycm9yJykuaW5jKCk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRLZXlTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLm9wdGlvbnMuc3RhcnQsXG4gICAgICAgIGVuZDogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICAgc3RlcDogdGhpcy5vcHRpb25zLnN0ZXAsXG4gICAgICAgIHN0ZXBzOiB0aGlzLm9wdGlvbnMuc3RlcHMsXG4gICAgICAgIGNvbHVtblR5cGU6IHRoaXMub3B0aW9ucy5jb2x1bW5fdHlwZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uOiBmdW5jdGlvbihjb2x1bW4sIGlzVGltZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMub3B0aW9ucy5pc190aW1lID0gaXNUaW1lID09PSB1bmRlZmluZWQgPyB0cnVlOiBmYWxzZTtcbiAgICAgIHRoaXMucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmV0Y2hNYXAoKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RlcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMub3B0aW9ucy5zdGVwcywgdGhpcy5vcHRpb25zLmRhdGFfc3RlcHMpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib3VuZHM7XG4gICAgfSxcblxuICAgIGdldFNRTDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNxbCB8fCBcInNlbGVjdCAqIGZyb20gXCIgKyB0aGlzLm9wdGlvbnMudGFibGU7XG4gICAgfSxcblxuICAgIHNldFNRTDogZnVuY3Rpb24oc3FsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNxbCAhPSBzcWwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNxbCA9IHNxbDtcbiAgICAgICAgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2J1aWxkTWFwc0FwaVRlbXBsYXRlOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgdmFyIHVzZXIgPSBvcHRzLnVzZXJfbmFtZSB8fCBvcHRzLnVzZXI7XG4gICAgICAgb3B0cy5tYXBzX2FwaV90ZW1wbGF0ZSA9IG9wdHMudGlsZXJfcHJvdG9jb2wgK1xuICAgICAgICAgICBcIjovL1wiICsgKCh1c2VyKSA/IFwie3VzZXJ9LlwiOlwiXCIpICArXG4gICAgICAgICAgIG9wdHMudGlsZXJfZG9tYWluICtcbiAgICAgICAgICAgKChvcHRzLnRpbGVyX3BvcnQgIT0gXCJcIikgPyAoXCI6XCIgKyBvcHRzLnRpbGVyX3BvcnQpIDogXCJcIik7XG4gICAgfSxcblxuICAgIF90aWxlckhvc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdXNlciA9IG9wdHMudXNlcl9uYW1lIHx8IG9wdHMudXNlcjtcbiAgICAgIHJldHVybiBvcHRzLm1hcHNfYXBpX3RlbXBsYXRlLnJlcGxhY2UoJ3t1c2VyfScsIHVzZXIpO1xuICAgIH0sXG5cbiAgICB1cmw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGNkbl9ob3N0ID0gb3B0cy5jZG5fdXJsO1xuICAgICAgdmFyIGhhc19lbXB0eV9jZG4gPSAhY2RuX2hvc3QgfHwgKGNkbl9ob3N0ICYmICghY2RuX2hvc3QuaHR0cCAmJiAhY2RuX2hvc3QuaHR0cHMpKTtcblxuICAgICAgaWYgKG9wdHMubm9fY2RuIHx8IGhhc19lbXB0eV9jZG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVySG9zdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5pc0h0dHBzKCkgPyAnaHR0cHMnOiAnaHR0cCc7XG4gICAgICAgIHZhciBoID0gcHJvdG9jb2wgKyBcIjovL1wiO1xuICAgICAgICBpZiAoIXRoaXMuaXNIdHRwcygpKSB7XG4gICAgICAgICAgaCArPSBcIntzfS5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2RuX3VybCA9IGNkbl9ob3N0W3Byb3RvY29sXTtcbiAgICAgICAgLy8gYnVpbGQgZGVmYXVsdCB0ZW1wbGF0ZSB1cmwgaWYgdGhlIGNkbiB1cmwgaXMgbm90IHRlbXBsYXRpemVkXG4gICAgICAgIC8vIHRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmxpdHksIGlkZWFsbHkgd2Ugc2hvdWxkIHVzZSB0aGUgdXJsXG4gICAgICAgIC8vIHRoYXQgdGlsZXIgc2VuZHMgdG8gdXMgcmlnaHQgYXdheVxuICAgICAgICBpZiAoIXRoaXMuX2lzVXNlclRlbXBsYXRlVXJsKGNkbl91cmwpKSB7XG4gICAgICAgICAgY2RuX3VybCA9IGNkbl91cmwgICsgXCIve3VzZXJ9XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZXIgPSBvcHRzLnVzZXJfbmFtZSB8fCBvcHRzLnVzZXI7XG4gICAgICAgIGggKz0gY2RuX3VybC5yZXBsYWNlKCd7dXNlcn0nLCB1c2VyKVxuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBfaXNVc2VyVGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIHQuaW5kZXhPZigne3VzZXJ9JykgIT09IC0xO1xuICAgIH0sXG5cbiAgICBpc0h0dHBzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWFwc19hcGlfdGVtcGxhdGUuaW5kZXhPZignaHR0cHMnKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2dlbmVyYXRlQ2FydG9DU1M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHIgPSB7XG4gICAgICAgICctdG9ycXVlLWZyYW1lLWNvdW50JzogdGhpcy5vcHRpb25zLnN0ZXBzLFxuICAgICAgICAnLXRvcnF1ZS1yZXNvbHV0aW9uJzogdGhpcy5vcHRpb25zLnJlc29sdXRpb24sXG4gICAgICAgICctdG9ycXVlLWFnZ3JlZ2F0aW9uLWZ1bmN0aW9uJzogXCInXCIgKyB0aGlzLm9wdGlvbnMuY291bnRieSArIFwiJ1wiLFxuICAgICAgICAnLXRvcnF1ZS10aW1lLWF0dHJpYnV0ZSc6IFwiJ1wiICsgdGhpcy5vcHRpb25zLmNvbHVtbiArIFwiJ1wiLFxuICAgICAgICAnLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uJzogdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPyAnY3VtdWxhdGl2ZSc6ICdsaW5lYXInLFxuICAgICAgfTtcbiAgICAgIHZhciBzdCA9ICdNYXB7JztcbiAgICAgIGZvciAodmFyIGsgaW4gYXR0cikge1xuICAgICAgICBzdCArPSBrICsgXCI6XCIgKyBhdHRyW2tdICsgXCI7XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3QgKyBcIn1cIjtcbiAgICB9LFxuXG4gICAgX2ZldGNoTWFwOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGxheWVyZ3JvdXAgPSB7fTtcbiAgICAgIHZhciBob3N0ID0gdGhpcy5vcHRpb25zLmR5bmFtaWNfY2RuID8gdGhpcy51cmwoKS5yZXBsYWNlKCd7c30nLCAnMCcpOiB0aGlzLl90aWxlckhvc3QoKTtcbiAgICAgIHZhciB1cmwgPSBob3N0ICsgXCIvYXBpL3YxL21hcFwiO1xuICAgICAgdmFyIG5hbWVkID0gdGhpcy5vcHRpb25zLm5hbWVkX21hcDtcbiAgICAgIHZhciBhbGxQYXJhbXMgPSB7fTtcblxuICAgICAgaWYobmFtZWQpIHtcbiAgICAgICAgLy90aWxlcy90ZW1wbGF0ZVxuICAgICAgICB1cmwgPSBob3N0ICsgXCIvYXBpL3YxL21hcC9uYW1lZC9cIiArIG5hbWVkLm5hbWUgKyBcIi9qc29ucFwiO1xuICAgICAgICBpZih0eXBlb2YgbmFtZWQucGFyYW1zICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICBsYXllcmdyb3VwID0gbmFtZWQucGFyYW1zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllcmdyb3VwID0ge1xuICAgICAgICAgIFwidmVyc2lvblwiOiBcIjEuMC4xXCIsXG4gICAgICAgICAgXCJzdGF0X3RhZ1wiOiB0aGlzLm9wdGlvbnMuc3RhdF90YWcgfHwgJ3RvcnF1ZScsXG4gICAgICAgICAgXCJsYXllcnNcIjogW3tcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRvcnF1ZVwiLFxuICAgICAgICAgICAgXCJvcHRpb25zXCI6IHtcbiAgICAgICAgICAgICAgXCJjYXJ0b2Nzc192ZXJzaW9uXCI6IFwiMS4wLjBcIixcbiAgICAgICAgICAgICAgXCJjYXJ0b2Nzc1wiOiB0aGlzLl9nZW5lcmF0ZUNhcnRvQ1NTKCksXG4gICAgICAgICAgICAgIFwic3FsXCI6IHRoaXMuZ2V0U1FMKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZih0aGlzLm9wdGlvbnMuc3RhdF90YWcpe1xuICAgICAgICBhbGxQYXJhbXNbXCJzdGF0X3RhZ1wiXSA9IHRoaXMub3B0aW9ucy5zdGF0X3RhZztcbiAgICAgIH1cblxuICAgICAgZXh0cmEgPSB0aGlzLl9leHRyYVBhcmFtcyhhbGxQYXJhbXMpO1xuXG4gICAgICAvLyB0aWxlciBuZWVkcyBtYXBfa2V5IGluc3RlYWQgb2YgYXBpX2tleVxuICAgICAgLy8gc28gcmVwbGFjZSBpdFxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIGV4dHJhID0gZXh0cmEucmVwbGFjZSgnYXBpX2tleT0nLCAnbWFwX2tleT0nKTtcbiAgICAgIH1cblxuICAgICAgdXJsID0gdXJsICtcbiAgICAgICAgXCI/Y29uZmlnPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGxheWVyZ3JvdXApKSArXG4gICAgICAgIFwiJmNhbGxiYWNrPT9cIiArIChleHRyYSA/IFwiJlwiICsgZXh0cmE6ICcnKTtcblxuICAgICAgdmFyIG1hcF9pbnN0YW5jZV90aW1lID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0LmxheWVyZ3JvdXAudGltZScpLnN0YXJ0KCk7XG4gICAgICB0b3JxdWUubmV0Lmpzb25wKHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgbWFwX2luc3RhbmNlX3RpbWUuZW5kKCk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3JzKXtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5lcnJvckNhbGxiYWNrICYmIHNlbGYub3B0aW9ucy5lcnJvckNhbGxiYWNrKGRhdGEuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvcnF1ZV9rZXkgPSBPYmplY3Qua2V5cyhkYXRhLm1ldGFkYXRhLnRvcnF1ZSlbMF1cbiAgICAgICAgICB2YXIgb3B0ID0gZGF0YS5tZXRhZGF0YS50b3JxdWVbdG9ycXVlX2tleV07XG4gICAgICAgICAgZm9yKHZhciBrIGluIG9wdCkge1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zW2tdID0gb3B0W2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB1c2UgY2RuX3VybCBpZiBwcmVzZW50XG4gICAgICAgICAgaWYgKGRhdGEuY2RuX3VybCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzZWxmLm9wdGlvbnMuY2RuX3VybCA9IHNlbGYub3B0aW9ucy5jZG5fdXJsIHx8IHt9O1xuICAgICAgICAgICAgYy5odHRwID0gZGF0YS5jZG5fdXJsLmh0dHAgfHwgYy5odHRwO1xuICAgICAgICAgICAgYy5odHRwcyA9IGRhdGEuY2RuX3VybC5odHRwcyB8fCBjLmh0dHBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnRlbXBsYXRlVXJsID0gc2VsZi51cmwoKSArIFwiL2FwaS92MS9tYXAvXCIgKyBkYXRhLmxheWVyZ3JvdXBpZCArIFwiL1wiICsgdG9ycXVlX2tleSArIFwiL3t6fS97eH0ve3l9Lmpzb24udG9ycXVlXCI7XG4gICAgICAgICAgc2VsZi5fc2V0UmVhZHkodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0LmxheWVyZ3JvdXAuZXJyb3InKS5pbmMoKTtcbiAgICAgICAgfVxuICAgICAgfSwgeyBjYWxsYmFja05hbWU6IHNlbGYub3B0aW9ucy5pbnN0YW5jaWF0ZUNhbGxiYWNrIH0pO1xuICAgIH1cblxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gd2luZHNoYWZ0O1xuIiwiICB2YXIgVEFVID0gTWF0aC5QSSoyO1xuICAvLyBtaW4gdmFsdWUgdG8gcmVuZGVyIGEgbGluZS4gXG4gIC8vIGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gcmVuZGVyIGEgbGluZSBvZiBhIHdpZHRoIGlzIG5vdCBldmVuIHZpc2libGVcbiAgdmFyIExJTkVXSURUSF9NSU5fVkFMVUUgPSAwLjA1OyBcbiAgdmFyIE1BWF9TUFJJVEVfUkFESVVTID0gMjU1O1xuXG4gIGZ1bmN0aW9uIHJlbmRlclBvaW50KGN0eCwgc3QpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gc3RbJ21hcmtlci1maWxsJ107XG4gICAgdmFyIHBpeGVsX3NpemUgPSBzdFsnbWFya2VyLXdpZHRoJ107XG5cbiAgICAvLyByZW5kZXIgYSBjaXJjbGVcbiAgICAvLyBUT0RPOiBmaWxsIGFuZCBzdHJva2Ugb3JkZXIgc2hvdWxkIGRlcGVuZCBvbiB0aGUgb3JkZXIgb2YgdGhlIHByb3BlcnRpZXNcbiAgICAvLyBpbiB0aGUgY2FydG9jc3MuXG5cbiAgICAvLyBmaWxsXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoMCwgMCwgcGl4ZWxfc2l6ZSwgMCwgVEFVLCB0cnVlLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoc3RbJ21hcmtlci1vcGFjaXR5J10gIT09IHVuZGVmaW5lZCApICBzdFsnbWFya2VyLWZpbGwtb3BhY2l0eSddID0gc3RbJ21hcmtlci1saW5lLW9wYWNpdHknXSA9IHN0WydtYXJrZXItb3BhY2l0eSddO1xuXG4gICAgaWYgKHN0WydtYXJrZXItZmlsbCddKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gPj0gMD8gc3RbJ21hcmtlci1maWxsLW9wYWNpdHknXTogMTtcblxuICAgICAgaWYgKGN0eC5nbG9iYWxBbHBoYSA+IDApIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHJva2VcbiAgICBpZiAoc3RbJ21hcmtlci1saW5lLWNvbG9yJ10gJiYgc3RbJ21hcmtlci1saW5lLXdpZHRoJ10gJiYgc3RbJ21hcmtlci1saW5lLXdpZHRoJ10gPiBMSU5FV0lEVEhfTUlOX1ZBTFVFKSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdFsnbWFya2VyLWxpbmUtb3BhY2l0eSddID49IDA/IHN0WydtYXJrZXItbGluZS1vcGFjaXR5J106IDE7XG4gICAgICBpZiAoc3RbJ21hcmtlci1saW5lLXdpZHRoJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3RbJ21hcmtlci1saW5lLXdpZHRoJ107XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdFsnbWFya2VyLWxpbmUtY29sb3InXTtcblxuICAgICAgLy8gZG8gbm90IHJlbmRlciBmb3IgYWxwaGEgPSAwXG4gICAgICBpZiAoY3R4Lmdsb2JhbEFscGhhID4gMCkge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUmVjdGFuZ2xlKGN0eCwgc3QpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gc3RbJ21hcmtlci1maWxsJ107XG4gICAgdmFyIHBpeGVsX3NpemUgPSBzdFsnbWFya2VyLXdpZHRoJ107XG4gICAgdmFyIHcgPSBwaXhlbF9zaXplICogMjtcblxuICAgIC8vIGZpbGxcbiAgICBpZiAoc3RbJ21hcmtlci1maWxsJ10pIHtcbiAgICAgIGlmIChzdFsnbWFya2VyLWZpbGwtb3BhY2l0eSddICE9PSB1bmRlZmluZWQgfHwgc3RbJ21hcmtlci1vcGFjaXR5J10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdFsnbWFya2VyLWZpbGwtb3BhY2l0eSddIHx8IHN0WydtYXJrZXItb3BhY2l0eSddO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxSZWN0KC1waXhlbF9zaXplLCAtcGl4ZWxfc2l6ZSwgdywgdylcbiAgICB9XG5cbiAgICAvLyBzdHJva2VcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgaWYgKHN0WydtYXJrZXItbGluZS1jb2xvciddICYmIHN0WydtYXJrZXItbGluZS13aWR0aCddKSB7XG4gICAgICBpZiAoc3RbJ21hcmtlci1saW5lLW9wYWNpdHknXSkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdFsnbWFya2VyLWxpbmUtb3BhY2l0eSddO1xuICAgICAgfVxuICAgICAgaWYgKHN0WydtYXJrZXItbGluZS13aWR0aCddKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdFsnbWFya2VyLWxpbmUtd2lkdGgnXTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0WydtYXJrZXItbGluZS1jb2xvciddO1xuXG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGZvciBhbHBoYSA9IDBcbiAgICAgIGlmIChjdHguZ2xvYmFsQWxwaGEgPiAwKSB7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KC1waXhlbF9zaXplLCAtcGl4ZWxfc2l6ZSwgdywgdylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJTcHJpdGUoY3R4LCBpbWcsIHN0KSB7XG5cbiAgICBpZihpbWcuY29tcGxldGUpe1xuICAgICAgaWYgKHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gIT09IHVuZGVmaW5lZCB8fCBzdFsnbWFya2VyLW9wYWNpdHknXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gfHwgc3RbJ21hcmtlci1vcGFjaXR5J107XG4gICAgICB9XG4gICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgTWF0aC5taW4oaW1nLndpZHRoLCBNQVhfU1BSSVRFX1JBRElVUyksIE1hdGgubWluKGltZy5oZWlnaHQsIE1BWF9TUFJJVEVfUkFESVVTKSk7XG4gICAgfVxuICB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmRlclBvaW50OiByZW5kZXJQb2ludCxcbiAgICByZW5kZXJTcHJpdGU6IHJlbmRlclNwcml0ZSxcbiAgICByZW5kZXJSZWN0YW5nbGU6IHJlbmRlclJlY3RhbmdsZSxcbiAgICBNQVhfU1BSSVRFX1JBRElVUzogTUFYX1NQUklURV9SQURJVVNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjYXJ0b2NzczogcmVxdWlyZSgnLi9jYXJ0b2Nzc19yZW5kZXInKSxcbiAgICBQb2ludDogcmVxdWlyZSgnLi9wb2ludCcpLFxuICAgIFJlY3RhbmdsZTogcmVxdWlyZSgnLi9yZWN0YW5nbGUnKVxufTsiLCJ2YXIgdG9ycXVlID0gcmVxdWlyZSgnLi4vJyk7XG52YXIgY2FydG9jc3MgPSByZXF1aXJlKCcuL2NhcnRvY3NzX3JlbmRlcicpO1xudmFyIFByb2ZpbGVyID0gcmVxdWlyZSgnLi4vcHJvZmlsZXInKTtcbnZhciBjYXJ0byA9IGdsb2JhbC5jYXJ0byB8fCByZXF1aXJlKCdjYXJ0bycpO1xudmFyIEZpbHRlcnMgPSByZXF1aXJlKCcuL3RvcnF1ZV9maWx0ZXJzJyk7XG5cbiAgdmFyIFRBVSA9IE1hdGguUEkgKiAyO1xuICB2YXIgREVGQVVMVF9DQVJUT0NTUyA9IFtcbiAgICAnI2xheWVyIHsnLFxuICAgICcgIG1hcmtlci1maWxsOiAjNjYyNTA2OycsXG4gICAgJyAgbWFya2VyLXdpZHRoOiA0OycsXG4gICAgJyAgW3ZhbHVlID4gMV0geyBtYXJrZXItZmlsbDogI0ZFRTM5MTsgfScsXG4gICAgJyAgW3ZhbHVlID4gMl0geyBtYXJrZXItZmlsbDogI0ZFQzQ0RjsgfScsXG4gICAgJyAgW3ZhbHVlID4gM10geyBtYXJrZXItZmlsbDogI0ZFOTkyOTsgfScsXG4gICAgJyAgW3ZhbHVlID4gNF0geyBtYXJrZXItZmlsbDogI0VDNzAxNDsgfScsXG4gICAgJyAgW3ZhbHVlID4gNV0geyBtYXJrZXItZmlsbDogI0NDNEMwMjsgfScsXG4gICAgJyAgW3ZhbHVlID4gNl0geyBtYXJrZXItZmlsbDogIzk5MzQwNDsgfScsXG4gICAgJyAgW3ZhbHVlID4gN10geyBtYXJrZXItZmlsbDogIzY2MjUwNjsgfScsXG4gICAgJ30nXG4gIF0uam9pbignXFxuJyk7XG5cbiAgdmFyIENPTVBfT1BfVE9fQ0FOVkFTID0ge1xuICAgIFwic3JjXCI6ICdzb3VyY2Utb3ZlcicsXG4gICAgXCJzcmMtb3ZlclwiOiAnc291cmNlLW92ZXInLFxuICAgIFwiZHN0LW92ZXJcIjogJ2Rlc3RpbmF0aW9uLW92ZXInLFxuICAgIFwic3JjLWluXCI6ICdzb3VyY2UtaW4nLFxuICAgIFwiZHN0LWluXCI6ICdkZXN0aW5hdGlvbi1pbicsXG4gICAgXCJzcmMtb3V0XCI6ICdzb3VyY2Utb3V0JyxcbiAgICBcImRzdC1vdXRcIjogJ2Rlc3RpbmF0aW9uLW91dCcsXG4gICAgXCJzcmMtYXRvcFwiOiAnc291cmNlLWF0b3AnLFxuICAgIFwiZHN0LWF0b3BcIjogJ2Rlc3RpbmF0aW9uLWF0b3AnLFxuICAgIFwieG9yXCI6ICd4b3InLFxuICAgIFwiZGFya2VuXCI6ICdkYXJrZW4nLFxuICAgIFwibGlnaHRlblwiOiAnbGlnaHRlbicsXG4gICAgXCJzY3JlZW5cIjogXCJzY3JlZW5cIlxuICB9XG5cbiAgZnVuY3Rpb24gY29tcG9wMmNhbnZhcyhjb21wb3ApIHtcbiAgICByZXR1cm4gQ09NUF9PUF9UT19DQU5WQVNbY29tcG9wXSB8fCBjb21wb3A7XG4gIH1cblxuXG4gIC8vXG4gIC8vIHRoaXMgcmVuZGVyZXIganVzdCByZW5kZXIgcG9pbnRzIGRlcGVuZGluZyBvZiB0aGUgdmFsdWVcbiAgLy9cbiAgZnVuY3Rpb24gUG9pbnRSZW5kZXJlcihjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FudmFzIGNhbid0IGJlIHVuZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5fc3ByaXRlcyA9IFtdOyAvLyBzcHJpdGVzIHBlciBsYXllclxuICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG4gICAgdGhpcy5faWNvbnMgPSB7fTtcbiAgICB0aGlzLl9pY29uc1RvTG9hZCA9IDA7XG4gICAgdGhpcy5fZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuX2NhbnZhcywge2NhbnZhc0NsYXNzOiBvcHRpb25zLmNhbnZhc0NsYXNzfSk7XG4gICAgdGhpcy5zZXRDYXJ0b0NTUyh0aGlzLm9wdGlvbnMuY2FydG9jc3MgfHwgREVGQVVMVF9DQVJUT0NTUyk7XG4gICAgdGhpcy5USUxFX1NJWkUgPSAyNTY7XG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIHRoaXMuX2dyYWRpZW50cyA9IHt9O1xuXG4gICAgdGhpcy5fZm9yY2VQb2ludHMgPSBmYWxzZTtcbiAgfVxuXG4gIHRvcnF1ZS5leHRlbmQoUG9pbnRSZW5kZXJlci5wcm90b3R5cGUsIHRvcnF1ZS5FdmVudCwge1xuXG4gICAgY2xlYXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuX01hcFsnLXRvcnF1ZS1jbGVhci1jb2xvciddXG4gICAgICAvLyBzaG9ydGN1dCBmb3IgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgIGlmIChjb2xvciAgPT09IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKVwiIHx8ICFjb2xvcikge1xuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB2YXIgY29tcG9wID0gdGhpcy5fTWFwWydjb21wLW9wJ11cbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvcDJjYW52YXMoY29tcG9wKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0Q2FudmFzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvL1xuICAgIC8vIHNldHMgdGhlIGNhcnRvY3NzIHN0eWxlIHRvIHJlbmRlciBzdHVmZlxuICAgIC8vXG4gICAgc2V0Q2FydG9DU1M6IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gICAgICAvLyBjbGVhbiBzcHJpdGVzXG4gICAgICB0aGlzLnNldFNoYWRlcihuZXcgY2FydG8uUmVuZGVyZXJKUygpLnJlbmRlcihjYXJ0b2NzcykpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkZXI6IGZ1bmN0aW9uKHNoYWRlcikge1xuICAgICAgLy8gY2xlYW4gc3ByaXRlc1xuICAgICAgdGhpcy5fc3ByaXRlcyA9IFtdO1xuICAgICAgdGhpcy5fc2hhZGVyID0gc2hhZGVyO1xuICAgICAgdGhpcy5fTWFwID0gdGhpcy5fc2hhZGVyLmdldERlZmF1bHQoKS5nZXRTdHlsZSh7fSwgeyB6b29tOiAwIH0pO1xuICAgICAgdmFyIGltZ19uYW1lcyA9IHRoaXMuX3NoYWRlci5nZXRJbWFnZVVSTHMoKTtcbiAgICAgIHRoaXMuX3ByZWxvYWRJY29ucyhpbWdfbmFtZXMpO1xuICAgIH0sXG5cbiAgICBjbGVhclNwcml0ZUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3Nwcml0ZXMgPSBbXTtcbiAgICB9LFxuXG5cbiAgICAvL1xuICAgIC8vIGdlbmVyYXRlIHNwcml0ZSBiYXNlZCBvbiBjYXJ0b2NzcyBzdHlsZVxuICAgIC8vXG4gICAgZ2VuZXJhdGVTcHJpdGU6IGZ1bmN0aW9uKHNoYWRlciwgdmFsdWUsIHNoYWRlclZhcnMpIHtcbiAgICAgIHZhciBwcm9mID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucmVuZGVyZXIucG9pbnQuZ2VuZXJhdGVTcHJpdGUnKS5zdGFydCgpO1xuICAgICAgdmFyIHN0ID0gc2hhZGVyLmdldFN0eWxlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9LCBzaGFkZXJWYXJzKTtcblxuICAgICAgdmFyIHJldCA9IHRoaXMuZ2VuZXJhdGVTcHJpdGVGb3JTdHlsZShzdCk7XG4gICAgICBwcm9mLmVuZCh0cnVlKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlU3ByaXRlRm9yU3R5bGU6IGZ1bmN0aW9uKHN0KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmKHRoaXMuX3N0eWxlID09PSBudWxsIHx8IHRoaXMuX3N0eWxlICE9PSBzdCl7XG4gICAgICAgIHRoaXMuX3N0eWxlID0gc3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludFNpemUgPSBzdFsnbWFya2VyLXdpZHRoJ107XG4gICAgICBpZiAoIXBvaW50U2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0WydtYXJrZXItb3BhY2l0eSddID09PSAwICYmICFzdFsnbWFya2VyLWxpbmUtb3BhY2l0eSddKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKCk7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBtYXJrZXJGaWxlID0gc3RbXCJtYXJrZXItZmlsZVwiXSB8fCBzdFtcInBvaW50LWZpbGVcIl07XG4gICAgICB2YXIgcXVhbGlmaWVkVXJsID0gbWFya2VyRmlsZSAmJiB0aGlzLl9xdWFsaWZ5VVJMKG1hcmtlckZpbGUpO1xuXG4gICAgICBpZiAocXVhbGlmaWVkVXJsICYmIHRoaXMuX2ljb25zVG9Mb2FkIDw9IDAgJiYgdGhpcy5faWNvbnNbcXVhbGlmaWVkVXJsXSkge1xuICAgICAgICB2YXIgaW1nID0gdGhpcy5faWNvbnNbcXVhbGlmaWVkVXJsXTtcblxuICAgICAgICB2YXIgZFdpZHRoID0gIE1hdGgubWluKHN0WydtYXJrZXItd2lkdGgnXSAqIDIgfHwgaW1nLndpZHRoLCBjYXJ0b2Nzcy5NQVhfU1BSSVRFX1JBRElVUyAqIDIpO1xuICAgICAgICB2YXIgZEhlaWdodCA9IE1hdGgubWluKChzdFsnbWFya2VyLWhlaWdodCddIHx8IGRXaWR0aCkgKiAoaW1nLndpZHRoIC8gaW1nLmhlaWdodCksIGNhcnRvY3NzLk1BWF9TUFJJVEVfUkFESVVTICogMik7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gY3R4LndpZHRoID0gZFdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY3R4LmhlaWdodCA9IGRIZWlnaHQ7XG5cbiAgICAgICAgY3R4LnNjYWxlKGRXaWR0aC9pbWcud2lkdGgsIGRIZWlnaHQvaW1nLmhlaWdodCk7XG5cbiAgICAgICAgY2FydG9jc3MucmVuZGVyU3ByaXRlKGN0eCwgaW1nLCBzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCB0aGUgZXh0ZXJpb3IgcmluZyB0byBjYWxjdWxhdGUgdGhlIHNpemVcbiAgICAgICAgdmFyIGNhbnZhc1NpemUgPSAoc3RbJ21hcmtlci1saW5lLXdpZHRoJ10gfHwgMCkgKyBwb2ludFNpemUqMiArIDI7XG4gICAgICAgIGNhbnZhc1NpemUgPSBNYXRoLmNlaWwoY2FudmFzU2l6ZSk7XG4gICAgICAgIC8vIHRoZSBzcHJpdGUgc2hvdWxkIGJlIHBsYWNlZCBpbiB0aGUgY2VudGVyIG9mIGEgcGl4ZWwgbm90IGluIHRoZSBtaWRkbGUgc28gXG4gICAgICAgIC8vIG1ha2UgdGhlIGNhbnZhcyBzaXplIG9kZFxuICAgICAgICBjYW52YXNTaXplICs9IGNhbnZhc1NpemUgJSAyID09PSAwID8gMSA6IDA7XG4gICAgICAgIHZhciB3ID0gY3R4LndpZHRoID0gY2FudmFzLndpZHRoID0gY3R4LmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBjYW52YXNTaXplO1xuICAgICAgICB3ID0gTWF0aC5mbG9vcih3LzIpICsgMTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3LCB3KTtcblxuICAgICAgICB2YXIgbXQgPSBzdFsnbWFya2VyLXR5cGUnXTtcbiAgICAgICAgaWYgKG10ICYmIG10ID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgIGNhcnRvY3NzLnJlbmRlclJlY3RhbmdsZShjdHgsIHN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJ0b2Nzcy5yZW5kZXJQb2ludChjdHgsIHN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRvcnF1ZS5mbGFncy5zcHJpdGVzX3RvX2ltYWdlcykge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2NyZWF0ZUltYWdlKCk7XG4gICAgICAgIGkuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuXG4gICAgLy9cbiAgICAvLyByZW5kZXJzIGFsbCB0aGUgbGF5ZXJzIChhbmQgZnJhbWVzIGZvciBlYWNoIGxheWVyKSBmcm9tIGNhcnRvY3NzXG4gICAgLy9cbiAgICByZW5kZXJUaWxlOiBmdW5jdGlvbih0aWxlLCBrZXksIHJlbmRlckZsYWdzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuX2ljb25zVG9Mb2FkID4gMCkge1xuICAgICAgICAgIHRoaXMub24oJ2FsbEljb25zTG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZS5hcHBseSh0aGlzLCBbdGlsZSwga2V5LCBjYWxsYmFja10pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9mID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucmVuZGVyZXIucG9pbnQucmVuZGVyTGF5ZXJzJykuc3RhcnQoKTtcbiAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9zaGFkZXIuZ2V0TGF5ZXJzKCk7XG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IG47ICsraSApIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICBpZiAobGF5ZXIubmFtZSgpICE9PSBcIk1hcFwiKSB7XG4gICAgICAgICAgdmFyIHNwcml0ZXMgPSB0aGlzLl9zcHJpdGVzW2ldIHx8ICh0aGlzLl9zcHJpdGVzW2ldID0ge30pO1xuICAgICAgICAgIC8vIGZyYW1lcyBmb3IgZWFjaCBsYXllclxuICAgICAgICAgIGZvcih2YXIgZnIgPSAwOyBmciA8IGxheWVyLmZyYW1lcygpLmxlbmd0aDsgKytmcikge1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gbGF5ZXIuZnJhbWVzKClbZnJdO1xuICAgICAgICAgICAgdmFyIGZyX3Nwcml0ZXMgPSBzcHJpdGVzW2ZyYW1lXSB8fCAoc3ByaXRlc1tmcmFtZV0gPSBbXSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUaWxlKHRpbGUsIGtleSAtIGZyYW1lLCBmcmFtZSwgZnJfc3ByaXRlcywgbGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9mLmVuZCh0cnVlKTtcblxuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2FudmFzQ2xhc3NcbiAgICAgICAgPyBuZXcgdGhpcy5vcHRpb25zLmNhbnZhc0NsYXNzKClcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW1hZ2VDbGFzc1xuICAgICAgICA/IG5ldyB0aGlzLm9wdGlvbnMuaW1hZ2VDbGFzcygpXG4gICAgICAgIDogbmV3IEltYWdlKCk7XG4gICAgfSxcblxuICAgIF9zZXRJbWFnZVNyYzogZnVuY3Rpb24oaW1nLCB1cmwsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNldEltYWdlU3JjKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zZXRJbWFnZVNyYyhpbWcsIHVybCwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCBpbWFnZScpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3F1YWxpZnlVUkw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucXVhbGlmeVVSTCAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucXVhbGlmeVVSTCh1cmwpO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgcmV0dXJuIGEuaHJlZjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9cbiAgICAvLyByZW5kZXJzIGEgdGlsZSBpbiB0aGUgY2FudmFzIGZvciBrZXkgZGVmaW5lZCBpblxuICAgIC8vIHRoZSB0b3JxdWUgdGlsZVxuICAgIC8vXG4gICAgX3JlbmRlclRpbGU6IGZ1bmN0aW9uKHRpbGUsIGtleSwgZnJhbWVfb2Zmc2V0LCBzcHJpdGVzLCBzaGFkZXIsIHNoYWRlclZhcnMpIHtcbiAgICAgIGlmICghdGhpcy5fY2FudmFzKSByZXR1cm47XG4gICAgICB2YXIgcHJvZiA9IFByb2ZpbGVyLm1ldHJpYygndG9ycXVlLnJlbmRlcmVyLnBvaW50LnJlbmRlclRpbGUnKS5zdGFydCgpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgIHZhciBibGVuZE1vZGUgPSBjb21wb3AyY2FudmFzKHNoYWRlci5ldmFsKCdjb21wLW9wJykpIHx8IHRoaXMub3B0aW9ucy5ibGVuZG1vZGU7XG4gICAgICBpZiAoYmxlbmRNb2RlKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgJiYga2V5ID4gdGlsZS5tYXhEYXRlKSB7XG4gICAgICAgIC8vVE9ETzogcHJlY2FjaGUgYmVjYXVzZSB0aGlzIHRpbGUgaXMgbm90IGdvaW5nIHRvIGNoYW5nZVxuICAgICAgICBrZXkgPSB0aWxlLm1heERhdGU7XG4gICAgICB9XG4gICAgICB2YXIgdGlsZU1heCA9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uICogKHRoaXMuVElMRV9TSVpFL3RoaXMub3B0aW9ucy5yZXNvbHV0aW9uIC0gMSlcbiAgICAgIHZhciBhY3RpdmVQaXhlbHMgPSB0aWxlLngubGVuZ3RoO1xuICAgICAgdmFyIGFuY2hvciA9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uLzI7XG4gICAgICBpZiAoYWN0aXZlUGl4ZWxzKSB7XG4gICAgICAgIHZhciBwaXhlbEluZGV4ID0gdGlsZS50aW1lSW5kZXhba2V5XTtcbiAgICAgICAgZm9yKHZhciBwID0gMDsgcCA8IGFjdGl2ZVBpeGVsczsgKytwKSB7XG4gICAgICAgICAgICB2YXIgcG9zSWR4ID0gdGlsZS5yZW5kZXJEYXRhUG9zW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgICAgIHZhciBjID0gdGlsZS5yZW5kZXJEYXRhW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgICAgIHZhciBzcCA9IHNwcml0ZXNbY107XG4gICAgICAgICAgICBpZiAoc3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgc3AgPSBzcHJpdGVzW2NdID0gdGhpcy5nZW5lcmF0ZVNwcml0ZShzaGFkZXIsIGMsIHRvcnF1ZS5leHRlbmQoeyB6b29tOiB0aWxlLnosICdmcmFtZS1vZmZzZXQnOiBmcmFtZV9vZmZzZXQgfSwgc2hhZGVyVmFycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwKSB7XG4gICAgICAgICAgICAgICB2YXIgeCA9IHRpbGUueFtwb3NJZHhdLSAoc3Aud2lkdGggPj4gMSkgKyBhbmNob3I7XG4gICAgICAgICAgICAgICB2YXIgeSA9IHRpbGVNYXggLSB0aWxlLnlbcG9zSWR4XSArIGFuY2hvcjsgLy8gZmxpcCBtZXJjYXRvclxuICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShzcCwgeCwgeSAtIChzcC5oZWlnaHQgPj4gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgcHJvZi5lbmQodHJ1ZSk7XG4gICAgfSxcblxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24oYikge1xuICAgICAgdGhpcy5vcHRpb25zLmJsZW5kbW9kZSA9IGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhY3RpdmUgcG9pbnRzIGZvciBhIHN0ZXAgaW4gYWN0aXZlIHpvb21cbiAgICAgKiByZXR1cm5zIGEgbGlzdCBvZiBib3VuZGluZyBib3hlcyBbW3N3LCBuZV0gLCBbXSwgW11dIHdoZXJlIG5lIGlzIGEge2xhdDogLi4sIGxvbjogLi4ufSBvYmpcbiAgICAgKiBlbXB0eSBsaXN0IGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBwaXhlbHNcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVQb2ludHNCQm94OiBmdW5jdGlvbih0aWxlLCBzdGVwKSB7XG4gICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICB2YXIgbWVyY2F0b3IgPSBuZXcgdG9ycXVlLk1lcmNhdG9yKCk7XG5cbiAgICAgIHZhciB0aWxlTWF4ID0gdGhpcy5vcHRpb25zLnJlc29sdXRpb24gKiAodGhpcy5USUxFX1NJWkUvdGhpcy5vcHRpb25zLnJlc29sdXRpb24gLSAxKTtcbiAgICAgIC8vdGhpcy5yZW5kZXJlci5yZW5kZXJUaWxlKHRpbGUsIHRoaXMua2V5LCBwb3MueCwgcG9zLnkpO1xuICAgICAgdmFyIGFjdGl2ZVBpeGVscyA9IHRpbGUudGltZUNvdW50W3N0ZXBdO1xuICAgICAgdmFyIHBpeGVsSW5kZXggPSB0aWxlLnRpbWVJbmRleFtzdGVwXTtcbiAgICAgIGZvcih2YXIgcCA9IDA7IHAgPCBhY3RpdmVQaXhlbHM7ICsrcCkge1xuICAgICAgICB2YXIgcG9zSWR4ID0gdGlsZS5yZW5kZXJEYXRhUG9zW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgdmFyIGMgPSB0aWxlLnJlbmRlckRhdGFbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgdmFyIHggPSB0aWxlLnhbcG9zSWR4XTtcbiAgICAgICAgIHZhciB5ID0gdGlsZU1heCAtIHRpbGUueVtwb3NJZHhdOyAvLyBmbGlwIG1lcmNhdG9yXG4gICAgICAgICBwb3NpdGlvbnMucHVzaChtZXJjYXRvci50aWxlUGl4ZWxCQm94KFxuICAgICAgICAgICB0aWxlLmNvb3JkLngsXG4gICAgICAgICAgIHRpbGUuY29vcmQueSxcbiAgICAgICAgICAgdGlsZS5jb29yZC56LFxuICAgICAgICAgICB4LCB5XG4gICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgYWN0aXZlIHBpeGVsc1xuICAgICAqIEB0aWxlIHRpbGUgb2JqZWN0XG4gICAgICogQHN0ZXAgaW50ZWdlciB3aXRoIHRoZSBzdGVwXG4gICAgICogQHZhbHVlcyAob3B0aW9uYWwpIGFuIGFycmF5IHdoZXJlIHRoZSB2YWx1ZXMgd2lsbCBiZSBwbGFjZWRcbiAgICAgKi9cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKHRpbGUsIHN0ZXAsIHZhbHVlcykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtdO1xuICAgICAgdmFyIGFjdGl2ZVBpeGVscyA9IHRpbGUudGltZUNvdW50W3N0ZXBdO1xuICAgICAgdmFyIHBpeGVsSW5kZXggPSB0aWxlLnRpbWVJbmRleFtzdGVwXTtcbiAgICAgIGZvcih2YXIgcCA9IDA7IHAgPCBhY3RpdmVQaXhlbHM7ICsrcCkge1xuICAgICAgICB2YXIgcG9zSWR4ID0gdGlsZS5yZW5kZXJEYXRhUG9zW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgdmFsdWVzLnB1c2godGlsZS5yZW5kZXJEYXRhW3BpeGVsSW5kZXggKyBwXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIHZhbHVlIGZvciB4LCB5ICh0aWxlIGNvb3JkaW5hdGVzKVxuICAgIC8vIG51bGwgZm9yIG5vIHZhbHVlXG4gICAgZ2V0VmFsdWVGb3I6IGZ1bmN0aW9uKHRpbGUsIHN0ZXAsIHB4LCBweSkge1xuICAgICAgdmFyIG1lcmNhdG9yID0gbmV3IHRvcnF1ZS5NZXJjYXRvcigpO1xuICAgICAgdmFyIHJlcyA9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgdmFyIHJlczIgPSByZXMgPj4gMTtcblxuICAgICAgdmFyIHRpbGVNYXggPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAqICh0aGlzLlRJTEVfU0laRS90aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAtIDEpO1xuICAgICAgLy90aGlzLnJlbmRlcmVyLnJlbmRlclRpbGUodGlsZSwgdGhpcy5rZXksIHBvcy54LCBwb3MueSk7XG4gICAgICB2YXIgYWN0aXZlUGl4ZWxzID0gdGlsZS50aW1lQ291bnRbc3RlcF07XG4gICAgICB2YXIgcGl4ZWxJbmRleCA9IHRpbGUudGltZUluZGV4W3N0ZXBdO1xuICAgICAgZm9yKHZhciBwID0gMDsgcCA8IGFjdGl2ZVBpeGVsczsgKytwKSB7XG4gICAgICAgIHZhciBwb3NJZHggPSB0aWxlLnJlbmRlckRhdGFQb3NbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICB2YXIgYyA9IHRpbGUucmVuZGVyRGF0YVtwaXhlbEluZGV4ICsgcF07XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICB2YXIgeCA9IHRpbGUueFtwb3NJZHhdO1xuICAgICAgICAgdmFyIHkgPSB0aWxlTWF4IC0gdGlsZS55W3Bvc0lkeF07XG4gICAgICAgICB2YXIgZHggPSBweCArIHJlczIgLSB4O1xuICAgICAgICAgdmFyIGR5ID0gcHkgKyByZXMyIC0geTtcbiAgICAgICAgIGlmIChkeCA+PSAwICYmIGR4IDwgcmVzICYmIGR5ID49IDAgJiYgZHkgPCByZXMpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICB2YWx1ZTogYyxcbiAgICAgICAgICAgICBiYm94OiBtZXJjYXRvci50aWxlUGl4ZWxCQm94KFxuICAgICAgICAgICAgICAgdGlsZS5jb29yZC54LFxuICAgICAgICAgICAgICAgdGlsZS5jb29yZC55LFxuICAgICAgICAgICAgICAgdGlsZS5jb29yZC56LFxuICAgICAgICAgICAgICAgeCAtIHJlczIsIHkgLSByZXMyLCByZXNcbiAgICAgICAgICAgICApXG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9wcmVsb2FkSWNvbnM6IGZ1bmN0aW9uKGltZ19uYW1lcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoaW1nX25hbWVzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2ZvcmNlUG9pbnRzKSB7XG5cbiAgICAgICAgdmFyIHF1YWxpZmllZEltYWdlVXJsU2V0ID0gT2JqZWN0LmtleXMoaW1nX25hbWVzLnJlZHVjZShmdW5jdGlvbihpbWdOYW1lc01hcCwgaW1nTmFtZSkge1xuICAgICAgICAgICAgdmFyIHF1YWxpZmllZFVybCA9IHNlbGYuX3F1YWxpZnlVUkwoaW1nTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX2ljb25zW3F1YWxpZmllZFVybF0pIHtcbiAgICAgICAgICAgICAgICBpbWdOYW1lc01hcFtxdWFsaWZpZWRVcmxdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbWdOYW1lc01hcDtcbiAgICAgICAgfSwge30pKTtcblxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBzZWxmLl9zaGFkZXIuZ2V0TGF5ZXJzKCkuc29tZShmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbGF5ZXIuc2hhZGVyW1wiaW1hZ2UtZmlsdGVyc1wiXSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5faWNvbnNUb0xvYWQgKz0gcXVhbGlmaWVkSW1hZ2VVcmxTZXQubGVuZ3RoO1xuXG4gICAgICAgIHF1YWxpZmllZEltYWdlVXJsU2V0LmZvckVhY2goZnVuY3Rpb24ocXVhbGlmaWVkSW1hZ2VVcmwpIHtcbiAgICAgICAgICBzZWxmLl9pY29uc1txdWFsaWZpZWRJbWFnZVVybF0gPSBudWxsO1xuXG4gICAgICAgICAgdmFyIGltZyA9IHNlbGYuX2NyZWF0ZUltYWdlKCk7XG5cbiAgICAgICAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX3NldEltYWdlU3JjKGltZywgcXVhbGlmaWVkSW1hZ2VVcmwsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBzZWxmLl9mb3JjZVBvaW50cyA9IHRydWU7XG4gICAgICAgICAgICAgIHNlbGYuY2xlYXJTcHJpdGVDYWNoZSgpO1xuICAgICAgICAgICAgICBzZWxmLl9pY29uc1RvTG9hZCA9IDA7XG4gICAgICAgICAgICAgIHNlbGYuZmlyZShcImFsbEljb25zTG9hZGVkXCIpO1xuICAgICAgICAgICAgICBpZihmaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIk9ubHkgQ09SUy1lbmFibGVkLCBvciBzYW1lIGRvbWFpbiBpbWFnZS1maWxlcyBjYW4gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGltYWdlLWZpbHRlcnNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IGdldCBtYXJrZXItZmlsZSBcIiArIHF1YWxpZmllZEltYWdlVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYuX2ljb25zW3F1YWxpZmllZEltYWdlVXJsXSA9IGltZztcbiAgICAgICAgICAgICAgc2VsZi5faWNvbnNUb0xvYWQtLTtcblxuICAgICAgICAgICAgICBpZiAoc2VsZi5faWNvbnNUb0xvYWQgPD0gMCl7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhclNwcml0ZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKFwiYWxsSWNvbnNMb2FkZWRcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmlyZShcImFsbEljb25zTG9hZGVkXCIpO1xuICAgICAgfVxuICB9LFxuXG4gIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLl9zdHlsZSl7XG4gICAgICBpZih0aGlzLl9zdHlsZVsnaW1hZ2UtZmlsdGVycyddKXtcbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRLZXkoaW1mKXtcbiAgICAgICAgICB2YXIgaGFzaCA9IFwiXCJcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW1mLmFyZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHJnYiA9IGltZi5hcmdzW2ldLnJnYjtcbiAgICAgICAgICAgIGhhc2ggKz0gcmdiWzBdICsgXCI6XCIgKyByZ2JbMV0gKyBcIjpcIiArIHJnYlsyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyYWRpZW50ID0gdGhpcy5fZ3JhZGllbnRzW2dyYWRpZW50S2V5KHRoaXMuX3N0eWxlWydpbWFnZS1maWx0ZXJzJ10pXTtcbiAgICAgICAgaWYoIWdyYWRpZW50KXtcbiAgICAgICAgICBmdW5jdGlvbiBjb21wb25lbnRUb0hleChjKSB7XG4gICAgICAgICAgICB2YXIgaGV4ID0gYy50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmdiVG9IZXgociwgZywgYikge1xuICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgY29tcG9uZW50VG9IZXgocikgKyBjb21wb25lbnRUb0hleChnKSArIGNvbXBvbmVudFRvSGV4KGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncmFkaWVudCA9IHt9O1xuICAgICAgICAgIHZhciBjb2xvcml6ZSA9IHRoaXMuX3N0eWxlWydpbWFnZS1maWx0ZXJzJ10uYXJncztcblxuICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSAxL2NvbG9yaXplLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yaXplLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBrZXkgPSBpbmNyZW1lbnQgKiBpICsgaW5jcmVtZW50O1xuICAgICAgICAgICAgdmFyIHJnYiA9IGNvbG9yaXplW2ldLnJnYjtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRDb2xvciA9IHJnYlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgICAgICAgICAgZ3JhZGllbnRba2V5XSA9IGZvcm1hdHRlZENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9ncmFkaWVudHNbZ3JhZGllbnRLZXkodGhpcy5fc3R5bGVbJ2ltYWdlLWZpbHRlcnMnXSldID0gZ3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlsdGVycy5ncmFkaWVudChncmFkaWVudCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuZHJhdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cblBvaW50UmVuZGVyZXIuQ09NUF9PUF9UT19DQU5WQVMgPSBDT01QX09QX1RPX0NBTlZBUztcblxuXG4gIC8vIGV4cG9ydHMgcHVibGljIGFwaVxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFJlbmRlcmVyO1xuIiwidmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4uLycpO1xudmFyIGNhcnRvY3NzID0gcmVxdWlyZSgnLi9jYXJ0b2Nzc19yZW5kZXInKTtcbnZhciBQcm9maWxlciA9IHJlcXVpcmUoJy4uL3Byb2ZpbGVyJyk7XG52YXIgY2FydG8gPSBnbG9iYWwuY2FydG8gfHwgcmVxdWlyZSgnY2FydG8nKTtcbnZhciBGaWx0ZXJzID0gcmVxdWlyZSgnLi90b3JxdWVfZmlsdGVycycpO1xudmFyIFBvaW50UmVuZGVyZXIgPSByZXF1aXJlKCcuL3BvaW50JylcblxudmFyIFBpeGVsUmVuZGVyZXIgPSBmdW5jdGlvbihjYW52YXMsIG9wdGlvbnMpIHtcbiAgUG9pbnRSZW5kZXJlci5jYWxsKHRoaXMsIGNhbnZhcywgb3B0aW9ucyk7XG59XG5cbnRvcnF1ZS5leHRlbmQoUGl4ZWxSZW5kZXJlci5wcm90b3R5cGUsIFBvaW50UmVuZGVyZXIucHJvdG90eXBlLCB7XG5cbiAgICBnZW5lcmF0ZVNwcml0ZTogZnVuY3Rpb24oc2hhZGVyLCB2YWx1ZSwgc2hhZGVyVmFycykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHByb2YgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5yZW5kZXJlci5wb2ludC5nZW5lcmF0ZVNwcml0ZScpLnN0YXJ0KCk7XG4gICAgICB2YXIgc3QgPSBzaGFkZXIuZ2V0U3R5bGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0sIHNoYWRlclZhcnMpO1xuICAgICAgaWYodGhpcy5fc3R5bGUgPT09IG51bGwgfHwgdGhpcy5fc3R5bGUgIT09IHN0KXtcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHN0WydtYXJrZXItd2lkdGgnXSxcbiAgICAgICAgY29sb3I6IHN0WydtYXJrZXItZmlsbCddLFxuICAgICAgICBmaWxsX29wYWNpdHk6IHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gPT09IHVuZGVmaW5lZCA/IDEuMDogc3RbJ21hcmtlci1maWxsLW9wYWNpdHknXVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVuZGVyVGlsZTogZnVuY3Rpb24odGlsZSwga2V5LCBmcmFtZV9vZmZzZXQsIHNwcml0ZXMsIHNoYWRlciwgc2hhZGVyVmFycykge1xuICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHJldHVybjtcbiAgICAgIHZhciBwcm9mID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucmVuZGVyZXIucG9pbnQucmVuZGVyVGlsZScpLnN0YXJ0KCk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlICYmIGtleSA+IHRpbGUubWF4RGF0ZSkge1xuICAgICAgICAvL1RPRE86IHByZWNhY2hlIGJlY2F1c2UgdGhpcyB0aWxlIGlzIG5vdCBnb2luZyB0byBjaGFuZ2VcbiAgICAgICAga2V5ID0gdGlsZS5tYXhEYXRlO1xuICAgICAgfVxuICAgICAgdmFyIHRpbGVNYXggPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAqICh0aGlzLlRJTEVfU0laRS90aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAtIDEpXG4gICAgICB2YXIgYWN0aXZlUGl4ZWxzID0gdGlsZS54Lmxlbmd0aDtcbiAgICAgIHZhciBhbmNob3IgPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbi8yO1xuICAgICAgaWYgKGFjdGl2ZVBpeGVscykge1xuICAgICAgICB2YXIgcGl4ZWxJbmRleCA9IHRpbGUudGltZUluZGV4W2tleV07XG4gICAgICAgIGZvcih2YXIgcCA9IDA7IHAgPCBhY3RpdmVQaXhlbHM7ICsrcCkge1xuICAgICAgICAgICAgdmFyIHBvc0lkeCA9IHRpbGUucmVuZGVyRGF0YVBvc1twaXhlbEluZGV4ICsgcF07XG4gICAgICAgICAgICB2YXIgYyA9IHRpbGUucmVuZGVyRGF0YVtwaXhlbEluZGV4ICsgcF07XG4gICAgICAgICAgICB2YXIgc3AgPSBzcHJpdGVzW2NdO1xuICAgICAgICAgICAgaWYgKHNwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgIHNwID0gc3ByaXRlc1tjXSA9IHRoaXMuZ2VuZXJhdGVTcHJpdGUoc2hhZGVyLCBjLCB0b3JxdWUuZXh0ZW5kKHsgem9vbTogdGlsZS56LCAnZnJhbWUtb2Zmc2V0JzogZnJhbWVfb2Zmc2V0IH0sIHNoYWRlclZhcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcCkge1xuICAgICAgICAgICAgICB2YXIgeCA9IHRpbGUueFtwb3NJZHhdLSAoc3Aud2lkdGggPj4gMSkgKyBhbmNob3I7XG4gICAgICAgICAgICAgIHZhciB5ID0gdGlsZU1heCAtIHRpbGUueVtwb3NJZHhdICsgYW5jaG9yOyAvLyBmbGlwIG1lcmNhdG9yXG4gICAgICAgICAgICAgIGlmIChzcC5maWxsX29wYWNpdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3AuZmlsbF9vcGFjaXR5XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNwLmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBzcC53aWR0aCwgc3Aud2lkdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaXhlbFJlbmRlcmVyO1xuIiwiLypcbiBCYXNlZCBvbiBzaW1wbGVoZWF0LCBhIHRpbnkgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBkcmF3aW5nIGhlYXRtYXBzIHdpdGggQ2FudmFzLCBcbiBieSBWbGFkaW1pciBBZ2Fmb25raW5cbiBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9zaW1wbGVoZWF0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHRvcnF1ZV9maWx0ZXJzKGNhbnZhcywgb3B0aW9ucykge1xuICAgIC8vIGpzaGludCBuZXdjYXA6IGZhbHNlLCB2YWxpZHRoaXM6IHRydWVcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgdG9ycXVlX2ZpbHRlcnMpKSB7IHJldHVybiBuZXcgdG9ycXVlX2ZpbHRlcnMoY2FudmFzLCBvcHRpb25zKTsgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXMgPSB0eXBlb2YgY2FudmFzID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykgOiBjYW52YXM7XG5cbiAgICB0aGlzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLl93aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgdGhpcy5fbWF4ID0gMTtcbiAgICB0aGlzLl9kYXRhID0gW107XG5cbiAgICB0aGlzLmNhbnZhc0NsYXNzID0gb3B0aW9ucy5jYW52YXNDbGFzcztcbn1cblxudG9ycXVlX2ZpbHRlcnMucHJvdG90eXBlID0ge1xuXG4gICAgZGVmYXVsdEdyYWRpZW50OiB7XG4gICAgICAgIDAuNDogJ2JsdWUnLFxuICAgICAgICAwLjY6ICdjeWFuJyxcbiAgICAgICAgMC43OiAnbGltZScsXG4gICAgICAgIDAuODogJ3llbGxvdycsXG4gICAgICAgIDEuMDogJ3JlZCdcbiAgICB9LFxuXG4gICAgZ3JhZGllbnQ6IGZ1bmN0aW9uIChncmFkKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIDI1NngxIGdyYWRpZW50IHRoYXQgd2UnbGwgdXNlIHRvIHR1cm4gYSBncmF5c2NhbGUgaGVhdG1hcCBpbnRvIGEgY29sb3JlZCBvbmVcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcygpLFxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAyNTYpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBncmFkKSB7XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoK2ksIGdyYWRbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMjU2KTtcblxuICAgICAgICB0aGlzLl9ncmFkID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAyNTYpLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ncmFkKSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50KHRoaXMuZGVmYXVsdEdyYWRpZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHZhciBjb2xvcmVkID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLl9jb2xvcml6ZShjb2xvcmVkLmRhdGEsIHRoaXMuX2dyYWQpO1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNvbG9yZWQsIDAsIDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfY29sb3JpemU6IGZ1bmN0aW9uIChwaXhlbHMsIGdyYWRpZW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAzLCBsZW4gPSBwaXhlbHMubGVuZ3RoLCBqOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGogPSBwaXhlbHNbaV0gKiA0OyAvLyBnZXQgZ3JhZGllbnQgY29sb3IgZnJvbSBvcGFjaXR5IHZhbHVlXG5cbiAgICAgICAgICAgIGlmIChqKSB7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW2kgLSAzXSA9IGdyYWRpZW50W2pdO1xuICAgICAgICAgICAgICAgIHBpeGVsc1tpIC0gMl0gPSBncmFkaWVudFtqICsgMV07XG4gICAgICAgICAgICAgICAgcGl4ZWxzW2kgLSAxXSA9IGdyYWRpZW50W2ogKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY3JlYXRlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzQ2xhc3NcbiAgICAgICAgICAgID8gbmV3IHRoaXMuY2FudmFzQ2xhc3MoKVxuICAgICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvcnF1ZV9maWx0ZXJzO1xuIiwidmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4gIHZhciBsYXN0Q2FsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24ganNvbnAodXJsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQgPyAxMDAwMDogb3B0aW9ucy50aW1lb3V0O1xuICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAvLyBmdW5jdGlvbiBuYW1lXG4gICAgIHZhciBmbk5hbWUgPSBvcHRpb25zLmNhbGxiYWNrTmFtZSB8fCAndG9ycXVlXycgKyBEYXRlLm5vdygpO1xuXG4gICAgIGlmICh0b3JxdWUuaXNGdW5jdGlvbihmbk5hbWUpKSB7XG4gICAgICAgZm5OYW1lID0gZm5OYW1lKCk7XG4gICAgIH1cblxuICAgICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XG4gICAgICAgZGVsZXRlIHdpbmRvd1tmbk5hbWVdO1xuICAgICB9XG5cbiAgICAgd2luZG93W2ZuTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICBjbGVhbigpO1xuICAgICAgIGNhbGxiYWNrLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcbiAgICAgfTtcblxuICAgICAvLyB0aW1lb3V0IGZvciBlcnJvcnNcbiAgICAgdmFyIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IFxuICAgICAgIGNsZWFuKCk7XG4gICAgICAgY2FsbGJhY2suY2FsbCh3aW5kb3csIG51bGwpOyBcbiAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcblxuICAgICAvLyBzZXR1cCB1cmxcbiAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ2NhbGxiYWNrPVxcPycsICdjYWxsYmFjaz0nICsgZm5OYW1lKTtcbiAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgLy8gZGVmZXIgdGhlIGxvYWRpbmcgYmVjYXVzZSBJRTkgbG9hZHMgaW4gdGhlIHNhbWUgZnJhbWUgdGhlIHNjcmlwdFxuICAgICAvLyBzbyBMb2FkZXIuX3NjcmlwdCBpcyBudWxsXG4gICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTsgfSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQodXJsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCdcbiAgICB9O1xuICAgIGxhc3RDYWxsID0geyB1cmw6IHVybCwgY2FsbGJhY2s6IGNhbGxiYWNrIH07XG4gICAgdmFyIHJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcbiAgICAvLyBmcm9tIGQzLmpzXG4gICAgaWYgKGdsb2JhbC5YRG9tYWluUmVxdWVzdFxuICAgICAgICAmJiAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdClcbiAgICAgICAgJiYgL14oaHR0cChzKT86KT9cXC9cXC8vLnRlc3QodXJsKSkgcmVxdWVzdCA9IFhEb21haW5SZXF1ZXN0O1xuXG4gICAgdmFyIHJlcSA9IG5ldyByZXF1ZXN0KCk7XG4gICAgcmVxLm9wZW4ob3B0aW9ucy5tZXRob2QsIHVybCwgdHJ1ZSk7XG5cblxuICAgIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgICB2YXIgc3RhdHVzID0gcmVxLnN0YXR1cywgcmVzdWx0O1xuICAgICAgdmFyIHIgPSBvcHRpb25zLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJyA/IHJlcS5yZXNwb25zZTogcmVxLnJlc3BvbnNlVGV4dDtcbiAgICAgIGlmICghc3RhdHVzICYmIHIgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgY2FsbGJhY2socmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFwib25sb2FkXCIgaW4gcmVxXG4gICAgICA/IHJlcS5vbmxvYWQgPSByZXEub25lcnJvciA9IHJlc3BvbmRcbiAgICAgIDogcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgeyByZXEucmVhZHlTdGF0ZSA+IDMgJiYgcmVzcG9uZCgpOyB9O1xuXG4gICAgcmVxLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgcmVxLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlOyAvLydhcnJheWJ1ZmZlcic7XG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgLy9yZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKVxuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCIqXCIpO1xuICAgIH1cbiAgICByZXEuc2VuZChvcHRpb25zLmRhdGEpO1xuICAgIHJldHVybiByZXE7XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0KHVybCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZ2V0KHVybCwgY2FsbGJhY2ssIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgfSk7XG4gIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0OiBnZXQsXG4gICAgcG9zdDogcG9zdCxcbiAgICBqc29ucDoganNvbnAsXG4gICAgbGFzdENhbGw6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFzdENhbGw7IH1cbn07XG4iLCIoZnVuY3Rpb24gKHRyZWUpIHtcblxudHJlZS5mdW5jdGlvbnMgPSB7XG4gICAgcmdiOiBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2JhKHIsIGcsIGIsIDEuMCk7XG4gICAgfSxcbiAgICByZ2JhOiBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgICAgICB2YXIgcmdiID0gW3IsIGcsIGJdLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbnVtYmVyKGMpOyB9KTtcbiAgICAgICAgYSA9IG51bWJlcihhKTtcbiAgICAgICAgaWYgKHJnYi5zb21lKGlzTmFOKSB8fCBpc05hTihhKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcihyZ2IsIGEpO1xuICAgIH0sXG4gICAgLy8gT25seSByZXF1aXJlIHZhbFxuICAgIHN0b3A6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGNvbG9yLCBtb2RlO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGNvbG9yID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIG1vZGUgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzOiAndGFnJyxcbiAgICAgICAgICAgIHZhbDogdmFsLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcblxcdDxzdG9wIHZhbHVlPVwiJyArIHZhbC5ldihlbnYpICsgJ1wiJyArXG4gICAgICAgICAgICAgICAgICAgIChjb2xvciA/ICcgY29sb3I9XCInICsgY29sb3IuZXYoZW52KSArICdcIiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKG1vZGUgPyAnIG1vZGU9XCInICsgbW9kZS5ldihlbnYpICsgJ1wiICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaHNsOiBmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oc2xhKGgsIHMsIGwsIDEuMCk7XG4gICAgfSxcbiAgICBoc2xhOiBmdW5jdGlvbiAoaCwgcywgbCwgYSkge1xuICAgICAgICBoID0gKG51bWJlcihoKSAlIDM2MCkgLyAzNjA7XG4gICAgICAgIHMgPSBudW1iZXIocyk7IGwgPSBudW1iZXIobCk7IGEgPSBudW1iZXIoYSk7XG4gICAgICAgIGlmIChbaCwgcywgbCwgYV0uc29tZShpc05hTikpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzLFxuICAgICAgICAgICAgbTEgPSBsICogMiAtIG0yO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJnYmEoaHVlKGggKyAxLzMpICogMjU1LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGh1ZShoKSAgICAgICAqIDI1NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBodWUoaCAtIDEvMykgKiAyNTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaHVlKGgpIHtcbiAgICAgICAgICAgIGggPSBoIDwgMCA/IGggKyAxIDogKGggPiAxID8gaCAtIDEgOiBoKTtcbiAgICAgICAgICAgIGlmICAgICAgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgICAgICBlbHNlIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgcmV0dXJuIG0xO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBodWU6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24oTWF0aC5yb3VuZChjb2xvci50b0hTTCgpLmgpKTtcbiAgICB9LFxuICAgIHNhdHVyYXRpb246IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24oTWF0aC5yb3VuZChjb2xvci50b0hTTCgpLnMgKiAxMDApLCAnJScpO1xuICAgIH0sXG4gICAgbGlnaHRuZXNzOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGltZW5zaW9uKE1hdGgucm91bmQoY29sb3IudG9IU0woKS5sICogMTAwKSwgJyUnKTtcbiAgICB9LFxuICAgIGFscGhhOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGltZW5zaW9uKGNvbG9yLnRvSFNMKCkuYSk7XG4gICAgfSxcbiAgICBzYXR1cmF0ZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wucyArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5zID0gY2xhbXAoaHNsLnMpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wucyAtPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5zID0gY2xhbXAoaHNsLnMpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgbGlnaHRlbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wubCArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5sID0gY2xhbXAoaHNsLmwpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZGFya2VuOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5sIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLmwgPSBjbGFtcChoc2wubCk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBmYWRlaW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaHNsLmEgKz0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICBoc2wuYSA9IGNsYW1wKGhzbC5hKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGZhZGVvdXQ6IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaHNsLmEgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICBoc2wuYSA9IGNsYW1wKGhzbC5hKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIHNwaW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG4gICAgICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQudmFsdWUpICUgMzYwO1xuXG4gICAgICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblxuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGVudGl0eSwgYSwgYikge1xuICAgICAgICBpZiAoZW50aXR5LmlzID09PSAnZmllbGQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5LnRvU3RyaW5nICsgJy5yZXBsYWNlKCcgKyBhLnRvU3RyaW5nKCkgKyAnLCAnICsgYi50b1N0cmluZygpICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZXBsYWNlKGEsIGIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvL1xuICAgIC8vIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEhhbXB0b24gQ2F0bGluLCBOYXRoYW4gV2VpemVuYmF1bSwgYW5kIENocmlzIEVwcHN0ZWluXG4gICAgLy8gaHR0cDovL3Nhc3MtbGFuZy5jb21cbiAgICAvL1xuICAgIG1peDogZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyLCB3ZWlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSB3ZWlnaHQudmFsdWUgLyAxMDAuMDtcbiAgICAgICAgdmFyIHcgPSBwICogMiAtIDE7XG4gICAgICAgIHZhciBhID0gY29sb3IxLnRvSFNMKCkuYSAtIGNvbG9yMi50b0hTTCgpLmE7XG5cbiAgICAgICAgdmFyIHcxID0gKCgodyAqIGEgPT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgICAgdmFyIHcyID0gMSAtIHcxO1xuXG4gICAgICAgIHZhciByZ2IgPSBbY29sb3IxLnJnYlswXSAqIHcxICsgY29sb3IyLnJnYlswXSAqIHcyLFxuICAgICAgICAgICAgICAgICAgIGNvbG9yMS5yZ2JbMV0gKiB3MSArIGNvbG9yMi5yZ2JbMV0gKiB3MixcbiAgICAgICAgICAgICAgICAgICBjb2xvcjEucmdiWzJdICogdzEgKyBjb2xvcjIucmdiWzJdICogdzJdO1xuXG4gICAgICAgIHZhciBhbHBoYSA9IGNvbG9yMS5hbHBoYSAqIHAgKyBjb2xvcjIuYWxwaGEgKiAoMSAtIHApO1xuXG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcihyZ2IsIGFscGhhKTtcbiAgICB9LFxuICAgIGdyZXlzY2FsZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2F0dXJhdGUoY29sb3IsIG5ldyB0cmVlLkRpbWVuc2lvbigxMDApKTtcbiAgICB9LFxuICAgICclJzogZnVuY3Rpb24gKHF1b3RlZCAvKiBhcmcsIGFyZywgLi4uKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgc3RyID0gcXVvdGVkLnZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyVzLywgICAgYXJnc1tpXS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lW2RhXS8sIGFyZ3NbaV0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyUlL2csICclJyk7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5RdW90ZWQoc3RyKTtcbiAgICB9XG59O1xuXG52YXIgaW1hZ2VfZmlsdGVyX2Z1bmN0b3JzID0gW1xuICAgICdlbWJvc3MnLCAnYmx1cicsICdncmF5JywgJ3NvYmVsJywgJ2VkZ2UtZGV0ZWN0JyxcbiAgICAneC1ncmFkaWVudCcsICd5LWdyYWRpZW50JywgJ3NoYXJwZW4nXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZV9maWx0ZXJfZnVuY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZiA9IGltYWdlX2ZpbHRlcl9mdW5jdG9yc1tpXTtcbiAgICB0cmVlLmZ1bmN0aW9uc1tmXSA9IChmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5JbWFnZUZpbHRlcihmKTtcbiAgICAgICAgfTtcbiAgICB9KShmKTtcbn1cblxudHJlZS5mdW5jdGlvbnNbJ2FnZy1zdGFjay1ibHVyJ10gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyB0cmVlLkltYWdlRmlsdGVyKCdhZ2ctc3RhY2stYmx1cicsIFt4LCB5XSk7XG59O1xuXG50cmVlLmZ1bmN0aW9uc1snc2NhbGUtaHNsYSddID0gZnVuY3Rpb24oaDAsaDEsczAsczEsbDAsbDEsYTAsYTEpIHtcbiAgICByZXR1cm4gbmV3IHRyZWUuSW1hZ2VGaWx0ZXIoJ3NjYWxlLWhzbGEnLCBbaDAsaDEsczAsczEsbDAsbDEsYTAsYTFdKTtcbn07XG5cbmZ1bmN0aW9uIGhzbGEoaCkge1xuICAgIHJldHVybiB0cmVlLmZ1bmN0aW9ucy5oc2xhKGguaCwgaC5zLCBoLmwsIGguYSk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiB0cmVlLkRpbWVuc2lvbikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuLnVuaXQgPT0gJyUnID8gbi52YWx1ZSAvIDEwMCA6IG4udmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKG4pID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xhbXAodmFsKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHZhbCkpO1xufVxuXG59KShyZXF1aXJlKCcuL3RyZWUnKSk7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuXG5mdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICAgIGlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicpWzFdLCAxMCkgPiA0KSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkZXIgbm9kZVxuICAgICAgICB2YXIgcGFja2FnZV9qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKF9fZGlybmFtZSwnLi4vLi4vcGFja2FnZS5qc29uJykpKTtcbiAgICAgICAgcmV0dXJuIHBhY2thZ2VfanNvbi52ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgfVxufVxuXG52YXIgY2FydG8gPSB7XG4gICAgdmVyc2lvbjogZ2V0VmVyc2lvbigpLFxuICAgIFBhcnNlcjogcmVxdWlyZSgnLi9wYXJzZXInKS5QYXJzZXIsXG4gICAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXInKS5SZW5kZXJlcixcbiAgICB0cmVlOiByZXF1aXJlKCcuL3RyZWUnKSxcbiAgICBSZW5kZXJlckpTOiByZXF1aXJlKCcuL3JlbmRlcmVyX2pzJyksXG4gICAgZGVmYXVsdF9yZWZlcmVuY2U6IHJlcXVpcmUoJy4vdG9ycXVlLXJlZmVyZW5jZScpLFxuXG4gICAgLy8gQFRPRE9cbiAgICB3cml0ZUVycm9yOiBmdW5jdGlvbihjdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICAgICAgdmFyIGV4dHJhY3QgPSBjdHguZXh0cmFjdDtcbiAgICAgICAgdmFyIGVycm9yID0gW107XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7IHJldHVybjsgfVxuXG4gICAgICAgIG9wdGlvbnMuaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQgfHwgJyc7XG5cbiAgICAgICAgaWYgKCEoJ2luZGV4JyBpbiBjdHgpIHx8ICFleHRyYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbC5lcnJvcihvcHRpb25zLmluZGVudCArIChjdHguc3RhY2sgfHwgY3R4Lm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoZXh0cmFjdFswXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvci5wdXNoKHN0eWxpemUoKGN0eC5saW5lIC0gMSkgKyAnICcgKyBleHRyYWN0WzBdLCAnZ3JleScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYWN0WzFdID09PSAnJyAmJiB0eXBlb2YgZXh0cmFjdFsyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4dHJhY3RbMV0gPSAnwrYnO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yLnB1c2goY3R4LmxpbmUgKyAnICcgKyBleHRyYWN0WzFdLnNsaWNlKDAsIGN0eC5jb2x1bW4pICtcbiAgICAgICAgICAgIHN0eWxpemUoc3R5bGl6ZShleHRyYWN0WzFdW2N0eC5jb2x1bW5dLCAnYm9sZCcpICtcbiAgICAgICAgICAgIGV4dHJhY3RbMV0uc2xpY2UoY3R4LmNvbHVtbiArIDEpLCAneWVsbG93JykpO1xuXG4gICAgICAgIGlmICh0eXBlb2YoZXh0cmFjdFsyXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvci5wdXNoKHN0eWxpemUoKGN0eC5saW5lICsgMSkgKyAnICcgKyBleHRyYWN0WzJdLCAnZ3JleScpKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciA9IG9wdGlvbnMuaW5kZW50ICsgZXJyb3Iuam9pbignXFxuJyArIG9wdGlvbnMuaW5kZW50KSArICdcXDAzM1swbVxcbic7XG5cbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMuaW5kZW50ICsgbWVzc2FnZSArIHN0eWxpemUoY3R4Lm1lc3NhZ2UsICdyZWQnKTtcbiAgICAgICAgaWYgKGN0eC5maWxlbmFtZSkgKG1lc3NhZ2UgKz0gc3R5bGl6ZSgnIGluICcsICdyZWQnKSArIGN0eC5maWxlbmFtZSk7XG5cbiAgICAgICAgdXRpbC5lcnJvcihtZXNzYWdlLCBlcnJvcik7XG5cbiAgICAgICAgaWYgKGN0eC5jYWxsTGluZSkge1xuICAgICAgICAgICAgdXRpbC5lcnJvcihzdHlsaXplKCdmcm9tICcsICdyZWQnKSArIChjdHguZmlsZW5hbWUgfHwgJycpKTtcbiAgICAgICAgICAgIHV0aWwuZXJyb3Ioc3R5bGl6ZShjdHguY2FsbExpbmUsICdncmV5JykgKyAnICcgKyBjdHguY2FsbEV4dHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguc3RhY2spIHsgdXRpbC5lcnJvcihzdHlsaXplKGN0eC5zdGFjaywgJ3JlZCcpKTsgfVxuICAgIH1cbn07XG5cbnJlcXVpcmUoJy4vdHJlZS9jYWxsJyk7XG5yZXF1aXJlKCcuL3RyZWUvY29sb3InKTtcbnJlcXVpcmUoJy4vdHJlZS9jb21tZW50Jyk7XG5yZXF1aXJlKCcuL3RyZWUvZGVmaW5pdGlvbicpO1xucmVxdWlyZSgnLi90cmVlL2RpbWVuc2lvbicpO1xucmVxdWlyZSgnLi90cmVlL2VsZW1lbnQnKTtcbnJlcXVpcmUoJy4vdHJlZS9leHByZXNzaW9uJyk7XG5yZXF1aXJlKCcuL3RyZWUvZmlsdGVyc2V0Jyk7XG5yZXF1aXJlKCcuL3RyZWUvZmlsdGVyJyk7XG5yZXF1aXJlKCcuL3RyZWUvZmllbGQnKTtcbnJlcXVpcmUoJy4vdHJlZS9rZXl3b3JkJyk7XG5yZXF1aXJlKCcuL3RyZWUvbGF5ZXInKTtcbnJlcXVpcmUoJy4vdHJlZS9saXRlcmFsJyk7XG5yZXF1aXJlKCcuL3RyZWUvb3BlcmF0aW9uJyk7XG5yZXF1aXJlKCcuL3RyZWUvcXVvdGVkJyk7XG5yZXF1aXJlKCcuL3RyZWUvaW1hZ2VmaWx0ZXInKTtcbnJlcXVpcmUoJy4vdHJlZS9yZWZlcmVuY2UnKTtcbnJlcXVpcmUoJy4vdHJlZS9ydWxlJyk7XG5yZXF1aXJlKCcuL3RyZWUvcnVsZXNldCcpO1xucmVxdWlyZSgnLi90cmVlL3NlbGVjdG9yJyk7XG5yZXF1aXJlKCcuL3RyZWUvc3R5bGUnKTtcbnJlcXVpcmUoJy4vdHJlZS91cmwnKTtcbnJlcXVpcmUoJy4vdHJlZS92YWx1ZScpO1xucmVxdWlyZSgnLi90cmVlL3ZhcmlhYmxlJyk7XG5yZXF1aXJlKCcuL3RyZWUvem9vbScpO1xucmVxdWlyZSgnLi90cmVlL2ludmFsaWQnKTtcbnJlcXVpcmUoJy4vdHJlZS9mb250c2V0Jyk7XG5yZXF1aXJlKCcuL3RyZWUvZnJhbWVfb2Zmc2V0Jyk7XG5yZXF1aXJlKCcuL2Z1bmN0aW9ucycpO1xuXG5mb3IgKHZhciBrIGluIGNhcnRvKSB7IGV4cG9ydHNba10gPSBjYXJ0b1trXTsgfVxuXG4vLyBTdHlsaXplIGEgc3RyaW5nXG5mdW5jdGlvbiBzdHlsaXplKHN0ciwgc3R5bGUpIHtcbiAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAnYm9sZCcgOiBbMSwgMjJdLFxuICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICAgICAgICd5ZWxsb3cnIDogWzMzLCAzOV0sXG4gICAgICAgICdncmVlbicgOiBbMzIsIDM5XSxcbiAgICAgICAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgICAgICAgJ2dyZXknIDogWzkwLCAzOV1cbiAgICB9O1xuICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMV0gKyAnbSc7XG59XG4iLCJ2YXIgY2FydG8gPSBleHBvcnRzLFxuICAgIHRyZWUgPSByZXF1aXJlKCcuL3RyZWUnKSxcbiAgICBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vLyAgICBUb2tlbiBtYXRjaGluZyBpcyBkb25lIHdpdGggdGhlIGAkYCBmdW5jdGlvbiwgd2hpY2ggZWl0aGVyIHRha2VzXG4vLyAgICBhIHRlcm1pbmFsIHN0cmluZyBvciByZWdleHAsIG9yIGEgbm9uLXRlcm1pbmFsIGZ1bmN0aW9uIHRvIGNhbGwuXG4vLyAgICBJdCBhbHNvIHRha2VzIGNhcmUgb2YgbW92aW5nIGFsbCB0aGUgaW5kaWNlcyBmb3J3YXJkcy5cbmNhcnRvLlBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihlbnYpIHtcbiAgICB2YXIgaW5wdXQsICAgICAgIC8vIExlU1MgaW5wdXQgc3RyaW5nXG4gICAgICAgIGksICAgICAgICAgICAvLyBjdXJyZW50IGluZGV4IGluIGBpbnB1dGBcbiAgICAgICAgaiwgICAgICAgICAgIC8vIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgdGVtcCwgICAgICAgIC8vIHRlbXBvcmFyaWx5IGhvbGRzIGEgY2h1bmsncyBzdGF0ZSwgZm9yIGJhY2t0cmFja2luZ1xuICAgICAgICBtZW1vLCAgICAgICAgLy8gdGVtcG9yYXJpbHkgaG9sZHMgYGlgLCB3aGVuIGJhY2t0cmFja2luZ1xuICAgICAgICBmdXJ0aGVzdCwgICAgLy8gZnVydGhlc3QgaW5kZXggdGhlIHBhcnNlciBoYXMgZ29uZSB0b1xuICAgICAgICBjaHVua3MsICAgICAgLy8gY2h1bmtpZmllZCBpbnB1dFxuICAgICAgICBjdXJyZW50LCAgICAgLy8gaW5kZXggb2YgY3VycmVudCBjaHVuaywgaW4gYGlucHV0YFxuICAgICAgICBwYXJzZXI7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciBhbGwgZmlsZXNcbiAgICAvLyBoYXZlIGJlZW4gaW1wb3J0ZWQgdGhyb3VnaCBgQGltcG9ydGAuXG4gICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBmdW5jdGlvbiBzYXZlKCkgICAge1xuICAgICAgICB0ZW1wID0gY2h1bmtzW2pdO1xuICAgICAgICBtZW1vID0gaTtcbiAgICAgICAgY3VycmVudCA9IGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICAgIGNodW5rc1tqXSA9IHRlbXA7XG4gICAgICAgIGkgPSBtZW1vO1xuICAgICAgICBjdXJyZW50ID0gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAoaSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNodW5rc1tqXSA9IGNodW5rc1tqXS5zbGljZShpIC0gY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL1xuICAgIC8vIFBhcnNlIGZyb20gYSB0b2tlbiwgcmVnZXhwIG9yIHN0cmluZywgYW5kIG1vdmUgZm9yd2FyZCBpZiBtYXRjaFxuICAgIC8vXG4gICAgZnVuY3Rpb24gJCh0b2spIHtcbiAgICAgICAgdmFyIG1hdGNoLCBhcmdzLCBsZW5ndGgsIGMsIGluZGV4LCBlbmRJbmRleCwgaztcblxuICAgICAgICAvLyBOb24tdGVybWluYWxcbiAgICAgICAgaWYgKHRvayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rLmNhbGwocGFyc2VyLnBhcnNlcnMpO1xuICAgICAgICAvLyBUZXJtaW5hbFxuICAgICAgICAvLyBFaXRoZXIgbWF0Y2ggYSBzaW5nbGUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCxcbiAgICAgICAgLy8gb3IgbWF0Y2ggYSByZWdleHAgaW4gdGhlIGN1cnJlbnQgY2h1bmsgKGNodW5rW2pdKS5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodG9rKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQuY2hhckF0KGkpID09PSB0b2sgPyB0b2sgOiBudWxsO1xuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHN5bmMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bmMoKTtcblxuICAgICAgICAgICAgbWF0Y2ggPSB0b2suZXhlYyhjaHVua3Nbal0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXRjaCBpcyBjb25maXJtZWQsIGFkZCB0aGUgbWF0Y2ggbGVuZ3RoIHRvIGBpYCxcbiAgICAgICAgLy8gYW5kIGNvbnN1bWUgYW55IGV4dHJhIHdoaXRlLXNwYWNlIGNoYXJhY3RlcnMgKCcgJyB8fCAnXFxuJylcbiAgICAgICAgLy8gd2hpY2ggY29tZSBhZnRlciB0aGF0LiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgTGVTUydzXG4gICAgICAgIC8vIGdyYW1tYXIgaXMgbW9zdGx5IHdoaXRlLXNwYWNlIGluc2Vuc2l0aXZlLlxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBtZW0gPSBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gaSArIGNodW5rc1tqXS5sZW5ndGggLSBsZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoISAoYyA9PT0gMzIgfHwgYyA9PT0gMTAgfHwgYyA9PT0gOSkpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua3Nbal0gPSBjaHVua3Nbal0uc2xpY2UobGVuZ3RoICsgKGkgLSBtZW0pKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpO1xuXG4gICAgICAgICAgICBpZiAoY2h1bmtzW2pdLmxlbmd0aCA9PT0gMCAmJiBqIDwgY2h1bmtzLmxlbmd0aCAtIDEpIHsgaisrOyB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YobWF0Y2gpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmxlbmd0aCA9PT0gMSA/IG1hdGNoWzBdIDogbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYW1lIGFzICQoKSwgYnV0IGRvbid0IGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlcixcbiAgICAvLyBqdXN0IHJldHVybiB0aGUgbWF0Y2guXG4gICAgZnVuY3Rpb24gcGVlayh0b2spIHtcbiAgICAgICAgaWYgKHR5cGVvZih0b2spID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdChpKSA9PT0gdG9rO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICEhdG9rLnRlc3QoY2h1bmtzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFcnJvckxpbmUoc3R5bGUsIGVycm9ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChzdHlsZS5zbGljZSgwLCBlcnJvckluZGV4KS5tYXRjaCgvXFxuL2cpIHx8ICcnKS5sZW5ndGggKyAxO1xuICAgIH1cblxuXG4gICAgLy8gTWFrZSBhbiBlcnJvciBvYmplY3QgZnJvbSBhIHBhc3NlZCBzZXQgb2YgcHJvcGVydGllcy5cbiAgICAvLyBBY2NlcHRlZCBwcm9wZXJ0aWVzOlxuICAgIC8vIC0gYG1lc3NhZ2VgOiBUZXh0IG9mIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgIC8vIC0gYGZpbGVuYW1lYDogRmlsZW5hbWUgd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxuICAgIC8vIC0gYGluZGV4YDogQ2hhci4gaW5kZXggd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvcihlcnIpIHtcbiAgICAgICAgdmFyIGVpbnB1dDtcblxuICAgICAgICBfKGVycikuZGVmYXVsdHMoe1xuICAgICAgICAgICAgaW5kZXg6IGZ1cnRoZXN0LFxuICAgICAgICAgICAgZmlsZW5hbWU6IGVudi5maWxlbmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQYXJzZSBlcnJvci4nLFxuICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgIGNvbHVtbjogLTFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVyci5maWxlbmFtZSAmJiB0aGF0LmVudi5pbnB1dHMgJiYgdGhhdC5lbnYuaW5wdXRzW2Vyci5maWxlbmFtZV0pIHtcbiAgICAgICAgICAgIGVpbnB1dCA9IHRoYXQuZW52LmlucHV0c1tlcnIuZmlsZW5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWlucHV0ID0gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBlcnIubGluZSA9IGV4dHJhY3RFcnJvckxpbmUoZWlucHV0LCBlcnIuaW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBuID0gZXJyLmluZGV4OyBuID49IDAgJiYgZWlucHV0LmNoYXJBdChuKSAhPT0gJ1xcbic7IG4tLSkge1xuICAgICAgICAgICAgZXJyLmNvbHVtbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihfKCc8JT1maWxlbmFtZSU+OjwlPWxpbmUlPjo8JT1jb2x1bW4lPiA8JT1tZXNzYWdlJT4nKS50ZW1wbGF0ZShlcnIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmVudiA9IGVudiA9IGVudiB8fCB7fTtcbiAgICB0aGlzLmVudi5maWxlbmFtZSA9IHRoaXMuZW52LmZpbGVuYW1lIHx8IG51bGw7XG4gICAgdGhpcy5lbnYuaW5wdXRzID0gdGhpcy5lbnYuaW5wdXRzIHx8IHt9O1xuXG4gICAgLy8gVGhlIFBhcnNlclxuICAgIHBhcnNlciA9IHtcblxuICAgICAgICBleHRyYWN0RXJyb3JMaW5lOiBleHRyYWN0RXJyb3JMaW5lLFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgaW50byBhbiBhYnN0cmFjdCBzeW50YXggdHJlZS5cbiAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIG9uIHBhcnNlIGVycm9ycy5cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHJvb3QsIHN0YXJ0LCBlbmQsIHpvbmUsIGxpbmUsIGxpbmVzLCBidWZmID0gW10sIGMsIGVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgaSA9IGogPSBjdXJyZW50ID0gZnVydGhlc3QgPSAwO1xuICAgICAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgICAgICBpbnB1dCA9IHN0ci5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGVudi5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZW52LmlucHV0c1tlbnYuZmlsZW5hbWVdID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlYXJseV9leGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFNwbGl0IHRoZSBpbnB1dCBpbnRvIGNodW5rcy5cbiAgICAgICAgICAgIGNodW5rcyA9IChmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSAwLFxuICAgICAgICAgICAgICAgICAgICBza2lwID0gLyg/OkBcXHtbXFx3LV0rXFx9fFteXCInYFxce1xcfVxcL1xcKFxcKVxcXFxdKSsvZyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IC9cXC9cXCooPzpbXipdfFxcKitbXlxcLypdKSpcXCorXFwvfFxcL1xcLy4qL2csXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IC9cIigoPzpbXlwiXFxcXFxcclxcbl18XFxcXC4pKilcInwnKCg/OlteJ1xcXFxcXHJcXG5dfFxcXFwuKSopJ3xgKCg/OlteYF18XFxcXC4pKilgL2csXG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmtzWzBdLFxuICAgICAgICAgICAgICAgICAgICBpblBhcmFtO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGMsIGNjOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBza2lwLmxhc3RJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IHNraXAuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMgPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQubGFzdEluZGV4ID0gc3RyaW5nLmxhc3RJbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gc3RyaW5nLmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5QYXJhbSAmJiBjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjID0gaW5wdXQuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyA9PT0gJy8nIHx8IGNjID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBjb21tZW50LmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzogaWYgKCEgaW5QYXJhbSkgeyBsZXZlbCArKzsgICAgICAgIGNodW5rLnB1c2goYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ30nOiBpZiAoISBpblBhcmFtKSB7IGxldmVsIC0tOyAgICAgICAgY2h1bmsucHVzaChjKTsgY2h1bmtzWysral0gPSBjaHVuayA9IFtdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6IGlmICghIGluUGFyYW0pIHsgaW5QYXJhbSA9IHRydWU7ICBjaHVuay5wdXNoKGMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcpJzogaWYgKCAgaW5QYXJhbSkgeyBpblBhcmFtID0gZmFsc2U7IGNodW5rLnB1c2goYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BhcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChsZXZlbCA+IDApID8gXCJtaXNzaW5nIGNsb3NpbmcgYH1gXCIgOiBcIm1pc3Npbmcgb3BlbmluZyBge2BcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjaHVua3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmpvaW4oJycpOyB9KTtcbiAgICAgICAgICAgIH0pKFtbXV0pO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCB3aXRoIHRoZSBwcmltYXJ5IHJ1bGUuXG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgc3ludGF4IHRyZWUgaXMgaGVsZCB1bmRlciBhIFJ1bGVzZXQgbm9kZSxcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIGByb290YCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSwgc28gbm8gYHt9YCBhcmVcbiAgICAgICAgICAgIC8vIG91dHB1dC5cbiAgICAgICAgICAgIHJvb3QgPSBuZXcgdHJlZS5SdWxlc2V0KFtdLCAkKHRoaXMucGFyc2Vycy5wcmltYXJ5KSk7XG4gICAgICAgICAgICByb290LnJvb3QgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBHZXQgYW4gYXJyYXkgb2YgUnVsZXNldCBvYmplY3RzLCBmbGF0dGVuZWRcbiAgICAgICAgICAgIC8vIGFuZCBzb3J0ZWQgYWNjb3JkaW5nIHRvIHNwZWNpZmljaXR5U29ydFxuICAgICAgICAgICAgcm9vdC50b0xpc3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUsIGxpbmVzLCBjb2x1bW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVudikge1xuICAgICAgICAgICAgICAgICAgICBlbnYuZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudi5lcnJvcnMpIGVudi5lcnJvcnMgPSBuZXcgRXJyb3IoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudi5lcnJvcnMubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudi5lcnJvcnMubWVzc2FnZSArPSAnXFxuJyArIG1ha2VFcnJvcihlKS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnYuZXJyb3JzLm1lc3NhZ2UgPSBtYWtlRXJyb3IoZSkubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZW52LmZyYW1lcyA9IGVudi5mcmFtZXMgfHwgW107XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHBvcHVsYXRlcyBJbnZhbGlkLWNhdXNlZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5mbGF0dGVuKFtdLCBbXSwgZW52KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnMuc29ydChzcGVjaWZpY2l0eVNvcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgcnVsZXMgYnkgc3BlY2lmaWNpdHk6IHRoaXMgZnVuY3Rpb24gZXhwZWN0cyBzZWxlY3RvcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHNwbGl0IGFscmVhZHkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV3JpdHRlbiB0byBiZSB1c2VkIGFzIGEgLnNvcnQoRnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gYXJndW1lbnQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gWzEsIDAsIDAsIDQ2N10gPiBbMCwgMCwgMSwgNTIwXVxuICAgICAgICAgICAgdmFyIHNwZWNpZmljaXR5U29ydCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXMgPSBhLnNwZWNpZmljaXR5O1xuICAgICAgICAgICAgICAgIHZhciBicyA9IGIuc3BlY2lmaWNpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXNbMF0gIT0gYnNbMF0pIHJldHVybiBic1swXSAtIGFzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChhc1sxXSAhPSBic1sxXSkgcmV0dXJuIGJzWzFdIC0gYXNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGFzWzJdICE9IGJzWzJdKSByZXR1cm4gYnNbMl0gLSBhc1syXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnNbM10gLSBhc1szXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEhlcmUgaW4sIHRoZSBwYXJzaW5nIHJ1bGVzL2Z1bmN0aW9uc1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSBzeW50YXggdHJlZSBnZW5lcmF0ZWQgaXMgYXMgZm9sbG93czpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBSdWxlc2V0IC0+ICBSdWxlIC0+IFZhbHVlIC0+IEV4cHJlc3Npb24gLT4gRW50aXR5XG4gICAgICAgIC8vXG4gICAgICAgIC8vICBJbiBnZW5lcmFsLCBtb3N0IHJ1bGVzIHdpbGwgdHJ5IHRvIHBhcnNlIGEgdG9rZW4gd2l0aCB0aGUgYCQoKWAgZnVuY3Rpb24sIGFuZCBpZiB0aGUgcmV0dXJuXG4gICAgICAgIC8vICB2YWx1ZSBpcyB0cnVseSwgd2lsbCByZXR1cm4gYSBuZXcgbm9kZSwgb2YgdGhlIHJlbGV2YW50IHR5cGUuIFNvbWV0aW1lcywgd2UgbmVlZCB0byBjaGVja1xuICAgICAgICAvLyAgZmlyc3QsIGJlZm9yZSBwYXJzaW5nLCB0aGF0J3Mgd2hlbiB3ZSB1c2UgYHBlZWsoKWAuXG4gICAgICAgIHBhcnNlcnM6IHtcbiAgICAgICAgICAgIC8vIFRoZSBgcHJpbWFyeWAgcnVsZSBpcyB0aGUgKmVudHJ5KiBhbmQgKmV4aXQqIHBvaW50IG9mIHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAvLyBUaGUgcnVsZXMgaGVyZSBjYW4gYXBwZWFyIGF0IGFueSBsZXZlbCBvZiB0aGUgcGFyc2UgdHJlZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgcmVjdXJzaXZlIG5hdHVyZSBvZiB0aGUgZ3JhbW1hciBpcyBhbiBpbnRlcnBsYXkgYmV0d2VlbiB0aGUgYGJsb2NrYFxuICAgICAgICAgICAgLy8gcnVsZSwgd2hpY2ggcmVwcmVzZW50cyBgeyAuLi4gfWAsIHRoZSBgcnVsZXNldGAgcnVsZSwgYW5kIHRoaXMgYHByaW1hcnlgIHJ1bGUsXG4gICAgICAgICAgICAvLyBhcyByZXByZXNlbnRlZCBieSB0aGlzIHNpbXBsaWZpZWQgZ3JhbW1hcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgcHJpbWFyeSAg4oaSICAocnVsZXNldCB8IHJ1bGUpK1xuICAgICAgICAgICAgLy8gICAgIHJ1bGVzZXQgIOKGkiAgc2VsZWN0b3IrIGJsb2NrXG4gICAgICAgICAgICAvLyAgICAgYmxvY2sgICAg4oaSICAneycgcHJpbWFyeSAnfSdcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPbmx5IGF0IG9uZSBwb2ludCBpcyB0aGUgcHJpbWFyeSBydWxlIG5vdCBjYWxsZWQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGJsb2NrIHJ1bGU6IGF0IHRoZSByb290IGxldmVsLlxuICAgICAgICAgICAgcHJpbWFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUsIHJvb3QgPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgobm9kZSA9ICQodGhpcy5ydWxlKSB8fCAkKHRoaXMucnVsZXNldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuY29tbWVudCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgvXltcXHNcXG5dKy8pIHx8IChub2RlID0gJCh0aGlzLmludmFsaWQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkgcm9vdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGludmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSAkKC9eW147XFxuXSpbO1xcbl0vKTtcblxuICAgICAgICAgICAgICAgIC8vIFRvIGZhaWwgZ3JhY2VmdWxseSwgbWF0Y2ggZXZlcnl0aGluZyB1bnRpbCBhIHNlbWljb2xvbiBvciBsaW5lYnJlYWsuXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5JbnZhbGlkKGNodW5rLCBtZW1vKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBXZSBjcmVhdGUgYSBDb21tZW50IG5vZGUgZm9yIENTUyBjb21tZW50cyBgLyogKi9gLFxuICAgICAgICAgICAgLy8gYnV0IGtlZXAgdGhlIExlU1MgY29tbWVudHMgYC8vYCBzaWxlbnQsIGJ5IGp1c3Qgc2tpcHBpbmdcbiAgICAgICAgICAgIC8vIG92ZXIgdGhlbS5cbiAgICAgICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSAhPT0gJy8nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkgKyAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db21tZW50KCQoL15cXC9cXC8uKi8pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQgPSAkKC9eXFwvXFwqKD86W14qXXxcXCorW15cXC8qXSkqXFwqK1xcL1xcbj8vKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBFbnRpdGllcyBhcmUgdG9rZW5zIHdoaWNoIGNhbiBiZSBmb3VuZCBpbnNpZGUgYW4gRXhwcmVzc2lvblxuICAgICAgICAgICAgZW50aXRpZXM6IHtcblxuICAgICAgICAgICAgICAgIC8vIEEgc3RyaW5nLCB3aGljaCBzdXBwb3J0cyBlc2NhcGluZyBcIiBhbmQgJyBcIm1pbGt5IHdheVwiICdoZVxcJ3MgdGhlIG9uZSEnXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSAhPT0gJ1wiJyAmJiBpbnB1dC5jaGFyQXQoaSkgIT09IFwiJ1wiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSAkKC9eXCIoKD86W15cIlxcXFxcXHJcXG5dfFxcXFwuKSopXCJ8JygoPzpbXidcXFxcXFxyXFxuXXxcXFxcLikqKScvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlF1b3RlZChzdHJbMV0gfHwgc3RyWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIHJlZmVyZW5jZSB0byBhIE1hcG5payBmaWVsZCwgbGlrZSBbTkFNRV1cbiAgICAgICAgICAgICAgICAvLyBCZWhpbmQgdGhlIHNjZW5lcywgdGhpcyBoYXMgdGhlIHNhbWUgcmVwcmVzZW50YXRpb24sIGJ1dCBDYXJ0b1xuICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIGNhcmVmdWwgdG8gd2FybiB3aGVuIHVuc3VwcG9ydGVkIG9wZXJhdGlvbnMgYXJlIHVzZWQuXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCdbJykpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkX25hbWUgPSAkKC8oXlteXFxdXSspLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghICQoJ10nKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRfbmFtZSkgcmV0dXJuIG5ldyB0cmVlLkZpZWxkKGZpZWxkX25hbWVbMV0pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29tcGFyaXNvbiBvcGVyYXRvclxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gJCgvXj1+fD18IT18PD18Pj18PHw+Lyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQSBjYXRjaC1hbGwgd29yZCwgc3VjaCBhczogaGFyZC1saWdodFxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGNhbiBzdGFydCB3aXRoIGVpdGhlciBhIGxldHRlciBvciBhIGRhc2ggKC0pLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGNvbnRhaW4gbnVtYmVycywgdW5kZXJzY29yZXMsIGFuZCBsZXR0ZXJzLlxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9ICQoL15bQS1aYS16LV0rW0EtWmEtei0wLTlfXSovKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGspIHsgcmV0dXJuIG5ldyB0cmVlLktleXdvcmQoayk7IH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIGxpa2UgcmdiKDI1NSwgMCwgMjU1KVxuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHBhcnNlZCB3aXRoIHRoZSBgZW50aXRpZXMuYXJndW1lbnRzYCBwYXJzZXIuXG4gICAgICAgICAgICAgICAgY2FsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lLCBhcmdzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG5hbWUgPSAvXihbXFx3XFwtXSt8JSlcXCgvLmV4ZWMoY2h1bmtzW2pdKSkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVsxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3VybCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVybCgpIGlzIGhhbmRsZWQgYnkgdGhlIHVybCBwYXJzZXIgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IG5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgJCgnKCcpOyAvLyBQYXJzZSB0aGUgJygnIGFuZCBjb25zdW1lIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgICAgICAgICAgICAgYXJncyA9ICQodGhpcy5lbnRpdGllc1snYXJndW1lbnRzJ10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghJCgnKScpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5DYWxsKG5hbWUsIGFyZ3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBBcmd1bWVudHMgYXJlIGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgYXJnO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhcmcgPSAkKHRoaXMuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxpdGVyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzLmVudGl0aWVzLmRpbWVuc2lvbikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5rZXl3b3JkY29sb3IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMuaGV4Y29sb3IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMucXVvdGVkKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdXJsKCkgdG9rZW5zXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBzcGVjaWZpYyBydWxlIGZvciB1cmxzLCBiZWNhdXNlIHRoZXkgZG9uJ3QgcmVhbGx5IGJlaGF2ZSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZnVuY3Rpb24gY2FsbHMuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFyZ3VtZW50IGRvZXNuJ3QgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGVuY2xvc2VkIHdpdGhpbiBhIHN0cmluZywgc28gaXQgY2FuJ3QgYmUgcGFyc2VkIGFzIGFuIEV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSkgIT09ICd1JyB8fCAhJCgvXnVybFxcKC8pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJCh0aGlzLmVudGl0aWVzLnF1b3RlZCkgfHwgJCh0aGlzLmVudGl0aWVzLnZhcmlhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoL15bXFwtXFx3JUAkXFwvLiY9OjsjKz9+XSsvKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuSW52YWxpZCh2YWx1ZSwgbWVtbywgJ01pc3NpbmcgY2xvc2luZyApIGluIFVSTC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5VUkwoKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIHRyZWUuVmFyaWFibGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IG5ldyB0cmVlLlF1b3RlZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEEgVmFyaWFibGUgZW50aXR5LCBzdWNoIGFzIGBAZmlua2AsIGluXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgd2lkdGg6IEBmaW5rICsgMnB4XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBkaWZmZXJlbnQgcGFyc2VyIGZvciB2YXJpYWJsZSBkZWZpbml0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBzZWUgYHBhcnNlcnMudmFyaWFibGVgLlxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUsIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkpID09PSAnQCcgJiYgKG5hbWUgPSAkKC9eQFtcXHctXSsvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5WYXJpYWJsZShuYW1lLCBpbmRleCwgZW52LmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBoZXhjb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZ2I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSkgPT09ICcjJyAmJiAocmdiID0gJCgvXiMoW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ29sb3IocmdiWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBrZXl3b3JkY29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmdiID0gY2h1bmtzW2pdLm1hdGNoKC9eW2Etel0rLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZ2IgJiYgcmdiWzBdIGluIHRyZWUuUmVmZXJlbmNlLmRhdGEuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ29sb3IodHJlZS5SZWZlcmVuY2UuZGF0YS5jb2xvcnNbJCgvXlthLXpdKy8pXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQSBEaW1lbnNpb24sIHRoYXQgaXMsIGEgbnVtYmVyIGFuZCBhIHVuaXQuIFRoZSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gdW5pdCB0aGF0IGhhcyBhbiBlZmZlY3QgaXMgJVxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjID4gNTcgfHwgYyA8IDQ1KSB8fCBjID09PSA0NykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAkKC9eKC0/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/KShcXCV8XFx3Kyk/Lyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRpbWVuc2lvbih2YWx1ZVsxXSwgdmFsdWVbMl0sIG1lbW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIHBhcnQgb2YgYSB2YXJpYWJsZSBkZWZpbml0aW9uLlxuICAgICAgICAgICAgLy8gVXNlZCBpbiB0aGUgYHJ1bGVgIHBhcnNlci4gTGlrZSBAZmluazpcbiAgICAgICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSkgPT09ICdAJyAmJiAobmFtZSA9ICQoL14oQFtcXHctXSspXFxzKjovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRW50aXRpZXMgYXJlIHRoZSBzbWFsbGVzdCByZWNvZ25pemVkIHRva2VuLFxuICAgICAgICAgICAgLy8gYW5kIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSBydWxlJ3MgdmFsdWUuXG4gICAgICAgICAgICBlbnRpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMuZW50aXRpZXMuY2FsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmxpdGVyYWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5maWVsZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLnZhcmlhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMudXJsKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMua2V5d29yZCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBIFJ1bGUgdGVybWluYXRvci4gTm90ZSB0aGF0IHdlIHVzZSBgcGVlaygpYCB0byBjaGVjayBmb3IgJ30nLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgYGJsb2NrYCBydWxlIHdpbGwgYmUgZXhwZWN0aW5nIGl0LCBidXQgd2Ugc3RpbGwgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAgICAgICAgIC8vIGl0J3MgdGhlcmUsIGlmICc7JyB3YXMgb21taXR0ZWQuXG4gICAgICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKCc7JykgfHwgcGVlaygnfScpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRWxlbWVudHMgYXJlIHRoZSBidWlsZGluZyBibG9ja3MgZm9yIFNlbGVjdG9ycy4gVGhleSBjb25zaXN0IG9mXG4gICAgICAgICAgICAvLyBhbiBlbGVtZW50IG5hbWUsIHN1Y2ggYXMgYSB0YWcgYSBjbGFzcywgb3IgYCpgLlxuICAgICAgICAgICAgZWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSAkKC9eKD86Wy4jXVtcXHdcXC1dK3xcXCp8TWFwKS8pO1xuICAgICAgICAgICAgICAgIGlmIChlKSByZXR1cm4gbmV3IHRyZWUuRWxlbWVudChlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEF0dGFjaG1lbnRzIGFsbG93IGFkZGluZyBtdWx0aXBsZSBsaW5lcywgcG9seWdvbnMgZXRjLiB0byBhblxuICAgICAgICAgICAgLy8gb2JqZWN0LiBUaGVyZSBjYW4gb25seSBiZSBvbmUgYXR0YWNobWVudCBwZXIgc2VsZWN0b3IuXG4gICAgICAgICAgICBhdHRhY2htZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9ICQoL146OihbXFx3XFwtXSsoPzpcXC9bXFx3XFwtXSspKikvKTtcbiAgICAgICAgICAgICAgICBpZiAocykgcmV0dXJuIHNbMV07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBTZWxlY3RvcnMgYXJlIG1hZGUgb3V0IG9mIG9uZSBvciBtb3JlIEVsZW1lbnRzLCBzZWUgYWJvdmUuXG4gICAgICAgICAgICBzZWxlY3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEsIGF0dGFjaG1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGUsIGVsZW1lbnRzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGYsIGZpbHRlcnMgPSBuZXcgdHJlZS5GaWx0ZXJzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgeiwgem9vbXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVfb2Zmc2V0ID0gdHJlZS5GcmFtZU9mZnNldC5ub25lO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IDAsIGNvbmRpdGlvbnMgPSAwO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGUgPSAkKHRoaXMuZWxlbWVudCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoeiA9ICQodGhpcy56b29tKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChmbyA9ICQodGhpcy5mcmFtZV9vZmZzZXQpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGYgPSAkKHRoaXMuZmlsdGVyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChhID0gJCh0aGlzLmF0dGFjaG1lbnQpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgem9vbXMucHVzaCh6KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVfb2Zmc2V0ID0gZm87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGZpbHRlcnMuYWRkKGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGkgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0YWNobWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRW5jb3VudGVyZWQgc2Vjb25kIGF0dGFjaG1lbnQgbmFtZS4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ3snIHx8IGMgPT09ICd9JyB8fCBjID09PSAnOycgfHwgYyA9PT0gJywnKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5TZWxlY3RvcihmaWx0ZXJzLCB6b29tcywgZnJhbWVfb2Zmc2V0LCBlbGVtZW50cywgYXR0YWNobWVudCwgY29uZGl0aW9ucywgbWVtbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleSwgb3AsIHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoISAkKCdbJykpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID0gJCgvXlthLXpBLVowLTlcXC1fXSsvKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMucXVvdGVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMudmFyaWFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5rZXl3b3JkKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBhdCAxLjAuMFxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgdHJlZS5RdW90ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyB0cmVlLkZpZWxkKGtleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKG9wID0gJCh0aGlzLmVudGl0aWVzLmNvbXBhcmlzb24pKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbCA9ICQodGhpcy5lbnRpdGllcy5xdW90ZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy52YXJpYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmRpbWVuc2lvbikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmtleXdvcmQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5maWVsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBjbG9zaW5nIF0gb2YgZmlsdGVyLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBtZW1vIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkuaXMpIGtleSA9IG5ldyB0cmVlLkZpZWxkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRmlsdGVyKGtleSwgb3AsIHZhbCwgbWVtbywgZW52LmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZyYW1lX29mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBvcCwgdmFsO1xuICAgICAgICAgICAgICAgIGlmICgkKC9eXFxbXFxzKmZyYW1lLW9mZnNldC9nKSAmJlxuICAgICAgICAgICAgICAgICAgICAob3AgPSAkKHRoaXMuZW50aXRpZXMuY29tcGFyaXNvbikpICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWwgPSAkKC9eXFxkKy8pKSAmJlxuICAgICAgICAgICAgICAgICAgICAkKCddJykpICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJlZS5GcmFtZU9mZnNldChvcCwgdmFsLCBtZW1vKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB6b29tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9wLCB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKCQoL15cXFtcXHMqem9vbS9nKSAmJlxuICAgICAgICAgICAgICAgICAgICAob3AgPSAkKHRoaXMuZW50aXRpZXMuY29tcGFyaXNvbikpICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWwgPSAkKHRoaXMuZW50aXRpZXMudmFyaWFibGUpIHx8ICQodGhpcy5lbnRpdGllcy5kaW1lbnNpb24pKSAmJiAkKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5ab29tKG9wLCB2YWwsIG1lbW8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gVGhlIGBibG9ja2AgcnVsZSBpcyB1c2VkIGJ5IGBydWxlc2V0YFxuICAgICAgICAgICAgLy8gSXQncyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBgcHJpbWFyeWAgcnVsZSwgd2l0aCBhZGRlZCBge31gLlxuICAgICAgICAgICAgYmxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCQoJ3snKSAmJiAoY29udGVudCA9ICQodGhpcy5wcmltYXJ5KSkgJiYgJCgnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGRpdiwgLmNsYXNzLCBib2R5ID4gcCB7Li4ufVxuICAgICAgICAgICAgcnVsZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9ycyA9IFtdLCBzLCBmLCBsLCBydWxlcywgZmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIHNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChzID0gJCh0aGlzLnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChzKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCQodGhpcy5jb21tZW50KSkge31cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgkKHRoaXMuY29tbWVudCkpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgkKHRoaXMuY29tbWVudCkpIHt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPiAwICYmIChydWxlcyA9ICQodGhpcy5ibG9jaykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNbMF0uZWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNbMF0uZWxlbWVudHNbMF0udmFsdWUgPT09ICdNYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnMgPSBuZXcgdHJlZS5SdWxlc2V0KHNlbGVjdG9ycywgcnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnMuaXNNYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5SdWxlc2V0KHNlbGVjdG9ycywgcnVsZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcnVsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUsIHZhbHVlLCBjID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHNhdmUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnLicgfHwgYyA9PT0gJyMnKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPSAkKHRoaXMudmFyaWFibGUpIHx8ICQodGhpcy5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkKHRoaXMudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAkKHRoaXMuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlJ1bGUobmFtZSwgdmFsdWUsIG1lbW8sIGVudi5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmb250OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBbXSwgZXhwcmVzc2lvbiA9IFtdLCB3ZWlnaHQsIGZvbnQsIGU7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZSA9ICQodGhpcy5lbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKG5ldyB0cmVlLkV4cHJlc3Npb24oZXhwcmVzc2lvbikpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCQoJywnKSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZSA9ICQodGhpcy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghICQoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5WYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBIFZhbHVlIGlzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgRXhwcmVzc2lvbnNcbiAgICAgICAgICAgIC8vIEluIGEgUnVsZSwgYSBWYWx1ZSByZXByZXNlbnRzIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGA6YCxcbiAgICAgICAgICAgIC8vIGFuZCBiZWZvcmUgdGhlIGA7YC5cbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgZXhwcmVzc2lvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChlID0gJCh0aGlzLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghICQoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5WYWx1ZShleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWUoZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBBIHN1Yi1leHByZXNzaW9uLCBjb250YWluZWQgYnkgcGFyZW50aGVuc2lzXG4gICAgICAgICAgICBzdWI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCQoJygnKSAmJiAoZSA9ICQodGhpcy5leHByZXNzaW9uKSkgJiYgJCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWlzbm9tZXIgYmVjYXVzZSBpdCBhY3R1YWxseSBoYW5kbGVzIG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAgICAvLyBhbmQgZGl2aXNpb24uXG4gICAgICAgICAgICBtdWx0aXBsaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIGEsIG9wLCBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKG0gPSAkKHRoaXMub3BlcmFuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChvcCA9ICgkKCcvJykgfHwgJCgnKicpIHx8ICQoJyUnKSkpICYmIChhID0gJCh0aGlzLm9wZXJhbmQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3IHRyZWUuT3BlcmF0aW9uKG9wLCBbb3BlcmF0aW9uIHx8IG0sIGFdLCBtZW1vKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uIHx8IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZGl0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgYSwgb3AsIG9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobSA9ICQodGhpcy5tdWx0aXBsaWNhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChvcCA9ICQoL15bLStdXFxzKy8pIHx8IChpbnB1dC5jaGFyQXQoaSAtIDEpICE9ICcgJyAmJiAoJCgnKycpIHx8ICQoJy0nKSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGEgPSAkKHRoaXMubXVsdGlwbGljYXRpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3IHRyZWUuT3BlcmF0aW9uKG9wLCBbb3BlcmF0aW9uIHx8IG0sIGFdLCBtZW1vKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uIHx8IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQW4gb3BlcmFuZCBpcyBhbnl0aGluZyB0aGF0IGNhbiBiZSBwYXJ0IG9mIGFuIG9wZXJhdGlvbixcbiAgICAgICAgICAgIC8vIHN1Y2ggYXMgYSBDb2xvciwgb3IgYSBWYXJpYWJsZVxuICAgICAgICAgICAgb3BlcmFuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcy5zdWIpIHx8ICQodGhpcy5lbnRpdHkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRXhwcmVzc2lvbnMgZWl0aGVyIHJlcHJlc2VudCBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyxcbiAgICAgICAgICAgIC8vIG9yIHdoaXRlLXNwYWNlIGRlbGltaXRlZCBFbnRpdGllcy4gIEB2YXIgKiAyXG4gICAgICAgICAgICBleHByZXNzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgZGVsaW0sIGVudGl0aWVzID0gW10sIGQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZSA9ICQodGhpcy5hZGRpdGlvbikgfHwgJCh0aGlzLmVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50aXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRXhwcmVzc2lvbihlbnRpdGllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICQoL14oKFthLXpdWy1hLXpfMC05XSpcXC8pP1xcKj8tP1stYS16XzAtOV0rKVxccyo6Lyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHJldHVybiBuYW1lWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VyO1xufTtcbiIsInZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGNhcnRvID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jYXJ0by5SZW5kZXJlciA9IGZ1bmN0aW9uIFJlbmRlcmVyKGVudiwgb3B0aW9ucykge1xuICAgIHRoaXMuZW52ID0gZW52IHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5vcHRpb25zLm1hcG5pa192ZXJzaW9uID0gdGhpcy5vcHRpb25zLm1hcG5pa192ZXJzaW9uIHx8ICczLjAuMCc7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgYSBNU1MgZG9jdW1lbnQgKGdpdmVuIGFzIGFuIHN0cmluZykgaW50byBhXG4gKiBYTUwgU3R5bGUgZnJhZ21lbnQgKG1vc3RseSB1c2VmdWwgZm9yIGRlYnVnZ2luZylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0aGUgbXNzIGNvbnRlbnRzIGFzIGEgc3RyaW5nLlxuICovXG5jYXJ0by5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyTVNTID0gZnVuY3Rpb24gcmVuZGVyKGRhdGEpIHtcbiAgICAvLyBlZmZlY3RzIGlzIGEgY29udGFpbmVyIGZvciBzaWRlLWVmZmVjdHMsIHdoaWNoIGN1cnJlbnRseVxuICAgIC8vIGFyZSBsaW1pdGVkIHRvIEZvbnRTZXRzLlxuICAgIHZhciBlbnYgPSBfKHRoaXMuZW52KS5kZWZhdWx0cyh7XG4gICAgICAgIGJlbmNobWFyazogZmFsc2UsXG4gICAgICAgIHZhbGlkYXRpb25fZGF0YTogZmFsc2UsXG4gICAgICAgIGVmZmVjdHM6IFtdXG4gICAgfSk7XG5cbiAgICBpZiAoIWNhcnRvLnRyZWUuUmVmZXJlbmNlLnNldFZlcnNpb24odGhpcy5vcHRpb25zLm1hcG5pa192ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2V0IG1hcG5payB2ZXJzaW9uIHRvIFwiICsgdGhpcy5vcHRpb25zLm1hcG5pa192ZXJzaW9uKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIHN0eWxlcyA9IFtdO1xuXG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZSgnUGFyc2luZyBNU1MnKTtcbiAgICB2YXIgcGFyc2VyID0gKGNhcnRvLlBhcnNlcihlbnYpKS5wYXJzZShkYXRhKTtcbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lRW5kKCdQYXJzaW5nIE1TUycpO1xuXG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZSgnUnVsZSBnZW5lcmF0aW9uJyk7XG4gICAgdmFyIHJ1bGVfbGlzdCA9IHBhcnNlci50b0xpc3QoZW52KTtcbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lRW5kKCdSdWxlIGdlbmVyYXRpb24nKTtcblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWUoJ1J1bGUgaW5oZXJpdGFuY2UnKTtcbiAgICB2YXIgcnVsZXMgPSBpbmhlcml0RGVmaW5pdGlvbnMocnVsZV9saXN0LCBlbnYpO1xuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWVFbmQoJ1J1bGUgaW5oZXJpdGFuY2UnKTtcblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWUoJ1N0eWxlIHNvcnQnKTtcbiAgICB2YXIgc29ydGVkID0gc29ydFN0eWxlcyhydWxlcyxlbnYpO1xuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWVFbmQoJ1N0eWxlIHNvcnQnKTtcblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWUoJ1RvdGFsIFN0eWxlIGdlbmVyYXRpb24nKTtcbiAgICBmb3IgKHZhciBrID0gMCwgcnVsZSwgc3R5bGVfbmFtZTsgayA8IHNvcnRlZC5sZW5ndGg7IGsrKykge1xuICAgICAgICBydWxlID0gc29ydGVkW2tdO1xuICAgICAgICBzdHlsZV9uYW1lID0gJ3N0eWxlJyArIChydWxlLmF0dGFjaG1lbnQgIT09ICdfX2RlZmF1bHRfXycgPyAnLScgKyBydWxlLmF0dGFjaG1lbnQgOiAnJyk7XG4gICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlX25hbWUpO1xuICAgICAgICB2YXIgYmVuY2hfbmFtZSA9ICdcXHRTdHlsZSBcIicrc3R5bGVfbmFtZSsnXCIgKCMnK2srJykgdG9YTUwnO1xuICAgICAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lKGJlbmNoX25hbWUpO1xuICAgICAgICAvLyBlbnYuZWZmZWN0cyBjYW4gYmUgbW9kaWZpZWQgYnkgdGhpcyBjYWxsXG4gICAgICAgIG91dHB1dC5wdXNoKGNhcnRvLnRyZWUuU3R5bGVYTUwoc3R5bGVfbmFtZSwgcnVsZS5hdHRhY2htZW50LCBydWxlLCBlbnYpKTtcbiAgICAgICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZUVuZChiZW5jaF9uYW1lKTtcbiAgICB9XG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZUVuZCgnVG90YWwgU3R5bGUgZ2VuZXJhdGlvbicpO1xuICAgIGlmIChlbnYuZXJyb3JzKSB0aHJvdyBlbnYuZXJyb3JzO1xuICAgIHJldHVybiBvdXRwdXQuam9pbignXFxuJyk7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgYSBNTUwgZG9jdW1lbnQgKGdpdmVuIGFzIGFuIG9iamVjdCkgaW50byBhXG4gKiBmdWxseS1sb2NhbGl6ZWQgWE1MIGZpbGUgcmVhZHkgZm9yIE1hcG5pazIgY29uc3VtcHRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbSAtIHRoZSBKU09OIGZpbGUgYXMgYSBzdHJpbmcuXG4gKi9cbmNhcnRvLlJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIobSkge1xuICAgIC8vIGVmZmVjdHMgaXMgYSBjb250YWluZXIgZm9yIHNpZGUtZWZmZWN0cywgd2hpY2ggY3VycmVudGx5XG4gICAgLy8gYXJlIGxpbWl0ZWQgdG8gRm9udFNldHMuXG4gICAgdmFyIGVudiA9IF8odGhpcy5lbnYpLmRlZmF1bHRzKHtcbiAgICAgICAgYmVuY2htYXJrOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGlvbl9kYXRhOiBmYWxzZSxcbiAgICAgICAgZWZmZWN0czogW10sXG4gICAgICAgIHBwaTogOTAuNzE0XG4gICAgfSk7XG5cbiAgICBpZiAoIWNhcnRvLnRyZWUuUmVmZXJlbmNlLnNldFZlcnNpb24odGhpcy5vcHRpb25zLm1hcG5pa192ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2V0IG1hcG5payB2ZXJzaW9uIHRvIFwiICsgdGhpcy5vcHRpb25zLm1hcG5pa192ZXJzaW9uKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICAvLyBUcmFuc2Zvcm0gc3R5bGVzaGVldHMgaW50byBkZWZpbml0aW9ucy5cbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBfKG0uU3R5bGVzaGVldCkuY2hhaW4oKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxlc2hlZXQgb2JqZWN0IGlzIGV4cGVjdGVkIG5vdCBhIHN0cmluZzogJ1wiICsgcyArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVudmlyb25tZW50IGZyb20gc3R5bGVzaGVldCB0byBzdHlsZXNoZWV0LFxuICAgICAgICAgICAgLy8gYWxsb3dzIGZyYW1lcyBhbmQgZWZmZWN0cyB0byBiZSBtYWludGFpbmVkLlxuICAgICAgICAgICAgZW52ID0gXyhlbnYpLmV4dGVuZCh7ZmlsZW5hbWU6cy5pZH0pO1xuXG4gICAgICAgICAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHJvb3QgPSAoY2FydG8uUGFyc2VyKGVudikpLnBhcnNlKHMuZGF0YSk7XG4gICAgICAgICAgICBpZiAoZW52LmJlbmNobWFyaylcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcnNpbmcgdGltZTogJyArIChuZXcgRGF0ZSgpIC0gdGltZSkgKyAnbXMnKTtcbiAgICAgICAgICAgIHJldHVybiByb290LnRvTGlzdChlbnYpO1xuICAgICAgICB9KVxuICAgICAgICAuZmxhdHRlbigpXG4gICAgICAgIC52YWx1ZSgpO1xuXG4gICAgZnVuY3Rpb24gYXBwbGllc1RvKG5hbWUsIGNsYXNzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLmFwcGxpZXNUbyhsLm5hbWUsIGNsYXNzSW5kZXgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsYXllcnMgYW5kIGNyZWF0ZSBzdHlsZXMgY3VzdG9tLWJ1aWx0XG4gICAgLy8gZm9yIGVhY2ggb2YgdGhlbSwgYW5kIGFwcGx5IHRob3NlIHN0eWxlcyB0byB0aGUgbGF5ZXJzLlxuICAgIHZhciBzdHlsZXMsIGwsIGNsYXNzSW5kZXgsIHJ1bGVzLCBzb3J0ZWQsIG1hdGNoaW5nO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5MYXllci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsID0gbS5MYXllcltpXTtcbiAgICAgICAgc3R5bGVzID0gW107XG4gICAgICAgIGNsYXNzSW5kZXggPSB7fTtcblxuICAgICAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS53YXJuKCdwcm9jZXNzaW5nIGxheWVyOiAnICsgbC5pZCk7XG4gICAgICAgIC8vIENsYXNzZXMgYXJlIGdpdmVuIGFzIHNwYWNlLXNlcGFyYXRlZCBhbHBoYW51bWVyaWMgc3RyaW5ncy5cbiAgICAgICAgdmFyIGNsYXNzZXMgPSAobFsnY2xhc3MnXSB8fCAnJykuc3BsaXQoL1xccysvZyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY2xhc3NJbmRleFtjbGFzc2VzW2pdXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hpbmcgPSBkZWZpbml0aW9ucy5maWx0ZXIoYXBwbGllc1RvKGwubmFtZSwgY2xhc3NJbmRleCkpO1xuICAgICAgICBydWxlcyA9IGluaGVyaXREZWZpbml0aW9ucyhtYXRjaGluZywgZW52KTtcbiAgICAgICAgc29ydGVkID0gc29ydFN0eWxlcyhydWxlcywgZW52KTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMCwgcnVsZSwgc3R5bGVfbmFtZTsgayA8IHNvcnRlZC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgcnVsZSA9IHNvcnRlZFtrXTtcbiAgICAgICAgICAgIHN0eWxlX25hbWUgPSBsLm5hbWUgKyAocnVsZS5hdHRhY2htZW50ICE9PSAnX19kZWZhdWx0X18nID8gJy0nICsgcnVsZS5hdHRhY2htZW50IDogJycpO1xuXG4gICAgICAgICAgICAvLyBlbnYuZWZmZWN0cyBjYW4gYmUgbW9kaWZpZWQgYnkgdGhpcyBjYWxsXG4gICAgICAgICAgICB2YXIgc3R5bGVYTUwgPSBjYXJ0by50cmVlLlN0eWxlWE1MKHN0eWxlX25hbWUsIHJ1bGUuYXR0YWNobWVudCwgcnVsZSwgZW52KTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlWE1MKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3R5bGVYTUwpO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnB1c2goY2FydG8udHJlZS5MYXllclhNTChsLCBzdHlsZXMpKTtcbiAgICB9XG5cbiAgICBvdXRwdXQudW5zaGlmdChlbnYuZWZmZWN0cy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS50b1hNTChlbnYpO1xuICAgIH0pLmpvaW4oJ1xcbicpKTtcblxuICAgIHZhciBtYXBfcHJvcGVydGllcyA9IGdldE1hcFByb3BlcnRpZXMobSwgZGVmaW5pdGlvbnMsIGVudik7XG5cbiAgICAvLyBFeGl0IG9uIGVycm9ycy5cbiAgICBpZiAoZW52LmVycm9ycykgdGhyb3cgZW52LmVycm9ycztcblxuICAgIC8vIFBhc3MgVGlsZUpTT04gYW5kIG90aGVyIGN1c3RvbSBwYXJhbWV0ZXJzIHRocm91Z2ggdG8gTWFwbmlrIFhNTC5cbiAgICB2YXIgcGFyYW1ldGVycyA9IF8obSkucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIHYsIGspIHtcbiAgICAgICAgaWYgKCF2ICYmIHYgIT09IDApIHJldHVybiBtZW1vO1xuXG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAvLyBLbm93biBza2lwcGFibGUgcHJvcGVydGllcy5cbiAgICAgICAgY2FzZSAnc3JzJzpcbiAgICAgICAgY2FzZSAnTGF5ZXInOlxuICAgICAgICBjYXNlICdTdHlsZXNoZWV0JzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBOb24gVVJMLWJvdW5kIFRpbGVKU09OIHByb3BlcnRpZXMuXG4gICAgICAgIGNhc2UgJ2JvdW5kcyc6XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGNhc2UgJ21pbnpvb20nOlxuICAgICAgICBjYXNlICdtYXh6b29tJzpcbiAgICAgICAgY2FzZSAndmVyc2lvbic6XG4gICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+JyArIHYgKyAnPC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgQ0RBVEEuXG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICBjYXNlICdkZXNjcmlwdGlvbic6XG4gICAgICAgIGNhc2UgJ2xlZ2VuZCc6XG4gICAgICAgIGNhc2UgJ2F0dHJpYnV0aW9uJzpcbiAgICAgICAgY2FzZSAndGVtcGxhdGUnOlxuICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cIicgKyBrICsgJ1wiPjwhW0NEQVRBWycgKyB2ICsgJ11dPjwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1hcG5payBpbWFnZSBmb3JtYXQuXG4gICAgICAgIGNhc2UgJ2Zvcm1hdCc6XG4gICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+JyArIHYgKyAnPC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gTWFwbmlrIGludGVyYWN0aXZpdHkgc2V0dGluZ3MuXG4gICAgICAgIGNhc2UgJ2ludGVyYWN0aXZpdHknOlxuICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cImludGVyYWN0aXZpdHlfbGF5ZXJcIj4nICsgdi5sYXllciArICc8L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIG1lbW8ucHVzaCgnICA8UGFyYW1ldGVyIG5hbWU9XCJpbnRlcmFjdGl2aXR5X2ZpZWxkc1wiPicgKyB2LmZpZWxkcyArICc8L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTdXBwb3J0IGFueSBhZGRpdGlvbmFsIHNjYWxhciBwcm9wZXJ0aWVzLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICAgIG1lbW8ucHVzaCgnICA8UGFyYW1ldGVyIG5hbWU9XCInICsgayArICdcIj48IVtDREFUQVsnICsgdiArICddXT48L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ251bWJlcicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cIicgKyBrICsgJ1wiPicgKyB2ICsgJzwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cIicgKyBrICsgJ1wiPicgKyB2ICsgJzwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgW10pO1xuICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCkgb3V0cHV0LnVuc2hpZnQoXG4gICAgICAgICc8UGFyYW1ldGVycz5cXG4nICtcbiAgICAgICAgcGFyYW1ldGVycy5qb2luKCdcXG4nKSArXG4gICAgICAgICdcXG48L1BhcmFtZXRlcnM+XFxuJ1xuICAgICk7XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IF8obWFwX3Byb3BlcnRpZXMpLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiAnICcgKyB2OyB9KS5qb2luKCcnKTtcblxuICAgIG91dHB1dC51bnNoaWZ0KFxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiICcgK1xuICAgICAgICAnZW5jb2Rpbmc9XCJ1dGYtOFwiPz5cXG4nICtcbiAgICAgICAgJzwhRE9DVFlQRSBNYXBbXT5cXG4nICtcbiAgICAgICAgJzxNYXAnICsgcHJvcGVydGllcyArJz5cXG4nKTtcbiAgICBvdXRwdXQucHVzaCgnPC9NYXA+Jyk7XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjdXJyZW50bHkgbW9kaWZpZXMgJ2N1cnJlbnQnXG4gKiBAcGFyYW0ge0FycmF5fSAgY3VycmVudCAgY3VycmVudCBsaXN0IG9mIHJ1bGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBhIERlZmluaXRpb24gb2JqZWN0IHRvIGFkZCB0byB0aGUgcnVsZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBieUZpbHRlciBhbiBvYmplY3QvZGljdGlvbmFyeSBvZiBleGlzdGluZyBmaWx0ZXJzLiBUaGlzIGlzXG4gKiBhY3R1YWxseSBrZXllZCBgYXR0YWNobWVudC0+ZmlsdGVyYFxuICogQHBhcmFtIHtPYmplY3R9IGVudiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuKi9cbmZ1bmN0aW9uIGFkZFJ1bGVzKGN1cnJlbnQsIGRlZmluaXRpb24sIGJ5RmlsdGVyLCBlbnYpIHtcbiAgICB2YXIgbmV3RmlsdGVycyA9IGRlZmluaXRpb24uZmlsdGVycyxcbiAgICAgICAgbmV3UnVsZXMgPSBkZWZpbml0aW9uLnJ1bGVzLFxuICAgICAgICB1cGRhdGVkRmlsdGVycywgY2xvbmUsIHByZXZpb3VzO1xuXG4gICAgLy8gVGhlIGN1cnJlbnQgZGVmaW5pdGlvbiBtaWdodCBoYXZlIGJlZW4gc3BsaXQgdXAgaW50b1xuICAgIC8vIG11bHRpcGxlIGRlZmluaXRpb25zIGFscmVhZHkuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBjdXJyZW50Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzID0gY3VycmVudFtrXS5maWx0ZXJzLmNsb25lV2l0aChuZXdGaWx0ZXJzKTtcbiAgICAgICAgaWYgKHVwZGF0ZWRGaWx0ZXJzKSB7XG4gICAgICAgICAgICBwcmV2aW91cyA9IGJ5RmlsdGVyW3VwZGF0ZWRGaWx0ZXJzXTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIGRlZmluaXRpb24gd2l0aCB0aG9zZSBleGFjdFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcnMuIEFkZCB0aGUgY3VycmVudCBkZWZpbml0aW9ucycgcnVsZXNcbiAgICAgICAgICAgICAgICAvLyBhbmQgc3RvcCBwcm9jZXNzaW5nIGl0IGFzIHRoZSBleGlzdGluZyBydWxlXG4gICAgICAgICAgICAgICAgLy8gaGFzIGFscmVhZHkgZ29uZSBkb3duIHRoZSBpbmhlcml0YW5jZSBjaGFpbi5cbiAgICAgICAgICAgICAgICBwcmV2aW91cy5hZGRSdWxlcyhuZXdSdWxlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb25lID0gY3VycmVudFtrXS5jbG9uZSh1cGRhdGVkRmlsdGVycyk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgb25seSBtYWludGFpbmluZyB0aGUgY2xvbmVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIGRpZCBhY3R1YWxseSBhZGQgcnVsZXMuIElmIG5vdCwgdGhlcmUnc1xuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8ga2VlcCB0aGUgY2xvbmUgYXJvdW5kLlxuICAgICAgICAgICAgICAgIGlmIChjbG9uZS5hZGRSdWxlcyhuZXdSdWxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaW5zZXJ0ZWQgYW4gZWxlbWVudCBiZWZvcmUgdGhpcyBvbmUsIHNvIHdlIG5lZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoYXQgaW4gdGhlIG5leHQgbG9vcCBpdGVyYXRpb24sIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBwZXJmb3JtaW5nIHRoZSBzYW1lIHRhc2sgZm9yIHRoaXMgZWxlbWVudCBhZ2FpbixcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVuY2UgdGhlIGsrKy5cbiAgICAgICAgICAgICAgICAgICAgYnlGaWx0ZXJbdXBkYXRlZEZpbHRlcnNdID0gY2xvbmU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGssIDAsIGNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGVkRmlsdGVycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaWYgdXBkYXRlZEZpbHRlcnMgaXMgbnVsbCwgdGhlbiBhZGRpbmcgdGhlIGZpbHRlcnMgZG9lc24ndFxuICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSBvciBzcGxpdCB0aGUgc2VsZWN0b3IsIHNvIHdlIGFkZFJ1bGVzIHRvIHRoZVxuICAgICAgICAgICAgLy8gY29tYmluZWQgc2VsZWN0b3JcblxuICAgICAgICAgICAgLy8gRmlsdGVycyBjYW4gYmUgYWRkZWQsIGJ1dCB0aGV5IGRvbid0IGNoYW5nZSB0aGVcbiAgICAgICAgICAgIC8vIGZpbHRlcnMuIFRoaXMgbWVhbnMgd2UgZG9uJ3QgaGF2ZSB0byBzcGxpdCB0aGVcbiAgICAgICAgICAgIC8vIGRlZmluaXRpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBjbG9uZWQgaGVyZSBiZWNhdXNlIG9mIHNoYXJlZCBjbGFzc2VzLCBzZWVcbiAgICAgICAgICAgIC8vIHNoYXJlZGNsYXNzLm1zc1xuICAgICAgICAgICAgY3VycmVudFtrXSA9IGN1cnJlbnRba10uY2xvbmUoKTtcbiAgICAgICAgICAgIGN1cnJlbnRba10uYWRkUnVsZXMobmV3UnVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHVwZGF0ZWRGZWF0dXJlcyBpcyBmYWxzZSwgdGhlbiB0aGUgZmlsdGVycyBzcGxpdCB0aGUgcnVsZSxcbiAgICAgICAgLy8gc28gdGhleSBhcmVuJ3QgdGhlIHNhbWUgaW5oZXJpdGFuY2UgY2hhaW5cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8qKlxuICogQXBwbHkgaW5oZXJpdGVkIHN0eWxlcyBmcm9tIHRoZWlyIGFuY2VzdG9ycyB0byB0aGVtLlxuICpcbiAqIGNhbGxlZCBlaXRoZXIgb25jZSBwZXIgcmVuZGVyIChpbiB0aGUgY2FzZSBvZiBtc3MpIG9yIHBlciBsYXllclxuICogKGZvciBtbWwpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb25zIC0gYSBsaXN0IG9mIGRlZmluaXRpb25zIG9iamVjdHNcbiAqICAgdGhhdCBjb250YWluIC5ydWxlc1xuICogQHBhcmFtIHtPYmplY3R9IGVudiAtIHRoZSBlbnZpcm9ubWVudFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk+fSBhbiBhcnJheSBvZiBhcnJheXMgaXMgcmV0dXJuZWQsXG4gKiAgIGluIHdoaWNoIGVhY2ggYXJyYXkgcmVmZXJzIHRvIGEgc3BlY2lmaWMgYXR0YWNobWVudFxuICovXG5mdW5jdGlvbiBpbmhlcml0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIGVudikge1xuICAgIHZhciBpbmhlcml0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIC8vIGRlZmluaXRpb25zIGFyZSBvcmRlcmVkIGJ5IHNwZWNpZmljaXR5LFxuICAgIC8vIGhpZ2ggKGluZGV4IDApIHRvIGxvd1xuICAgIHZhciBieUF0dGFjaG1lbnQgPSB7fSxcbiAgICAgICAgYnlGaWx0ZXIgPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGN1cnJlbnQsIHByZXZpb3VzLCBhdHRhY2htZW50O1xuXG4gICAgLy8gRXZhbHVhdGUgdGhlIGZpbHRlcnMgc3BlY2lmaWVkIGJ5IGVhY2ggZGVmaW5pdGlvbiB3aXRoIHRoZSBnaXZlblxuICAgIC8vIGVudmlyb25tZW50IHRvIGNvcnJlY3RseSByZXNvbHZlIHZhcmlhYmxlIHJlZmVyZW5jZXNcbiAgICBkZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZC5maWx0ZXJzLmV2KGVudik7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmluaXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgYXR0YWNobWVudCA9IGRlZmluaXRpb25zW2ldLmF0dGFjaG1lbnQ7XG4gICAgICAgIGN1cnJlbnQgPSBbZGVmaW5pdGlvbnNbaV1dO1xuXG4gICAgICAgIGlmICghYnlBdHRhY2htZW50W2F0dGFjaG1lbnRdKSB7XG4gICAgICAgICAgICBieUF0dGFjaG1lbnRbYXR0YWNobWVudF0gPSBbXTtcbiAgICAgICAgICAgIGJ5QXR0YWNobWVudFthdHRhY2htZW50XS5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgIGJ5RmlsdGVyW2F0dGFjaG1lbnRdID0ge307XG4gICAgICAgICAgICByZXN1bHQucHVzaChieUF0dGFjaG1lbnRbYXR0YWNobWVudF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBzdWJzZXF1ZW50IHJ1bGVzLlxuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBkZWZpbml0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zW2pdLmF0dGFjaG1lbnQgPT09IGF0dGFjaG1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGluaGVyaXQgcnVsZXMgZnJvbSB0aGUgc2FtZSBhdHRhY2htZW50LlxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhZGRSdWxlcyhjdXJyZW50LCBkZWZpbml0aW9uc1tqXSwgYnlGaWx0ZXJbYXR0YWNobWVudF0sIGVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGN1cnJlbnQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGJ5RmlsdGVyW2F0dGFjaG1lbnRdW2N1cnJlbnRba10uZmlsdGVyc10gPSBjdXJyZW50W2tdO1xuICAgICAgICAgICAgYnlBdHRhY2htZW50W2F0dGFjaG1lbnRdLnB1c2goY3VycmVudFtrXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS53YXJuKCdJbmhlcml0YW5jZSB0aW1lOiAnICsgKChuZXcgRGF0ZSgpIC0gaW5oZXJpdFRpbWUpKSArICdtcycpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufVxuXG4vLyBTb3J0IHN0eWxlcyBieSB0aGUgbWluaW11bSBpbmRleCBvZiB0aGVpciBydWxlcy5cbi8vIFRoaXMgc29ydHMgYSBzbGljZSBvZiB0aGUgc3R5bGVzLCBzbyBpdCByZXR1cm5zIGEgc29ydGVkXG4vLyBhcnJheSBidXQgZG9lcyBub3QgY2hhbmdlIHRoZSBpbnB1dC5cbmZ1bmN0aW9uIHNvcnRTdHlsZXNJbmRleChhLCBiKSB7IHJldHVybiBiLmluZGV4IC0gYS5pbmRleDsgfVxuZnVuY3Rpb24gc29ydFN0eWxlcyhzdHlsZXMsIGVudikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgc3R5bGUuaW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBzdHlsZS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gc3R5bGVbYl0ucnVsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJ1bGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tyXTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pbmRleCA8IHN0eWxlLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmluZGV4ID0gcnVsZS5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gc3R5bGVzLnNsaWNlKCk7XG4gICAgcmVzdWx0LnNvcnQoc29ydFN0eWxlc0luZGV4KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgYSBydWxlIGxpa2UgTWFwIHsgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjsgfSxcbiAqIGlmIGFueSwgYW5kIHJldHVybiBhIGxpc3Qgb2YgcHJvcGVydGllcyB0byBiZSBpbnNlcnRlZFxuICogaW50byB0aGUgPE1hcCBlbGVtZW50IG9mIHRoZSByZXN1bHRpbmcgWE1MLiBUcmFuc2xhdGVzXG4gKiBwcm9wZXJ0aWVzIG9mIHRoZSBtbWwgb2JqZWN0IGF0IGBtYCBkaXJlY3RseSBpbnRvIFhNTFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbSB0aGUgbW1sIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmluaXRpb25zIHRoZSBvdXRwdXQgb2YgdG9MaXN0LlxuICogQHBhcmFtIHtPYmplY3R9IGVudlxuICogQHJldHVybiB7U3RyaW5nfSByZW5kZXJlZCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRNYXBQcm9wZXJ0aWVzKG0sIGRlZmluaXRpb25zLCBlbnYpIHtcbiAgICB2YXIgcnVsZXMgPSB7fTtcbiAgICB2YXIgc3ltYm9saXplcnMgPSBjYXJ0by50cmVlLlJlZmVyZW5jZS5kYXRhLnN5bWJvbGl6ZXJzLm1hcDtcblxuICAgIF8obSkuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gc3ltYm9saXplcnMpIHJ1bGVzW2tleV0gPSBrZXkgKyAnPVwiJyArIHZhbHVlICsgJ1wiJztcbiAgICB9KTtcblxuICAgIGRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiByLmVsZW1lbnRzLmpvaW4oJycpID09PSAnTWFwJztcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gci5ydWxlc1tpXS5uYW1lO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHN5bWJvbGl6ZXJzKSkge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSdWxlICcgKyBrZXkgKyAnIG5vdCBhbGxvd2VkIGZvciBNYXAuJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHIucnVsZXNbaV0uaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bGVzW2tleV0gPSByLnJ1bGVzW2ldLmV2KGVudikudG9YTUwoZW52KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBydWxlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXJ0bztcbm1vZHVsZS5leHBvcnRzLmFkZFJ1bGVzID0gYWRkUnVsZXM7XG5tb2R1bGUuZXhwb3J0cy5pbmhlcml0RGVmaW5pdGlvbnMgPSBpbmhlcml0RGVmaW5pdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5zb3J0U3R5bGVzID0gc29ydFN0eWxlcztcbiIsIihmdW5jdGlvbihjYXJ0bykge1xudmFyIHRyZWUgPSByZXF1aXJlKCcuL3RyZWUnKTtcbnZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cbmZ1bmN0aW9uIENhcnRvQ1NTKHN0eWxlLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuaW1hZ2VVUkxzID0gW107XG4gIGlmKHN0eWxlKSB7XG4gICAgdGhpcy5zZXRTdHlsZShzdHlsZSk7XG4gIH1cbn1cblxuQ2FydG9DU1MuTGF5ZXIgPSBmdW5jdGlvbihzaGFkZXIsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XG59O1xuXG5cbkNhcnRvQ1NTLkxheWVyLnByb3RvdHlwZSA9IHtcblxuICBmdWxsTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLmF0dGFjaG1lbnQ7XG4gIH0sXG5cbiAgbmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbE5hbWUoKS5zcGxpdCgnOjonKVswXTtcbiAgfSxcblxuICAvLyBmcmFtZXMgdGhpcyBsYXllciBuZWVkIHRvIGJlIHJlbmRlcmVkXG4gIGZyYW1lczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLmZyYW1lcztcbiAgfSxcblxuICBhdHRhY2htZW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsTmFtZSgpLnNwbGl0KCc6OicpWzFdO1xuICB9LFxuXG4gIGV2YWw6IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB2YXIgcCA9IHRoaXMuc2hhZGVyW3Byb3BdO1xuICAgIGlmICghcCB8fCAhcC5zdHlsZSkgcmV0dXJuO1xuICAgIHJldHVybiBwLnN0eWxlKHt9LCB7IHpvb206IDAsICdmcmFtZS1vZmZzZXQnOiAwIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIGBwcm9wc2A6IGZlYXR1cmUgcHJvcGVydGllc1xuICAgKiBgY29udGV4dGA6IHJlbmRlcmluZyBwcm9wZXJ0aWVzLCBpLmUgem9vbVxuICAgKi9cbiAgZ2V0U3R5bGU6IGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgZm9yKHZhciBpIGluIHRoaXMuc2hhZGVyKSB7XG4gICAgICBpZihpICE9PSAnYXR0YWNobWVudCcgJiYgaSAhPT0gJ3pvb20nICYmIGkgIT09ICdmcmFtZXMnICYmIGkgIT09ICdzeW1ib2xpemVycycpIHtcbiAgICAgICAgc3R5bGVbaV0gPSB0aGlzLnNoYWRlcltpXS5zdHlsZShwcm9wcywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBzeW1ib2xpemVycyB0aGF0IG5lZWQgdG8gYmUgcmVuZGVyZWQgd2l0aCBcbiAgICogdGhpcyBzdHlsZS4gVGhlIG9yZGVyIGlzIHRoZSByZW5kZXJpbmcgb3JkZXIuXG4gICAqIEByZXR1cm5zIGEgbGlzdCB3aXRoIDMgcG9zc2libGUgdmFsdWVzICdsaW5lJywgJ21hcmtlcicsICdwb2x5Z29uJ1xuICAgKi9cbiAgZ2V0U3ltYm9saXplcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlci5zeW1ib2xpemVycztcbiAgfSxcblxuICAvKipcbiAgICogcmV0dXJucyBpZiB0aGUgc3R5bGUgdmFyaWVzIHdpdGggc29tZSBmZWF0dXJlIHByb3BlcnR5LlxuICAgKiBVc2VmdWwgdG8gb3B0aW1pemUgcmVuZGVyaW5nXG4gICAqL1xuICBpc1ZhcmlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIGkgaW4gdGhpcy5zaGFkZXIpIHtcbiAgICAgIGlmKGkgIT09ICdhdHRhY2htZW50JyAmJiBpICE9PSAnem9vbScgJiYgaSAhPT0gJ2ZyYW1lcycgJiYgaSAhPT0gJ3N5bWJvbGl6ZXJzJykge1xuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyW2ldLmNvbnN0YW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGdldFNoYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRydWUgaWYgYSBmZWF0dXJlIG5lZWRzIHRvIGJlIHJlbmRlcmVkXG4gICAqL1xuICBmaWx0ZXI6IGZ1bmN0aW9uKGZlYXR1cmVUeXBlLCBwcm9wcywgY29udGV4dCkge1xuICAgIGZvcih2YXIgaSBpbiB0aGlzLnNoYWRlcikge1xuICAgICB2YXIgcyA9IHRoaXMuc2hhZGVyW2ldKHByb3BzLCBjb250ZXh0KTtcbiAgICAgaWYocykge1xuICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvL1xuICAvLyBnaXZlbiBhIGdlb2VtdHJ5IHR5cGUgcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgb25lIGFjb3JkaW5nIHRoZSBDYXJ0b0NTU1xuICAvLyBGb3IgcG9pbnRzIHRoZXJlIGFyZSB0d28ga2luZCBvZiB0eXBlczogcG9pbnQgYW5kIHNwcml0ZSwgdGhlIGZpcnN0IG9uZSBcbiAgLy8gaXMgYSBjaXJjbGUsIHNlY29uZCBvbmUgaXMgYW4gaW1hZ2Ugc3ByaXRlXG4gIC8vXG4gIC8vIHRoZSBvdGhlciBnZW9tZXRyeSB0eXBlcyBhcmUgdGhlIHNhbWUgdGhhbiBnZW9qc29uIChwb2x5Z29uLCBsaW5lc3RyaW5nLi4uKVxuICAvL1xuICB0cmFuc2Zvcm1HZW9tZXRyeTogZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB0eXBlO1xuICB9LFxuXG4gIHRyYW5zZm9ybUdlb21ldHJpZXM6IGZ1bmN0aW9uKGdlb2pzb24pIHtcbiAgICByZXR1cm4gZ2VvanNvbjtcbiAgfVxuXG59O1xuXG5DYXJ0b0NTUy5wcm90b3R5cGUgPSB7XG5cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgdmFyIGxheWVycyA9IHRoaXMucGFyc2Uoc3R5bGUpO1xuICAgIGlmKCFsYXllcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnBhcnNlX2Vudi5lcnJvcnMpO1xuICAgIH1cbiAgICB0aGlzLmxheWVycyA9IGxheWVycy5tYXAoZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FydG9DU1MuTGF5ZXIoc2hhZGVyKTtcbiAgICB9KTtcbiAgfSxcblxuICBnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgfSxcblxuICBnZXREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kTGF5ZXIoeyBhdHRhY2htZW50OiAnX19kZWZhdWx0X18nIH0pO1xuICB9LFxuXG4gIGZpbmRMYXllcjogZnVuY3Rpb24od2hlcmUpIHtcbiAgICByZXR1cm4gXy5maW5kKHRoaXMubGF5ZXJzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHdoZXJlKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWVba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZih2KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHYgPSB2LmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGVyZVtrZXldICE9PSB2KSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcblxuICBfY3JlYXRlRm46IGZ1bmN0aW9uKG9wcykge1xuICAgIHZhciBib2R5ID0gb3BzLmpvaW4oJ1xcbicpO1xuICAgIGlmKHRoaXMub3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coYm9keSk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKFwiZGF0YVwiLFwiY3R4XCIsIFwidmFyIF92YWx1ZSA9IG51bGw7IFwiICsgIGJvZHkgKyBcIjsgcmV0dXJuIF92YWx1ZTsgXCIpO1xuICB9LFxuXG4gIF9jb21waWxlOiBmdW5jdGlvbihzaGFkZXIpIHtcbiAgICBpZih0eXBlb2Ygc2hhZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaGFkZXIgPSBldmFsKFwiKGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIgKyBzaGFkZXIgK1wiOyB9KSgpXCIpO1xuICAgIH1cbiAgICB0aGlzLnNoYWRlcl9zcmMgPSBzaGFkZXI7XG4gICAgZm9yKHZhciBhdHRyIGluIHNoYWRlcikge1xuICAgICAgICB2YXIgYyA9IG1hcHBlclthdHRyXTtcbiAgICAgICAgaWYoYykge1xuICAgICAgICAgICAgdGhpcy5jb21waWxlZFtjXSA9IGV2YWwoXCIoZnVuY3Rpb24oKSB7IHJldHVybiBzaGFkZXJbYXR0cl07IH0pKCk7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRJbWFnZVVSTHM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VVUkxzO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihjYXJ0b2Nzcykge1xuICAgIHZhciBwYXJzZV9lbnYgPSB7XG4gICAgICBmcmFtZXM6IFtdLFxuICAgICAgZXJyb3JzOiBbXSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChvYmopO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wYXJzZV9lbnYgPSBwYXJzZV9lbnY7XG5cbiAgICB2YXIgcnVsZXNldCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHJ1bGVzZXQgPSAobmV3IGNhcnRvLlBhcnNlcihwYXJzZV9lbnYpKS5wYXJzZShjYXJ0b2Nzcyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBhZGQgdGhlIHN0eWxlLm1zcyBzdHJpbmcgdG8gbWF0Y2ggdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgICAgcGFyc2VfZW52LmVycm9ycy5wdXNoKGUubWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmKHJ1bGVzZXQpIHtcblxuICAgICAgZnVuY3Rpb24gZGVmS2V5KGRlZikge1xuICAgICAgICByZXR1cm4gZGVmLmVsZW1lbnRzWzBdICsgXCI6OlwiICsgZGVmLmF0dGFjaG1lbnQ7XG4gICAgICB9XG4gICAgICB2YXIgZGVmcyA9IHJ1bGVzZXQudG9MaXN0KHBhcnNlX2Vudik7XG4gICAgICBkZWZzLnJldmVyc2UoKTtcbiAgICAgIC8vIGdyb3VwIGJ5IGVsZW1lbnRzWzBdLnZhbHVlOjphdHRhY2htZW50XG4gICAgICB2YXIgbGF5ZXJzID0ge307XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgdmFyIGtleSA9IGRlZktleShkZWYpO1xuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNba2V5XSA9IChsYXllcnNba2V5XSB8fCB7XG4gICAgICAgICAgc3ltYm9saXplcnM6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IodmFyIHUgPSAwOyB1PGRlZi5ydWxlcy5sZW5ndGg7IHUrKyl7XG4gICAgICAgICAgICBpZihkZWYucnVsZXNbdV0ubmFtZSA9PT0gXCJtYXJrZXItZmlsZVwiIHx8IGRlZi5ydWxlc1t1XS5uYW1lID09PSBcInBvaW50LWZpbGVcIil7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVmLnJ1bGVzW3VdLnZhbHVlLnZhbHVlWzBdLnZhbHVlWzBdLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VVUkxzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBsYXllci5mcmFtZXMgPSBbXTtcbiAgICAgICAgbGF5ZXIuem9vbSA9IHRyZWUuWm9vbS5hbGw7XG4gICAgICAgIHZhciBwcm9wcyA9IGRlZi50b0pTKHBhcnNlX2Vudik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIGNvbnNvbGUubG9nKFwicHJvcHNcIiwgcHJvcHMpO1xuICAgICAgICBmb3IodmFyIHYgaW4gcHJvcHMpIHtcbiAgICAgICAgICB2YXIgbHlyID0gbGF5ZXJbdl0gPSBsYXllclt2XSB8fCB7XG4gICAgICAgICAgICBjb25zdGFudDogZmFsc2UsXG4gICAgICAgICAgICBzeW1ib2xpemVyOiBudWxsLFxuICAgICAgICAgICAganM6IFtdLFxuICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGJ1aWxkIGphdmFzY3JpcHQgc3RhdGVtZW50c1xuICAgICAgICAgIGx5ci5qcy5wdXNoKHByb3BzW3ZdLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLmpzOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgLy8gZ2V0IHN5bWJvbGl6ZXIgZm9yIHByb3BcbiAgICAgICAgICBseXIuc3ltYm9saXplciA9IF8uZmlyc3QocHJvcHNbdl0ubWFwKGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEuc3ltYm9saXplcjsgfSkpO1xuICAgICAgICAgIC8vIHNlcmFjaCB0aGUgbWF4IGluZGV4IHRvIGtub3cgcmVuZGVyaW5nIG9yZGVyXG4gICAgICAgICAgbHlyLmluZGV4ID0gXy5tYXgocHJvcHNbdl0ubWFwKGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEuaW5kZXg7IH0pLmNvbmNhdChseXIuaW5kZXgpKTtcbiAgICAgICAgICBseXIuY29uc3RhbnQgPSAhXy5hbnkocHJvcHNbdl0ubWFwKGZ1bmN0aW9uKGEpIHsgcmV0dXJuICFhLmNvbnN0YW50OyB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9yZGVyZWRfbGF5ZXJzID0gW107XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSBjb25zb2xlLmxvZyhsYXllcnMpO1xuXG4gICAgICB2YXIgZG9uZSA9IHt9O1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRlZnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGRlZiA9IGRlZnNbaV07XG4gICAgICAgIHZhciBrID0gZGVmS2V5KGRlZik7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1trXTtcbiAgICAgICAgaWYoIWRvbmVba10pIHtcbiAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGVidWcpIGNvbnNvbGUubG9nKFwiKipcIiwgayk7XG4gICAgICAgICAgZm9yKHZhciBwcm9wIGluIGxheWVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ3pvb20nICYmIHByb3AgIT09ICdmcmFtZXMnICYmIHByb3AgIT09ICdzeW1ib2xpemVycycpIHtcbiAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRlYnVnKSBjb25zb2xlLmxvZyhcIipcIiwgcHJvcCk7XG4gICAgICAgICAgICAgIGxheWVyW3Byb3BdLnN0eWxlID0gdGhpcy5fY3JlYXRlRm4obGF5ZXJbcHJvcF0uanMpO1xuICAgICAgICAgICAgICBsYXllci5zeW1ib2xpemVycy5wdXNoKGxheWVyW3Byb3BdLnN5bWJvbGl6ZXIpO1xuICAgICAgICAgICAgICBsYXllci5zeW1ib2xpemVycyA9IF8udW5pcShsYXllci5zeW1ib2xpemVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxheWVyLmF0dGFjaG1lbnQgPSBrO1xuICAgICAgICAgIG9yZGVyZWRfbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgIGRvbmVba10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLnpvb20gfD0gZGVmLnpvb207XG4gICAgICAgIGxheWVyLmZyYW1lcy5wdXNoKGRlZi5mcmFtZV9vZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyB1bmlxIHRoZSBmcmFtZXNcbiAgICAgIGZvcihpID0gMDsgaSA8IG9yZGVyZWRfbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG9yZGVyZWRfbGF5ZXJzW2ldLmZyYW1lcyA9IF8udW5pcShvcmRlcmVkX2xheWVyc1tpXS5mcmFtZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JkZXJlZF9sYXllcnM7XG5cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuY2FydG8uUmVuZGVyZXJKUyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24gPSB0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24gfHwgJ2xhdGVzdCc7XG59O1xuXG4vLyBQcmVwYXJlIGEgamF2YXNjcmlwdCBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGxheWVyc1xuY2FydG8uUmVuZGVyZXJKUy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNhcnRvY3NzLCBjYWxsYmFjaykge1xuICAgIHZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3RvcnF1ZS1yZWZlcmVuY2UnKTtcbiAgICB0cmVlLlJlZmVyZW5jZS5zZXREYXRhKHJlZmVyZW5jZS52ZXJzaW9uLmxhdGVzdCk7XG4gICAgcmV0dXJuIG5ldyBDYXJ0b0NTUyhjYXJ0b2NzcywgdGhpcy5vcHRpb25zKTtcbn1cblxuaWYodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2FydG8uUmVuZGVyZXJKUztcbn1cblxuXG59KShyZXF1aXJlKCcuLi9jYXJ0bycpKTtcbiIsInZhciBfbWFwbmlrX3JlZmVyZW5jZV9sYXRlc3QgPSB7XG4gICAgXCJ2ZXJzaW9uXCI6IFwiMi4xLjFcIixcbiAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgXCJmaWx0ZXItbW9kZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgIFwiYWxsXCIsXG4gICAgICAgICAgICAgICAgXCJmaXJzdFwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJDb250cm9sIHRoZSBwcm9jZXNzaW5nIGJlaGF2aW9yIG9mIFJ1bGUgZmlsdGVycyB3aXRoaW4gYSBTdHlsZS4gSWYgJ2FsbCcgaXMgdXNlZCB0aGVuIGFsbCBSdWxlcyBhcmUgcHJvY2Vzc2VkIHNlcXVlbnRpYWxseSBpbmRlcGVuZGVudCBvZiB3aGV0aGVyIGFueSBwcmV2aW91cyBmaWx0ZXJzIG1hdGNoZWQuIElmICdmaXJzdCcgaXMgdXNlZCB0aGVuIGl0IG1lYW5zIHByb2Nlc3NpbmcgZW5kcyBhZnRlciB0aGUgZmlyc3QgbWF0Y2ggKGEgcG9zaXRpdmUgZmlsdGVyIGV2YWx1YXRpb24pIGFuZCBubyBmdXJ0aGVyIFJ1bGVzIGluIHRoZSBTdHlsZSBhcmUgcHJvY2Vzc2VkICgnZmlyc3QnIGlzIHVzdWFsbHkgdGhlIGRlZmF1bHQgZm9yIENTUyBpbXBsZW1lbnRhdGlvbnMgb24gdG9wIG9mIE1hcG5payB0byBzaW1wbGlmeSB0cmFuc2xhdGlvbiBmcm9tIENTUyB0byBNYXBuaWsgWE1MKVwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYWxsXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkFsbCBSdWxlcyBpbiBhIFN0eWxlIGFyZSBwcm9jZXNzZWQgd2hldGhlciB0aGV5IGhhdmUgZmlsdGVycyBvciBub3QgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSBmaWx0ZXIgY29uZGl0aW9ucyBldmFsdWF0ZSB0byB0cnVlLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaW1hZ2UtZmlsdGVyc1wiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcImltYWdlLWZpbHRlcnNcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gZmlsdGVyc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgW1wiYWdnLXN0YWNrLWJsdXJcIiwgMl0sXG4gICAgICAgICAgICAgICAgW1wiZW1ib3NzXCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImJsdXJcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wiZ3JheVwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJzb2JlbFwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJlZGdlLWRldGVjdFwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJ4LWdyYWRpZW50XCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcInktZ3JhZGllbnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wiaW52ZXJ0XCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcInNoYXJwZW5cIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wiY29sb3JpemUtYWxwaGFcIiwgLTFdLFxuICAgICAgICAgICAgICAgIFtcImNvbG9yLXRvLWFscGhhXCIsIDFdLFxuICAgICAgICAgICAgICAgIFtcInNjYWxlLWhzbGFcIiwgOF1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRvY1wiOiBcIkEgbGlzdCBvZiBpbWFnZSBmaWx0ZXJzLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcImNvbXAtb3BcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBsYXllciBvbiB0b3Agb2Ygb3RoZXIgbGF5ZXJzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBsYXllciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIGxheWVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcInNvdXJjZS1vdmVyXCIsIC8vIGFkZGVkIGZvciB0b3JxdWVcbiAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICBcImxpZ2h0ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwib3BhY2l0eVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gYWxwaGEgdmFsdWUgZm9yIHRoZSBzdHlsZSAod2hpY2ggbWVhbnMgYW4gYWxwaGEgYXBwbGllZCB0byBhbGwgZmVhdHVyZXMgaW4gc2VwYXJhdGUgYnVmZmVyIGFuZCB0aGVuIGNvbXBvc2l0ZWQgYmFjayB0byBtYWluIGJ1ZmZlcilcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzZXBhcmF0ZSBidWZmZXIgd2lsbCBiZSB1c2VkIGFuZCBubyBhbHBoYSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHN0eWxlIGFmdGVyIHJlbmRlcmluZ1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwibGF5ZXJcIiA6IHtcbiAgICAgICAgXCJuYW1lXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIiA6IHRydWUsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGxheWVyIG5hbWUgaGFzIGJlZW4gcHJvdmlkZWRcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG5hbWUgb2YgYSBsYXllci4gQ2FuIGJlIGFueXRoaW5nIHlvdSB3aXNoIGFuZCBpcyBub3Qgc3RyaWN0bHkgdmFsaWRhdGVkLCBidXQgaWRlYWxseSB1bmlxdWUgIGluIHRoZSBtYXBcIlxuICAgICAgICB9LFxuICAgICAgICBcInNyc1wiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIHNycyB2YWx1ZSBpcyBwcm92aWRlZCBhbmQgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIE1hcCdzIHNyc1wiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtIGRlZmluaXRpb24gZm9yIHRoZSBsYXllciwgYWthIHRoZSBwcm9qZWN0aW9uLiBDYW4gZWl0aGVyIGJlIGEgcHJvajQgbGl0ZXJhbCBzdHJpbmcgbGlrZSAnK3Byb2o9bG9uZ2xhdCArZWxscHM9V0dTODQgK2RhdHVtPVdHUzg0ICtub19kZWZzJyBvciwgaWYgdGhlIHByb3BlciBwcm9qNCBlcHNnL25hZC9ldGMgaWRlbnRpZmllciBmaWxlcyBhcmUgaW5zdGFsbGVkLCBhIHN0cmluZyB0aGF0IHVzZXMgYW4gaWQgbGlrZTogJytpbml0PWVwc2c6NDMyNidcIlxuICAgICAgICB9LFxuICAgICAgICBcInN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwidHlwZVwiOlwiYm9vbGVhblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGlzIGxheWVyIHdpbGwgYmUgbWFya2VkIGFzIGFjdGl2ZSBhbmQgYXZhaWxhYmxlIGZvciBwcm9jZXNzaW5nXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkEgcHJvcGVydHkgdGhhdCBjYW4gYmUgc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBsYXllciBmcm9tIGJlaW5nIHByb2Nlc3NlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWluem9vbVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIwXCIsXG4gICAgICAgICAgICBcInR5cGVcIjpcImZsb2F0XCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBsYXllciB3aWxsIGJlIHZpc2libGUgYXQgdGhlIG1pbmltdW0gcG9zc2libGUgc2NhbGVcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gc2NhbGUgZGVub21pbmF0b3IgdGhhdCB0aGlzIGxheWVyIHdpbGwgYmUgdmlzaWJsZSBhdC4gQSBsYXllcidzIHZpc2liaWxpdHkgaXMgZGV0ZXJtaW5lZCBieSB3aGV0aGVyIGl0cyBzdGF0dXMgaXMgdHJ1ZSBhbmQgaWYgdGhlIE1hcCBzY2FsZSA+PSBtaW56b29tIC0gMWUtNiBhbmQgc2NhbGUgPCBtYXh6b29tICsgMWUtNlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4em9vbVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIxLjc5NzY5ZSszMDhcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIGxheWVyIHdpbGwgYmUgdmlzaWJsZSBhdCB0aGUgbWF4aW11bSBwb3NzaWJsZSBzY2FsZVwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBzY2FsZSBkZW5vbWluYXRvciB0aGF0IHRoaXMgbGF5ZXIgd2lsbCBiZSB2aXNpYmxlIGF0LiBUaGUgZGVmYXVsdCBpcyB0aGUgbnVtZXJpYyBsaW1pdCBvZiB0aGUgQysrIGRvdWJsZSB0eXBlLCB3aGljaCBtYXkgdmFyeSBzbGlnaHRseSBieSBzeXN0ZW0sIGJ1dCBpcyBsaWtlbHkgYSBtYXNzaXZlIG51bWJlciBsaWtlIDEuNzk3NjllKzMwOCBhbmQgZW5zdXJlcyB0aGF0IHRoaXMgbGF5ZXIgd2lsbCBhbHdheXMgYmUgdmlzaWJsZSB1bmxlc3MgdGhlIHZhbHVlIGlzIHJlZHVjZWQuIEEgbGF5ZXIncyB2aXNpYmlsaXR5IGlzIGRldGVybWluZWQgYnkgd2hldGhlciBpdHMgc3RhdHVzIGlzIHRydWUgYW5kIGlmIHRoZSBNYXAgc2NhbGUgPj0gbWluem9vbSAtIDFlLTYgYW5kIHNjYWxlIDwgbWF4em9vbSArIDFlLTZcIlxuICAgICAgICB9LFxuICAgICAgICBcInF1ZXJ5YWJsZVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICBcInR5cGVcIjpcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIGxheWVyIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBmb3IgdGhlIGRpcmVjdCBxdWVyeWluZyBvZiBkYXRhIHZhbHVlc1wiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGlzIHByb3BlcnR5IHdhcyBhZGRlZCBmb3IgR2V0RmVhdHVyZUluZm8vV01TIGNvbXBhdGliaWxpdHkgYW5kIGlzIHJhcmVseSB1c2VkLiBJdCBpcyBvZmYgYnkgZGVmYXVsdCBtZWFuaW5nIHRoYXQgaW4gYSBXTVMgY29udGV4dCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgYWJsZSB0byBiZSBxdWVyaWVkIHVubGVzcyB0aGUgcHJvcGVydHkgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2xlYXItbGFiZWwtY2FjaGVcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSByZW5kZXJlcidzIGNvbGxpc2lvbiBkZXRlY3RvciBjYWNoZSAodXNlZCBmb3IgYXZvaWRpbmcgZHVwbGljYXRlIGxhYmVscyBhbmQgb3ZlcmxhcHBpbmcgbWFya2Vycykgd2lsbCBub3QgYmUgY2xlYXJlZCBpbW1lZGlhdGVseSBiZWZvcmUgcHJvY2Vzc2luZyB0aGlzIGxheWVyXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoaXMgcHJvcGVydHksIGJ5IGRlZmF1bHQgb2ZmLCBjYW4gYmUgZW5hYmxlZCB0byBhbGxvdyBhIHVzZXIgdG8gY2xlYXIgdGhlIGNvbGxpc2lvbiBkZXRlY3RvciBjYWNoZSBiZWZvcmUgYSBnaXZlbiBsYXllciBpcyBwcm9jZXNzZWQuIFRoaXMgbWF5IGJlIGRlc2lyYWJsZSB0byBlbnN1cmUgdGhhdCBhIGdpdmVuIGxheWVycyBkYXRhIHNob3dzIHVwIG9uIHRoZSBtYXAgZXZlbiBpZiBpdCBub3JtYWxseSB3b3VsZCBub3QgYmVjYXVzZSBvZiBjb2xsaXNpb25zIHdpdGggcHJldmlvdXNseSByZW5kZXJlZCBsYWJlbHMgb3IgbWFya2Vyc1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ3JvdXAtYnlcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICBcInR5cGVcIjpcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBzcGVjaWFsIGxheWVyIGdyb3VwaW5nIHdpbGwgYmUgdXNlZCBkdXJpbmcgcmVuZGVyaW5nXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9tYXBuaWsvbWFwbmlrL3dpa2kvR3JvdXBlZC1yZW5kZXJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImJ1ZmZlci1zaXplXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjBcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gYnVmZmVyIHdpbGwgYmUgdXNlZFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJFeHRyYSB0b2xlcmFuY2UgYXJvdW5kIHRoZSBMYXllciBleHRlbnQgKGluIHBpeGVscykgdXNlZCB0byB3aGVuIHF1ZXJ5aW5nIGFuZCAocG90ZW50aWFsbHkpIGNsaXBwaW5nIHRoZSBsYXllciBkYXRhIGR1cmluZyByZW5kZXJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1heGltdW0tZXh0ZW50XCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwiYmJveFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBjbGlwcGluZyBleHRlbnQgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkFuIGV4dGVudCB0byBiZSB1c2VkIHRvIGxpbWl0IHRoZSBib3VuZHMgdXNlZCB0byBxdWVyeSB0aGlzIHNwZWNpZmljIGxheWVyIGRhdGEgZHVyaW5nIHJlbmRlcmluZy4gU2hvdWxkIGJlIG1pbngsIG1pbnksIG1heHgsIG1heHkgaW4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBMYXllci5cIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInN5bWJvbGl6ZXJzXCIgOiB7XG4gICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgICBcImltYWdlLWZpbHRlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiaW1hZ2UtZmlsdGVyc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIGZpbHRlcnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcImFnZy1zdGFjay1ibHVyXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJlbWJvc3NcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImJsdXJcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImdyYXlcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNvYmVsXCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJlZGdlLWRldGVjdFwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wieC1ncmFkaWVudFwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wieS1ncmFkaWVudFwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiaW52ZXJ0XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzaGFycGVuXCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJjb2xvcml6ZS1hbHBoYVwiLCAtMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcImNvbG9yLXRvLWFscGhhXCIsIDFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZS1oc2xhXCIsIDhdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgbGlzdCBvZiBpbWFnZSBmaWx0ZXJzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IGxheWVyIG9uIHRvcCBvZiBvdGhlciBsYXllcnNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBsYXllciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIGxheWVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic291cmNlLW92ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb2Z0LWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLW1lcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNhdHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gYWxwaGEgdmFsdWUgZm9yIHRoZSBzdHlsZSAod2hpY2ggbWVhbnMgYW4gYWxwaGEgYXBwbGllZCB0byBhbGwgZmVhdHVyZXMgaW4gc2VwYXJhdGUgYnVmZmVyIGFuZCB0aGVuIGNvbXBvc2l0ZWQgYmFjayB0byBtYWluIGJ1ZmZlcilcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNlcGFyYXRlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYW5kIG5vIGFscGhhIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgc3R5bGUgYWZ0ZXIgcmVuZGVyaW5nXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJhY2tncm91bmQtY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJNYXAgQmFja2dyb3VuZCBjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWltYWdlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJhY2tncm91bmQtaW1hZ2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBpbWFnZSB0aGF0IGlzIHJlcGVhdGVkIGJlbG93IGFsbCBmZWF0dXJlcyBvbiBhIG1hcCBhcyBhIGJhY2tncm91bmQuXCIsXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk1hcCBCYWNrZ3JvdW5kIGltYWdlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzcnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIrcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK25vX2RlZnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBwcm9qNCBsaXRlcmFsIG9mIEVQU0c6NDMyNiBpcyBhc3N1bWVkIHRvIGJlIHRoZSBNYXAncyBzcGF0aWFsIHJlZmVyZW5jZSBhbmQgYWxsIGRhdGEgZnJvbSBsYXllcnMgd2l0aGluIHRoaXMgbWFwIHdpbGwgYmUgcGxvdHRlZCB1c2luZyB0aGlzIGNvb3JkaW5hdGUgc3lzdGVtLiBJZiBhbnkgbGF5ZXJzIGRvIG5vdCBkZWNsYXJlIGFuIHNycyB2YWx1ZSB0aGVuIHRoZXkgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHNycyBhcyB0aGUgTWFwIGFuZCBub3QgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgbmVlZGVkIHRvIHBsb3QgdGhlbSBpbiB0aGUgTWFwJ3MgY29vcmRpbmF0ZSBzcGFjZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTWFwIHNwYXRpYWwgcmVmZXJlbmNlIChwcm9qNCBzdHJpbmcpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJ1ZmZlci1zaXplXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1ZmZlci1zaXplXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGJ1ZmZlciB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkV4dHJhIHRvbGVyYW5jZSBhcm91bmQgdGhlIG1hcCAoaW4gcGl4ZWxzKSB1c2VkIHRvIGVuc3VyZSBsYWJlbHMgY3Jvc3NpbmcgdGlsZSBib3VuZGFyaWVzIGFyZSBlcXVhbGx5IHJlbmRlcmVkIGluIGVhY2ggdGlsZSAoZS5nLiBjdXQgaW4gZWFjaCB0aWxlKS4gTm90IGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBcXFwiYXZvaWQtZWRnZXNcXFwiLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtYXhpbXVtLWV4dGVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJiYm94XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBjbGlwcGluZyBleHRlbnQgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBleHRlbnQgdG8gYmUgdXNlZCB0byBsaW1pdCB0aGUgYm91bmRzIHVzZWQgdG8gcXVlcnkgYWxsIGxheWVycyBkdXJpbmcgcmVuZGVyaW5nLiBTaG91bGQgYmUgbWlueCwgbWlueSwgbWF4eCwgbWF4eSBpbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIE1hcC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYmFzZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJiYXNlXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGlzIGJhc2UgcGF0aCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcgbWVhbmluZyB0aGF0IGFueSByZWxhdGl2ZSBwYXRocyB0byBmaWxlcyByZWZlcmVuY2VkIGluIHN0eWxlcyBvciBsYXllcnMgd2lsbCBiZSBpbnRlcnByZXRlZCByZWxhdGl2ZSB0byB0aGUgYXBwbGljYXRpb24gcHJvY2Vzcy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFueSByZWxhdGl2ZSBwYXRocyB1c2VkIHRvIHJlZmVyZW5jZSBmaWxlcyB3aWxsIGJlIHVuZGVyc3Rvb2QgYXMgcmVsYXRpdmUgdG8gdGhpcyBkaXJlY3RvcnkgcGF0aCBpZiB0aGUgbWFwIGlzIGxvYWRlZCBmcm9tIGFuIGluIG1lbW9yeSBvYmplY3QgcmF0aGVyIHRoYW4gZnJvbSB0aGUgZmlsZXN5c3RlbS4gSWYgdGhlIG1hcCBpcyBsb2FkZWQgZnJvbSB0aGUgZmlsZXN5c3RlbSBhbmQgdGhpcyBvcHRpb24gaXMgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBkaXJlY3Rvcnkgb2YgdGhlIHN0eWxlc2hlZXQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBhdGhzLWZyb20teG1sXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiUGF0aHMgcmVhZCBmcm9tIFhNTCB3aWxsIGJlIGludGVycHJldGVkIGZyb20gdGhlIGxvY2F0aW9uIG9mIHRoZSBYTUxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJ2YWx1ZSB0byBjb250cm9sIHdoZXRoZXIgcGF0aHMgaW4gdGhlIFhNTCB3aWxsIGJlIGludGVycHJldGVkIGZyb20gdGhlIGxvY2F0aW9uIG9mIHRoZSBYTUwgb3IgZnJvbSB0aGUgd29ya2luZyBkaXJlY3Rvcnkgb2YgdGhlIHByb2dyYW0gdGhhdCBjYWxscyBsb2FkX21hcCgpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1pbmltdW0tdmVyc2lvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJNYXBuaWsgdmVyc2lvbiB3aWxsIG5vdCBiZSBkZXRlY3RlZCBhbmQgbm8gZXJyb3Igd2lsbCBiZSB0aHJvd24gYWJvdXQgY29tcGF0aWJpbGl0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbnVtdW0gTWFwbmlrIHZlcnNpb24gKGUuZy4gMC43LjIpIG5lZWRlZCB0byB1c2UgY2VydGFpbiBmdW5jdGlvbmFsaXR5IGluIHRoZSBzdHlsZXNoZWV0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZvbnQtZGlyZWN0b3J5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImZvbnQtZGlyZWN0b3J5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gbWFwLXNwZWNpZmljIGZvbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiUGF0aCB0byBhIGRpcmVjdG9yeSB3aGljaCBob2xkcyBmb250cyB3aGljaCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aGVuIHRoZSBNYXAgaXMgbG9hZGVkIChpbiBhZGRpdGlvbiB0byBhbnkgZm9udHMgdGhhdCBtYXkgYmUgYXV0b21hdGljYWxseSByZWdpc3RlcmVkKS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvbHlnb25cIjoge1xuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgxMjgsMTI4LDEyOCwxKVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ3JheSBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigxMjgsMTI4LDEyOClcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkZpbGwgY29sb3IgdG8gYXNzaWduIHRvIGEgcG9seWdvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBwb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2FtbWFcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1nYW1tYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJmdWxseSBhbnRpYWxpYXNlZFwiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxldmVsIG9mIGFudGlhbGlhc2luZyBvZiBwb2x5Z29uIGVkZ2VzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdhbW1hLW1ldGhvZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWdhbW1hLW1ldGhvZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwicG93ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaW5lYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGhyZXNob2xkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicG93ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInBvdyh4LGdhbW1hKSBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBwaXhlbCBnYW1tYSwgd2hpY2ggcHJvZHVjZXMgc2xpZ2h0bHkgc21vb3RoZXIgbGluZSBhbmQgcG9seWdvbiBhbnRpYWxpYXNpbmcgdGhhbiB0aGUgJ2xpbmVhcicgbWV0aG9kLCB3aGlsZSBvdGhlciBtZXRob2RzIGFyZSB1c3VhbGx5IG9ubHkgdXNlZCB0byBkaXNhYmxlIEFBXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBBbnRpZ3JhaW4gR2VvbWV0cnkgc3BlY2lmaWMgcmVuZGVyaW5nIGhpbnQgdG8gY29udHJvbCB0aGUgcXVhbGl0eSBvZiBhbnRpYWxpYXNpbmcuIFVuZGVyIHRoZSBob29kIGluIE1hcG5payB0aGlzIG1ldGhvZCBpcyB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlICdnYW1tYScgdmFsdWUgKHdoaWNoIGRlZmF1bHRzIHRvIDEpLiBUaGUgbWV0aG9kcyBhcmUgaW4gdGhlIEFHRyBzb3VyY2UgYXQgaHR0cHM6Ly9naXRodWIuY29tL21hcG5pay9tYXBuaWsvYmxvYi9tYXN0ZXIvZGVwcy9hZ2cvaW5jbHVkZS9hZ2dfZ2FtbWFfZnVuY3Rpb25zLmhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWNsaXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIGJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBiZWZvcmUgcmVuZGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJnZW9tZXRyaWVzIGFyZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYnkgZGVmYXVsdCBmb3IgYmVzdCByZW5kZXJpbmcgcGVyZm9ybWFuY2UuIEluIHNvbWUgY2FzZXMgdXNlcnMgbWF5IHdpc2ggdG8gZGlzYWJsZSB0aGlzIHRvIGF2b2lkIHJlbmRlcmluZyBhcnRpZmFjdHMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNtb290aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXNtb290aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzbW9vdGhpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IFwiMC0xXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTbW9vdGhzIG91dCBnZW9tZXRyeSBhbmdsZXMuIDAgaXMgbm8gc21vb3RoaW5nLCAxIGlzIGZ1bGx5IHNtb290aGVkLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2lsbCBwcm9kdWNlIHdpbGQsIGxvb3BpbmcgZ2VvbWV0cmllcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbWV0cnktdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZ2VvbWV0cnktdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFsbG93cyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2VvbWV0cnkuXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXJcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBzeW1ib2xpemVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gc3ltYm9saXplcnMgYXRvcCBvciBiZWxvdyBpdC5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1wiY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb2Z0LWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLW1lcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNhdHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZVwiOiB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgwLDAsMCwxKVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJibGFjayBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigwLDAsMClcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiBhIGRyYXduIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHdpZHRoIG9mIGEgbGluZSBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWpvaW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJtaXRlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibWl0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcImJldmVsXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGJlaGF2aW9yIG9mIGxpbmVzIHdoZW4gam9pbmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWNhcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJ1dHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImJ1dHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNxdWFyZVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5nc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtZ2FtbWFcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1nYW1tYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJmdWxseSBhbnRpYWxpYXNlZFwiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxldmVsIG9mIGFudGlhbGlhc2luZyBvZiBzdHJva2UgbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtZ2FtbWEtbWV0aG9kXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtZ2FtbWEtbWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb3dlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aHJlc2hvbGRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb3dlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwicG93KHgsZ2FtbWEpIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHBpeGVsIGdhbW1hLCB3aGljaCBwcm9kdWNlcyBzbGlnaHRseSBzbW9vdGhlciBsaW5lIGFuZCBwb2x5Z29uIGFudGlhbGlhc2luZyB0aGFuIHRoZSAnbGluZWFyJyBtZXRob2QsIHdoaWxlIG90aGVyIG1ldGhvZHMgYXJlIHVzdWFsbHkgb25seSB1c2VkIHRvIGRpc2FibGUgQUFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIEFudGlncmFpbiBHZW9tZXRyeSBzcGVjaWZpYyByZW5kZXJpbmcgaGludCB0byBjb250cm9sIHRoZSBxdWFsaXR5IG9mIGFudGlhbGlhc2luZy4gVW5kZXIgdGhlIGhvb2QgaW4gTWFwbmlrIHRoaXMgbWV0aG9kIGlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgJ2dhbW1hJyB2YWx1ZSAod2hpY2ggZGVmYXVsdHMgdG8gMSkuIFRoZSBtZXRob2RzIGFyZSBpbiB0aGUgQUdHIHNvdXJjZSBhdCBodHRwczovL2dpdGh1Yi5jb20vbWFwbmlrL21hcG5pay9ibG9iL21hc3Rlci9kZXBzL2FnZy9pbmNsdWRlL2FnZ19nYW1tYV9mdW5jdGlvbnMuaFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtZGFzaGFycmF5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBwYWlyIG9mIGxlbmd0aCB2YWx1ZXMgW2EsYl0sIHdoZXJlIChhKSBpcyB0aGUgZGFzaCBsZW5ndGggYW5kIChiKSBpcyB0aGUgZ2FwIGxlbmd0aCByZXNwZWN0aXZlbHkuIE1vcmUgdGhhbiB0d28gdmFsdWVzIGFyZSBzdXBwb3J0ZWQgZm9yIG1vcmUgY29tcGxleCBwYXR0ZXJucy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJzb2xpZCBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtZGFzaC1vZmZzZXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJ2YWxpZCBwYXJhbWV0ZXIgYnV0IG5vdCBjdXJyZW50bHkgdXNlZCBpbiByZW5kZXJlcnMgKG9ubHkgZXhpc3RzIGZvciBleHBlcmltZW50YWwgc3ZnIHN1cHBvcnQgaW4gTWFwbmlrIHdoaWNoIGlzIG5vdCB5ZXQgZW5hYmxlZClcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJzb2xpZCBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtbWl0ZXJsaW1pdFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbGltaXQgb24gdGhlIHJhdGlvIG9mIHRoZSBtaXRlciBsZW5ndGggdG8gdGhlIHN0cm9rZS13aWR0aC4gVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcyB0byBhdm9pZCB0aGUgbWl0ZXIgZXh0ZW5kaW5nIGJleW9uZCB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2luZyBwYXRoLiBOb3JtYWxseSB3aWxsIG5vdCBuZWVkIHRvIGJlIHNldCwgYnV0IGEgbGFyZ2VyIHZhbHVlIGNhbiBzb21ldGltZXMgaGVscCBhdm9pZCBqYWdneSBhcnRpZmFjdHMuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDQuMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIldpbGwgYXV0by1jb252ZXJ0IG1pdGVycyB0byBiZXZlbCBsaW5lIGpvaW5zIHdoZW4gdGhldGEgaXMgbGVzcyB0aGFuIDI5IGRlZ3JlZXMgYXMgcGVyIHRoZSBTVkcgc3BlYzogJ21pdGVyTGVuZ3RoIC8gc3Ryb2tlLXdpZHRoID0gMSAvIHNpbiAoIHRoZXRhIC8gMiApJ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtc21vb3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNtb290aGluZ1wiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNtb290aHMgb3V0IGdlb21ldHJ5IGFuZ2xlcy4gMCBpcyBubyBzbW9vdGhpbmcsIDEgaXMgZnVsbHkgc21vb3RoZWQuIFZhbHVlcyBncmVhdGVyIHRoYW4gMSB3aWxsIHByb2R1Y2Ugd2lsZCwgbG9vcGluZyBnZW9tZXRyaWVzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvZmZzZXRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1vZmZzZXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gb2Zmc2V0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJPZmZzZXRzIGEgbGluZSBhIG51bWJlciBvZiBwaXhlbHMgcGFyYWxsZWwgdG8gaXRzIGFjdHVhbCBwYXRoLiBQb3N0aXZlIHZhbHVlcyBtb3ZlIHRoZSBsaW5lIGxlZnQsIG5lZ2F0aXZlIHZhbHVlcyBtb3ZlIGl0IHJpZ2h0IChyZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgdGhlIGxpbmUpLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyYXN0ZXJpemVyXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcmFzdGVyaXplclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZnVsbFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZhc3RcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZnVsbFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRXhwb3NlcyBhbiBhbHRlcm5hdGUgQUdHIHJlbmRlcmluZyBtZXRob2QgdGhhdCBzYWNyaWZpY2VzIHNvbWUgYWNjdXJhY3kgZm9yIHNwZWVkLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tZXRyeS10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXJrZXJzXCI6IHtcbiAgICAgICAgICAgIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gU1ZHIGZpbGUgdGhhdCB0aGlzIG1hcmtlciBzaG93cyBhdCBlYWNoIHBsYWNlbWVudC4gSWYgbm8gZmlsZSBpcyBnaXZlbiwgdGhlIG1hcmtlciB3aWxsIHNob3cgYW4gZWxsaXBzZS5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkFuIGVsbGlwc2Ugb3IgY2lyY2xlLCBpZiB3aWR0aCBlcXVhbHMgaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvdmVyYWxsIG9wYWNpdHkgb2YgdGhlIG1hcmtlciwgaWYgc2V0LCBvdmVycmlkZXMgYm90aCB0aGUgb3BhY2l0eSBvZiBib3RoIHRoZSBmaWxsIGFuZCBzdHJva2VcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBzdHJva2Utb3BhY2l0eSBhbmQgZmlsbC1vcGFjaXR5IHdpbGwgYmUgdXNlZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsbC1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgZmlsbCBvcGFjaXR5IG9mIHRoZSBtYXJrZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbGluZS1jb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBzdHJva2UgYXJvdW5kIGEgbWFya2VyIHNoYXBlLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJsYWNrXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLXdpZHRoXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIHN0cm9rZSBhcm91bmQgYSBtYXJrZXIgc2hhcGUsIGluIHBpeGVscy4gVGhpcyBpcyBwb3NpdGlvbmVkIG9uIHRoZSBib3VuZGFyeSwgc28gaGlnaCB2YWx1ZXMgY2FuIGNvdmVyIHRoZSBhcmVhIGl0c2VsZi5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbGluZS1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIGEgbGluZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiUGxhY2UgbWFya2VycyBhdCB0aGUgY2VudGVyIHBvaW50IChjZW50cm9pZCkgb2YgdGhlIGdlb21ldHJ5XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBdHRlbXB0IHRvIHBsYWNlIG1hcmtlcnMgb24gYSBwb2ludCwgaW4gdGhlIGNlbnRlciBvZiBhIHBvbHlnb24sIG9yIGlmIG1hcmtlcnMtcGxhY2VtZW50OmxpbmUsIHRoZW4gbXVsdGlwbGUgdGltZXMgYWxvbmcgYSBsaW5lLiAnaW50ZXJpb3InIHBsYWNlbWVudCBjYW4gYmUgdXNlZCB0byBlbnN1cmUgdGhhdCBwb2ludHMgcGxhY2VkIG9uIHBvbHlnb25zIGFyZSBmb3JjZWQgdG8gYmUgaW5zaWRlIHRoZSBwb2x5Z29uIGludGVyaW9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm11bHRpLXBvbGljeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbXVsdGktcG9saWN5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJlYWNoXCIsXG4gICAgICAgICAgICAgICAgICAgIFwid2hvbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsYXJnZXN0XCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImVhY2hcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIklmIGEgZmVhdHVyZSBjb250YWlucyBtdWx0aXBsZSBnZW9tZXRyaWVzIGFuZCB0aGUgcGxhY2VtZW50IHR5cGUgaXMgZWl0aGVyIHBvaW50IG9yIGludGVyaW9yIHRoZW4gYSBtYXJrZXIgd2lsbCBiZSByZW5kZXJlZCBmb3IgZWFjaFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBzcGVjaWFsIHNldHRpbmcgdG8gYWxsb3cgdGhlIHVzZXIgdG8gY29udHJvbCByZW5kZXJpbmcgYmVoYXZpb3IgZm9yICdtdWx0aS1nZW9tZXRyaWVzJyAod2hlbiBhIGZlYXR1cmUgY29udGFpbnMgbXVsdGlwbGUgZ2VvbWV0cmllcykuIFRoaXMgc2V0dGluZyBkb2VzIG5vdCBhcHBseSB0byBtYXJrZXJzIHBsYWNlZCBhbG9uZyBsaW5lcy4gVGhlICdlYWNoJyBwb2xpY3kgaXMgZGVmYXVsdCBhbmQgbWVhbnMgYWxsIGdlb21ldHJpZXMgd2lsbCBnZXQgYSBtYXJrZXIuIFRoZSAnd2hvbGUnIHBvbGljeSBtZWFucyB0aGF0IHRoZSBhZ2dyZWdhdGUgY2VudHJvaWQgYmV0d2VlbiBhbGwgZ2VvbWV0cmllcyB3aWxsIGJlIHVzZWQuIFRoZSAnbGFyZ2VzdCcgcG9saWN5IG1lYW5zIHRoYXQgb25seSB0aGUgbGFyZ2VzdCAoYnkgYm91bmRpbmcgYm94IGFyZWFzKSBmZWF0dXJlIHdpbGwgZ2V0IGEgcmVuZGVyZWQgbWFya2VyICh0aGlzIGlzIGhvdyB0ZXh0IGxhYmVsaW5nIGJlaGF2ZXMgYnkgZGVmYXVsdCkuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1hcmtlci10eXBlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci10eXBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJhcnJvd1wiLFxuICAgICAgICAgICAgICAgICAgICBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZWN0YW5nbGVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGRlZmF1bHQgbWFya2VyLXR5cGUuIElmIGEgU1ZHIGZpbGUgaXMgbm90IGdpdmVuIGFzIHRoZSBtYXJrZXItZmlsZSBwYXJhbWV0ZXIsIHRoZSByZW5kZXJlciBwcm92aWRlcyBlaXRoZXIgYW4gYXJyb3cgb3IgYW4gZWxsaXBzZSAoYSBjaXJjbGUgaWYgaGVpZ2h0IGlzIGVxdWFsIHRvIHdpZHRoKVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ3aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgaWYgdXNpbmcgb25lIG9mIHRoZSBkZWZhdWx0IHR5cGVzLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhlaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLCBpZiB1c2luZyBvbmUgb2YgdGhlIGRlZmF1bHQgdHlwZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJsdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgYXJlYSBvZiB0aGUgbWFya2VyLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWFsbG93LW92ZXJsYXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIG92ZXJsYXBwaW5nIG1hcmtlcnMgYXJlIHNob3duIG9yIGhpZGRlbi5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkRvIG5vdCBhbGxvdyBtYWtlcnMgdG8gb3ZlcmxhcCB3aXRoIGVhY2ggb3RoZXIgLSBvdmVybGFwcGluZyBtYXJrZXJzIHdpbGwgbm90IGJlIHNob3duLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1pZ25vcmUtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImRvIG5vdCBzdG9yZSB0aGUgYmJveCBvZiB0aGlzIGdlb21ldHJ5IGluIHRoZSBjb2xsaXNpb24gZGV0ZWN0b3IgY2FjaGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcInZhbHVlIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgcGxhY2VtZW50IG9mIHRoZSBmZWF0dXJlIHdpbGwgcHJldmVudCB0aGUgcGxhY2VtZW50IG9mIG90aGVyIGZlYXR1cmVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwYWNlIGJldHdlZW4gcmVwZWF0ZWQgbGFiZWxzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEwMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtYXgtZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLW1heC1lcnJvclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAuMixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGRpZmZlcmVuY2UgYmV0d2VlbiBhY3R1YWwgbWFya2VyIHBsYWNlbWVudCBhbmQgdGhlIG1hcmtlci1zcGFjaW5nIHBhcmFtZXRlci4gU2V0dGluZyBhIGhpZ2ggdmFsdWUgY2FuIGFsbG93IHRoZSByZW5kZXJlciB0byB0cnkgdG8gcmVzb2x2ZSBwbGFjZW1lbnQgY29uZmxpY3RzIHdpdGggb3RoZXIgc3ltYm9saXplcnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIHRyYW5zZm9ybWF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTVkcgdHJhbnNmb3JtYXRpb24gZGVmaW5pdGlvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1jbGlwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBiZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYmVmb3JlIHJlbmRlcmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiZ2VvbWV0cmllcyBhcmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJ5IGRlZmF1bHQgZm9yIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJbiBzb21lIGNhc2VzIHVzZXJzIG1heSB3aXNoIHRvIGRpc2FibGUgdGhpcyB0byBhdm9pZCByZW5kZXJpbmcgYXJ0aWZhY3RzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzbW9vdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXNtb290aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzbW9vdGhpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IFwiMC0xXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTbW9vdGhzIG91dCBnZW9tZXRyeSBhbmdsZXMuIDAgaXMgbm8gc21vb3RoaW5nLCAxIGlzIGZ1bGx5IHNtb290aGVkLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2lsbCBwcm9kdWNlIHdpbGQsIGxvb3BpbmcgZ2VvbWV0cmllcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbWV0cnktdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNoaWVsZFwiOiB7XG4gICAgICAgICAgICBcIm5hbWVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLW5hbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInNlcmlhbGl6YXRpb25cIjogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgc2hpZWxkXFxcInMgdGV4dCBsYWJlbC4gRGF0YSBjb2x1bW5zIGFyZSBzcGVjaWZpZWQgdXNpbmcgYnJhY2tldHMgbGlrZSBbY29sdW1uX25hbWVdXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWZpbGVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgZmlsZSB0byByZW5kZXIgYmVoaW5kIHRoZSBzaGllbGQgdGV4dFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmYWNlLW5hbWVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWZhY2UtbmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwidmFsaWRhdGVcIjogXCJmb250XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJGb250IG5hbWUgYW5kIHN0eWxlIHRvIHVzZSBmb3IgdGhlIHNoaWVsZCB0ZXh0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmxvY2staW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXVubG9jay1pbWFnZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBpZiB5b3UgYXJlIHRyeWluZyB0byBwb3NpdGlvbiB0ZXh0IGJlc2lkZSByYXRoZXIgdGhhbiBvbiB0b3Agb2YgdGhlIHNoaWVsZCBpbWFnZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRleHQgYWxpZ25tZW50IHJlbGF0aXZlIHRvIHRoZSBzaGllbGQgaW1hZ2UgdXNlcyB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSBhcyB0aGUgYW5jaG9yIGZvciB0ZXh0IHBvc2l0aW9uaW5nLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzaXplXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1zaXplXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzaXplIG9mIHRoZSBzaGllbGQgdGV4dCBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHNoaWVsZCB0ZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0ZXhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSG93IHRoaXMgc2hpZWxkIHNob3VsZCBiZSBwbGFjZWQuIFBvaW50IHBsYWNlbWVudCBhdHRlbXB0cyB0byBwbGFjZSBpdCBvbiB0b3Agb2YgcG9pbnRzLCBsaW5lIHBsYWNlcyBhbG9uZyBsaW5lcyBtdWx0aXBsZSB0aW1lcyBwZXIgZmVhdHVyZSwgdmVydGV4IHBsYWNlcyBvbiB0aGUgdmVydGV4ZXMgb2YgcG9seWdvbnMsIGFuZCBpbnRlcmlvciBhdHRlbXB0cyB0byBwbGFjZSBpbnNpZGUgb2YgcG9seWdvbnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1hdm9pZC1lZGdlc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGVsbCBwb3NpdGlvbmluZyBhbGdvcml0aG0gdG8gYXZvaWQgbGFiZWxpbmcgbmVhciBpbnRlcnNlY3Rpb24gZWRnZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtYWxsb3ctb3ZlcmxhcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgb3ZlcmxhcHBpbmcgc2hpZWxkcyBhcmUgc2hvd24gb3IgaGlkZGVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IHNoaWVsZHMgdG8gb3ZlcmxhcCB3aXRoIG90aGVyIG1hcCBlbGVtZW50cyBhbHJlYWR5IHBsYWNlZC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS1kaXN0YW5jZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtbWluLWRpc3RhbmNlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIk1pbmltdW0gZGlzdGFuY2UgdG8gdGhlIG5leHQgc2hpZWxkIHN5bWJvbCwgbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIHNoaWVsZC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3BhY2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtc3BhY2luZ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc3BhY2luZyBiZXR3ZWVuIHJlcGVhdGVkIG9jY3VycmVuY2VzIG9mIHRoZSBzYW1lIHNoaWVsZCBvbiBhIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS1wYWRkaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1taW4tcGFkZGluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGV0ZXJtaW5lcyB0aGUgbWluaW11bSBhbW91bnQgb2YgcGFkZGluZyB0aGF0IGEgc2hpZWxkIGdldHMgcmVsYXRpdmUgdG8gb3RoZXIgc2hpZWxkc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXdyYXAtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTGVuZ3RoIG9mIGEgY2h1bmsgb2YgdGV4dCBpbiBjaGFyYWN0ZXJzIGJlZm9yZSB3cmFwcGluZyB0ZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtYmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC13cmFwLWJlZm9yZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJXcmFwIHRleHQgYmVmb3JlIHdyYXAtd2lkdGggaXMgcmVhY2hlZC4gSWYgZmFsc2UsIHdyYXBwZWQgbGluZXMgd2lsbCBiZSBhIGJpdCBsb25nZXIgdGhhbiB3cmFwLXdpZHRoLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ3cmFwLWNoYXJhY3RlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtd3JhcC1jaGFyYWN0ZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJVc2UgdGhpcyBjaGFyYWN0ZXIgaW5zdGVhZCBvZiBhIHNwYWNlIHRvIHdyYXAgbG9uZyBuYW1lcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1maWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1oYWxvLWZpbGxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiNGRkZGRkZcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGNvbG9yIG9mIHRoZSBoYWxvIGFyb3VuZCB0aGUgdGV4dC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1yYWRpdXNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWhhbG8tcmFkaXVzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZ5IHRoZSByYWRpdXMgb2YgdGhlIGhhbG8gaW4gcGl4ZWxzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBoYWxvXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2hhcmFjdGVyLXNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWNoYXJhY3Rlci1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkhvcml6b250YWwgc3BhY2luZyBiZXR3ZWVuIGNoYXJhY3RlcnMgKGluIHBpeGVscykuIEN1cnJlbnRseSB3b3JrcyBmb3IgcG9pbnQgcGxhY2VtZW50IG9ubHksIG5vdCBsaW5lIHBsYWNlbWVudC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibGluZS1zcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1saW5lLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlZlcnRpY2FsIHNwYWNpbmcgYmV0d2VlbiBsaW5lcyBvZiBtdWx0aWxpbmUgbGFiZWxzIChpbiBwaXhlbHMpXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZHhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXRleHQtZHhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2UgdGV4dCB3aXRoaW4gc2hpZWxkIGJ5IGZpeGVkIGFtb3VudCwgaW4gcGl4ZWxzLCArLy0gYWxvbmcgdGhlIFggYXhpcy4gIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBzaGlmdCB0aGUgdGV4dCByaWdodFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtdGV4dC1keVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSB0ZXh0IHdpdGhpbiBzaGllbGQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWSBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IGRvd25cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2hpZWxkLWR4XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1keFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSBzaGllbGQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWCBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNoaWVsZC1keVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtZHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2Ugc2hpZWxkIGJ5IGZpeGVkIGFtb3VudCwgaW4gcGl4ZWxzLCArLy0gYWxvbmcgdGhlIFkgYXhpcy4gIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiKERlZmF1bHQgMS4wKSAtIG9wYWNpdHkgb2YgdGhlIGltYWdlIHVzZWQgZm9yIHRoZSBzaGllbGRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC10ZXh0LW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiKERlZmF1bHQgMS4wKSAtIG9wYWNpdHkgb2YgdGhlIHRleHQgcGxhY2VkIG9uIHRvcCBvZiB0aGUgc2hpZWxkXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhvcml6b250YWwtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1ob3Jpem9udGFsLWFsaWdubWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pZGRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzaGllbGQncyBob3Jpem9udGFsIGFsaWdubWVudCBmcm9tIGl0cyBjZW50ZXJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidmVydGljYWwtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC12ZXJ0aWNhbC1hbGlnbm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcInRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pZGRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgICBcImF1dG9cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc2hpZWxkJ3MgdmVydGljYWwgYWxpZ25tZW50IGZyb20gaXRzIGNlbnRlcnBvaW50XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibWlkZGxlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC10ZXh0LXRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInVwcGVyY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvd2VyY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNhcGl0YWxpemVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUcmFuc2Zvcm0gdGhlIGNhc2Ugb2YgdGhlIGNoYXJhY3RlcnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImp1c3RpZnktYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1qdXN0aWZ5LWFsaWdubWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRlZmluZSBob3cgdGV4dCBpbiBhIHNoaWVsZCdzIGxhYmVsIGlzIGp1c3RpZmllZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIGltYWdlIGZpbGUgdG8gYmUgcmVwZWF0ZWQgYW5kIHdhcnBlZCBhbG9uZyBhIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXBhdHRlcm4tY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1zbW9vdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc21vb3RoaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU21vb3RocyBvdXQgZ2VvbWV0cnkgYW5nbGVzLiAwIGlzIG5vIHNtb290aGluZywgMSBpcyBmdWxseSBzbW9vdGhlZC4gVmFsdWVzIGdyZWF0ZXIgdGhhbiAxIHdpbGwgcHJvZHVjZSB3aWxkLCBsb29waW5nIGdlb21ldHJpZXMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21ldHJ5LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXBhdHRlcm4tZ2VvbWV0cnktdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFsbG93cyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2VvbWV0cnkuXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXBhdHRlcm4tY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2x5Z29uLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkltYWdlIHRvIHVzZSBhcyBhIHJlcGVhdGVkIHBhdHRlcm4gZmlsbCB3aXRoaW4gYSBwb2x5Z29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tYWxpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsb2NhbFwiLFxuICAgICAgICAgICAgICAgICAgICBcImdsb2JhbFwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJsb2NhbFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BlY2lmeSB3aGV0aGVyIHRvIGFsaWduIHBhdHRlcm4gZmlsbHMgdG8gdGhlIGxheWVyIG9yIHRvIHRoZSBtYXAuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdhbW1hXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1nYW1tYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJmdWxseSBhbnRpYWxpYXNlZFwiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxldmVsIG9mIGFudGlhbGlhc2luZyBvZiBwb2x5Z29uIHBhdHRlcm4gZWRnZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCIoRGVmYXVsdCAxLjApIC0gQXBwbHkgYW4gb3BhY2l0eSBsZXZlbCB0byB0aGUgaW1hZ2UgdXNlZCBmb3IgdGhlIHBhdHRlcm5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBpbWFnZSBpcyByZW5kZXJlZCB3aXRob3V0IG1vZGlmaWNhdGlvbnNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1zbW9vdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc21vb3RoaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU21vb3RocyBvdXQgZ2VvbWV0cnkgYW5nbGVzLiAwIGlzIG5vIHNtb290aGluZywgMSBpcyBmdWxseSBzbW9vdGhlZC4gVmFsdWVzIGdyZWF0ZXIgdGhhbiAxIHdpbGwgcHJvZHVjZSB3aWxkLCBsb29waW5nIGdlb21ldHJpZXMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21ldHJ5LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tZ2VvbWV0cnktdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFsbG93cyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2VvbWV0cnkuXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXJcIjoge1xuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInJhc3Rlci1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIHJhc3RlciBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVycy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsdGVyLWZhY3RvclwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItZmlsdGVyLWZhY3RvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAtMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkFsbG93IHRoZSBkYXRhc291cmNlIHRvIGNob29zZSBhcHByb3ByaWF0ZSBkb3duc2NhbGluZy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhpcyBpcyB1c2VkIGJ5IHRoZSBSYXN0ZXIgb3IgR2RhbCBkYXRhc291cmNlcyB0byBwcmUtZG93bnNjYWxlIGltYWdlcyB1c2luZyBvdmVydmlld3MuIEhpZ2hlciBudW1iZXJzIGNhbiBzb21ldGltZXMgY2F1c2UgbXVjaCBiZXR0ZXIgc2NhbGVkIGltYWdlIG91dHB1dCwgYXQgdGhlIGNvc3Qgb2Ygc3BlZWQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNjYWxpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicmFzdGVyLXNjYWxpbmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIm5lYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJmYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmlsaW5lYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiaWxpbmVhcjhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiaWN1YmljXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3BsaW5lMTZcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcGxpbmUzNlwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhbm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYW1taW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGVybWl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImthaXNlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInF1YWRyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjYXRyb21cIixcbiAgICAgICAgICAgICAgICAgICAgXCJnYXVzc2lhblwiLFxuICAgICAgICAgICAgICAgICAgICBcImJlc3NlbFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pdGNoZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2luY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImxhbmN6b3NcIixcbiAgICAgICAgICAgICAgICAgICAgXCJibGFja21hblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJuZWFyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc2NhbGluZyBhbGdvcml0aG0gdXNlZCB0byBtYWtpbmcgZGlmZmVyZW50IHJlc29sdXRpb24gdmVyc2lvbnMgb2YgdGhpcyByYXN0ZXIgbGF5ZXIuIEJpbGluZWFyIGlzIGEgZ29vZCBjb21wcm9taXNlIGJldHdlZW4gc3BlZWQgYW5kIGFjY3VyYWN5LCB3aGlsZSBsYW5jem9zIGdpdmVzIHRoZSBoaWdoZXN0IHF1YWxpdHkuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1lc2gtc2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItbWVzaC1zaXplXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDE2LFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiUmVwcm9qZWN0aW9uIG1lc2ggd2lsbCBiZSAxLzE2IG9mIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBzb3VyY2UgaW1hZ2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSByZWR1Y2VkIHJlc29sdXRpb24gbWVzaCBpcyB1c2VkIGZvciByYXN0ZXIgcmVwcm9qZWN0aW9uLCBhbmQgdGhlIHRvdGFsIGltYWdlIHNpemUgaXMgZGl2aWRlZCBieSB0aGUgbWVzaC1zaXplIHRvIGRldGVybWluZSB0aGUgcXVhbGl0eSBvZiB0aGF0IG1lc2guIFZhbHVlcyBmb3IgbWVzaC1zaXplIGxhcmdlciB0aGFuIHRoZSBkZWZhdWx0IHdpbGwgcmVzdWx0IGluIGZhc3RlciByZXByb2plY3Rpb24gYnV0IG1pZ2h0IGxlYWQgdG8gZGlzdG9ydGlvbi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2ludFwiOiB7XG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVyaVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgZmlsZSB0byByZXByZXNlbnQgYSBwb2ludFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LWFsbG93LW92ZXJsYXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIG92ZXJsYXBwaW5nIHBvaW50cyBhcmUgc2hvd24gb3IgaGlkZGVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IHBvaW50cyB0byBvdmVybGFwIHdpdGggZWFjaCBvdGhlciAtIG92ZXJsYXBwaW5nIG1hcmtlcnMgd2lsbCBub3QgYmUgc2hvd24uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtaWdub3JlLXBsYWNlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJkbyBub3Qgc3RvcmUgdGhlIGJib3ggb2YgdGhpcyBnZW9tZXRyeSBpbiB0aGUgY29sbGlzaW9uIGRldGVjdG9yIGNhY2hlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJ2YWx1ZSB0byBjb250cm9sIHdoZXRoZXIgdGhlIHBsYWNlbWVudCBvZiB0aGUgZmVhdHVyZSB3aWxsIHByZXZlbnQgdGhlIHBsYWNlbWVudCBvZiBvdGhlciBmZWF0dXJlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLjAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJGdWxseSBvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgdmFsdWUgZnJvbSAwIHRvIDEgdG8gY29udHJvbCB0aGUgb3BhY2l0eSBvZiB0aGUgcG9pbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LXBsYWNlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiY2VudHJvaWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkhvdyB0aGlzIHBvaW50IHNob3VsZCBiZSBwbGFjZWQuIENlbnRyb2lkIGNhbGN1bGF0ZXMgdGhlIGdlb21ldHJpYyBjZW50ZXIgb2YgYSBwb2x5Z29uLCB3aGljaCBjYW4gYmUgb3V0c2lkZSBvZiBpdCwgd2hpbGUgaW50ZXJpb3IgYWx3YXlzIHBsYWNlcyBpbnNpZGUgb2YgYSBwb2x5Z29uLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImNlbnRyb2lkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2ludC10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gdHJhbnNmb3JtYXRpb25cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNWRyB0cmFuc2Zvcm1hdGlvbiBkZWZpbml0aW9uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgIFwibmFtZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LW5hbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJzZXJpYWxpemF0aW9uXCI6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIERhdGEgY29sdW1ucyBhcmUgc3BlY2lmaWVkIHVzaW5nIGJyYWNrZXRzIGxpa2UgW2NvbHVtbl9uYW1lXVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmYWNlLW5hbWVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1mYWNlLW5hbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcInZhbGlkYXRlXCI6IFwiZm9udFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRm9udCBuYW1lIGFuZCBzdHlsZSB0byByZW5kZXIgYSBsYWJlbCBpblwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXNpemVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRleHQgc2l6ZSBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC1yYXRpb1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXJhdGlvXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEZWZpbmUgdGhlIGFtb3VudCBvZiB0ZXh0IChvZiB0aGUgdG90YWwpIHByZXNlbnQgb24gc3VjY2Vzc2l2ZSBsaW5lcyB3aGVuIHdyYXBwaW5nIG9jY3Vyc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC13cmFwLXdpZHRoXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJMZW5ndGggb2YgYSBjaHVuayBvZiB0ZXh0IGluIGNoYXJhY3RlcnMgYmVmb3JlIHdyYXBwaW5nIHRleHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ3cmFwLWJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXdyYXAtYmVmb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIldyYXAgdGV4dCBiZWZvcmUgd3JhcC13aWR0aCBpcyByZWFjaGVkLiBJZiBmYWxzZSwgd3JhcHBlZCBsaW5lcyB3aWxsIGJlIGEgYml0IGxvbmdlciB0aGFuIHdyYXAtd2lkdGguXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtY2hhcmFjdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtd3JhcC1jaGFyYWN0ZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJVc2UgdGhpcyBjaGFyYWN0ZXIgaW5zdGVhZCBvZiBhIHNwYWNlIHRvIHdyYXAgbG9uZyB0ZXh0LlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtc3BhY2luZ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBiZXR3ZWVuIHJlcGVhdGVkIHRleHQgbGFiZWxzIG9uIGEgbGluZSAoYWthLiBsYWJlbC1zcGFjaW5nKVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjaGFyYWN0ZXItc3BhY2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWNoYXJhY3Rlci1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkhvcml6b250YWwgc3BhY2luZyBhZGp1c3RtZW50IGJldHdlZW4gY2hhcmFjdGVycyBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibGluZS1zcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbGluZS1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlZlcnRpY2FsIHNwYWNpbmcgYWRqdXN0bWVudCBiZXR3ZWVuIGxpbmVzIGluIHBpeGVsc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsYWJlbC1wb3NpdGlvbi10b2xlcmFuY2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1sYWJlbC1wb3NpdGlvbi10b2xlcmFuY2VcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRoZSBsYWJlbCB0byBiZSBkaXNwbGFjZWQgZnJvbSBpdHMgaWRlYWwgcG9zaXRpb24gYnkgYSBudW1iZXIgb2YgcGl4ZWxzIChvbmx5IHdvcmtzIHdpdGggcGxhY2VtZW50OmxpbmUpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1heC1jaGFyLWFuZ2xlLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWF4LWNoYXItYW5nbGUtZGVsdGFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjIyLjVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGFuZ2xlIGNoYW5nZSwgaW4gZGVncmVlcywgYWxsb3dlZCBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMgaW4gYSBsYWJlbC4gVGhpcyB2YWx1ZSBpbnRlcm5hbGx5IGlzIGNvbnZlcnRlZCB0byByYWRpYW5zIHRvIHRoZSBkZWZhdWx0IGlzIDIyLjUqbWF0aC5waS8xODAuMC4gVGhlIGhpZ2hlciB0aGUgdmFsdWUgdGhlIGZld2VyIGxhYmVscyB3aWxsIGJlIHBsYWNlZCBhcm91bmQgYXJvdW5kIHNoYXJwIGNvcm5lcnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGNvbG9yIGZvciB0aGUgdGV4dFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBudW1iZXIgZnJvbSAwIHRvIDEgc3BlY2lmeWluZyB0aGUgb3BhY2l0eSBmb3IgdGhlIHRleHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMS4wLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRnVsbHkgb3BhcXVlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1maWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtaGFsby1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIHRoZSBjb2xvciBvZiB0aGUgaGFsbyBhcm91bmQgdGhlIHRleHQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhhbG8tcmFkaXVzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtaGFsby1yYWRpdXNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwZWNpZnkgdGhlIHJhZGl1cyBvZiB0aGUgaGFsbyBpbiBwaXhlbHNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIGhhbG9cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkeFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWR4XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRpc3BsYWNlIHRleHQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWCBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtZHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2UgdGV4dCBieSBmaXhlZCBhbW91bnQsIGluIHBpeGVscywgKy8tIGFsb25nIHRoZSBZIGF4aXMuICBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgc2hpZnQgdGhlIHRleHQgZG93blwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2ZXJ0aWNhbC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC12ZXJ0aWNhbC1hbGlnbm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgIFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiUG9zaXRpb24gb2YgbGFiZWwgcmVsYXRpdmUgdG8gcG9pbnQgcG9zaXRpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRGVmYXVsdCBhZmZlY3RlZCBieSB2YWx1ZSBvZiBkeTsgXFxcImJvdHRvbVxcXCIgZm9yIGR5PjAsIFxcXCJ0b3BcXFwiIGZvciBkeTwwLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhdm9pZC1lZGdlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWF2b2lkLWVkZ2VzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUZWxsIHBvc2l0aW9uaW5nIGFsZ29yaXRobSB0byBhdm9pZCBsYWJlbGluZyBuZWFyIGludGVyc2VjdGlvbiBlZGdlcy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLWRpc3RhbmNlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWluLWRpc3RhbmNlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIHBlcm1pdHRlZCBkaXN0YW5jZSB0byB0aGUgbmV4dCB0ZXh0IHN5bWJvbGl6ZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS1wYWRkaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWluLXBhZGRpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRldGVybWluZXMgdGhlIG1pbmltdW0gYW1vdW50IG9mIHBhZGRpbmcgdGhhdCBhIHRleHQgc3ltYm9saXplciBnZXRzIHJlbGF0aXZlIHRvIG90aGVyIHRleHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLXBhdGgtbGVuZ3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWluLXBhdGgtbGVuZ3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInBsYWNlIGxhYmVscyBvbiBhbGwgcGF0aHNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlBsYWNlIGxhYmVscyBvbmx5IG9uIHBhdGhzIGxvbmdlciB0aGFuIHRoaXMgdmFsdWUuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1hbGxvdy1vdmVybGFwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciBvdmVybGFwcGluZyB0ZXh0IGlzIHNob3duIG9yIGhpZGRlbi5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkRvIG5vdCBhbGxvdyB0ZXh0IHRvIG92ZXJsYXAgd2l0aCBvdGhlciB0ZXh0IC0gb3ZlcmxhcHBpbmcgbWFya2VycyB3aWxsIG5vdCBiZSBzaG93bi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1vcmllbnRhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJSb3RhdGUgdGhlIHRleHQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXBsYWNlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmVydGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJpb3JcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicG9pbnRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgdGhlIHN0eWxlIG9mIHBsYWNlbWVudCBvZiBhIHBvaW50IHZlcnN1cyB0aGUgZ2VvbWV0cnkgaXQgaXMgYXR0YWNoZWQgdG8uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudC10eXBlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtcGxhY2VtZW50LXR5cGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlJlLXBvc2l0aW9uIGFuZC9vciByZS1zaXplIHRleHQgdG8gYXZvaWQgb3ZlcmxhcHMuIFxcXCJzaW1wbGVcXFwiIGZvciBiYXNpYyBhbGdvcml0aG0gKHVzaW5nIHRleHQtcGxhY2VtZW50cyBzdHJpbmcsKSBcXFwiZHVtbXlcXFwiIHRvIHR1cm4gdGhpcyBmZWF0dXJlIG9mZi5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImR1bW15XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2ltcGxlXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImR1bW15XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1wbGFjZW1lbnRzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJJZiBcXFwicGxhY2VtZW50LXR5cGVcXFwiIGlzIHNldCB0byBcXFwic2ltcGxlXFxcIiwgdXNlIHRoaXMgXFxcIlBPU0lUSU9OUyxbU0laRVNdXFxcIiBzdHJpbmcuIEFuIGV4YW1wbGUgaXMgYHRleHQtcGxhY2VtZW50czogXFxcIkUsTkUsU0UsVyxOVyxTV1xcXCI7YCBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsb3dlcmNhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjYXBpdGFsaXplXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVHJhbnNmb3JtIHRoZSBjYXNlIG9mIHRoZSBjaGFyYWN0ZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJob3Jpem9udGFsLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWhvcml6b250YWwtYWxpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRleHQncyBob3Jpem9udGFsIGFsaWdubWVudCBmcm9tIGl0cyBjZW50ZXJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwianVzdGlmeS1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1hbGlnblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRlZmluZSBob3cgdGV4dCBpcyBqdXN0aWZpZWRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJBdXRvIGFsaWdubWVudCBtZWFucyB0aGF0IHRleHQgd2lsbCBiZSBjZW50ZXJlZCBieSBkZWZhdWx0IGV4Y2VwdCB3aGVuIHVzaW5nIHRoZSBgcGxhY2VtZW50LXR5cGVgIHBhcmFtZXRlciAtIGluIHRoYXQgY2FzZSBlaXRoZXIgcmlnaHQgb3IgbGVmdCBqdXN0aWZpY2F0aW9uIHdpbGwgYmUgdXNlZCBhdXRvbWF0aWNhbGx5IGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgdGV4dCBjb3VsZCBiZSBmaXQgZ2l2ZW4gdGhlIGB0ZXh0LXBsYWNlbWVudHNgIGRpcmVjdGl2ZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWNsaXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIGJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBiZWZvcmUgcmVuZGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJnZW9tZXRyaWVzIGFyZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYnkgZGVmYXVsdCBmb3IgYmVzdCByZW5kZXJpbmcgcGVyZm9ybWFuY2UuIEluIHNvbWUgY2FzZXMgdXNlcnMgbWF5IHdpc2ggdG8gZGlzYWJsZSB0aGlzIHRvIGF2b2lkIHJlbmRlcmluZyBhcnRpZmFjdHMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJ1aWxkaW5nXCI6IHtcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJidWlsZGluZy1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBidWlsZGluZ3Mgd2FsbHMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1aWxkaW5nLWZpbGwtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiB0aGUgYnVpbGRpbmcgYXMgYSB3aG9sZSwgaW5jbHVkaW5nIGFsbCB3YWxscy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1aWxkaW5nLWhlaWdodFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGhlaWdodCBvZiB0aGUgYnVpbGRpbmcgaW4gcGl4ZWxzLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidG9ycXVlXCI6IHtcbiAgICAgICAgICBcIi10b3JxdWUtY2xlYXItY29sb3JcIjoge1xuICAgICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtY2xlYXItY29sb3JcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKVwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImZ1bGwgY2xlYXJcIixcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJjb2xvciB1c2VkIHRvIGNsZWFyIGNhbnZhcyBvbiBlYWNoIGZyYW1lXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1mcmFtZS1jb3VudFwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1mcmFtZS1jb3VudFwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIxMjhcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBkYXRhIGlzIGJyb2tlbiBpbnRvIDEyOCB0aW1lIGZyYW1lc1wiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIk51bWJlciBvZiBhbmltYXRpb24gc3RlcHMvZnJhbWVzIHVzZWQgaW4gdGhlIGFuaW1hdGlvbi4gSWYgdGhlIGRhdGEgY29udGFpbnMgYSBmZXdlcmUgbnVtYmVyIG9mIHRvdGFsIGZyYW1lcywgdGhlIGxlc3NlciB2YWx1ZSB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1yZXNvbHV0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLXJlc29sdXRpb25cIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMlwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjpcImZsb2F0XCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiXCIsXG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BhdGlhbCByZXNvbHV0aW9uIGluIHBpeGVscy4gQSByZXNvbHV0aW9uIG9mIDEgbWVhbnMgbm8gc3BhdGlhbCBhZ2dyZWdhdGlvbiBvZiB0aGUgZGF0YS4gQW55IG90aGVyIHJlc29sdXRpb24gb2YgTiByZXN1bHRzIGluIHNwYXRpYWwgYWdncmVnYXRpb24gaW50byBjZWxscyBvZiBOeE4gcGl4ZWxzLiBUaGUgdmFsdWUgTiBtdXN0IGJlIHBvd2VyIG9mIDJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCItdG9ycXVlLWFuaW1hdGlvbi1kdXJhdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1hbmltYXRpb24tZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMzBcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBhbmltYXRpb24gbGFzdHMgMzAgc2Vjb25kc1wiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuaW1hdGlvbiBkdXJhdGlvbiBpbiBzZWNvbmRzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1hZ2dyZWdhdGlvbi1mdW5jdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1hZ2dyZWdhdGlvbi1mdW5jdGlvblwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJjb3VudChjYXJ0b2RiX2lkKVwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0aGUgdmFsdWUgZm9yIGVhY2ggY2VsbCBpcyB0aGUgY291bnQgb2YgcG9pbnRzIGluIHRoYXQgY2VsbFwiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgZnVuY3Rpb24gdXNlZCB0byBjYWxjdWxhdGUgYSB2YWx1ZSBmcm9tIHRoZSBhZ2dyZWdhdGUgZGF0YSBmb3IgZWFjaCBjZWxsLiBTZWUgLXRvcnF1ZS1yZXNvbHV0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS10aW1lLWF0dHJpYnV0ZVwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS10aW1lLWF0dHJpYnV0ZVwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBkYXRhIGNvbHVtbiBpbiB5b3VyIHRhYmxlIHRoYXQgaXMgb2YgYSB0aW1lIGJhc2VkIHR5cGVcIixcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGFibGUgY29sdW1uIHRoYXQgY29udGFpbnMgdGhlIHRpbWUgaW5mb3JtYXRpb24gdXNlZCBjcmVhdGUgdGhlIGFuaW1hdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIi10b3JxdWUtZGF0YS1hZ2dyZWdhdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uXCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImxpbmVhclwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgIFwibGluZWFyXCIsXG4gICAgICAgICAgICAgICAgXCJjdW11bGF0aXZlXCJcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJwcmV2aW91cyB2YWx1ZXMgYXJlIGRpc2NhcmRlZFwiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgbGluZWFyIGFuaW1hdGlvbiB3aWxsIGRpc2NhcmQgcHJldmlvdXMgdmFsdWVzIHdoaWxlIGEgY3VtdWxhdGl2ZSBhbmltYXRpb24gd2lsbCBhY2N1bXVsYXRlIHRoZW0gdW50aWwgaXQgcmVzdGFydHNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJjb2xvcnNcIjoge1xuICAgICAgICBcImFsaWNlYmx1ZVwiOiAgWzI0MCwgMjQ4LCAyNTVdLFxuICAgICAgICBcImFudGlxdWV3aGl0ZVwiOiAgWzI1MCwgMjM1LCAyMTVdLFxuICAgICAgICBcImFxdWFcIjogIFswLCAyNTUsIDI1NV0sXG4gICAgICAgIFwiYXF1YW1hcmluZVwiOiAgWzEyNywgMjU1LCAyMTJdLFxuICAgICAgICBcImF6dXJlXCI6ICBbMjQwLCAyNTUsIDI1NV0sXG4gICAgICAgIFwiYmVpZ2VcIjogIFsyNDUsIDI0NSwgMjIwXSxcbiAgICAgICAgXCJiaXNxdWVcIjogIFsyNTUsIDIyOCwgMTk2XSxcbiAgICAgICAgXCJibGFja1wiOiAgWzAsIDAsIDBdLFxuICAgICAgICBcImJsYW5jaGVkYWxtb25kXCI6ICBbMjU1LDIzNSwyMDVdLFxuICAgICAgICBcImJsdWVcIjogIFswLCAwLCAyNTVdLFxuICAgICAgICBcImJsdWV2aW9sZXRcIjogIFsxMzgsIDQzLCAyMjZdLFxuICAgICAgICBcImJyb3duXCI6ICBbMTY1LCA0MiwgNDJdLFxuICAgICAgICBcImJ1cmx5d29vZFwiOiAgWzIyMiwgMTg0LCAxMzVdLFxuICAgICAgICBcImNhZGV0Ymx1ZVwiOiAgWzk1LCAxNTgsIDE2MF0sXG4gICAgICAgIFwiY2hhcnRyZXVzZVwiOiAgWzEyNywgMjU1LCAwXSxcbiAgICAgICAgXCJjaG9jb2xhdGVcIjogIFsyMTAsIDEwNSwgMzBdLFxuICAgICAgICBcImNvcmFsXCI6ICBbMjU1LCAxMjcsIDgwXSxcbiAgICAgICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiAgWzEwMCwgMTQ5LCAyMzddLFxuICAgICAgICBcImNvcm5zaWxrXCI6ICBbMjU1LCAyNDgsIDIyMF0sXG4gICAgICAgIFwiY3JpbXNvblwiOiAgWzIyMCwgMjAsIDYwXSxcbiAgICAgICAgXCJjeWFuXCI6ICBbMCwgMjU1LCAyNTVdLFxuICAgICAgICBcImRhcmtibHVlXCI6ICBbMCwgMCwgMTM5XSxcbiAgICAgICAgXCJkYXJrY3lhblwiOiAgWzAsIDEzOSwgMTM5XSxcbiAgICAgICAgXCJkYXJrZ29sZGVucm9kXCI6ICBbMTg0LCAxMzQsIDExXSxcbiAgICAgICAgXCJkYXJrZ3JheVwiOiAgWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICBcImRhcmtncmVlblwiOiAgWzAsIDEwMCwgMF0sXG4gICAgICAgIFwiZGFya2dyZXlcIjogIFsxNjksIDE2OSwgMTY5XSxcbiAgICAgICAgXCJkYXJra2hha2lcIjogIFsxODksIDE4MywgMTA3XSxcbiAgICAgICAgXCJkYXJrbWFnZW50YVwiOiAgWzEzOSwgMCwgMTM5XSxcbiAgICAgICAgXCJkYXJrb2xpdmVncmVlblwiOiAgWzg1LCAxMDcsIDQ3XSxcbiAgICAgICAgXCJkYXJrb3JhbmdlXCI6ICBbMjU1LCAxNDAsIDBdLFxuICAgICAgICBcImRhcmtvcmNoaWRcIjogIFsxNTMsIDUwLCAyMDRdLFxuICAgICAgICBcImRhcmtyZWRcIjogIFsxMzksIDAsIDBdLFxuICAgICAgICBcImRhcmtzYWxtb25cIjogIFsyMzMsIDE1MCwgMTIyXSxcbiAgICAgICAgXCJkYXJrc2VhZ3JlZW5cIjogIFsxNDMsIDE4OCwgMTQzXSxcbiAgICAgICAgXCJkYXJrc2xhdGVibHVlXCI6ICBbNzIsIDYxLCAxMzldLFxuICAgICAgICBcImRhcmtzbGF0ZWdyZXlcIjogIFs0NywgNzksIDc5XSxcbiAgICAgICAgXCJkYXJrdHVycXVvaXNlXCI6ICBbMCwgMjA2LCAyMDldLFxuICAgICAgICBcImRhcmt2aW9sZXRcIjogIFsxNDgsIDAsIDIxMV0sXG4gICAgICAgIFwiZGVlcHBpbmtcIjogIFsyNTUsIDIwLCAxNDddLFxuICAgICAgICBcImRlZXBza3libHVlXCI6ICBbMCwgMTkxLCAyNTVdLFxuICAgICAgICBcImRpbWdyYXlcIjogIFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgICAgXCJkaW1ncmV5XCI6ICBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICAgIFwiZG9kZ2VyYmx1ZVwiOiAgWzMwLCAxNDQsIDI1NV0sXG4gICAgICAgIFwiZmlyZWJyaWNrXCI6ICBbMTc4LCAzNCwgMzRdLFxuICAgICAgICBcImZsb3JhbHdoaXRlXCI6ICBbMjU1LCAyNTAsIDI0MF0sXG4gICAgICAgIFwiZm9yZXN0Z3JlZW5cIjogIFszNCwgMTM5LCAzNF0sXG4gICAgICAgIFwiZnVjaHNpYVwiOiAgWzI1NSwgMCwgMjU1XSxcbiAgICAgICAgXCJnYWluc2Jvcm9cIjogIFsyMjAsIDIyMCwgMjIwXSxcbiAgICAgICAgXCJnaG9zdHdoaXRlXCI6ICBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgICAgIFwiZ29sZFwiOiAgWzI1NSwgMjE1LCAwXSxcbiAgICAgICAgXCJnb2xkZW5yb2RcIjogIFsyMTgsIDE2NSwgMzJdLFxuICAgICAgICBcImdyYXlcIjogIFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJncmV5XCI6ICBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICAgIFwiZ3JlZW5cIjogIFswLCAxMjgsIDBdLFxuICAgICAgICBcImdyZWVueWVsbG93XCI6ICBbMTczLCAyNTUsIDQ3XSxcbiAgICAgICAgXCJob25leWRld1wiOiAgWzI0MCwgMjU1LCAyNDBdLFxuICAgICAgICBcImhvdHBpbmtcIjogIFsyNTUsIDEwNSwgMTgwXSxcbiAgICAgICAgXCJpbmRpYW5yZWRcIjogIFsyMDUsIDkyLCA5Ml0sXG4gICAgICAgIFwiaW5kaWdvXCI6ICBbNzUsIDAsIDEzMF0sXG4gICAgICAgIFwiaXZvcnlcIjogIFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgICAgXCJraGFraVwiOiAgWzI0MCwgMjMwLCAxNDBdLFxuICAgICAgICBcImxhdmVuZGVyXCI6ICBbMjMwLCAyMzAsIDI1MF0sXG4gICAgICAgIFwibGF2ZW5kZXJibHVzaFwiOiAgWzI1NSwgMjQwLCAyNDVdLFxuICAgICAgICBcImxhd25ncmVlblwiOiAgWzEyNCwgMjUyLCAwXSxcbiAgICAgICAgXCJsZW1vbmNoaWZmb25cIjogIFsyNTUsIDI1MCwgMjA1XSxcbiAgICAgICAgXCJsaWdodGJsdWVcIjogIFsxNzMsIDIxNiwgMjMwXSxcbiAgICAgICAgXCJsaWdodGNvcmFsXCI6ICBbMjQwLCAxMjgsIDEyOF0sXG4gICAgICAgIFwibGlnaHRjeWFuXCI6ICBbMjI0LCAyNTUsIDI1NV0sXG4gICAgICAgIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogIFsyNTAsIDI1MCwgMjEwXSxcbiAgICAgICAgXCJsaWdodGdyYXlcIjogIFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgXCJsaWdodGdyZWVuXCI6ICBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgICAgIFwibGlnaHRncmV5XCI6ICBbMjExLCAyMTEsIDIxMV0sXG4gICAgICAgIFwibGlnaHRwaW5rXCI6ICBbMjU1LCAxODIsIDE5M10sXG4gICAgICAgIFwibGlnaHRzYWxtb25cIjogIFsyNTUsIDE2MCwgMTIyXSxcbiAgICAgICAgXCJsaWdodHNlYWdyZWVuXCI6ICBbMzIsIDE3OCwgMTcwXSxcbiAgICAgICAgXCJsaWdodHNreWJsdWVcIjogIFsxMzUsIDIwNiwgMjUwXSxcbiAgICAgICAgXCJsaWdodHNsYXRlZ3JheVwiOiAgWzExOSwgMTM2LCAxNTNdLFxuICAgICAgICBcImxpZ2h0c2xhdGVncmV5XCI6ICBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgIFwibGlnaHRzdGVlbGJsdWVcIjogIFsxNzYsIDE5NiwgMjIyXSxcbiAgICAgICAgXCJsaWdodHllbGxvd1wiOiAgWzI1NSwgMjU1LCAyMjRdLFxuICAgICAgICBcImxpbWVcIjogIFswLCAyNTUsIDBdLFxuICAgICAgICBcImxpbWVncmVlblwiOiAgWzUwLCAyMDUsIDUwXSxcbiAgICAgICAgXCJsaW5lblwiOiAgWzI1MCwgMjQwLCAyMzBdLFxuICAgICAgICBcIm1hZ2VudGFcIjogIFsyNTUsIDAsIDI1NV0sXG4gICAgICAgIFwibWFyb29uXCI6ICBbMTI4LCAwLCAwXSxcbiAgICAgICAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6ICBbMTAyLCAyMDUsIDE3MF0sXG4gICAgICAgIFwibWVkaXVtYmx1ZVwiOiAgWzAsIDAsIDIwNV0sXG4gICAgICAgIFwibWVkaXVtb3JjaGlkXCI6ICBbMTg2LCA4NSwgMjExXSxcbiAgICAgICAgXCJtZWRpdW1wdXJwbGVcIjogIFsxNDcsIDExMiwgMjE5XSxcbiAgICAgICAgXCJtZWRpdW1zZWFncmVlblwiOiAgWzYwLCAxNzksIDExM10sXG4gICAgICAgIFwibWVkaXVtc2xhdGVibHVlXCI6ICBbMTIzLCAxMDQsIDIzOF0sXG4gICAgICAgIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogIFswLCAyNTAsIDE1NF0sXG4gICAgICAgIFwibWVkaXVtdHVycXVvaXNlXCI6ICBbNzIsIDIwOSwgMjA0XSxcbiAgICAgICAgXCJtZWRpdW12aW9sZXRyZWRcIjogIFsxOTksIDIxLCAxMzNdLFxuICAgICAgICBcIm1pZG5pZ2h0Ymx1ZVwiOiAgWzI1LCAyNSwgMTEyXSxcbiAgICAgICAgXCJtaW50Y3JlYW1cIjogIFsyNDUsIDI1NSwgMjUwXSxcbiAgICAgICAgXCJtaXN0eXJvc2VcIjogIFsyNTUsIDIyOCwgMjI1XSxcbiAgICAgICAgXCJtb2NjYXNpblwiOiAgWzI1NSwgMjI4LCAxODFdLFxuICAgICAgICBcIm5hdmFqb3doaXRlXCI6ICBbMjU1LCAyMjIsIDE3M10sXG4gICAgICAgIFwibmF2eVwiOiAgWzAsIDAsIDEyOF0sXG4gICAgICAgIFwib2xkbGFjZVwiOiAgWzI1MywgMjQ1LCAyMzBdLFxuICAgICAgICBcIm9saXZlXCI6ICBbMTI4LCAxMjgsIDBdLFxuICAgICAgICBcIm9saXZlZHJhYlwiOiAgWzEwNywgMTQyLCAzNV0sXG4gICAgICAgIFwib3JhbmdlXCI6ICBbMjU1LCAxNjUsIDBdLFxuICAgICAgICBcIm9yYW5nZXJlZFwiOiAgWzI1NSwgNjksIDBdLFxuICAgICAgICBcIm9yY2hpZFwiOiAgWzIxOCwgMTEyLCAyMTRdLFxuICAgICAgICBcInBhbGVnb2xkZW5yb2RcIjogIFsyMzgsIDIzMiwgMTcwXSxcbiAgICAgICAgXCJwYWxlZ3JlZW5cIjogIFsxNTIsIDI1MSwgMTUyXSxcbiAgICAgICAgXCJwYWxldHVycXVvaXNlXCI6ICBbMTc1LCAyMzgsIDIzOF0sXG4gICAgICAgIFwicGFsZXZpb2xldHJlZFwiOiAgWzIxOSwgMTEyLCAxNDddLFxuICAgICAgICBcInBhcGF5YXdoaXBcIjogIFsyNTUsIDIzOSwgMjEzXSxcbiAgICAgICAgXCJwZWFjaHB1ZmZcIjogIFsyNTUsIDIxOCwgMTg1XSxcbiAgICAgICAgXCJwZXJ1XCI6ICBbMjA1LCAxMzMsIDYzXSxcbiAgICAgICAgXCJwaW5rXCI6ICBbMjU1LCAxOTIsIDIwM10sXG4gICAgICAgIFwicGx1bVwiOiAgWzIyMSwgMTYwLCAyMjFdLFxuICAgICAgICBcInBvd2RlcmJsdWVcIjogIFsxNzYsIDIyNCwgMjMwXSxcbiAgICAgICAgXCJwdXJwbGVcIjogIFsxMjgsIDAsIDEyOF0sXG4gICAgICAgIFwicmVkXCI6ICBbMjU1LCAwLCAwXSxcbiAgICAgICAgXCJyb3N5YnJvd25cIjogIFsxODgsIDE0MywgMTQzXSxcbiAgICAgICAgXCJyb3lhbGJsdWVcIjogIFs2NSwgMTA1LCAyMjVdLFxuICAgICAgICBcInNhZGRsZWJyb3duXCI6ICBbMTM5LCA2OSwgMTldLFxuICAgICAgICBcInNhbG1vblwiOiAgWzI1MCwgMTI4LCAxMTRdLFxuICAgICAgICBcInNhbmR5YnJvd25cIjogIFsyNDQsIDE2NCwgOTZdLFxuICAgICAgICBcInNlYWdyZWVuXCI6ICBbNDYsIDEzOSwgODddLFxuICAgICAgICBcInNlYXNoZWxsXCI6ICBbMjU1LCAyNDUsIDIzOF0sXG4gICAgICAgIFwic2llbm5hXCI6ICBbMTYwLCA4MiwgNDVdLFxuICAgICAgICBcInNpbHZlclwiOiAgWzE5MiwgMTkyLCAxOTJdLFxuICAgICAgICBcInNreWJsdWVcIjogIFsxMzUsIDIwNiwgMjM1XSxcbiAgICAgICAgXCJzbGF0ZWJsdWVcIjogIFsxMDYsIDkwLCAyMDVdLFxuICAgICAgICBcInNsYXRlZ3JheVwiOiAgWzExMiwgMTI4LCAxNDRdLFxuICAgICAgICBcInNsYXRlZ3JleVwiOiAgWzExMiwgMTI4LCAxNDRdLFxuICAgICAgICBcInNub3dcIjogIFsyNTUsIDI1MCwgMjUwXSxcbiAgICAgICAgXCJzcHJpbmdncmVlblwiOiAgWzAsIDI1NSwgMTI3XSxcbiAgICAgICAgXCJzdGVlbGJsdWVcIjogIFs3MCwgMTMwLCAxODBdLFxuICAgICAgICBcInRhblwiOiAgWzIxMCwgMTgwLCAxNDBdLFxuICAgICAgICBcInRlYWxcIjogIFswLCAxMjgsIDEyOF0sXG4gICAgICAgIFwidGhpc3RsZVwiOiAgWzIxNiwgMTkxLCAyMTZdLFxuICAgICAgICBcInRvbWF0b1wiOiAgWzI1NSwgOTksIDcxXSxcbiAgICAgICAgXCJ0dXJxdW9pc2VcIjogIFs2NCwgMjI0LCAyMDhdLFxuICAgICAgICBcInZpb2xldFwiOiAgWzIzOCwgMTMwLCAyMzhdLFxuICAgICAgICBcIndoZWF0XCI6ICBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgICAgIFwid2hpdGVcIjogIFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJ3aGl0ZXNtb2tlXCI6ICBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgICAgIFwieWVsbG93XCI6ICBbMjU1LCAyNTUsIDBdLFxuICAgICAgICBcInllbGxvd2dyZWVuXCI6ICBbMTU0LCAyMDUsIDUwXSxcbiAgICAgICAgXCJ0cmFuc3BhcmVudFwiOiAgWzAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBcImZpbHRlclwiOiB7XG4gICAgICAgIFwidmFsdWVcIjogW1xuICAgICAgICAgICAgXCJ0cnVlXCIsXG4gICAgICAgICAgICBcImZhbHNlXCIsXG4gICAgICAgICAgICBcIm51bGxcIixcbiAgICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICAgIFwibGluZXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJwb2x5Z29uXCIsXG4gICAgICAgICAgICBcImNvbGxlY3Rpb25cIlxuICAgICAgICBdXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvbjoge1xuICAgIGxhdGVzdDogX21hcG5pa19yZWZlcmVuY2VfbGF0ZXN0LFxuICAgICcyLjEuMSc6IF9tYXBuaWtfcmVmZXJlbmNlX2xhdGVzdFxuICB9XG59O1xuIiwiLyoqXG4gKiBUT0RPOiBkb2N1bWVudCB0aGlzLiBXaGF0IGRvZXMgdGhpcyBkbz9cbiAqL1xuaWYodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uIChvYmosIGZ1bikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAociA9IGZ1bi5jYWxsKG9iaiwgb2JqW2ldKSkgeyByZXR1cm4gcjsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG4iLCIoZnVuY3Rpb24odHJlZSkge1xudmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG50cmVlLkNhbGwgPSBmdW5jdGlvbiBDYWxsKG5hbWUsIGFyZ3MsIGluZGV4KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbn07XG5cbnRyZWUuQ2FsbC5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdjYWxsJyxcbiAgICAvLyBXaGVuIGV2dWF0aW5nIGEgZnVuY3Rpb24gY2FsbCxcbiAgICAvLyB3ZSBlaXRoZXIgZmluZCB0aGUgZnVuY3Rpb24gaW4gYHRyZWUuZnVuY3Rpb25zYCBbMV0sXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjYWxsIGl0LCBwYXNzaW5nIHRoZSAgZXZhbHVhdGVkIGFyZ3VtZW50cyxcbiAgICAvLyBvciB3ZSBzaW1wbHkgcHJpbnQgaXQgb3V0IGFzIGl0IGFwcGVhcmVkIG9yaWdpbmFsbHkgWzJdLlxuICAgIC8vIFRoZSAqZnVuY3Rpb25zLmpzKiBmaWxlIGNvbnRhaW5zIHRoZSBidWlsdC1pbiBmdW5jdGlvbnMuXG4gICAgLy8gVGhlIHJlYXNvbiB3aHkgd2UgZXZhbHVhdGUgdGhlIGFyZ3VtZW50cywgaXMgaW4gdGhlIGNhc2Ugd2hlcmVcbiAgICAvLyB3ZSB0cnkgdG8gcGFzcyBhIHZhcmlhYmxlIHRvIGEgZnVuY3Rpb24sIGxpa2U6IGBzYXR1cmF0ZShAY29sb3IpYC5cbiAgICAvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJlY2VpdmUgdGhlIHZhbHVlLCBub3QgdGhlIHZhcmlhYmxlLlxuICAgICdldic6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5ldihlbnYpOyB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2ldLmlzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5hbWUgaW4gdHJlZS5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmZ1bmN0aW9uc1t0aGlzLm5hbWVdLmxlbmd0aCA8PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0cmVlLmZ1bmN0aW9uc1t0aGlzLm5hbWVdLmFwcGx5KHRyZWUuZnVuY3Rpb25zLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5jb3JyZWN0IGFyZ3VtZW50cyBnaXZlbiB0byAnICsgdGhpcy5uYW1lICsgJygpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlzOiAndW5kZWZpbmVkJywgdmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCkuICcgKyB0cmVlLmZ1bmN0aW9uc1t0aGlzLm5hbWVdLmxlbmd0aCArICcgZXhwZWN0ZWQuJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm4gPSB0cmVlLlJlZmVyZW5jZS5tYXBuaWtGdW5jdGlvbnNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IF8ucGFpcnModHJlZS5SZWZlcmVuY2UubWFwbmlrRnVuY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVhcCBjbG9zZXN0LCBuZWVkcyBpbXByb3ZlbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgbWVhbiA9IGZ1bmN0aW9ucy5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZbMF0sIHRyZWUuUmVmZXJlbmNlLmVkaXREaXN0YW5jZShuYW1lLCBmWzBdKSwgZlsxXV07XG4gICAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhWzFdIC0gYlsxXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAndW5rbm93biBmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJygpLCBkaWQgeW91IG1lYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFuWzBdWzBdICsgJygnICsgbWVhblswXVsyXSArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm4gIT09IGFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgIShBcnJheS5pc0FycmF5KGZuKSAmJiBfLmluY2x1ZGUoZm4sIGFyZ3MubGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IHZhcmlhYmxlLWFyZyBmdW5jdGlvbnMgbGlrZSBgY29sb3JpemUtYWxwaGFgXG4gICAgICAgICAgICAgICAgZm4gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2Z1bmN0aW9uICcgKyB0aGlzLm5hbWUgKyAnKCkgdGFrZXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiArICcgYXJndW1lbnRzIGFuZCB3YXMgZ2l2ZW4gJyArIGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZXZhbHVhdGVkIHZlcnNpb25zIG9mIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudiwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0aGlzLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJygnICsgdGhpcy5hcmdzLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbi8vIFJHQiBDb2xvcnMgLSAjZmYwMDE0LCAjZWVlXG4vLyBjYW4gYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIDMgb3IgNiBjaGFyIHN0cmluZyBvciBhIDMgb3IgNCBlbGVtZW50XG4vLyBudW1lcmljYWwgYXJyYXlcbnRyZWUuQ29sb3IgPSBmdW5jdGlvbiBDb2xvcihyZ2IsIGEpIHtcbiAgICAvLyBUaGUgZW5kIGdvYWwgaGVyZSwgaXMgdG8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgIC8vIGludG8gYW4gaW50ZWdlciB0cmlwbGV0LCBzdWNoIGFzIGAxMjgsIDI1NSwgMGBcbiAgICAvL1xuICAgIC8vIFRoaXMgZmFjaWxpdGF0ZXMgb3BlcmF0aW9ucyBhbmQgY29udmVyc2lvbnMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmdiKSkge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5zbGljZSgwLCAzKTtcbiAgICB9IGVsc2UgaWYgKHJnYi5sZW5ndGggPT0gNikge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5tYXRjaCgvLnsyfS9nKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGMsIDE2KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZ2IgPSByZ2Iuc3BsaXQoJycpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYyArIGMsIDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IGE7XG4gICAgfSBlbHNlIGlmIChyZ2IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSByZ2JbM107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgfVxufTtcblxudHJlZS5Db2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdjb2xvcicsXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gSWYgd2UgaGF2ZSBzb21lIHRyYW5zcGFyZW5jeSwgdGhlIG9ubHkgd2F5IHRvIHJlcHJlc2VudCBpdFxuICAgIC8vIGlzIHZpYSBgcmdiYWAuIE90aGVyd2lzZSwgd2UgdXNlIHRoZSBoZXggcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2hpY2ggaGFzIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgYnJvd3NlcnMuXG4gICAgLy8gVmFsdWVzIGFyZSBjYXBwZWQgYmV0d2VlbiBgMGAgYW5kIGAyNTVgLCByb3VuZGVkIGFuZCB6ZXJvLXBhZGRlZC5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFscGhhIDwgMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHRoaXMucmdiLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYyk7XG4gICAgICAgICAgICB9KS5jb25jYXQodGhpcy5hbHBoYSkuam9pbignLCAnKSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnIycgKyB0aGlzLnJnYi5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAoaSA+IDI1NSA/IDI1NSA6IChpIDwgMCA/IDAgOiBpKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmxlbmd0aCA9PT0gMSA/ICcwJyArIGkgOiBpO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gT3BlcmF0aW9ucyBoYXZlIHRvIGJlIGRvbmUgcGVyLWNoYW5uZWwsIGlmIG5vdCxcbiAgICAvLyBjaGFubmVscyB3aWxsIHNwaWxsIG9udG8gZWFjaCBvdGhlci4gT25jZSB3ZSBoYXZlXG4gICAgLy8gb3VyIHJlc3VsdCwgaW4gdGhlIGZvcm0gb2YgYW4gaW50ZWdlciB0cmlwbGV0LFxuICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBDb2xvciBub2RlIHRvIGhvbGQgdGhlIHJlc3VsdC5cbiAgICBvcGVyYXRlOiBmdW5jdGlvbihlbnYsIG9wLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgdHJlZS5Db2xvcikpIHtcbiAgICAgICAgICAgIG90aGVyID0gb3RoZXIudG9Db2xvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAzOyBjKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IHRyZWUub3BlcmF0ZShvcCwgdGhpcy5yZ2JbY10sIG90aGVyLnJnYltjXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbG9yKHJlc3VsdCk7XG4gICAgfSxcblxuICAgIHRvSFNMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSxcbiAgICAgICAgICAgIGcgPSB0aGlzLnJnYlsxXSAvIDI1NSxcbiAgICAgICAgICAgIGIgPSB0aGlzLnJnYlsyXSAvIDI1NSxcbiAgICAgICAgICAgIGEgPSB0aGlzLmFscGhhO1xuXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyLCBkID0gbWF4IC0gbWluO1xuXG4gICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgaCA9IHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoIC89IDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaDogaCAqIDM2MCwgczogcywgbDogbCwgYTogYSB9O1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkNvbW1lbnQgPSBmdW5jdGlvbiBDb21tZW50KHZhbHVlLCBzaWxlbnQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zaWxlbnQgPSAhIXNpbGVudDtcbn07XG5cbnRyZWUuQ29tbWVudC5wcm90b3R5cGUgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICByZXR1cm4gJzwhLS0nICsgdGhpcy52YWx1ZSArICctLT4nO1xuICAgIH0sXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKSxcbiAgICBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vLyBBIGRlZmluaXRpb24gaXMgdGhlIGNvbWJpbmF0aW9uIG9mIGEgc2VsZWN0b3IgYW5kIHJ1bGVzLCBsaWtlXG4vLyAjZm9vIHtcbi8vICAgICBwb2x5Z29uLW9wYWNpdHk6MS4wO1xuLy8gfVxuLy9cbi8vIFRoZSBzZWxlY3RvciBjYW4gaGF2ZSBmaWx0ZXJzXG50cmVlLkRlZmluaXRpb24gPSBmdW5jdGlvbiBEZWZpbml0aW9uKHNlbGVjdG9yLCBydWxlcykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBzZWxlY3Rvci5lbGVtZW50cztcbiAgICBhc3NlcnQub2soc2VsZWN0b3IuZmlsdGVycyBpbnN0YW5jZW9mIHRyZWUuRmlsdGVyc2V0KTtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5ydWxlSW5kZXggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCd6b29tJyBpbiB0aGlzLnJ1bGVzW2ldKSB0aGlzLnJ1bGVzW2ldID0gdGhpcy5ydWxlc1tpXS5jbG9uZSgpO1xuICAgICAgICB0aGlzLnJ1bGVzW2ldLnpvb20gPSBzZWxlY3Rvci56b29tO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleFt0aGlzLnJ1bGVzW2ldLnVwZGF0ZUlEKCldID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5maWx0ZXJzID0gc2VsZWN0b3IuZmlsdGVycztcbiAgICB0aGlzLnpvb20gPSBzZWxlY3Rvci56b29tO1xuICAgIHRoaXMuZnJhbWVfb2Zmc2V0ID0gc2VsZWN0b3IuZnJhbWVfb2Zmc2V0O1xuICAgIHRoaXMuYXR0YWNobWVudCA9IHNlbGVjdG9yLmF0dGFjaG1lbnQgfHwgJ19fZGVmYXVsdF9fJztcbiAgICB0aGlzLnNwZWNpZmljaXR5ID0gc2VsZWN0b3Iuc3BlY2lmaWNpdHkoKTtcbn07XG5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5maWx0ZXJzLnRvU3RyaW5nKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSAnXFxuICAgICcgKyB0aGlzLnJ1bGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVycykgYXNzZXJ0Lm9rKGZpbHRlcnMgaW5zdGFuY2VvZiB0cmVlLkZpbHRlcnNldCk7XG4gICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0cmVlLkRlZmluaXRpb24ucHJvdG90eXBlKTtcbiAgICBjbG9uZS5ydWxlcyA9IHRoaXMucnVsZXMuc2xpY2UoKTtcbiAgICBjbG9uZS5ydWxlSW5kZXggPSBfLmNsb25lKHRoaXMucnVsZUluZGV4KTtcbiAgICBjbG9uZS5maWx0ZXJzID0gZmlsdGVycyA/IGZpbHRlcnMgOiB0aGlzLmZpbHRlcnMuY2xvbmUoKTtcbiAgICBjbG9uZS5hdHRhY2htZW50ID0gdGhpcy5hdHRhY2htZW50O1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUuYWRkUnVsZXMgPSBmdW5jdGlvbihydWxlcykge1xuICAgIHZhciBhZGRlZCA9IDA7XG5cbiAgICAvLyBBZGQgb25seSB1bmlxdWUgcnVsZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMucnVsZUluZGV4W3J1bGVzW2ldLmlkXSkge1xuICAgICAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMucnVsZUluZGV4W3J1bGVzW2ldLmlkXSA9IHRydWU7XG4gICAgICAgICAgICBhZGRlZCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xufTtcblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBzZWxlY3RvciBtYXRjaGVzIGEgZ2l2ZW4gaWRcbi8vIGFuZCBhcnJheSBvZiBjbGFzc2VzLCBieSBkZXRlcm1pbmluZyB3aGV0aGVyXG4vLyBhbGwgZWxlbWVudHMgaXQgY29udGFpbnMgbWF0Y2guXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLmFwcGxpZXNUbyA9IGZ1bmN0aW9uKGlkLCBjbGFzc2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICAgIGlmICghKGVsZW0ud2lsZGNhcmQgfHxcbiAgICAgICAgICAgIChlbGVtLnR5cGUgPT09ICdjbGFzcycgJiYgY2xhc3Nlc1tlbGVtLmNsZWFuXSkgfHxcbiAgICAgICAgICAgIChlbGVtLnR5cGUgPT09ICdpZCcgJiYgaWQgPT09IGVsZW0uY2xlYW4pKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIHN5bWJvbGl6ZXJOYW1lKHN5bWJvbGl6ZXIpIHtcbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikgeyByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7IH1cbiAgICByZXR1cm4gc3ltYm9saXplci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgIHN5bWJvbGl6ZXIuc2xpY2UoMSkucmVwbGFjZSgvXFwtLi8sIGNhcGl0YWxpemUpICsgJ1N5bWJvbGl6ZXInO1xufVxuXG4vLyBHZXQgYSBzaW1wbGUgbGlzdCBvZiB0aGUgc3ltYm9saXplcnMsIGluIG9yZGVyXG5mdW5jdGlvbiBzeW1ib2xpemVyTGlzdChzeW1fb3JkZXIpIHtcbiAgICByZXR1cm4gc3ltX29yZGVyLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdlswXTsgfSk7XG59XG5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUuc3ltYm9saXplcnNUb1hNTCA9IGZ1bmN0aW9uKGVudiwgc3ltYm9saXplcnMsIHpvb20pIHtcbiAgICB2YXIgeG1sID0gem9vbS50b1hNTChlbnYpLmpvaW4oJycpICsgdGhpcy5maWx0ZXJzLnRvWE1MKGVudik7XG5cbiAgICAvLyBTb3J0IHN5bWJvbGl6ZXJzIGJ5IHRoZSBpbmRleCBvZiB0aGVpciBmaXJzdCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gICAgdmFyIHN5bV9vcmRlciA9IFtdLCBpbmRleGVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzeW1ib2xpemVyc1trZXldKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goc3ltYm9saXplcnNba2V5XVtwcm9wXS5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbl9pZHggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBpbmRleGVzKTtcbiAgICAgICAgc3ltX29yZGVyLnB1c2goW2tleSwgbWluX2lkeF0pO1xuICAgIH1cblxuICAgIHN5bV9vcmRlciA9IHN5bWJvbGl6ZXJMaXN0KHN5bV9vcmRlcik7XG4gICAgdmFyIHN5bV9jb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bV9vcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHN5bWJvbGl6ZXJzW3N5bV9vcmRlcltpXV07XG4gICAgICAgIHZhciBzeW1ib2xpemVyID0gc3ltX29yZGVyW2ldLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAgICAgLy8gU2tpcCB0aGUgbWFnaWNhbCAqIHN5bWJvbGl6ZXIgd2hpY2ggaXMgdXNlZCBmb3IgdW5pdmVyc2FsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gd2hpY2ggYXJlIGJ1YmJsZWQgdXAgdG8gU3R5bGUgZWxlbWVudHMgaW50ZWFkIG9mIFN5bWJvbGl6ZXIgZWxlbWVudHMuXG4gICAgICAgIGlmIChzeW1ib2xpemVyID09PSAnKicpIGNvbnRpbnVlO1xuICAgICAgICBzeW1fY291bnQrKztcblxuICAgICAgICB2YXIgZmFpbCA9IHRyZWUuUmVmZXJlbmNlLnJlcXVpcmVkUHJvcGVydGllcyhzeW1ib2xpemVyLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGZhaWwpIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gYXR0cmlidXRlc1tPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zaGlmdCgpXTtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZmFpbCxcbiAgICAgICAgICAgICAgICBpbmRleDogcnVsZS5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcnVsZS5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IHN5bWJvbGl6ZXJOYW1lKHN5bWJvbGl6ZXIpO1xuXG4gICAgICAgIHZhciBzZWxmY2xvc2luZyA9IHRydWUsIHRhZ2NvbnRlbnQ7XG4gICAgICAgIHhtbCArPSAnICAgIDwnICsgbmFtZSArICcgJztcbiAgICAgICAgZm9yICh2YXIgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9saXplciA9PT0gJ21hcCcpIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ01hcCBwcm9wZXJ0aWVzIGFyZSBub3QgcGVybWl0dGVkIGluIG90aGVyIHJ1bGVzJyxcbiAgICAgICAgICAgICAgICBpbmRleDogYXR0cmlidXRlc1tqXS5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogYXR0cmlidXRlc1tqXS5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgeCA9IHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKGF0dHJpYnV0ZXNbal0ubmFtZSk7XG4gICAgICAgICAgICBpZiAoeCAmJiB4LnNlcmlhbGl6YXRpb24gJiYgeC5zZXJpYWxpemF0aW9uID09PSAnY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmY2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRhZ2NvbnRlbnQgPSBhdHRyaWJ1dGVzW2pdLmV2KGVudikudG9YTUwoZW52LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCAmJiB4LnNlcmlhbGl6YXRpb24gJiYgeC5zZXJpYWxpemF0aW9uID09PSAndGFnJykge1xuICAgICAgICAgICAgICAgIHNlbGZjbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFnY29udGVudCA9IGF0dHJpYnV0ZXNbal0uZXYoZW52KS50b1hNTChlbnYsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWwgKz0gYXR0cmlidXRlc1tqXS5ldihlbnYpLnRvWE1MKGVudikgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGZjbG9zaW5nKSB7XG4gICAgICAgICAgICB4bWwgKz0gJy8+XFxuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFnY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHRhZ2NvbnRlbnQuaW5kZXhPZignPCcpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgeG1sICs9ICc+JyArIHRhZ2NvbnRlbnQgKyAnPC8nICsgbmFtZSArICc+XFxuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeG1sICs9ICc+PCFbQ0RBVEFbJyArIHRhZ2NvbnRlbnQgKyAnXV0+PC8nICsgbmFtZSArICc+XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN5bV9jb3VudCB8fCAheG1sKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuICcgIDxSdWxlPlxcbicgKyB4bWwgKyAnICA8L1J1bGU+XFxuJztcbn07XG5cbi8vIFRha2UgYSB6b29tIHJhbmdlIG9mIHpvb21zIGFuZCAnaScsIHRoZSBpbmRleCBvZiBhIHJ1bGUgaW4gdGhpcy5ydWxlcyxcbi8vIGFuZCBmaW5kcyBhbGwgYXBwbGljYWJsZSBzeW1ib2xpemVyc1xudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS5jb2xsZWN0U3ltYm9saXplcnMgPSBmdW5jdGlvbih6b29tcywgaSkge1xuICAgIHZhciBzeW1ib2xpemVycyA9IHt9LCBjaGlsZDtcblxuICAgIGZvciAodmFyIGogPSBpOyBqIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGlsZCA9IHRoaXMucnVsZXNbal07XG4gICAgICAgIHZhciBrZXkgPSBjaGlsZC5pbnN0YW5jZSArICcvJyArIGNoaWxkLnN5bWJvbGl6ZXI7XG4gICAgICAgIGlmICh6b29tcy5jdXJyZW50ICYgY2hpbGQuem9vbSAmJlxuICAgICAgICAgICAoIShrZXkgaW4gc3ltYm9saXplcnMpIHx8XG4gICAgICAgICAgICghKGNoaWxkLm5hbWUgaW4gc3ltYm9saXplcnNba2V5XSkpKSkge1xuICAgICAgICAgICAgem9vbXMuY3VycmVudCAmPSBjaGlsZC56b29tO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHN5bWJvbGl6ZXJzKSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbGl6ZXJzW2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN5bWJvbGl6ZXJzW2tleV1bY2hpbGQubmFtZV0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhzeW1ib2xpemVycykubGVuZ3RoKSB7XG4gICAgICAgIHpvb21zLnJ1bGUgJj0gKHpvb21zLmF2YWlsYWJsZSAmPSB+em9vbXMuY3VycmVudCk7XG4gICAgICAgIHJldHVybiBzeW1ib2xpemVycztcbiAgICB9XG59O1xuXG4vLyBUaGUgdHJlZS5ab29tLnRvU3RyaW5nIGZ1bmN0aW9uIGlnbm9yZXMgdGhlIGhvbGVzIGluIHpvb20gcmFuZ2VzIGFuZCBvdXRwdXRzXG4vLyBzY2FsZWRlbm9taW5hdG9ycyB0aGF0IGNvdmVyIHRoZSB3aG9sZSByYW5nZSBmcm9tIHRoZSBmaXJzdCB0byBsYXN0IGJpdCBzZXQuXG4vLyBUaGlzIGFsZ29yaXRobSBjYW4gcHJvZHVjZXMgem9vbSByYW5nZXMgdGhhdCBtYXkgaGF2ZSBob2xlcy4gSG93ZXZlcixcbi8vIHdoZW4gdXNpbmcgdGhlIGZpbHRlci1tb2RlPVwiZmlyc3RcIiwgbW9yZSBzcGVjaWZpYyB6b29tIGZpbHRlcnMgd2lsbCBhbHdheXNcbi8vIGVuZCB1cCBiZWZvcmUgYnJvYWRlciByYW5nZXMuIFRoZSBmaWx0ZXItbW9kZSB3aWxsIHBpY2sgdGhvc2UgZmlyc3QgYmVmb3JlXG4vLyByZXNvcnRpbmcgdG8gdGhlIHpvb20gcmFuZ2Ugd2l0aCB0aGUgaG9sZSBhbmQgc3RvcCBwcm9jZXNzaW5nIGZ1cnRoZXIgcnVsZXMuXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZW52LCBleGlzdGluZykge1xuICAgIHZhciBmaWx0ZXIgPSB0aGlzLmZpbHRlcnMudG9TdHJpbmcoKTtcbiAgICBpZiAoIShmaWx0ZXIgaW4gZXhpc3RpbmcpKSBleGlzdGluZ1tmaWx0ZXJdID0gdHJlZS5ab29tLmFsbDtcblxuICAgIHZhciBhdmFpbGFibGUgPSB0cmVlLlpvb20uYWxsLCB4bWwgPSAnJywgem9vbSwgc3ltYm9saXplcnMsXG4gICAgICAgIHpvb21zID0geyBhdmFpbGFibGU6IHRyZWUuWm9vbS5hbGwgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoICYmIGF2YWlsYWJsZTsgaSsrKSB7XG4gICAgICAgIHpvb21zLnJ1bGUgPSB0aGlzLnJ1bGVzW2ldLnpvb207XG4gICAgICAgIGlmICghKGV4aXN0aW5nW2ZpbHRlcl0gJiB6b29tcy5ydWxlKSkgY29udGludWU7XG5cbiAgICAgICAgd2hpbGUgKHpvb21zLmN1cnJlbnQgPSB6b29tcy5ydWxlICYgYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9saXplcnMgPSB0aGlzLmNvbGxlY3RTeW1ib2xpemVycyh6b29tcywgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShleGlzdGluZ1tmaWx0ZXJdICYgem9vbXMuY3VycmVudCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHhtbCArPSB0aGlzLnN5bWJvbGl6ZXJzVG9YTUwoZW52LCBzeW1ib2xpemVycyxcbiAgICAgICAgICAgICAgICAgICAgKG5ldyB0cmVlLlpvb20oKSkuc2V0Wm9vbShleGlzdGluZ1tmaWx0ZXJdICYgem9vbXMuY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nW2ZpbHRlcl0gJj0gfnpvb21zLmN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geG1sO1xufTtcblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS50b0pTID0gZnVuY3Rpb24oZW52KSB7XG4gIHZhciBzaGFkZXJBdHRycyA9IHt9O1xuXG4gIC8vIG1lcmdlIGNvbmRpdGlvbnMgZnJvbSBmaWx0ZXJzIHdpdGggem9vbSBjb25kaXRpb24gb2YgdGhlXG4gIC8vIGRlZmluaXRpb25cbiAgdmFyIHpvb20gPSBcIihcIiArIHRoaXMuem9vbSArIFwiICYgKDEgPDwgY3R4Lnpvb20pKVwiO1xuICB2YXIgZnJhbWVfb2Zmc2V0ID0gdGhpcy5mcmFtZV9vZmZzZXQ7XG4gIHZhciBfaWYgPSB0aGlzLmZpbHRlcnMudG9KUyhlbnYpO1xuICB2YXIgZmlsdGVycyA9IFt6b29tXTtcbiAgaWYoX2lmKSBmaWx0ZXJzLnB1c2goX2lmKTtcbiAgaWYoZnJhbWVfb2Zmc2V0KSBmaWx0ZXJzLnB1c2goJ2N0eFtcImZyYW1lLW9mZnNldFwiXSA9PT0gJyArIGZyYW1lX29mZnNldCk7XG4gIF9pZiA9IGZpbHRlcnMuam9pbihcIiAmJiBcIik7XG4gIF8uZWFjaCh0aGlzLnJ1bGVzLCBmdW5jdGlvbihydWxlKSB7XG4gICAgICBpZihydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlKSB7XG4gICAgICAgIHNoYWRlckF0dHJzW3J1bGUubmFtZV0gPSBzaGFkZXJBdHRyc1tydWxlLm5hbWVdIHx8IFtdO1xuXG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgIGluZGV4OiBydWxlLmluZGV4LFxuICAgICAgICAgIHN5bWJvbGl6ZXI6IHJ1bGUuc3ltYm9saXplclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfaWYpIHtcbiAgICAgICAgICByLmpzID0gXCJpZihcIiArIF9pZiArIFwiKXtcIiArIHJ1bGUudmFsdWUudG9KUyhlbnYpICsgXCJ9XCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByLmpzID0gcnVsZS52YWx1ZS50b0pTKGVudik7XG4gICAgICAgIH1cblxuICAgICAgICByLmNvbnN0YW50ID0gcnVsZS52YWx1ZS5ldihlbnYpLmlzICE9PSAnZmllbGQnO1xuICAgICAgICByLmZpbHRlcmVkID0gISFfaWY7XG5cbiAgICAgICAgc2hhZGVyQXR0cnNbcnVsZS5uYW1lXS5wdXNoKHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZXNldCBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAvL2lmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlc2V0KSB7XG4gICAgICAgICAgLy92YXIgc2ggPSBydWxlLnRvSlMoZW52KTtcbiAgICAgICAgICAvL2Zvcih2YXIgdiBpbiBzaCkge1xuICAgICAgICAgICAgLy9zaGFkZXJBdHRyc1t2XSA9IHNoYWRlckF0dHJzW3ZdIHx8IFtdO1xuICAgICAgICAgICAgLy9mb3IodmFyIGF0dHIgaW4gc2hbdl0pIHtcbiAgICAgICAgICAgICAgLy9zaGFkZXJBdHRyc1t2XS5wdXNoKHNoW3ZdW2F0dHJdKTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgIC8vfVxuICAgICAgICAvL31cbiAgICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaGFkZXJBdHRycztcbn07XG5cblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG52YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbi8vXG4vLyBBIG51bWJlciB3aXRoIGEgdW5pdFxuLy9cbnRyZWUuRGltZW5zaW9uID0gZnVuY3Rpb24gRGltZW5zaW9uKHZhbHVlLCB1bml0LCBpbmRleCkge1xuICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB0aGlzLnVuaXQgPSB1bml0IHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxudHJlZS5EaW1lbnNpb24ucHJvdG90eXBlID0ge1xuICAgIGlzOiAnZmxvYXQnLFxuICAgIHBoeXNpY2FsX3VuaXRzOiBbJ20nLCAnY20nLCAnaW4nLCAnbW0nLCAncHQnLCAncGMnXSxcbiAgICBzY3JlZW5fdW5pdHM6IFsncHgnLCAnJSddLFxuICAgIGFsbF91bml0czogWydtJywgJ2NtJywgJ2luJywgJ21tJywgJ3B0JywgJ3BjJywgJ3B4JywgJyUnXSxcbiAgICBkZW5zaXRpZXM6IHtcbiAgICAgICAgbTogMC4wMjU0LFxuICAgICAgICBtbTogMjUuNCxcbiAgICAgICAgY206IDIuNTQsXG4gICAgICAgIHB0OiA3MixcbiAgICAgICAgcGM6IDZcbiAgICB9LFxuICAgIGV2OiBmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIGlmICh0aGlzLnVuaXQgJiYgIV8uY29udGFpbnModGhpcy5hbGxfdW5pdHMsIHRoaXMudW5pdCkpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHVuaXQ6ICdcIiArIHRoaXMudW5pdCArIFwiJ1wiLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGlzOiAndW5kZWZpbmVkJywgdmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgdW5pdHMgd2hpY2ggYXJlIG5vdCBweCBvciAlXG4gICAgICAgIGlmICh0aGlzLnVuaXQgJiYgXy5jb250YWlucyh0aGlzLnBoeXNpY2FsX3VuaXRzLCB0aGlzLnVuaXQpKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5wcGkpIHtcbiAgICAgICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcInBwaSBpcyBub3Qgc2V0LCBzbyBtZXRyaWMgdW5pdHMgY2FuJ3QgYmUgdXNlZFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzOiAndW5kZWZpbmVkJywgdmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGFsbCB1bml0cyB0byBpbmNoXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGluY2ggdG8gcHggdXNpbmcgcHBpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gKHRoaXMudmFsdWUgLyB0aGlzLmRlbnNpdGllc1t0aGlzLnVuaXRdKSAqIGVudi5wcGk7XG4gICAgICAgICAgICB0aGlzLnVuaXQgPSAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ29sb3IoW3RoaXMudmFsdWUsIHRoaXMudmFsdWUsIHRoaXMudmFsdWVdKTtcbiAgICB9LFxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgucm91bmQodGhpcy52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgb3BlcmF0ZTogZnVuY3Rpb24oZW52LCBvcCwgb3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudW5pdCA9PT0gJyUnICYmIG90aGVyLnVuaXQgIT09ICclJykge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSWYgdHdvIG9wZXJhbmRzIGRpZmZlciwgdGhlIGZpcnN0IG11c3Qgbm90IGJlICUnLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnVuaXQgIT09ICclJyAmJiBvdGhlci51bml0ID09PSAnJScpIHtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJyonIHx8IG9wID09PSAnLycgfHwgb3AgPT09ICclJykge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQZXJjZW50IHZhbHVlcyBjYW4gb25seSBiZSBhZGRlZCBvciBzdWJ0cmFjdGVkIGZyb20gb3RoZXIgdmFsdWVzJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24odHJlZS5vcGVyYXRlKG9wLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLCB0aGlzLnZhbHVlICogb3RoZXIudmFsdWUgKiAwLjAxKSxcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9oZXJlIHRoZSBvcGVyYW5kcyBhcmUgZWl0aGVyIHRoZSBzYW1lICglIG9yIHVuZGVmaW5lZCBvciBweCksIG9yIG9uZSBpcyB1bmRlZmluZWQgYW5kIHRoZSBvdGhlciBpcyBweFxuICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGltZW5zaW9uKHRyZWUub3BlcmF0ZShvcCwgdGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpLFxuICAgICAgICAgICAgdGhpcy51bml0IHx8IG90aGVyLnVuaXQpO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG4vLyBBbiBlbGVtZW50IGlzIGFuIGlkIG9yIGNsYXNzIHNlbGVjdG9yXG50cmVlLkVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICBpZiAodGhpcy52YWx1ZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdpZCc7XG4gICAgICAgIHRoaXMuY2xlYW4gPSB0aGlzLnZhbHVlLnJlcGxhY2UoL14jLywgJycpO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWx1ZVswXSA9PT0gJy4nKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjbGFzcyc7XG4gICAgICAgIHRoaXMuY2xlYW4gPSB0aGlzLnZhbHVlLnJlcGxhY2UoL15cXC4vLCAnJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbHVlLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3dpbGRjYXJkJztcbiAgICB9XG59O1xuXG4vLyBEZXRlcm1pbmUgdGhlICdzcGVjaWZpY2l0eSBtYXRyaXgnIG9mIHRoaXNcbi8vIHNwZWNpZmljIHNlbGVjdG9yXG50cmVlLkVsZW1lbnQucHJvdG90eXBlLnNwZWNpZmljaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHRoaXMudHlwZSA9PT0gJ2lkJykgPyAxIDogMCwgLy8gYVxuICAgICAgICAodGhpcy50eXBlID09PSAnY2xhc3MnKSA/IDEgOiAwICAvLyBiXG4gICAgXTtcbn07XG5cbnRyZWUuRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmFsdWU7IH07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkV4cHJlc3Npb24gPSBmdW5jdGlvbiBFeHByZXNzaW9uKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcblxudHJlZS5FeHByZXNzaW9uLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ2V4cHJlc3Npb24nLFxuICAgIGV2OiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkV4cHJlc3Npb24odGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmV2KGVudik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXS5ldihlbnYpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvU3RyaW5nKGVudik7XG4gICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5GaWVsZCA9IGZ1bmN0aW9uIEZpZWxkKGNvbnRlbnQpIHtcbiAgICB0aGlzLnZhbHVlID0gY29udGVudCB8fCAnJztcbn07XG5cbnRyZWUuRmllbGQucHJvdG90eXBlID0ge1xuICAgIGlzOiAnZmllbGQnLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHRoaXMudmFsdWUgKyAnXSc7XG4gICAgfSxcbiAgICAnZXYnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuRmlsdGVyID0gZnVuY3Rpb24gRmlsdGVyKGtleSwgb3AsIHZhbCwgaW5kZXgsIGZpbGVuYW1lKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG5cbiAgICB0aGlzLmlkID0gdGhpcy5rZXkgKyB0aGlzLm9wICsgdGhpcy52YWw7XG59O1xuXG4vLyB4bWxzYWZlLCBudW1lcmljLCBzdWZmaXhcbnZhciBvcHMgPSB7XG4gICAgJzwnOiBbJyAmbHQ7ICcsICdudW1lcmljJ10sXG4gICAgJz4nOiBbJyAmZ3Q7ICcsICdudW1lcmljJ10sXG4gICAgJz0nOiBbJyA9ICcsICdib3RoJ10sXG4gICAgJyE9JzogWycgIT0gJywgJ2JvdGgnXSxcbiAgICAnPD0nOiBbJyAmbHQ7PSAnLCAnbnVtZXJpYyddLFxuICAgICc+PSc6IFsnICZndDs9ICcsICdudW1lcmljJ10sXG4gICAgJz1+JzogWycubWF0Y2goJywgJ3N0cmluZycsICcpJ11cbn07XG5cbnRyZWUuRmlsdGVyLnByb3RvdHlwZS5ldiA9IGZ1bmN0aW9uKGVudikge1xuICAgIHRoaXMua2V5ID0gdGhpcy5rZXkuZXYoZW52KTtcbiAgICB0aGlzLnZhbCA9IHRoaXMudmFsLmV2KGVudik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG50cmVlLkZpbHRlci5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICBpZiAodHJlZS5SZWZlcmVuY2UuZGF0YS5maWx0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5LmlzID09PSAna2V5d29yZCcgJiYgLTEgPT09IHRyZWUuUmVmZXJlbmNlLmRhdGEuZmlsdGVyLnZhbHVlLmluZGV4T2YodGhpcy5rZXkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5rZXkudG9TdHJpbmcoKSArICcgaXMgbm90IGEgdmFsaWQga2V5d29yZCBpbiBhIGZpbHRlciBleHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsLmlzID09PSAna2V5d29yZCcgJiYgLTEgPT09IHRyZWUuUmVmZXJlbmNlLmRhdGEuZmlsdGVyLnZhbHVlLmluZGV4T2YodGhpcy52YWwudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy52YWwudG9TdHJpbmcoKSArICcgaXMgbm90IGEgdmFsaWQga2V5d29yZCBpbiBhIGZpbHRlciBleHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleSA9IHRoaXMua2V5LnRvU3RyaW5nKGZhbHNlKTtcbiAgICB2YXIgdmFsID0gdGhpcy52YWwudG9TdHJpbmcodGhpcy52YWwuaXMgPT0gJ3N0cmluZycpO1xuXG4gICAgaWYgKFxuICAgICAgICAob3BzW3RoaXMub3BdWzFdID09ICdudW1lcmljJyAmJiBpc05hTih2YWwpICYmIHRoaXMudmFsLmlzICE9PSAnZmllbGQnKSB8fFxuICAgICAgICAob3BzW3RoaXMub3BdWzFdID09ICdzdHJpbmcnICYmICh2YWwpWzBdICE9IFwiJ1wiKVxuICAgICkge1xuICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCB1c2Ugb3BlcmF0b3IgXCInICsgdGhpcy5vcCArICdcIiB3aXRoIHZhbHVlICcgKyB0aGlzLnZhbCxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleSArIG9wc1t0aGlzLm9wXVswXSArIHZhbCArIChvcHNbdGhpcy5vcF1bMl0gfHwgJycpO1xufTtcblxudHJlZS5GaWx0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdbJyArIHRoaXMuaWQgKyAnXSc7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwidmFyIHRyZWUgPSByZXF1aXJlKCcuLi90cmVlJyk7XG52YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxudHJlZS5GaWx0ZXJzZXQgPSBmdW5jdGlvbiBGaWx0ZXJzZXQoKSB7XG4gICAgdGhpcy5maWx0ZXJzID0ge307XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICBmaWx0ZXJzLnB1c2goJygnICsgdGhpcy5maWx0ZXJzW2lkXS50b1hNTChlbnYpLnRyaW0oKSArICcpJyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyAgICA8RmlsdGVyPicgKyBmaWx0ZXJzLmpvaW4oJyBhbmQgJykgKyAnPC9GaWx0ZXI+XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufTtcblxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuZmlsdGVycykgYXJyLnB1c2godGhpcy5maWx0ZXJzW2lkXS5pZCk7XG4gICAgcmV0dXJuIGFyci5zb3J0KCkuam9pbignXFx0Jyk7XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuZXYgPSBmdW5jdGlvbihlbnYpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnNbaV0uZXYoZW52KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgdHJlZS5GaWx0ZXJzZXQoKTtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgY2xvbmUuZmlsdGVyc1tpZF0gPSB0aGlzLmZpbHRlcnNbaWRdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG4vLyBOb3RlOiBvdGhlciBoYXMgdG8gYmUgYSB0cmVlLkZpbHRlcnNldC5cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS5jbG9uZVdpdGggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpZCBpbiBvdGhlci5maWx0ZXJzKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLmFkZGFibGUob3RoZXIuZmlsdGVyc1tpZF0pO1xuICAgICAgICAvLyBzdGF0dXMgaXMgdHJ1ZSwgZmFsc2Ugb3IgbnVsbC4gaWYgaXQncyBudWxsIHdlIGRvbid0IGZhaWwgdGhpc1xuICAgICAgICAvLyBjbG9uZSBub3IgZG8gd2UgYWRkIHRoZSBmaWx0ZXIuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBmaWx0ZXIgd2lsbCBvdmVycmlkZSBhbm90aGVyIHZhbHVlLlxuICAgICAgICAgICAgYWRkaXRpb25zLnB1c2gob3RoZXIuZmlsdGVyc1tpZF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkaW5nIHRoZSBvdGhlciBmaWx0ZXJzIGRvZXNuJ3QgbWFrZSB0aGlzIGZpbHRlcnNldCBpbnZhbGlkLCBidXQgaXRcbiAgICAvLyBkb2Vzbid0IGFkZCBhbnl0aGluZyB0byBpdCBlaXRoZXIuXG4gICAgaWYgKCFhZGRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbiBzdWNjZXNzZnVsbHkgYWRkIGFsbCBmaWx0ZXJzLiBOb3cgY2xvbmUgdGhlIGZpbHRlcnNldCBhbmQgYWRkIHRoZVxuICAgIC8vIG5ldyBydWxlcy5cbiAgICB2YXIgY2xvbmUgPSBuZXcgdHJlZS5GaWx0ZXJzZXQoKTtcblxuICAgIC8vIFdlIGNhbiBhZGQgdGhlIHJ1bGVzIHRoYXQgYXJlIGFscmVhZHkgcHJlc2VudCB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlXG4gICAgLy8gYWRkIGZ1bmN0aW9uIGFzIGEgRmlsdGVyc2V0IGlzIGFsd2F5cyBpbiBpdCdzIHNpbXBsZXN0IGNhbm9uaWNhbCBmb3JtLlxuICAgIGZvciAoaWQgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgIGNsb25lLmZpbHRlcnNbaWRdID0gdGhpcy5maWx0ZXJzW2lkXTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGFkZCBuZXcgZmlsdGVycyB0aGF0IGFjdHVhbGx5IGNoYW5nZSB0aGUgZmlsdGVyLlxuICAgIHdoaWxlIChpZCA9IGFkZGl0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgIGNsb25lLmFkZChpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbihlbnYpIHtcbiAgdmFyIG9wTWFwID0ge1xuICAgICc9JzogJz09PSdcbiAgfTtcbiAgcmV0dXJuIF8ubWFwKHRoaXMuZmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIG9wID0gZmlsdGVyLm9wO1xuICAgIGlmKG9wIGluIG9wTWFwKSB7XG4gICAgICBvcCA9IG9wTWFwW29wXTtcbiAgICB9XG4gICAgdmFyIHZhbCA9IGZpbHRlci52YWw7XG4gICAgaWYoZmlsdGVyLl92YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsID0gZmlsdGVyLl92YWwudG9TdHJpbmcodHJ1ZSk7XG4gICAgfVxuICAgIHZhciBhdHRycyA9IFwiZGF0YVwiO1xuICAgIHJldHVybiBhdHRycyArIFwiLlwiICsgZmlsdGVyLmtleS52YWx1ZSAgKyBcIiBcIiArIG9wICsgXCIgXCIgKyAodmFsLmlzID09PSAnc3RyaW5nJyA/IFwiJ1wiKyB2YWwgK1wiJ1wiIDogdmFsKTtcbiAgfSkuam9pbignICYmICcpO1xufTtcblxuLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhlIG5ldyBmaWx0ZXIgY2FuIGJlIGFkZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4vLyBJdCBjYW4gYWxzbyByZXR1cm4gbnVsbCwgYW5kIG9uIHRoZSBvdGhlciBzaWRlIHdlIHRlc3QgZm9yID09PSB0cnVlIG9yXG4vLyBmYWxzZVxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLmFkZGFibGUgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIga2V5ID0gZmlsdGVyLmtleS50b1N0cmluZygpLFxuICAgICAgICB2YWx1ZSA9IGZpbHRlci52YWwudG9TdHJpbmcoKTtcblxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlswLTldKyhcXC5bMC05XSopPyQvKSkgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIHN3aXRjaCAoZmlsdGVyLm9wKSB7XG4gICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBmb289IGFuZCB3ZSdyZSBhZGRpbmcgZm9vPVxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsLnRvU3RyaW5nKCkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIHZhbHVlXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10udmFsID4gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10gIT09IHVuZGVmaW5lZCAgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8PSddLnZhbCA8IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc9fic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9J10gIT09IHVuZGVmaW5lZCkgcmV0dXJuICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwgPT0gdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgdmFsdWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPiddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc+J10udmFsID49IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc+PSddLnZhbCA+IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10udmFsIDwgdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICBpZiAoa2V5ICsgJz0nIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10udmFsIDw9IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10udmFsID4gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPScgXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbCA8IHZhbHVlKSA/IGZhbHNlIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXS52YWwgPD0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10udmFsIDwgdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPj0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9JyBdICE9PSB1bmRlZmluZWQpIHJldHVybiAodGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsID49IHZhbHVlKSA/IGZhbHNlIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz49J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10udmFsID49IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc8JyBdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10udmFsIDwgdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPScgXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbCA+IHZhbHVlKSA/IGZhbHNlIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz49J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10udmFsID4gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXS52YWwgPD0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPD0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLy8gRG9lcyB0aGUgbmV3IGZpbHRlciBjb25zdGl0dXRlIGEgY29uZmxpY3Q/XG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuY29uZmxpY3QgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIga2V5ID0gZmlsdGVyLmtleS50b1N0cmluZygpLFxuICAgICAgICB2YWx1ZSA9IGZpbHRlci52YWwudG9TdHJpbmcoKTtcblxuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpKSB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgLy8gaWYgKGE9YikgJiYgKGE9YylcbiAgICAvLyBpZiAoYT1iKSAmJiAoYSE9YilcbiAgICAvLyBvciAoYSE9YikgJiYgKGE9YilcbiAgICBpZiAoKGZpbHRlci5vcCA9PT0gJz0nICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmFsdWUgIT0gdGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsLnRvU3RyaW5nKCkpIHx8XG4gICAgICAgIChmaWx0ZXIub3AgPT09ICchPScgJiYgdGhpcy5maWx0ZXJzW2tleSArICc9J10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB2YWx1ZSA9PSB0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwudG9TdHJpbmcoKSkgfHxcbiAgICAgICAgKGZpbHRlci5vcCA9PT0gJz0nICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZhbHVlID09IHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nXS52YWwudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlci50b1N0cmluZygpICsgJyBhZGRlZCB0byAnICsgdGhpcy50b1N0cmluZygpICsgJyBwcm9kdWNlcyBhbiBpbnZhbGlkIGZpbHRlcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gT25seSBjYWxsIHRoaXMgZnVuY3Rpb24gZm9yIGZpbHRlcnMgdGhhdCBoYXZlIGJlZW4gY2xlYXJlZCBieSAuYWRkYWJsZSgpLlxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZpbHRlciwgZW52KSB7XG4gICAgdmFyIGtleSA9IGZpbHRlci5rZXkudG9TdHJpbmcoKSxcbiAgICAgICAgaWQsXG4gICAgICAgIG9wID0gZmlsdGVyLm9wLFxuICAgICAgICBjb25mbGljdCA9IHRoaXMuY29uZmxpY3QoZmlsdGVyKSxcbiAgICAgICAgbnVtdmFsO1xuXG4gICAgaWYgKGNvbmZsaWN0KSByZXR1cm4gY29uZmxpY3Q7XG5cbiAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS5rZXkgPT0ga2V5KSBkZWxldGUgdGhpcy5maWx0ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyc1trZXkgKyAnPSddID0gZmlsdGVyO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICchPScpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICchPScgKyBmaWx0ZXIudmFsXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPX4nKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyc1trZXkgKyAnPX4nICsgZmlsdGVyLnZhbF0gPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJz4nKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBmaWx0ZXJzIHRoYXQgYXJlIGFsc28gPlxuICAgICAgICAvLyBidXQgYXJlIGxlc3MgdGhhbiB0aGlzIG9uZSwgdGhleSBkb24ndCBtYXR0ZXIsIHNvXG4gICAgICAgIC8vIHJlbW92ZSB0aGVtLlxuICAgICAgICBmb3IgKHZhciBqIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1tqXS5rZXkgPT0ga2V5ICYmIHRoaXMuZmlsdGVyc1tqXS52YWwgPD0gZmlsdGVyLnZhbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc+J10gPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJz49Jykge1xuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgbnVtdmFsID0gKCt0aGlzLmZpbHRlcnNba10udmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trXS5rZXkgPT0ga2V5ICYmIG51bXZhbCA8IGZpbHRlci52YWwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXJzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIGZpbHRlci52YWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIGZpbHRlci52YWxdO1xuICAgICAgICAgICAgZmlsdGVyLm9wID0gJz4nO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc+J10gPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10gPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPCcpIHtcbiAgICAgICAgZm9yICh2YXIgbCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIG51bXZhbCA9ICgrdGhpcy5maWx0ZXJzW2xdLnZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNbbF0ua2V5ID09IGtleSAmJiBudW12YWwgPj0gZmlsdGVyLnZhbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNbbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc8J10gPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJzw9Jykge1xuICAgICAgICBmb3IgKHZhciBtIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgbnVtdmFsID0gKCt0aGlzLmZpbHRlcnNbbV0udmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1ttXS5rZXkgPT0ga2V5ICYmIG51bXZhbCA+IGZpbHRlci52YWwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXJzW21dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIGZpbHRlci52YWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIGZpbHRlci52YWxdO1xuICAgICAgICAgICAgZmlsdGVyLm9wID0gJzwnO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc8J10gPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10gPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5fZ2V0Rm9udFNldCA9IGZ1bmN0aW9uKGVudiwgZm9udHMpIHtcbiAgICB2YXIgZm9udEtleSA9IGZvbnRzLmpvaW4oJycpO1xuICAgIGlmIChlbnYuX2ZvbnRNYXAgJiYgZW52Ll9mb250TWFwW2ZvbnRLZXldKSB7XG4gICAgICAgIHJldHVybiBlbnYuX2ZvbnRNYXBbZm9udEtleV07XG4gICAgfVxuXG4gICAgdmFyIG5ld19mb250c2V0ID0gbmV3IHRyZWUuRm9udFNldChlbnYsIGZvbnRzKTtcbiAgICBlbnYuZWZmZWN0cy5wdXNoKG5ld19mb250c2V0KTtcbiAgICBpZiAoIWVudi5fZm9udE1hcCkgZW52Ll9mb250TWFwID0ge307XG4gICAgZW52Ll9mb250TWFwW2ZvbnRLZXldID0gbmV3X2ZvbnRzZXQ7XG4gICAgcmV0dXJuIG5ld19mb250c2V0O1xufTtcblxudHJlZS5Gb250U2V0ID0gZnVuY3Rpb24gRm9udFNldChlbnYsIGZvbnRzKSB7XG4gICAgdGhpcy5mb250cyA9IGZvbnRzO1xuICAgIHRoaXMubmFtZSA9ICdmb250c2V0LScgKyBlbnYuZWZmZWN0cy5sZW5ndGg7XG59O1xuXG50cmVlLkZvbnRTZXQucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZW52KSB7XG4gICAgcmV0dXJuICc8Rm9udFNldCBuYW1lPVwiJyArXG4gICAgICAgIHRoaXMubmFtZSArXG4gICAgICAgICdcIj5cXG4nICtcbiAgICAgICAgdGhpcy5mb250cy5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuICcgIDxGb250IGZhY2UtbmFtZT1cIicgKyBmICsnXCIvPic7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpICtcbiAgICAgICAgJ1xcbjwvRm9udFNldD4nO1xufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsInZhciB0cmVlID0gcmVxdWlyZSgnLi4vdHJlZScpO1xuXG4vLyBTdG9yYWdlIGZvciBGcmFtZSBvZmZzZXQgdmFsdWVcbi8vIGFuZCBzdG9yZXMgdGhlbSBhcyBiaXQtc2VxdWVuY2VzIHNvIHRoYXQgdGhleSBjYW4gYmUgY29tYmluZWQsXG4vLyBpbnZlcnRlZCwgYW5kIGNvbXBhcmVkIHF1aWNrbHkuXG50cmVlLkZyYW1lT2Zmc2V0ID0gZnVuY3Rpb24ob3AsIHZhbHVlLCBpbmRleCkge1xuICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICBpZiAodmFsdWUgPiB0cmVlLkZyYW1lT2Zmc2V0Lm1heCB8fCB2YWx1ZSA8PSAwKSB7XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdPbmx5IGZyYW1lLW9mZnNldCBsZXZlbHMgYmV0d2VlbiAxIGFuZCAnICtcbiAgICAgICAgICAgICAgICB0cmVlLkZyYW1lT2Zmc2V0Lm1heCArICcgc3VwcG9ydGVkLicsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3AgIT09ICc9Jykge1xuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnb25seSA9IG9wZXJhdG9yIGlzIHN1cHBvcnRlZCBmb3IgZnJhbWUtb2Zmc2V0JyxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG50cmVlLkZyYW1lT2Zmc2V0Lm1heCA9IDMyO1xudHJlZS5GcmFtZU9mZnNldC5ub25lID0gMDtcblxuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5JbWFnZUZpbHRlciA9IGZ1bmN0aW9uIEltYWdlRmlsdGVyKGZpbHRlciwgYXJncykge1xuICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgIHRoaXMuYXJncyA9IGFyZ3MgfHwgbnVsbDtcbn07XG5cbnRyZWUuSW1hZ2VGaWx0ZXIucHJvdG90eXBlID0ge1xuICAgIGlzOiAnaW1hZ2VmaWx0ZXInLFxuICAgIGV2OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlciArICcoJyArIHRoaXMuYXJncy5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24gKHRyZWUpIHtcbnRyZWUuSW52YWxpZCA9IGZ1bmN0aW9uIEludmFsaWQoY2h1bmssIGluZGV4LCBtZXNzYWdlKSB7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnR5cGUgPSAnc3ludGF4JztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiSW52YWxpZCBjb2RlOiBcIiArIHRoaXMuY2h1bms7XG59O1xuXG50cmVlLkludmFsaWQucHJvdG90eXBlLmlzID0gJ2ludmFsaWQnO1xuXG50cmVlLkludmFsaWQucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oZW52KSB7XG4gICAgZW52LmVycm9yKHtcbiAgICAgICAgY2h1bms6IHRoaXMuY2h1bmssXG4gICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICB0eXBlOiAnc3ludGF4JyxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlIHx8IFwiSW52YWxpZCBjb2RlOiBcIiArIHRoaXMuY2h1bmtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpczogJ3VuZGVmaW5lZCdcbiAgICB9O1xufTtcbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLktleXdvcmQgPSBmdW5jdGlvbiBLZXl3b3JkKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHZhciBzcGVjaWFsID0ge1xuICAgICAgICAndHJhbnNwYXJlbnQnOiAnY29sb3InLFxuICAgICAgICAndHJ1ZSc6ICdib29sZWFuJyxcbiAgICAgICAgJ2ZhbHNlJzogJ2Jvb2xlYW4nXG4gICAgfTtcbiAgICB0aGlzLmlzID0gc3BlY2lhbFt2YWx1ZV0gPyBzcGVjaWFsW3ZhbHVlXSA6ICdrZXl3b3JkJztcbn07XG50cmVlLktleXdvcmQucHJvdG90eXBlID0ge1xuICAgIGV2OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuTGF5ZXJYTUwgPSBmdW5jdGlvbihvYmosIHN0eWxlcykge1xuICAgIHZhciBkc29wdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iai5EYXRhc291cmNlKSB7XG4gICAgICAgIGRzb3B0aW9ucy5wdXNoKCc8UGFyYW1ldGVyIG5hbWU9XCInICsgaSArICdcIj48IVtDREFUQVsnICtcbiAgICAgICAgICAgIG9iai5EYXRhc291cmNlW2ldICsgJ11dPjwvUGFyYW1ldGVyPicpO1xuICAgIH1cblxuICAgIHZhciBwcm9wX3N0cmluZyA9ICcnO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdtaW56b29tJykge1xuICAgICAgICAgICAgcHJvcF9zdHJpbmcgKz0gJyAgbWF4em9vbT1cIicgKyB0cmVlLlpvb20ucmFuZ2VzW29iai5wcm9wZXJ0aWVzW3Byb3BdXSArICdcIlxcbic7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ21heHpvb20nKSB7XG4gICAgICAgICAgICBwcm9wX3N0cmluZyArPSAnICBtaW56b29tPVwiJyArIHRyZWUuWm9vbS5yYW5nZXNbb2JqLnByb3BlcnRpZXNbcHJvcF0rMV0gKyAnXCJcXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcF9zdHJpbmcgKz0gJyAgJyArIHByb3AgKyAnPVwiJyArIG9iai5wcm9wZXJ0aWVzW3Byb3BdICsgJ1wiXFxuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnPExheWVyJyArXG4gICAgICAgICcgbmFtZT1cIicgKyBvYmoubmFtZSArICdcIlxcbicgK1xuICAgICAgICBwcm9wX3N0cmluZyArXG4gICAgICAgICgodHlwZW9mIG9iai5zdGF0dXMgPT09ICd1bmRlZmluZWQnKSA/ICcnIDogJyAgc3RhdHVzPVwiJyArIG9iai5zdGF0dXMgKyAnXCJcXG4nKSArXG4gICAgICAgICgodHlwZW9mIG9iai5zcnMgPT09ICd1bmRlZmluZWQnKSA/ICcnIDogJyAgc3JzPVwiJyArIG9iai5zcnMgKyAnXCInKSArICc+XFxuICAgICcgK1xuICAgICAgICBzdHlsZXMucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxTdHlsZU5hbWU+JyArIHMgKyAnPC9TdHlsZU5hbWU+JztcbiAgICAgICAgfSkuam9pbignXFxuICAgICcpICtcbiAgICAgICAgKGRzb3B0aW9ucy5sZW5ndGggP1xuICAgICAgICAnXFxuICAgIDxEYXRhc291cmNlPlxcbiAgICAgICAnICtcbiAgICAgICAgZHNvcHRpb25zLmpvaW4oJ1xcbiAgICAgICAnKSArXG4gICAgICAgICdcXG4gICAgPC9EYXRhc291cmNlPlxcbidcbiAgICAgICAgOiAnJykgK1xuICAgICAgICAnICA8L0xheWVyPlxcbic7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiLy8gQSBsaXRlcmFsIGlzIGEgbGl0ZXJhbCBzdHJpbmcgZm9yIE1hcG5payAtIHRoZVxuLy8gcmVzdWx0IG9mIHRoZSBjb21iaW5hdGlvbiBvZiBhIGB0cmVlLkZpZWxkYCB3aXRoIGFueVxuLy8gb3RoZXIgdHlwZS5cbihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuTGl0ZXJhbCA9IGZ1bmN0aW9uIEZpZWxkKGNvbnRlbnQpIHtcbiAgICB0aGlzLnZhbHVlID0gY29udGVudCB8fCAnJztcbiAgICB0aGlzLmlzID0gJ2ZpZWxkJztcbn07XG5cbnRyZWUuTGl0ZXJhbC5wcm90b3R5cGUgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgICdldic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiLy8gQW4gb3BlcmF0aW9uIGlzIGFuIGV4cHJlc3Npb24gd2l0aCBhbiBvcCBpbiBiZXR3ZWVuIHR3byBvcGVyYW5kcyxcbi8vIGxpa2UgMiArIDEuXG4oZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLk9wZXJhdGlvbiA9IGZ1bmN0aW9uIE9wZXJhdGlvbihvcCwgb3BlcmFuZHMsIGluZGV4KSB7XG4gICAgdGhpcy5vcCA9IG9wLnRyaW0oKTtcbiAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHM7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxudHJlZS5PcGVyYXRpb24ucHJvdG90eXBlLmlzID0gJ29wZXJhdGlvbic7XG5cbnRyZWUuT3BlcmF0aW9uLnByb3RvdHlwZS5ldiA9IGZ1bmN0aW9uKGVudikge1xuICAgIHZhciBhID0gdGhpcy5vcGVyYW5kc1swXS5ldihlbnYpLFxuICAgICAgICBiID0gdGhpcy5vcGVyYW5kc1sxXS5ldihlbnYpLFxuICAgICAgICB0ZW1wO1xuXG4gICAgaWYgKGEuaXMgPT09ICd1bmRlZmluZWQnIHx8IGIuaXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICB2YWx1ZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIHRyZWUuRGltZW5zaW9uICYmIGIgaW5zdGFuY2VvZiB0cmVlLkNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wID09PSAnKicgfHwgdGhpcy5vcCA9PT0gJysnKSB7XG4gICAgICAgICAgICB0ZW1wID0gYiwgYiA9IGEsIGEgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIk9wZXJhdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDYW4ndCBzdWJzdHJhY3Qgb3IgZGl2aWRlIGEgY29sb3IgZnJvbSBhIG51bWJlclwiLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9ubHkgY29uY2F0ZW5hdGUgcGxhaW4gc3RyaW5ncywgYmVjYXVzZSB0aGlzIGlzIGVhc2lseVxuICAgIC8vIHByZS1wcm9jZXNzZWRcbiAgICBpZiAoYSBpbnN0YW5jZW9mIHRyZWUuUXVvdGVkICYmIGIgaW5zdGFuY2VvZiB0cmVlLlF1b3RlZCAmJiB0aGlzLm9wICE9PSAnKycpIHtcbiAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgbWVzc2FnZTogXCJDYW4ndCBzdWJ0cmFjdCwgZGl2aWRlLCBvciBtdWx0aXBseSBzdHJpbmdzLlwiLFxuICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZpZWxkcywgbGl0ZXJhbHMsIGRpbWVuc2lvbnMsIGFuZCBxdW90ZWQgc3RyaW5ncyBjYW4gYmUgY29tYmluZWQuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiB0cmVlLkZpZWxkIHx8IGIgaW5zdGFuY2VvZiB0cmVlLkZpZWxkIHx8XG4gICAgICAgIGEgaW5zdGFuY2VvZiB0cmVlLkxpdGVyYWwgfHwgYiBpbnN0YW5jZW9mIHRyZWUuTGl0ZXJhbCkge1xuICAgICAgICBpZiAoYS5pcyA9PT0gJ2NvbG9yJyB8fCBiLmlzID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDYW4ndCBzdWJ0cmFjdCwgZGl2aWRlLCBvciBtdWx0aXBseSBjb2xvcnMgaW4gZXhwcmVzc2lvbnMuXCIsXG4gICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5MaXRlcmFsKGEuZXYoZW52KS50b1N0cmluZyh0cnVlKSArIHRoaXMub3AgKyBiLmV2KGVudikudG9TdHJpbmcodHJ1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEub3BlcmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgIG1lc3NhZ2U6ICdDYW5ub3QgZG8gbWF0aCB3aXRoIHR5cGUgJyArIGEuaXMgKyAnLicsXG4gICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICB0eXBlOiAncnVudGltZScsXG4gICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGEub3BlcmF0ZShlbnYsIHRoaXMub3AsIGIpO1xufTtcblxudHJlZS5vcGVyYXRlID0gZnVuY3Rpb24ob3AsIGEsIGIpIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgJysnOiByZXR1cm4gYSArIGI7XG4gICAgICAgIGNhc2UgJy0nOiByZXR1cm4gYSAtIGI7XG4gICAgICAgIGNhc2UgJyonOiByZXR1cm4gYSAqIGI7XG4gICAgICAgIGNhc2UgJyUnOiByZXR1cm4gYSAlIGI7XG4gICAgICAgIGNhc2UgJy8nOiByZXR1cm4gYSAvIGI7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuUXVvdGVkID0gZnVuY3Rpb24gUXVvdGVkKGNvbnRlbnQpIHtcbiAgICB0aGlzLnZhbHVlID0gY29udGVudCB8fCAnJztcbn07XG5cbnRyZWUuUXVvdGVkLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3N0cmluZycsXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24ocXVvdGVzKSB7XG4gICAgICAgIHZhciBlc2NhcGVkVmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICB2YXIgeG1sdmFsdWUgPSBlc2NhcGVkVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCcvZywgJ1xcXFxcXCcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXCIvZywgJyZxdW90OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFw+L2csICcmZ3Q7Jyk7XG4gICAgICAgIHJldHVybiAocXVvdGVzID09PSB0cnVlKSA/IFwiJ1wiICsgeG1sdmFsdWUgKyBcIidcIiA6IGVzY2FwZWRWYWx1ZTtcbiAgICB9LFxuXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvcGVyYXRlOiBmdW5jdGlvbihlbnYsIG9wLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuUXVvdGVkKHRyZWUub3BlcmF0ZShvcCwgdGhpcy50b1N0cmluZygpLCBvdGhlci50b1N0cmluZyh0aGlzLmNvbnRhaW5zX2ZpZWxkKSkpO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIvLyBDYXJ0byBwdWxscyBpbiBhIHJlZmVyZW5jZSBmcm9tIHRoZSBgbWFwbmlrLXJlZmVyZW5jZWBcbi8vIG1vZHVsZS4gVGhpcyBmaWxlIGJ1aWxkcyBpbmRleGVzIGZyb20gdGhhdCBmaWxlIGZvciBpdHMgdmFyaW91c1xuLy8gb3B0aW9ucywgYW5kIHByb3ZpZGVzIHZhbGlkYXRpb24gbWV0aG9kcyBmb3IgcHJvcGVydHk6IHZhbHVlXG4vLyBjb21iaW5hdGlvbnMuXG4oZnVuY3Rpb24odHJlZSkge1xuXG52YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICByZWYgPSB7fTtcblxucmVmLnNldERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmVmLmRhdGEgPSBkYXRhO1xuICAgIHJlZi5zZWxlY3Rvcl9jYWNoZSA9IGdlbmVyYXRlU2VsZWN0b3JDYWNoZShkYXRhKTtcbiAgICByZWYubWFwbmlrRnVuY3Rpb25zID0gZ2VuZXJhdGVNYXBuaWtGdW5jdGlvbnMoZGF0YSk7XG5cbiAgICByZWYubWFwbmlrRnVuY3Rpb25zLm1hdHJpeCA9IFs2XTtcbiAgICByZWYubWFwbmlrRnVuY3Rpb25zLnRyYW5zbGF0ZSA9IFsxLCAyXTtcbiAgICByZWYubWFwbmlrRnVuY3Rpb25zLnNjYWxlID0gWzEsIDJdO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMucm90YXRlID0gWzEsIDNdO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMuc2tld1ggPSBbMV07XG4gICAgcmVmLm1hcG5pa0Z1bmN0aW9ucy5za2V3WSA9IFsxXTtcblxuICAgIHJlZi5yZXF1aXJlZF9jYWNoZSA9IGdlbmVyYXRlUmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEpO1xufTtcblxucmVmLnNldFZlcnNpb24gPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICAgdmFyIG1hcG5pa19yZWZlcmVuY2UgPSByZXF1aXJlKCdtYXBuaWstcmVmZXJlbmNlJyk7XG4gICAgaWYgKG1hcG5pa19yZWZlcmVuY2UudmVyc2lvbi5oYXNPd25Qcm9wZXJ0eSh2ZXJzaW9uKSkge1xuICAgICAgICByZWYuc2V0RGF0YShtYXBuaWtfcmVmZXJlbmNlLnZlcnNpb25bdmVyc2lvbl0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxucmVmLnNlbGVjdG9yRGF0YSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBpKSB7XG4gICAgaWYgKHJlZi5zZWxlY3Rvcl9jYWNoZVtzZWxlY3Rvcl0pIHJldHVybiByZWYuc2VsZWN0b3JfY2FjaGVbc2VsZWN0b3JdW2ldO1xufTtcblxucmVmLnZhbGlkU2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gISFyZWYuc2VsZWN0b3JfY2FjaGVbc2VsZWN0b3JdOyB9O1xucmVmLnNlbGVjdG9yTmFtZSA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiByZWYuc2VsZWN0b3JEYXRhKHNlbGVjdG9yLCAyKTsgfTtcbnJlZi5zZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiByZWYuc2VsZWN0b3JEYXRhKHNlbGVjdG9yLCAwKTsgfTtcbnJlZi5zeW1ib2xpemVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHJlZi5zZWxlY3RvckRhdGEoc2VsZWN0b3IsIDEpOyB9O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdG9yQ2FjaGUoZGF0YSkge1xuICAgIHZhciBpbmRleCA9IHt9O1xuICAgIGZvciAodmFyIGkgaW4gZGF0YS5zeW1ib2xpemVycykge1xuICAgICAgICBmb3IgKHZhciBqIGluIGRhdGEuc3ltYm9saXplcnNbaV0pIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN5bWJvbGl6ZXJzW2ldW2pdLmhhc093blByb3BlcnR5KCdjc3MnKSkge1xuICAgICAgICAgICAgICAgIGluZGV4W2RhdGEuc3ltYm9saXplcnNbaV1bal0uY3NzXSA9IFtkYXRhLnN5bWJvbGl6ZXJzW2ldW2pdLCBpLCBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWFwbmlrRnVuY3Rpb25zKGRhdGEpIHtcbiAgICB2YXIgZnVuY3Rpb25zID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBkYXRhLnN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gZGF0YS5zeW1ib2xpemVyc1tpXSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc3ltYm9saXplcnNbaV1bal0udHlwZSA9PT0gJ2Z1bmN0aW9ucycpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRhdGEuc3ltYm9saXplcnNbaV1bal0uZnVuY3Rpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IGRhdGEuc3ltYm9saXplcnNbaV1bal0uZnVuY3Rpb25zW2tdO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNbZm5bMF1dID0gZm5bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEpIHtcbiAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICBmb3IgKHZhciBzeW1ib2xpemVyX25hbWUgaW4gZGF0YS5zeW1ib2xpemVycykge1xuICAgICAgICBjYWNoZVtzeW1ib2xpemVyX25hbWVdID0gW107XG4gICAgICAgIGZvciAodmFyIGogaW4gZGF0YS5zeW1ib2xpemVyc1tzeW1ib2xpemVyX25hbWVdKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zeW1ib2xpemVyc1tzeW1ib2xpemVyX25hbWVdW2pdLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbc3ltYm9saXplcl9uYW1lXS5wdXNoKGRhdGEuc3ltYm9saXplcnNbc3ltYm9saXplcl9uYW1lXVtqXS5jc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbn1cblxucmVmLnJlcXVpcmVkUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN5bWJvbGl6ZXJfbmFtZSwgcnVsZXMpIHtcbiAgICB2YXIgcmVxID0gcmVmLnJlcXVpcmVkX2NhY2hlW3N5bWJvbGl6ZXJfbmFtZV07XG4gICAgZm9yICh2YXIgaSBpbiByZXEpIHtcbiAgICAgICAgaWYgKCEocmVxW2ldIGluIHJ1bGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdQcm9wZXJ0eSAnICsgcmVxW2ldICsgJyByZXF1aXJlZCBmb3IgZGVmaW5pbmcgJyArXG4gICAgICAgICAgICAgICAgc3ltYm9saXplcl9uYW1lICsgJyBzdHlsZXMuJztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFRPRE86IGZpbmlzaCBpbXBsZW1lbnRhdGlvbiAtIHRoaXMgaXMgZGVhZCBjb2RlXG5yZWYuX3ZhbGlkYXRlVmFsdWUgPSB7XG4gICAgJ2ZvbnQnOiBmdW5jdGlvbihlbnYsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlbnYudmFsaWRhdGlvbl9kYXRhICYmIGVudi52YWxpZGF0aW9uX2RhdGEuZm9udHMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYudmFsaWRhdGlvbl9kYXRhLmZvbnRzLmluZGV4T2YodmFsdWUpICE9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5yZWYuaXNGb250ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS52YWxpZGF0ZSA9PSAnZm9udCc7XG59O1xuXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS85ODI5MjdcbnJlZi5lZGl0RGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKXtcbiAgICBpZiAoYS5sZW5ndGggPT09IDApIHJldHVybiBiLmxlbmd0aDtcbiAgICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiBhLmxlbmd0aDtcbiAgICB2YXIgbWF0cml4ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykgeyBtYXRyaXhbaV0gPSBbaV07IH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7IG1hdHJpeFswXVtqXSA9IGo7IH1cbiAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoYi5jaGFyQXQoaS0xKSA9PSBhLmNoYXJBdChqLTEpKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2ktMV1bai0xXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2ktMV1bai0xXSArIDEsIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihtYXRyaXhbaV1bai0xXSArIDEsIC8vIGluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbaS0xXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9ucyh2YWx1ZSwgc2VsZWN0b3IpIHtcbiAgICBpZiAodmFsdWUudmFsdWVbMF0uaXMgPT09ICdzdHJpbmcnKSByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKHZhciBpIGluIHZhbHVlLnZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gdmFsdWUudmFsdWVbaV0udmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZVtpXS52YWx1ZVtqXS5pcyAhPT0gJ2NhbGwnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZiA9IF8uZmluZChyZWZcbiAgICAgICAgICAgICAgICAuc2VsZWN0b3Ioc2VsZWN0b3IpLmZ1bmN0aW9ucywgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geFswXSA9PSB2YWx1ZS52YWx1ZVtpXS52YWx1ZVtqXS5uYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEoZiAmJiBmWzFdID09IC0xKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmlsdGVyIGlzIHVua25vd24gb3IgZ2l2ZW4gYW4gaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBpZiAoIWYgfHwgZlsxXSAhPT0gdmFsdWUudmFsdWVbaV0udmFsdWVbal0uYXJncy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkKHZhbHVlLCBzZWxlY3Rvcikge1xuICAgIGlmICh0eXBlb2YgcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlXG4gICAgICAgICAgICAuaW5kZXhPZih2YWx1ZS52YWx1ZVswXS52YWx1ZSkgIT09IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFsbG93IHVucXVvdGVkIGtleXdvcmRzIGFzIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxufVxuXG5yZWYudmFsaWRWYWx1ZSA9IGZ1bmN0aW9uKGVudiwgc2VsZWN0b3IsIHZhbHVlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgLy8gVE9ETzogaGFuZGxlIGluIHJldXNhYmxlIHdheVxuICAgIGlmICghcmVmLnNlbGVjdG9yKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS52YWx1ZVswXS5pcyA9PSAna2V5d29yZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlS2V5d29yZCh2YWx1ZSwgc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUudmFsdWVbMF0uaXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gY2F1Z2h0IGVhcmxpZXIgaW4gdGhlIGNoYWluIC0gaWdub3JlIGhlcmUgc28gdGhhdFxuICAgICAgICAvLyBlcnJvciBpcyBub3Qgb3ZlcnJpZGRlblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSAnbnVtYmVycycpIHtcbiAgICAgICAgZm9yIChpIGluIHZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudmFsdWVbaV0uaXMgIT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGUgPT0gJ3RhZ3MnKSB7XG4gICAgICAgIGlmICghdmFsdWUudmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF2YWx1ZS52YWx1ZVswXS52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlWzBdLmlzID09PSAndGFnJztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUudmFsdWVbMF0udmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZVswXS52YWx1ZVtpXS5pcyAhPT0gJ3RhZycpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSAnZnVuY3Rpb25zJykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHlvdSBjYW4gc3BlY2lmeSBhIHN0cmluZyBmb3IgYGZ1bmN0aW9uc2AtY29tcGF0aWJsZVxuICAgICAgICAvLyB2YWx1ZXMsIHRob3VnaCB0aGV5IHdpbGwgbm90IGJlIHZhbGlkYXRlZC5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRnVuY3Rpb25zKHZhbHVlLCBzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmIChyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGUgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgICAgaWYgKHZhbHVlLnZhbHVlWzBdLmlzID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICB2YWx1ZS52YWx1ZVswXS5yb3VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLmV4cHJlc3Npb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGUgPT0gdmFsdWUudmFsdWVbaV0uaXMgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAuX3ZhbGlkYXRlVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS52YWxpZGF0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW52LCB2YWx1ZS52YWx1ZVtpXS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSB2YWx1ZS52YWx1ZVswXS5pcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnRyZWUuUmVmZXJlbmNlID0gcmVmO1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbi8vIGEgcnVsZSBpcyBhIHNpbmdsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgY29tYmluYXRpb24sIG9yIHZhcmlhYmxlXG4vLyBuYW1lIGFuZCB2YWx1ZSBjb21iaW5hdGlvbiwgbGlrZVxuLy8gcG9seWdvbi1vcGFjaXR5OiAxLjA7IG9yIEBvcGFjaXR5OiAxLjA7XG50cmVlLlJ1bGUgPSBmdW5jdGlvbiBSdWxlKG5hbWUsIHZhbHVlLCBpbmRleCwgZmlsZW5hbWUpIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcvJyk7XG4gICAgdGhpcy5uYW1lID0gcGFydHMucG9wKCk7XG4gICAgdGhpcy5pbnN0YW5jZSA9IHBhcnRzLmxlbmd0aCA/IHBhcnRzWzBdIDogJ19fZGVmYXVsdF9fJztcbiAgICB0aGlzLnZhbHVlID0gKHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYWx1ZSkgP1xuICAgICAgICB2YWx1ZSA6IG5ldyB0cmVlLlZhbHVlKFt2YWx1ZV0pO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnN5bWJvbGl6ZXIgPSB0cmVlLlJlZmVyZW5jZS5zeW1ib2xpemVyKHRoaXMubmFtZSk7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgIHRoaXMudmFyaWFibGUgPSAobmFtZS5jaGFyQXQoMCkgPT09ICdAJyk7XG59O1xuXG50cmVlLlJ1bGUucHJvdG90eXBlLmlzID0gJ3J1bGUnO1xuXG50cmVlLlJ1bGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0cmVlLlJ1bGUucHJvdG90eXBlKTtcbiAgICBjbG9uZS5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGNsb25lLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBjbG9uZS5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgY2xvbmUuaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuICAgIGNsb25lLnN5bWJvbGl6ZXIgPSB0aGlzLnN5bWJvbGl6ZXI7XG4gICAgY2xvbmUuZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgIGNsb25lLnZhcmlhYmxlID0gdGhpcy52YXJpYWJsZTtcbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG50cmVlLlJ1bGUucHJvdG90eXBlLnVwZGF0ZUlEID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQgPSB0aGlzLnpvb20gKyAnIycgKyB0aGlzLmluc3RhbmNlICsgJyMnICsgdGhpcy5uYW1lO1xufTtcblxudHJlZS5SdWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnWycgKyB0cmVlLlpvb20udG9TdHJpbmcodGhpcy56b29tKSArICddICcgKyB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy52YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldE1lYW4obmFtZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0cmVlLlJlZmVyZW5jZS5zZWxlY3Rvcl9jYWNoZSkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIFtmLCB0cmVlLlJlZmVyZW5jZS5lZGl0RGlzdGFuY2UobmFtZSwgZildO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0pO1xufVxuXG4vLyBzZWNvbmQgYXJndW1lbnQsIGlmIHRydWUsIG91dHB1dHMgdGhlIHZhbHVlIG9mIHRoaXNcbi8vIHJ1bGUgd2l0aG91dCB0aGUgdXN1YWwgYXR0cmlidXRlPVwiY29udGVudFwiIHdyYXBwaW5nLiBSaWdodFxuLy8gbm93IHRoaXMgaXMganVzdCBmb3IgdGhlIFRleHRTeW1ib2xpemVyLCBidXQgYXBwbGllcyB0byBvdGhlclxuLy8gcHJvcGVydGllcyBpbiByZWZlcmVuY2UuanNvbiB3aGljaCBzcGVjaWZ5IHNlcmlhbGl6YXRpb249Y29udGVudFxudHJlZS5SdWxlLnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKGVudiwgY29udGVudCwgc2VwLCBmb3JtYXQpIHtcbiAgICBpZiAoIXRyZWUuUmVmZXJlbmNlLnZhbGlkU2VsZWN0b3IodGhpcy5uYW1lKSkge1xuICAgICAgICB2YXIgbWVhbiA9IGdldE1lYW4odGhpcy5uYW1lKTtcbiAgICAgICAgdmFyIG1lYW5fbWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAobWVhblswXVsxXSA8IDMpIHtcbiAgICAgICAgICAgIG1lYW5fbWVzc2FnZSA9ICcuIERpZCB5b3UgbWVhbiAnICsgbWVhblswXVswXSArICc/JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52LmVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5yZWNvZ25pemVkIHJ1bGU6IFwiICsgdGhpcy5uYW1lICsgbWVhbl9tZXNzYWdlLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICB0eXBlOiAnc3ludGF4JyxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgodGhpcy52YWx1ZSBpbnN0YW5jZW9mIHRyZWUuVmFsdWUpICYmXG4gICAgICAgICF0cmVlLlJlZmVyZW5jZS52YWxpZFZhbHVlKGVudiwgdGhpcy5uYW1lLCB0aGlzLnZhbHVlKSkge1xuICAgICAgICBpZiAoIXRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVbnJlY29nbml6ZWQgcHJvcGVydHk6ICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bnRheCcsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lO1xuICAgICAgICAgICAgaWYgKHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkudmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICB0eXBlbmFtZSA9IHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkudmFsaWRhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmVlLlJlZmVyZW5jZS5zZWxlY3Rvcih0aGlzLm5hbWUpLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdHlwZW5hbWUgPSAna2V5d29yZCAob3B0aW9uczogJyArIHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkudHlwZS5qb2luKCcsICcpICsgJyknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlbmFtZSA9IHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHZhbHVlIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJywgdGhlIHR5cGUgJyArIHR5cGVuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyBpcyBleHBlY3RlZC4gJyArIHRoaXMudmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAnIChvZiB0eXBlICcgKyB0aGlzLnZhbHVlLnZhbHVlWzBdLmlzICsgJykgJyArXG4gICAgICAgICAgICAgICAgICAgICcgd2FzIGdpdmVuLicsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bnRheCcsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAodHJlZS5SZWZlcmVuY2UuaXNGb250KHRoaXMubmFtZSkgJiYgdGhpcy52YWx1ZS52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBmID0gdHJlZS5fZ2V0Rm9udFNldChlbnYsIHRoaXMudmFsdWUudmFsdWUpO1xuICAgICAgICByZXR1cm4gJ2ZvbnRzZXQtbmFtZT1cIicgKyBmLm5hbWUgKyAnXCInO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhlbnYsIHRoaXMubmFtZSwgc2VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3JOYW1lKHRoaXMubmFtZSkgK1xuICAgICAgICAgICAgJz1cIicgK1xuICAgICAgICAgICAgdGhpcy52YWx1ZS50b1N0cmluZyhlbnYsIHRoaXMubmFtZSkgK1xuICAgICAgICAgICAgJ1wiJztcbiAgICB9XG59O1xuXG4vLyBUT0RPOiBSdWxlIGV2IGNoYWluIHNob3VsZCBhZGQgZm9udHNldHMgdG8gZW52LmZyYW1lc1xudHJlZS5SdWxlLnByb3RvdHlwZS5ldiA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IHRyZWUuUnVsZSh0aGlzLm5hbWUsXG4gICAgICAgIHRoaXMudmFsdWUuZXYoY29udGV4dCksXG4gICAgICAgIHRoaXMuaW5kZXgsXG4gICAgICAgIHRoaXMuZmlsZW5hbWUpO1xufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuUnVsZXNldCA9IGZ1bmN0aW9uIFJ1bGVzZXQoc2VsZWN0b3JzLCBydWxlcykge1xuICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAvLyBzdGF0aWMgY2FjaGUgb2YgZmluZCgpIGZ1bmN0aW9uXG4gICAgdGhpcy5fbG9va3VwcyA9IHt9O1xufTtcbnRyZWUuUnVsZXNldC5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdydWxlc2V0JyxcbiAgICAnZXYnOiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBydWxlc2V0ID0gbmV3IHRyZWUuUnVsZXNldCh0aGlzLnNlbGVjdG9ycywgdGhpcy5ydWxlcy5zbGljZSgwKSk7XG4gICAgICAgIHJ1bGVzZXQucm9vdCA9IHRoaXMucm9vdDtcblxuICAgICAgICAvLyBwdXNoIHRoZSBjdXJyZW50IHJ1bGVzZXQgdG8gdGhlIGZyYW1lcyBzdGFja1xuICAgICAgICBlbnYuZnJhbWVzLnVuc2hpZnQocnVsZXNldCk7XG5cbiAgICAgICAgLy8gRXZhbHVhdGUgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGZvciAoaSA9IDAsIHJ1bGU7IGkgPCBydWxlc2V0LnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBydWxlID0gcnVsZXNldC5ydWxlc1tpXTtcbiAgICAgICAgICAgIHJ1bGVzZXQucnVsZXNbaV0gPSBydWxlLmV2ID8gcnVsZS5ldihlbnYpIDogcnVsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvcCB0aGUgc3RhY2tcbiAgICAgICAgZW52LmZyYW1lcy5zaGlmdCgpO1xuXG4gICAgICAgIHJldHVybiBydWxlc2V0O1xuICAgIH0sXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwO1xuICAgIH0sXG4gICAgdmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlcykgeyByZXR1cm4gdGhpcy5fdmFyaWFibGVzOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlcyA9IHRoaXMucnVsZXMucmVkdWNlKGZ1bmN0aW9uKGhhc2gsIHIpIHtcbiAgICAgICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIHRyZWUuUnVsZSAmJiByLnZhcmlhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hbci5uYW1lXSA9IHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2YXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZXMoKVtuYW1lXTtcbiAgICB9LFxuICAgIHJ1bGVzZXRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3J1bGVzZXRzKSB7IHJldHVybiB0aGlzLl9ydWxlc2V0czsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc2V0cyA9IHRoaXMucnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHIgaW5zdGFuY2VvZiB0cmVlLlJ1bGVzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmIHx8IHRoaXM7XG4gICAgICAgIHZhciBydWxlcyA9IFtdLCBydWxlLCBtYXRjaCxcbiAgICAgICAgICAgIGtleSA9IHNlbGVjdG9yLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9sb29rdXBzKSB7IHJldHVybiB0aGlzLl9sb29rdXBzW2tleV07IH1cblxuICAgICAgICB0aGlzLnJ1bGVzZXRzKCkuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICBpZiAocnVsZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcnVsZS5zZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChydWxlLnNlbGVjdG9yc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgcnVsZS5maW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgdHJlZS5TZWxlY3RvcihudWxsLCBudWxsLCBudWxsLCBzZWxlY3Rvci5lbGVtZW50cy5zbGljZSgxKSksIHNlbGYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cHNba2V5XSA9IHJ1bGVzO1xuICAgIH0sXG4gICAgLy8gWm9vbXMgY2FuIHVzZSB2YXJpYWJsZXMuIFRoaXMgcmVwbGFjZXMgdHJlZS5ab29tIG9iamVjdHMgb24gc2VsZWN0b3JzXG4gICAgLy8gd2l0aCBzaW1wbGUgYml0LWFycmF5cyB0aGF0IHdlIGNhbiBjb21wYXJlIGVhc2lseS5cbiAgICBldlpvb21zOiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHp2YWwgPSB0cmVlLlpvb20uYWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCB0aGlzLnNlbGVjdG9yc1tpXS56b29tLmxlbmd0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgenZhbCA9IHp2YWwgJiB0aGlzLnNlbGVjdG9yc1tpXS56b29tW3pdLmV2KGVudikuem9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzW2ldLnpvb20gPSB6dmFsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmbGF0dGVuOiBmdW5jdGlvbihyZXN1bHQsIHBhcmVudHMsIGVudikge1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gW10sIGksIGo7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVudi5mcmFtZXMgPSBlbnYuZnJhbWVzLmNvbmNhdCh0aGlzLnJ1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBldmFsdWF0ZSB6b29tIHZhcmlhYmxlcyBvbiB0aGlzIG9iamVjdC5cbiAgICAgICAgdGhpcy5ldlpvb21zKGVudik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5zZWxlY3RvcnNbaV07XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQuZmlsdGVycykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgaW50ZXJuYWwgaW5jb25zaXN0ZW5jeT9cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZmlsdGVyc2V0LlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFyZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkRmlsdGVycyA9IHBhcmVudC5maWx0ZXJzLmNsb25lV2l0aChjaGlsZC5maWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZEZpbHRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlcnMgY291bGQgYmUgYWRkZWQsIGJ1dCB0aGV5IGRpZG4ndCBjaGFuZ2UgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXJzLiBUaGlzIG1lYW5zIHRoYXQgd2Ugb25seSBoYXZlIHRvIGNsb25lIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6b29tIGxldmVscyBvciB0aGUgYXR0YWNobWVudCBpcyBkaWZmZXJlbnQgdG9vLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC56b29tID09PSAocGFyZW50Lnpvb20gJiBjaGlsZC56b29tKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5mcmFtZV9vZmZzZXQgPT09IGNoaWxkLmZyYW1lX29mZnNldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5hdHRhY2htZW50ID09PSBjaGlsZC5hdHRhY2htZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVsZW1lbnRzLmpvaW4oKSA9PT0gY2hpbGQuZWxlbWVudHMuam9pbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkRmlsdGVycyA9IHBhcmVudC5maWx0ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFtZXJnZWRGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWVyZ2VkIGZpbHRlcnMgYXJlIGludmFsaWQsIHRoYXQgbWVhbnMgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gY2xvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUodHJlZS5TZWxlY3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5maWx0ZXJzID0gbWVyZ2VkRmlsdGVycztcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuem9vbSA9IHBhcmVudC56b29tICYgY2hpbGQuem9vbTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuZnJhbWVfb2Zmc2V0ID0gY2hpbGQuZnJhbWVfb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5lbGVtZW50cyA9IHBhcmVudC5lbGVtZW50cy5jb25jYXQoY2hpbGQuZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmF0dGFjaG1lbnQgJiYgY2hpbGQuYXR0YWNobWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuYXR0YWNobWVudCA9IHBhcmVudC5hdHRhY2htZW50ICsgJy8nICsgY2hpbGQuYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGNsb25lLmF0dGFjaG1lbnQgPSBjaGlsZC5hdHRhY2htZW50IHx8IHBhcmVudC5hdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5jb25kaXRpb25zID0gcGFyZW50LmNvbmRpdGlvbnMgKyBjaGlsZC5jb25kaXRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5pbmRleCA9IGNoaWxkLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChjbG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnVsZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlc1tpXTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhbnkgbmVzdGVkIHJ1bGVzZXRzXG4gICAgICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIHRyZWUuUnVsZXNldCkge1xuICAgICAgICAgICAgICAgIHJ1bGUuZmxhdHRlbihyZXN1bHQsIHNlbGVjdG9ycywgZW52KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIHRyZWUuUnVsZSkge1xuICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiB0cmVlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbnYuZXJyb3IocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSBydWxlcy5sZW5ndGggPyBydWxlc1swXS5pbmRleCA6IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBGb3Igc3BlY2lmaWNpdHkgc29ydCwgdXNlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcnVsZSB0byBhbGxvd1xuICAgICAgICAgICAgLy8gZGVmaW5pbmcgYXR0YWNobWVudHMgdGhhdCBhcmUgdW5kZXIgY3VycmVudCBlbGVtZW50IGFzIGEgZGVzY2VuZGFudFxuICAgICAgICAgICAgLy8gc2VsZWN0b3IuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzW2ldLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgdHJlZS5EZWZpbml0aW9uKHNlbGVjdG9yc1tpXSwgcnVsZXMuc2xpY2UoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuU2VsZWN0b3IgPSBmdW5jdGlvbiBTZWxlY3RvcihmaWx0ZXJzLCB6b29tLCBmcmFtZV9vZmZzZXQsIGVsZW1lbnRzLCBhdHRhY2htZW50LCBjb25kaXRpb25zLCBpbmRleCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cyB8fCBbXTtcbiAgICB0aGlzLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnMgfHwge307XG4gICAgdGhpcy5mcmFtZV9vZmZzZXQgPSBmcmFtZV9vZmZzZXQ7XG4gICAgdGhpcy56b29tID0gdHlwZW9mIHpvb20gIT09ICd1bmRlZmluZWQnID8gem9vbSA6IHRyZWUuWm9vbS5hbGw7XG4gICAgdGhpcy5jb25kaXRpb25zID0gY29uZGl0aW9ucztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuXG4vLyBEZXRlcm1pbmUgdGhlIHNwZWNpZmljaXR5IG9mIHRoaXMgc2VsZWN0b3Jcbi8vIGJhc2VkIG9uIHRoZSBzcGVjaWZpY2l0eSBvZiBpdHMgZWxlbWVudHMgLSBjYWxsaW5nXG4vLyBFbGVtZW50LnNwZWNpZmljaXR5KCkgaW4gb3JkZXIgdG8gZG8gc29cbi8vXG4vLyBbSUQsIENsYXNzLCBGaWx0ZXJzLCBQb3NpdGlvbiBpbiBkb2N1bWVudF1cbnRyZWUuU2VsZWN0b3IucHJvdG90eXBlLnNwZWNpZmljaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGUpIHtcbiAgICAgICAgdmFyIHNwZWMgPSBlLnNwZWNpZmljaXR5KCk7XG4gICAgICAgIG1lbW9bMF0gKz0gc3BlY1swXTtcbiAgICAgICAgbWVtb1sxXSArPSBzcGVjWzFdO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbMCwgMCwgdGhpcy5jb25kaXRpb25zLCB0aGlzLmluZGV4XSk7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbnZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vLyBHaXZlbiBhIHN0eWxlJ3MgbmFtZSwgYXR0YWNobWVudCwgZGVmaW5pdGlvbnMsIGFuZCBhbiBlbnZpcm9ubWVudCBvYmplY3QsXG4vLyByZXR1cm4gYSBzdHJpbmdpZmllZCBzdHlsZSBmb3IgTWFwbmlrXG50cmVlLlN0eWxlWE1MID0gZnVuY3Rpb24obmFtZSwgYXR0YWNobWVudCwgZGVmaW5pdGlvbnMsIGVudikge1xuICAgIHZhciBleGlzdGluZyA9IHt9O1xuICAgIHZhciBpbWFnZV9maWx0ZXJzID0gW10sIGltYWdlX2ZpbHRlcnNfaW5mbGF0ZSA9IFtdLCBkaXJlY3RfaW1hZ2VfZmlsdGVycyA9IFtdLCBjb21wX29wID0gW10sIG9wYWNpdHkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmaW5pdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkZWZpbml0aW9uc1tpXS5ydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdLm5hbWUgPT09ICdpbWFnZS1maWx0ZXJzJykge1xuICAgICAgICAgICAgICAgIGltYWdlX2ZpbHRlcnMucHVzaChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ2ltYWdlLWZpbHRlcnMtaW5mbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBpbWFnZV9maWx0ZXJzX2luZmxhdGUucHVzaChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ2RpcmVjdC1pbWFnZS1maWx0ZXJzJykge1xuICAgICAgICAgICAgICAgIGRpcmVjdF9pbWFnZV9maWx0ZXJzLnB1c2goZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdLm5hbWUgPT09ICdjb21wLW9wJykge1xuICAgICAgICAgICAgICAgIGNvbXBfb3AucHVzaChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eS5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBydWxlcyA9IGRlZmluaXRpb25zLm1hcChmdW5jdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLnRvWE1MKGVudiwgZXhpc3RpbmcpO1xuICAgIH0pO1xuXG4gICAgdmFyIGF0dHJzX3htbCA9ICcnO1xuXG4gICAgaWYgKGltYWdlX2ZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGF0dHJzX3htbCArPSAnIGltYWdlLWZpbHRlcnM9XCInICsgXy5jaGFpbihpbWFnZV9maWx0ZXJzKVxuICAgICAgICAgICAgLy8gcHJldmVudCBpZGVudGljYWwgZmlsdGVycyBmcm9tIGJlaW5nIGR1cGxpY2F0ZWQgaW4gdGhlIHN0eWxlXG4gICAgICAgICAgICAudW5pcShmdW5jdGlvbihpKSB7IHJldHVybiBpLmlkOyB9KS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIGYuZXYoZW52KS50b1hNTChlbnYsIHRydWUsICcsJywgJ2ltYWdlLWZpbHRlcicpO1xuICAgICAgICB9KS52YWx1ZSgpLmpvaW4oJywnKSArICdcIic7XG4gICAgfVxuXG4gICAgaWYgKGltYWdlX2ZpbHRlcnNfaW5mbGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgaW1hZ2UtZmlsdGVycy1pbmZsYXRlPVwiJyArIGltYWdlX2ZpbHRlcnNfaW5mbGF0ZVswXS52YWx1ZS5ldihlbnYpLnRvU3RyaW5nKCkgKyAnXCInO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3RfaW1hZ2VfZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgZGlyZWN0LWltYWdlLWZpbHRlcnM9XCInICsgXy5jaGFpbihkaXJlY3RfaW1hZ2VfZmlsdGVycylcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaWRlbnRpY2FsIGZpbHRlcnMgZnJvbSBiZWluZyBkdXBsaWNhdGVkIGluIHRoZSBzdHlsZVxuICAgICAgICAgICAgLnVuaXEoZnVuY3Rpb24oaSkgeyByZXR1cm4gaS5pZDsgfSkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmV2KGVudikudG9YTUwoZW52LCB0cnVlLCAnLCcsICdkaXJlY3QtaW1hZ2UtZmlsdGVyJyk7XG4gICAgICAgIH0pLnZhbHVlKCkuam9pbignLCcpICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAoY29tcF9vcC5sZW5ndGggJiYgY29tcF9vcFswXS52YWx1ZS5ldihlbnYpLnZhbHVlICE9ICdzcmMtb3ZlcicpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgY29tcC1vcD1cIicgKyBjb21wX29wWzBdLnZhbHVlLmV2KGVudikudG9TdHJpbmcoKSArICdcIic7XG4gICAgfVxuXG4gICAgaWYgKG9wYWNpdHkubGVuZ3RoICYmIG9wYWNpdHlbMF0udmFsdWUuZXYoZW52KS52YWx1ZSAhPSAxKSB7XG4gICAgICAgIGF0dHJzX3htbCArPSAnIG9wYWNpdHk9XCInICsgb3BhY2l0eVswXS52YWx1ZS5ldihlbnYpLnRvU3RyaW5nKCkgKyAnXCInO1xuICAgIH1cbiAgICB2YXIgcnVsZV9zdHJpbmcgPSBydWxlcy5qb2luKCcnKTtcbiAgICBpZiAoIWF0dHJzX3htbCAmJiAhcnVsZV9zdHJpbmcpIHJldHVybiAnJztcbiAgICByZXR1cm4gJzxTdHlsZSBuYW1lPVwiJyArIG5hbWUgKyAnXCIgZmlsdGVyLW1vZGU9XCJmaXJzdFwiJyArIGF0dHJzX3htbCArICc+XFxuJyArIHJ1bGVfc3RyaW5nICsgJzwvU3R5bGU+Jztcbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLlVSTCA9IGZ1bmN0aW9uIFVSTCh2YWwsIHBhdGhzKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICB0aGlzLnBhdGhzID0gcGF0aHM7XG59O1xuXG50cmVlLlVSTC5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICd1cmknLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGV2OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlVSTCh0aGlzLnZhbHVlLmV2KGN0eCksIHRoaXMucGF0aHMpO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLlZhbHVlID0gZnVuY3Rpb24gVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuXG50cmVlLlZhbHVlLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3ZhbHVlJyxcbiAgICBldjogZnVuY3Rpb24oZW52KSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF0uZXYoZW52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5WYWx1ZSh0aGlzLnZhbHVlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuZXYoZW52KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudiwgc2VsZWN0b3IsIHNlcCwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50b1N0cmluZyhlbnYsIGZvcm1hdCk7XG4gICAgICAgIH0pLmpvaW4oc2VwIHx8ICcsICcpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZSh0cmVlLlZhbHVlLnByb3RvdHlwZSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIG9iai52YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UoKTtcbiAgICAgICAgZWxzZSBvYmoudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBvYmouaXMgPSB0aGlzLmlzO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICB0b0pTOiBmdW5jdGlvbihlbnYpIHtcbiAgICAgIC8vdmFyIHYgPSB0aGlzLnZhbHVlWzBdLnZhbHVlWzBdO1xuICAgICAgdmFyIHZhbCA9IHRoaXMuZXYoZW52KTtcbiAgICAgIHZhciB2ID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICBpZih2YWwuaXMgPT09IFwiY29sb3JcIiB8fCB2YWwuaXMgPT09ICd1cmknIHx8IHZhbC5pcyA9PT0gJ3N0cmluZycgfHwgdmFsLmlzID09PSAna2V5d29yZCcpIHtcbiAgICAgICAgdiA9IFwiJ1wiICsgdiArIFwiJ1wiO1xuICAgICAgfSBlbHNlIGlmICh2YWwuaXMgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgLy8gcmVwbGFjZSBbdmFyaWFibGVdIGJ5IGN0eFsndmFyaWFibGUnXVxuICAgICAgICB2ID0gdi5yZXBsYWNlKC9cXFsoLiopXFxdL2csIFwiZGF0YVsnJDEnXVwiKTtcbiAgICAgIH1lbHNlIGlmICh2YWwuaXMgPT09ICdjYWxsJykge1xuICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbmFtZTogdmFsLm5hbWUsXG4gICAgICAgICAgICBhcmdzOiB2YWwuYXJnc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiX3ZhbHVlID0gXCIgKyB2ICsgXCI7XCI7XG4gICAgfVxuXG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5WYXJpYWJsZSA9IGZ1bmN0aW9uIFZhcmlhYmxlKG5hbWUsIGluZGV4LCBmaWxlbmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbn07XG5cbnRyZWUuVmFyaWFibGUucHJvdG90eXBlID0ge1xuICAgIGlzOiAndmFyaWFibGUnLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9LFxuICAgIGV2OiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgdmFyIHZhcmlhYmxlLFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NzcykgcmV0dXJuIHRoaXMuX2NzcztcblxuICAgICAgICB2YXIgdGhpc2ZyYW1lID0gZW52LmZyYW1lcy5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIGYubmFtZSA9PSB0aGlzLm5hbWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzZnJhbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc2ZyYW1lWzBdLnZhbHVlLmV2KGVudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICd2YXJpYWJsZSAnICsgdGhpcy5uYW1lICsgJyBpcyB1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwidmFyIHRyZWUgPSByZXF1aXJlKCcuLi90cmVlJyk7XG5cbi8vIFN0b3JhZ2UgZm9yIHpvb20gcmFuZ2VzLiBPbmx5IHN1cHBvcnRzIGNvbnRpbnVvdXMgcmFuZ2VzLFxuLy8gYW5kIHN0b3JlcyB0aGVtIGFzIGJpdC1zZXF1ZW5jZXMgc28gdGhhdCB0aGV5IGNhbiBiZSBjb21iaW5lZCxcbi8vIGludmVydGVkLCBhbmQgY29tcGFyZWQgcXVpY2tseS5cbnRyZWUuWm9vbSA9IGZ1bmN0aW9uKG9wLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLm9wID0gb3A7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbn07XG5cbnRyZWUuWm9vbS5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxudHJlZS5ab29tLnByb3RvdHlwZS5ldiA9IGZ1bmN0aW9uKGVudikge1xuICAgIHZhciBzdGFydCA9IDAsXG4gICAgICAgIGVuZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHRoaXMudmFsdWUuZXYoZW52KS50b1N0cmluZygpLCAxMCksXG4gICAgICAgIHpvb20gPSAwO1xuXG4gICAgaWYgKHZhbHVlID4gdHJlZS5ab29tLm1heFpvb20gfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnT25seSB6b29tIGxldmVscyBiZXR3ZWVuIDAgYW5kICcgK1xuICAgICAgICAgICAgICAgIHRyZWUuWm9vbS5tYXhab29tICsgJyBzdXBwb3J0ZWQuJyxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5vcCkge1xuICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgIHRoaXMuem9vbSA9IDEgPDwgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICBzdGFydCA9IHZhbHVlICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICBzdGFydCA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgZW5kID0gdmFsdWUgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgIGVuZCA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRyZWUuWm9vbS5tYXhab29tOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPj0gc3RhcnQgJiYgaSA8PSBlbmQpIHtcbiAgICAgICAgICAgIHpvb20gfD0gKDEgPDwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnRyZWUuWm9vbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56b29tO1xufTtcblxuLy8gQ292ZXJzIGFsbCB6b29tbGV2ZWxzIGZyb20gMCB0byAyMlxudHJlZS5ab29tLmFsbCA9IDB4N0ZGRkZGO1xuXG50cmVlLlpvb20ubWF4Wm9vbSA9IDIyO1xuXG50cmVlLlpvb20ucmFuZ2VzID0ge1xuICAgICAwOiAxMDAwMDAwMDAwLFxuICAgICAxOiA1MDAwMDAwMDAsXG4gICAgIDI6IDIwMDAwMDAwMCxcbiAgICAgMzogMTAwMDAwMDAwLFxuICAgICA0OiA1MDAwMDAwMCxcbiAgICAgNTogMjUwMDAwMDAsXG4gICAgIDY6IDEyNTAwMDAwLFxuICAgICA3OiA2NTAwMDAwLFxuICAgICA4OiAzMDAwMDAwLFxuICAgICA5OiAxNTAwMDAwLFxuICAgIDEwOiA3NTAwMDAsXG4gICAgMTE6IDQwMDAwMCxcbiAgICAxMjogMjAwMDAwLFxuICAgIDEzOiAxMDAwMDAsXG4gICAgMTQ6IDUwMDAwLFxuICAgIDE1OiAyNTAwMCxcbiAgICAxNjogMTI1MDAsXG4gICAgMTc6IDUwMDAsXG4gICAgMTg6IDI1MDAsXG4gICAgMTk6IDE1MDAsXG4gICAgMjA6IDc1MCxcbiAgICAyMTogNTAwLFxuICAgIDIyOiAyNTAsXG4gICAgMjM6IDEwMFxufTtcblxuLy8gT25seSB3b3JrcyBmb3Igc2luZ2xlIHJhbmdlIHpvb21zLiBgW1hYWC4uLi5YWFhYWC4uLi4uLi4uLl1gIGlzIGludmFsaWQuXG50cmVlLlpvb20ucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbmRpdGlvbnMgPSBbXTtcbiAgICBpZiAodGhpcy56b29tICE9IHRyZWUuWm9vbS5hbGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbCwgZW5kID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdHJlZS5ab29tLm1heFpvb207IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbSAmICgxIDw8IGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPiAwKSBjb25kaXRpb25zLnB1c2goJyAgICA8TWF4U2NhbGVEZW5vbWluYXRvcj4nICtcbiAgICAgICAgICAgIHRyZWUuWm9vbS5yYW5nZXNbc3RhcnRdICsgJzwvTWF4U2NhbGVEZW5vbWluYXRvcj5cXG4nKTtcbiAgICAgICAgaWYgKGVuZCA8IDIyKSBjb25kaXRpb25zLnB1c2goJyAgICA8TWluU2NhbGVEZW5vbWluYXRvcj4nICtcbiAgICAgICAgICAgIHRyZWUuWm9vbS5yYW5nZXNbZW5kICsgMV0gKyAnPC9NaW5TY2FsZURlbm9taW5hdG9yPlxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZGl0aW9ucztcbn07XG5cbnRyZWUuWm9vbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdHJlZS5ab29tLm1heFpvb207IGkrKykge1xuICAgICAgICBzdHIgKz0gKHRoaXMuem9vbSAmICgxIDw8IGkpKSA/ICdYJyA6ICcuJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpLFxuICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgZXhpc3RzU3luYyA9IHJlcXVpcmUoJ2ZzJykuZXhpc3RzU3luYyB8fCByZXF1aXJlKCdwYXRoJykuZXhpc3RzU3luYztcblxuLy8gTG9hZCBhbGwgc3RhdGVkIHZlcnNpb25zIGludG8gdGhlIG1vZHVsZSBleHBvcnRzXG5tb2R1bGUuZXhwb3J0cy52ZXJzaW9uID0ge307XG5cbnZhciByZWZzID0gW1xuICcyLjAuMCcsXG4gJzIuMC4xJyxcbiAnMi4wLjInLFxuICcyLjEuMCcsXG4gJzIuMS4xJyxcbiAnMi4yLjAnLFxuICcyLjMuMCcsXG4gJzMuMC4wJ1xuXTtcblxucmVmcy5tYXAoZnVuY3Rpb24odmVyc2lvbikge1xuICAgIG1vZHVsZS5leHBvcnRzLnZlcnNpb25bdmVyc2lvbl0gPSByZXF1aXJlKHBhdGguam9pbihfX2Rpcm5hbWUsIHZlcnNpb24sICdyZWZlcmVuY2UuanNvbicpKTtcbiAgICB2YXIgZHNfcGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsIHZlcnNpb24sICdkYXRhc291cmNlcy5qc29uJyk7XG4gICAgaWYgKGV4aXN0c1N5bmMoZHNfcGF0aCkpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMudmVyc2lvblt2ZXJzaW9uXS5kYXRhc291cmNlcyA9IHJlcXVpcmUoZHNfcGF0aCkuZGF0YXNvdXJjZXM7XG4gICAgfVxufSk7XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjYuMFxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIHRvIGJyZWFrIG91dCBvZiBhIGxvb3AgaXRlcmF0aW9uLlxuICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICBjb25jYXQgICAgICAgICAgID0gQXJyYXlQcm90by5jb25jYXQsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUZvckVhY2ggICAgICA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVNYXAgICAgICAgICAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVSZWR1Y2UgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZSxcbiAgICBuYXRpdmVSZWR1Y2VSaWdodCAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxuICAgIG5hdGl2ZUZpbHRlciAgICAgICA9IEFycmF5UHJvdG8uZmlsdGVyLFxuICAgIG5hdGl2ZUV2ZXJ5ICAgICAgICA9IEFycmF5UHJvdG8uZXZlcnksXG4gICAgbmF0aXZlU29tZSAgICAgICAgID0gQXJyYXlQcm90by5zb21lLFxuICAgIG5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVMYXN0SW5kZXhPZiAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS42LjAnO1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZm9yRWFjaGAgaWYgYXZhaWxhYmxlLlxuICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRvciB0byBlYWNoIGVsZW1lbnQuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBtYXBgIGlmIGF2YWlsYWJsZS5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVNYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgdmFyIHJlZHVjZUVycm9yID0gJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlUmlnaHRgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2VSaWdodCAmJiBvYmoucmVkdWNlUmlnaHQgPT09IG5hdGl2ZVJlZHVjZVJpZ2h0KSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gK2xlbmd0aCkge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIH1cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpbmRleCA9IGtleXMgPyBrZXlzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpbaW5kZXhdO1xuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpbmRleF0sIGluZGV4LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgYW55KG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikgcmV0dXJuIG9iai5maWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgfSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBldmVyeWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KSByZXR1cm4gb2JqLmV2ZXJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBzb21lYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIHZhciBhbnkgPSBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVTb21lICYmIG9iai5zb21lID09PSBuYXRpdmVTb21lKSByZXR1cm4gb2JqLnNvbWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocmVzdWx0IHx8IChyZXN1bHQgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICByZXR1cm4gYW55KG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXMoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXMoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIC8vIENhbid0IG9wdGltaXplIGFycmF5cyBvZiBpbnRlZ2VycyBsb25nZXIgdGhhbiA2NSw1MzUgZWxlbWVudHMuXG4gIC8vIFNlZSBbV2ViS2l0IEJ1ZyA4MDc5N10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTgwNzk3KVxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBvYmopO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGFuIGFycmF5LCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJhbmQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBbXTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbShpbmRleCsrKTtcbiAgICAgIHNodWZmbGVkW2luZGV4IC0gMV0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbiAgdmFyIGxvb2t1cEl0ZXJhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIGtleSwgdmFsdWUpIHtcbiAgICBfLmhhcyhyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XS5wdXNoKHZhbHVlKSA6IHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W21pZF0pIDwgdmFsdWUgPyBsb3cgPSBtaWQgKyAxIDogaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIGlmIChuIDwgMCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKipcbiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBvdXRwdXQpIHtcbiAgICBpZiAoc2hhbGxvdyAmJiBfLmV2ZXJ5KGlucHV0LCBfLmlzQXJyYXkpKSB7XG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KG91dHB1dCwgaW5wdXQpO1xuICAgIH1cbiAgICBlYWNoKGlucHV0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgc2hhbGxvdyA/IHB1c2guYXBwbHkob3V0cHV0LCB2YWx1ZSkgOiBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBvdXRwdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBbXSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBTcGxpdCBhbiBhcnJheSBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgZWFjaChhcnJheSwgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgKHByZWRpY2F0ZShlbGVtKSA/IHBhc3MgOiBmYWlsKS5wdXNoKGVsZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdG9yO1xuICAgICAgaXRlcmF0b3IgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpbml0aWFsID0gaXRlcmF0b3IgPyBfLm1hcChhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIDogYXJyYXk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGVhY2goaW5pdGlhbCwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoaXNTb3J0ZWQgPyAoIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gdmFsdWUpIDogIV8uY29udGFpbnMoc2VlbiwgdmFsdWUpKSB7XG4gICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihfLnVuaXEoYXJyYXkpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICByZXR1cm4gXy5jb250YWlucyhvdGhlciwgaXRlbSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTsgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gXy5tYXgoXy5wbHVjayhhcmd1bWVudHMsICdsZW5ndGgnKS5jb25jYXQoMCkpO1xuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCAnJyArIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gIC8vIHdlIG5lZWQgdGhpcyBmdW5jdGlvbi4gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhblxuICAvLyBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgICAgaSA9IChpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSwgaXNTb3J0ZWQpO1xuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBsYXN0SW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBoYXNJbmRleCA9IGZyb20gIT0gbnVsbDtcbiAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSB7XG4gICAgICByZXR1cm4gaGFzSW5kZXggPyBhcnJheS5sYXN0SW5kZXhPZihpdGVtLCBmcm9tKSA6IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IChoYXNJbmRleCA/IGZyb20gOiBhcnJheS5sZW5ndGgpO1xuICAgIHdoaWxlIChpLS0pIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZShpZHggPCBsZW5ndGgpIHtcbiAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuXG4gIHZhciBjdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgIHZhciBzZWxmID0gbmV3IGN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3Muc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmdzW2ldID09PSBfKSBhcmdzW2ldID0gYXJndW1lbnRzW3Bvc2l0aW9uKytdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZWFjaChmdW5jcywgZnVuY3Rpb24oZikgeyBvYmpbZl0gPSBfLmJpbmQob2JqW2ZdLCBvYmopOyB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0ge307XG4gICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gXy5oYXMobWVtbywga2V5KSA/IG1lbW9ba2V5XSA6IChtZW1vW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7IH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuICAgICAgaWYgKGxhc3QgPCB3YWl0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJhbikgcmV0dXJuIG1lbW87XG4gICAgICByYW4gPSB0cnVlO1xuICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFtmdW5jc1tpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBhZnRlciBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKCFfLmNvbnRhaW5zKGtleXMsIGtleSkpIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gYSAhPSArYSA/IGIgIT0gK2IgOiAoYSA9PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyIHNvdXJjZSBwYXR0ZXJucyBhbmQgZmxhZ3MuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmXG4gICAgICAgICAgICAgICBhLm11bHRpbGluZSA9PSBiLm11bHRpbGluZSAmJlxuICAgICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7XG4gICAgfVxuICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3Rgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIChhQ3RvciBpbnN0YW5jZW9mIGFDdG9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIChiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUgPSAwLCByZXN1bHQgPSB0cnVlO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiLCBbXSwgW10pO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAuXG4gIGVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBfLmhhcyhvYmosICdjYWxsZWUnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS5cbiAgaWYgKHR5cGVvZiAoLy4vKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PT0gYXR0cnMpIHJldHVybiB0cnVlOyAvL2F2b2lkIGNvbXBhcmluZyBhbiBvYmplY3QgdG8gaXRzZWxmLlxuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgIGVzY2FwZToge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgfVxuICB9O1xuICBlbnRpdHlNYXAudW5lc2NhcGUgPSBfLmludmVydChlbnRpdHlNYXAuZXNjYXBlKTtcblxuICAvLyBSZWdleGVzIGNvbnRhaW5pbmcgdGhlIGtleXMgYW5kIHZhbHVlcyBsaXN0ZWQgaW1tZWRpYXRlbHkgYWJvdmUuXG4gIHZhciBlbnRpdHlSZWdleGVzID0ge1xuICAgIGVzY2FwZTogICBuZXcgUmVnRXhwKCdbJyArIF8ua2V5cyhlbnRpdHlNYXAuZXNjYXBlKS5qb2luKCcnKSArICddJywgJ2cnKSxcbiAgICB1bmVzY2FwZTogbmV3IFJlZ0V4cCgnKCcgKyBfLmtleXMoZW50aXR5TWFwLnVuZXNjYXBlKS5qb2luKCd8JykgKyAnKScsICdnJylcbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIF8uZWFjaChbJ2VzY2FwZScsICd1bmVzY2FwZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBfW21ldGhvZF0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuICgnJyArIHN0cmluZykucmVwbGFjZShlbnRpdHlSZWdleGVzW21ldGhvZF0sIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlNYXBbbWV0aG9kXVttYXRjaF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHQnOiAgICAgJ3QnLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHR8XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgdmFyIHJlbmRlcjtcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgICAucmVwbGFjZShlc2NhcGVyLCBmdW5jdGlvbihtYXRjaCkgeyByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07IH0pO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgXCJyZXR1cm4gX19wO1xcblwiO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIChzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJykgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbiwgd2hpY2ggd2lsbCBkZWxlZ2F0ZSB0byB0aGUgd3JhcHBlci5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfKG9iaikuY2hhaW4oKTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT0gJ3NoaWZ0JyB8fCBuYW1lID09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgXy5leHRlbmQoXy5wcm90b3R5cGUsIHtcblxuICAgIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICBjaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jaGFpbiA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiY2FydG9cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4xNS4xLWNkYjFcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNhcnRvQ1NTIFN0eWxlc2hlZXQgQ29tcGlsZXJcIixcbiAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0b1wiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by5naXRcIlxuICB9LFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2FydG9EQlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2NhcnRvZGIuY29tL1wiXG4gIH0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwibWFwc1wiLFxuICAgIFwiY3NzXCIsXG4gICAgXCJzdHlsZXNoZWV0c1wiXG4gIF0sXG4gIFwiY29udHJpYnV0b3JzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJUb20gTWFjV3JpZ2h0XCIsXG4gICAgICBcImVtYWlsXCI6IFwibWFjd3JpZ2h0QGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJLb25zdGFudGluIEvDpGZlclwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJBbGV4aXMgU2VsbGllclwiLFxuICAgICAgXCJlbWFpbFwiOiBcInNlbGZAY2xvdWRoZWFkLm5ldFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJSYXVsIE9jaG9hXCIsXG4gICAgICBcImVtYWlsXCI6IFwicm9jaG9hQGNhcnRvZGIuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIkphdmkgU2FudGFuYVwiLFxuICAgICAgXCJlbWFpbFwiOiBcImpzYW50YW5hQGNhcnRvZGIuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwibGljZW5zZXNcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIkFwYWNoZVwiXG4gICAgfVxuICBdLFxuICBcImJpblwiOiB7XG4gICAgXCJjYXJ0b1wiOiBcIi4vYmluL2NhcnRvXCJcbiAgfSxcbiAgXCJtYW5cIjogW1xuICAgIFwiLi9tYW4vY2FydG8uMVwiXG4gIF0sXG4gIFwibWFpblwiOiBcIi4vbGliL2NhcnRvL2luZGV4XCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjQueFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInVuZGVyc2NvcmVcIjogXCJ+MS42LjBcIixcbiAgICBcIm1hcG5pay1yZWZlcmVuY2VcIjogXCJ+Ni4wLjJcIixcbiAgICBcIm9wdGltaXN0XCI6IFwifjAuNi4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibW9jaGFcIjogXCIxLjEyLnhcIixcbiAgICBcImpzaGludFwiOiBcIjAuMi54XCIsXG4gICAgXCJzYXhcIjogXCIwLjEueFwiLFxuICAgIFwiaXN0YW5idWxcIjogXCJ+MC4yLjE0XCIsXG4gICAgXCJjb3ZlcmFsbHNcIjogXCJ+Mi4xMC4xXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwifjcuMC4wXCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCIxLjMuM1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJwcmV0ZXN0XCI6IFwibnBtIGluc3RhbGxcIixcbiAgICBcInRlc3RcIjogXCJtb2NoYSAtUiBzcGVjXCIsXG4gICAgXCJjb3ZlcmFnZVwiOiBcImlzdGFuYnVsIGNvdmVyIC4vbm9kZV9tb2R1bGVzLy5iaW4vX21vY2hhICYmIGNvdmVyYWxscyA8IC4vY292ZXJhZ2UvbGNvdi5pbmZvXCJcbiAgfSxcbiAgXCJyZWFkbWVcIjogXCIjIENhcnRvQ1NTXFxuXFxuWyFbQnVpbGQgU3RhdHVzXShodHRwczovL3NlY3VyZS50cmF2aXMtY2kub3JnL21hcGJveC9jYXJ0by5wbmcpXShodHRwOi8vdHJhdmlzLWNpLm9yZy9tYXBib3gvY2FydG8pXFxuXFxuSXMgYXMgc3R5bGVzaGVldCByZW5kZXJlciBmb3IgamF2YXNjcmlwdCwgSXQncyBhbiBldm9sdXRpb24gb2YgdGhlIE1hcG5payByZW5kZXJlciBmcm9tIE1hcGJveC5cXG5QbGVhc2UsIHNlZSBvcmlnaW5hbCBbTWFwYm94IHJlcG9dKGh0dHA6Ly9naXRodWIuY29tL21hcGJveC9jYXJ0bykgZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGNyZWRpdHNcXG5cXG4jIyBRdWljayBTdGFydFxcblxcbmBgYGphdmFzY3JpcHRcXG4vLyBzaGFkZXIgaXMgYSBDYXJ0b0NTUyBvYmplY3RcXG5cXG52YXIgY2FydG9jc3MgPSBbXFxuICAgICcjbGF5ZXIgeycsXFxuICAgICcgbWFya2VyLXdpZHRoOiBbcHJvcGVydHldJyxcXG4gICAgJyBtYXJrZXItZmlsbDogcmVkJyxcXG4gICAgJ30nXFxuXS5qb2luKCcnKVxcbnZhciBzaGFkZXIgPSBuZXcgY2FydG8uUmVuZGVyZXJKUygpLnJlbmRlcihjYXJ0b2Nzcyk7XFxudmFyIGxheWVycyA9IHNoYWRlci5nZXRMYXllcnMoKVxcbmZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcXG4gICAgY29uc29sZS5sb2coXFxcImxheWVyIG5hbWU6IFxcXCIsIGxheWVyLmZ1bGxOYW1lKCkpXFxuICAgIGNvbnNvbGUubG9nKFxcXCItIGZyYW1lczogXFxcIiwgbGF5ZXIuZnJhbWVzKCkpXFxuICAgIGNvbnNvbGUubG9nKFxcXCItIGF0dGFjaG1lbnQ6IFxcXCIsIGxheWVyLmF0dGFjaG1lbnQoKSlcXG5cXG4gICAgdmFyIGxheWVyU2hhZGVyID0gbGF5ZXIuZ2V0U3R5bGUoeyBwcm9wZXJ0eTogMSB9LCB7IHpvb206IDEwIH0pXFxuICAgIGNvbnNvbGUubG9nKGxheWVyU2hhZGVyWydtYXJrZXItd2lkdGgnXSkgLy8gMVxcbiAgICBjb25zb2xlLmxvZyhsYXllclNoYWRlclsnbWFya2VyLWZpbGwnXSkgLy8gI0ZGMDAwMFxcbn1cXG5cXG5gYGBcXG5cXG4jIEFQSVxcblxcbiMjIFJlbmRlcmVySlNcXG5cXG4jIyMgcmVuZGVyKGNhcnRvY3NzKVxcblxcbiMjIENhcnRvQ1NTXFxuXFxuY29tcGlsZWQgY2FydG9jc3Mgb2JqZWN0XFxuXFxuIyMjIGdldExheWVyc1xcblxcbnJldHVybiB0aGUgbGF5ZXJzLCBhbiBhcnJheSBvZiBgYENhcnRvQ1NTLkxheWVyYGAgb2JqZWN0XFxuXFxuIyMjIGdldERlZmF1bHRcXG5cXG5yZXR1cm4gdGhlIGRlZmF1bHQgbGF5ZXIgKGBgQ2FydG9DU1MuTGF5ZXJgYCksIHVzdWFsbHkgdGhlIE1hcCBsYXllclxcblxcblxcbiMjIyBmaW5kTGF5ZXIod2hlcmUpXFxuXFxuZmluZCBhIGxheWVyIHVzaW5nIHdoZXJlIG9iamVjdC5cXG5cXG5gYGBcXG5zaGFkZXIuZmluZExheWVyKHsgbmFtZTogJ3Rlc3QnIH0pXFxuYGBgXFxuXFxuIyMgQ2FydG9DU1MuTGF5ZXJcXG5cXG4jIyMgZ2V0U3R5bGUocHJvcHMsIGNvbnRleHQpXFxuXFxucmV0dXJuIHRoZSBldmFsdWF0ZWQgc3R5bGU6XFxuICAgIC0gcHJvcHM6IG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgbmVlZGVkIHRvIHJlbmRlciB0aGUgc3R5bGUuIElmIHRoZSBjYXJ0b2NzcyBzdHlsZSB1c2VzXFxuICAgICAgc29tZSB2YXJpYWJsZXMgdGhleSBzaG91bGQgYmUgcGFzc2VkIGluIHRoaXMgb2JqZWN0XFxuICAgIC0gY29udGV4dDogcmVuZGVyaW5nIGNvbnRleHQgdmFyaWFibGVzIGxpa2UgYGB6b29tYGAgb3IgYW5pbWF0aW9uIGBgZnJhbWVgYFxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbiMjIFJlZmVyZW5jZSBEb2N1bWVudGF0aW9uXFxuXFxuKiBbbWFwYm94LmNvbS9jYXJ0b10oaHR0cDovL21hcGJveC5jb20vY2FydG8vKVxcblxcblxcblwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1kXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NhcnRvZGIvY2FydG9cIixcbiAgXCJfaWRcIjogXCJjYXJ0b0AwLjE1LjEtY2RiMVwiLFxuICBcIl9zaGFzdW1cIjogXCI2MjUzNGMyOTc1Y2JlZTA3M2YxMGM2YzE0YTBjN2U4ODljOTQ2OWU3XCIsXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0NhcnRvREIvY2FydG8vYXJjaGl2ZS9tYXN0ZXIudGFyLmd6XCIsXG4gIFwiX2Zyb21cIjogXCJodHRwczovL2dpdGh1Yi5jb20vQ2FydG9EQi9jYXJ0by9hcmNoaXZlL21hc3Rlci50YXIuZ3pcIlxufVxuIl19
