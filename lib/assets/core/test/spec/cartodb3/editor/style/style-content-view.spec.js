var Backbone = require('backbone');
var _ = require('underscore');
var MetricsTracker = require('../../../../../javascripts/cartodb3/components/metrics/metrics-tracker');
var UserActions = require('../../../../../javascripts/cartodb3/data/user-actions');
var StyleContentView = require('../../../../../javascripts/cartodb3/editor/style/style-content-view');
var StyleDefinitionModel = require('../../../../../javascripts/cartodb3/editor/style/style-definition-model');
var QueryGeometryModel = require('../../../../../javascripts/cartodb3/data/query-geometry-model');
var QuerySchemaModel = require('../../../../../javascripts/cartodb3/data/query-schema-model');
var AnalysisDefinitionNodesCollection = require('../../../../../javascripts/cartodb3/data/analysis-definition-nodes-collection');
var ConfigModel = require('../../../../../javascripts/cartodb3/data/config-model');
var UserModel = require('../../../../../javascripts/cartodb3/data/user-model');
var LayerDefinitionsCollection = require('../../../../../javascripts/cartodb3/data/layer-definitions-collection');
var LayerDefinitionModel = require('../../../../../javascripts/cartodb3/data/layer-definition-model');
var QueryRowsCollection = require('../../../../../javascripts/cartodb3/data/query-rows-collection');
var FactoryModals = require('../../factories/modals');

describe('editor/style/style-content-view', function () {
  beforeEach(function () {
    this.configModel = new ConfigModel({
      base_url: '/u/pepe'
    });

    this.userModel = new UserModel({}, {
      configModel: this.configModel
    });
    spyOn(this.userModel, 'featureEnabled').and.returnValue(true);

    this.overlayModel = new Backbone.Model();
    this.model = new StyleDefinitionModel({
      autogenerated: true
    });

    spyOn(MetricsTracker, 'track');

    var attrs = {
      query: 'SELECT * FROM table',
      status: 'unfetched',
      ready: true
    };
    var opts = {
      configModel: this.configModel
    };
    this.querySchemaModel = new QuerySchemaModel(attrs, opts);
    this.queryGeometryModel = new QueryGeometryModel(attrs, opts);

    this.analysisDefinitionNodesCollection = new AnalysisDefinitionNodesCollection(null, {
      configModel: this.configModel,
      userModel: this.userModel
    });

    this.a0 = this.analysisDefinitionNodesCollection.add({
      id: 'a0',
      type: 'source',
      table_name: 'foo'
    });
    spyOn(this.a0, 'isCustomQueryApplied').and.returnValue(false);

    this.layerDefinitionCollection = new LayerDefinitionsCollection(null, {
      configModel: this.configModel,
      userModel: this.userModel,
      analysisDefinitionNodesCollection: this.analysisDefinitionNodesCollection,
      mapId: 'm123',
      stateDefinitionModel: {}
    });
    this.layerDefinitionModel = new LayerDefinitionModel({
      id: 'abc-123',
      kind: 'carto',
      options: {
        type: 'CartoDB',
        color: '#FABADA',
        table_name: 'foo',
        query: 'SELECT * FROM foo',
        tile_style: 'asdasd',
        visible: true
      }
    }, {
      parse: true,
      configModel: this.configModel,
      collection: this.layerDefinitionCollection
    });

    this.layerDefinitionModel.styleModel = this.model;
    this.xhrSpy = jasmine.createSpyObj('xhr', ['abort', 'always', 'fail']);
    spyOn(Backbone.Model.prototype, 'sync').and.returnValue(this.xhrSpy);

    spyOn(this.layerDefinitionModel, 'save').and.callThrough();
    spyOn(this.layerDefinitionModel, 'getAnalysisDefinitionNodeModel').and.returnValue(this.a0);

    spyOn(this.querySchemaModel, 'fetch');
    spyOn(this.queryGeometryModel, 'fetch');
    spyOn(StyleContentView.prototype, 'render').and.callThrough();

    this.userActions = UserActions({
      userModel: this.userModel,
      analysisDefinitionsCollection: {},
      analysisDefinitionNodesCollection: {},
      layerDefinitionsCollection: {},
      widgetDefinitionsCollection: {}
    });

    this.queryRowsCollection = new QueryRowsCollection([], {
      configModel: this.configModel,
      querySchemaModel: this.querySchemaModel
    });

    spyOn(this.queryRowsCollection, 'fetch');
    spyOn(StyleContentView.prototype, '_fetchAllQueryObjectsIfNecessary').and.callThrough();

    this.view = new StyleContentView({
      configModel: this.configModel,
      userModel: this.userModel,
      userActions: this.userActions,
      layerDefinitionsCollection: new Backbone.Collection(),
      layerDefinitionModel: this.layerDefinitionModel,
      queryGeometryModel: this.queryGeometryModel,
      querySchemaModel: this.querySchemaModel,
      queryRowsCollection: this.queryRowsCollection,
      modals: FactoryModals.createModalService(),
      styleModel: this.model,
      overlayModel: this.overlayModel,
      editorModel: new Backbone.Model(),
      freezeTorgeAggregation: jasmine.createSpy('freezeTorgeAggregation')
    });

    this.view.render();
  });

  it('should fetch (if necessary) all query objects', function () {
    expect(StyleContentView.prototype._fetchAllQueryObjectsIfNecessary).toHaveBeenCalled();
  });

  describe('._initBinds', function () {
    it('should render when query schema is fetched', function () {
      StyleContentView.prototype.render.calls.reset();

      this.querySchemaModel.set('status', 'fetching');
      this.queryGeometryModel.set('status', 'fetched');
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled(); // not yet

      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set('status', 'fetched');
      expect(StyleContentView.prototype.render).toHaveBeenCalled();
    });

    it('should not render when query schema is loading/fetching', function () {
      StyleContentView.prototype.render.calls.reset();
      this.querySchemaModel.set('status', 'fetching');
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled();
      this.queryGeometryModel.set('status', 'fetching');
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled();
    });

    it('should render when styleModel is undone or redone', function () {
      StyleContentView.prototype.render.calls.reset();
      var fill = _.clone(this.model.get('fill'));
      fill.size = 34;
      this.model.set('fill', fill);
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled();
      this.model.undo();
      expect(StyleContentView.prototype.render).toHaveBeenCalled();
      this.model.redo();
      expect(StyleContentView.prototype.render.calls.count()).toBe(2);
    });
  });

  describe('.render', function () {
    it('should render "placeholder" if state is loading', function () {
      this.view.modelView.set({state: 'loading'});
      expect(this.view.$('.FormPlaceholder-paragraph').length).toBe(5);
      expect(_.size(this.view._subviews)).toBe(0);
    });

    it('should render properly when models are fetched and have selector for onboarding', function () {
      this.view.modelView.set({state: 'ready'});
      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set({
        status: 'fetched',
        simple_geom: 'point'
      });
      this.queryRowsCollection.statusModel.set('status', 'fetched');
      this.view.render();
      expect(this.view.$('.Carousel').length).toBe(1);
      expect(this.view.$('.Editor-HeaderInfo').length).toBe(2);
      expect(this.view.$el.children().first().hasClass('js-aggregationTypes')).toBe(true);
      expect(_.size(this.view._subviews)).toBe(3); // overlay counts
    });

    it('should not render carousel view when geometry is not point', function () {
      this.view.modelView.set({state: 'ready'});
      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set({
        status: 'fetched',
        simple_geom: 'polygon'
      });
      this.queryRowsCollection.statusModel.set('status', 'fetched');
      this.view.render();
      expect(this.view.$('.Carousel').length).toBe(0);
      expect(this.view.$('.Editor-HeaderInfo').length).toBe(1);
      expect(_.size(this.view._subviews)).toBe(2);
    });

    it('should not render _renderForm when data has no geometry', function () {
      this.view.modelView.set({state: 'ready'});
      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set({
        status: 'fetched',
        simple_geom: ''
      });
      this.queryRowsCollection.statusModel.set('status', 'fetched');

      this.view.render();
      expect(this.view.$el.html()).toContain('editor.style.style-form.properties.placeholder-text');
    });

    it('should have correct class for onboarding when showing the placeholder', function () {
      spyOn(this.view, '_hasError').and.returnValue(false);
      spyOn(this.view, '_isLoading').and.returnValue(false);
      spyOn(this.view, '_isReady').and.returnValue(true);
      spyOn(this.view._queryGeometryModel, 'hasValue').and.returnValue(false);

      this.view.render();

      expect(this.view.$('.js-styleNoGeom').length).toBe(1);
    });

    it('should render the "apply" button properly in advanced mode', function () {
      this.view.$('.Options-bar .CDB-Toggle.js-input').click();
      expect(this.view.$('.js-apply').hasClass('.CDB-Size-small')).toBeFalsy();
    });
  });

  describe('when layer is non georeferenced', function () {
    beforeEach(function () {
      this.view = new StyleContentView({
        configModel: this.configModel,
        userModel: this.userModel,
        userActions: this.userActions,
        layerDefinitionsCollection: new Backbone.Collection(),
        layerDefinitionModel: this.layerDefinitionModel,
        queryGeometryModel: this.queryGeometryModel,
        querySchemaModel: this.querySchemaModel,
        queryRowsCollection: this.queryRowsCollection,
        modals: FactoryModals.createModalService(),
        styleModel: this.model,
        overlayModel: this.overlayModel,
        editorModel: new Backbone.Model(),
        freezeTorgeAggregation: jasmine.createSpy('freezeTorgeAggregation')
      });

      this.view.render();
    });

    it('should not have any leaks', function () {
      expect(this.view).toHaveNoLeaks();
    });
  });

  describe('on style changed', function () {
    beforeEach(function () {
      spyOn(this.model, 'removeStylesPreAutoStyle');
      this.layerDefinitionModel.save.calls.reset();
      // Fake styleModel change
      var fillAttrs = _.clone(this.model.get('fill'));
      fillAttrs.size = 34;
      this.model.set('fill', fillAttrs);
    });

    it('should remove autogenerated attribute', function () {
      expect(this.model.get('autogenerated')).toBeFalsy();
    });

    it('should remove styles pre autostyle if autostyle', function () {
      this.layerDefinitionModel.set({autoStyle: true}, {silent: true});
      this.model._stylesPreAutoStyle = true;
      var fillAttrs = _.clone(this.model.get('fill'));
      fillAttrs.size = 12;
      this.model.set('fill', fillAttrs);
      expect(this.model.get('autogenerated')).toBeFalsy();
      expect(this.model.removeStylesPreAutoStyle).toHaveBeenCalled();
    });

    it('should not change cartocss_custom property when styleModel changes', function () {
      this.layerDefinitionModel.set('cartocss_custom', true);
      var fillAttrs = _.clone(this.model.get('fill'));
      fillAttrs.size = 12;
      this.model.set('fill', fillAttrs);
      expect(this.layerDefinitionModel.get('cartocss_custom')).toBe(true);
    });

    it('should save the layer', function () {
      expect(this.layerDefinitionModel.save.calls.count()).toBe(1);
    });
  });

  describe('autoStyle', function () {
    it('render on autostyle changes', function () {
      this.layerDefinitionModel.set({autoStyle: false});
      expect(StyleContentView.prototype.render).toHaveBeenCalled();
    });
  });

  it('should not have leaks', function () {
    expect(this.view).toHaveNoLeaks();
  });
});
