var cdb = require('cartodb.js');
var _ = require('underscore');
var syncAbort = require('./backbone/sync-abort');
var StyleDefinitionModel = require('../editor/style/style-definition-model');
var StyleCartoCSSModel = require('../editor/style/style-cartocss-model');
var nodeIds = require('../value-objects/analysis-node-ids');
var camshaftReference = require('./camshaft-reference');
var layerTypesAndKinds = require('./layer-types-and-kinds');
var InfowindowModel = require('./infowindow-click-model');
var TooltipModel = require('./infowindow-hover-model');

var OWN_ATTR_NAMES = ['id', 'order', 'color', 'table_name_alias', 'infowindow', 'tooltip'];

/**
 * Model to edit a layer definition.
 * Should always exist as part of a LayerDefinitionsCollection, so its URL is given from there.
 */
module.exports = cdb.core.Model.extend({
  defaults: {
    'color': '#ff6600'
  },

  /**
   * @override {Backbone.prototype.sync} abort ongoing request if there is any
   */
  sync: syncAbort,

  parse: function (r, opts) {
    r.options = r.options || {};

    // Flatten the attrs, to avoid having this.get('options').foobar internally
    var attrs = _
      .defaults(
        _.pick(r, OWN_ATTR_NAMES),
        _.omit(r.options, ['query', 'tile_style'])
    );

    // Only use type on the frontend, it will be mapped back when the model is serialized (see .toJSON)
    attrs.type = attrs.type || layerTypesAndKinds.getType(r.kind);

    // Map API endpoint attrs to the new names used client-side (cartodb.js in particular)
    if (r.options.tile_style) {
      attrs.cartocss = r.options.tile_style;
    }
    if (r.options.query) {
      attrs.sql = r.options.query;
    }

    if (r.infowindow) {
      if (!this.infowindowModel) {
        this.infowindowModel = new InfowindowModel(r.infowindow, {
          configModel: opts.configModel || this._configModel
        });
      }
    }
    if (r.tooltip) {
      if (!this.tooltipModel) {
        this.tooltipModel = new TooltipModel(r.tooltip, {
          configModel: opts.configModel || this._configModel
        });
      }
    }
    if (r.options.table_name) {
      if (!this.styleModel) {
        this.styleModel = new StyleDefinitionModel(r.options.style_properties, {
          parse: true
        });

        this.cartocssModel = new StyleCartoCSSModel({
          content: attrs.cartocss
        }, {
          history: r.options.cartocss_history || r.options.tile_style_history
        });
      }
    }

    // Flatten the rest of the attributes
    return attrs;
  },

  initialize: function (attrs, opts) {
    if (!opts.configModel) throw new Error('configModel is required');

    this._configModel = opts.configModel;

    this.on('change:source change:sql', this._onPosibleLayerSchemaChanged, this);

    if (this.styleModel) {
      this.styleModel.bind('change:type', function () {
        if (this.styleModel.isAggregatedType()) {
          this.infowindowModel && this.infowindowModel.clearFields();
        }
      }, this);
    }
  },

  toJSON: function () {
    // Un-flatten the internal attrs to the datastructure that's expected by the API endpoint
    var options = _.omit(this.attributes, OWN_ATTR_NAMES.concat(['cartocss', 'sql']));

    // Map back internal attrs to the expected attrs names by the API endpoint
    var cartocss = this.get('cartocss');
    if (cartocss) {
      options.tile_style = cartocss;
    }
    var sql = this.get('sql');
    if (sql) {
      options.query = sql;
    }

    var d = {
      kind: layerTypesAndKinds.getKind(this.get('type')),
      options: options
    };

    var infowindowData = this.infowindowModel && this.infowindowModel.toJSON();
    if (!_.isEmpty(infowindowData)) {
      d.infowindow = this.infowindowModel.toJSON();
    }

    var tooltipData = this.tooltipModel && this.tooltipModel.toJSON();
    if (!_.isEmpty(tooltipData)) {
      d.tooltip = this.tooltipModel.toJSON();
    }

    if (this.styleModel && !this.styleModel.isAutogenerated()) {
      d.options.style_properties = this.styleModel.toJSON();
    }

    if (this.cartocssModel) {
      d.options.cartocss_history = this.cartocssModel.getHistory();
    }

    var attributes = _.omit(this.attributes, 'infowindow', 'tooltip', 'options');

    return _.defaults(
      d,
      _.pick(attributes, OWN_ATTR_NAMES)
    );
  },

  isOwnerOfAnalysisNode: function (nodeModel) {
    return this.get('letter') === nodeIds.letter(nodeModel.id);
  },

  getName: function () {
    return this.get('name') ||
    this.get('table_name_alias') ||
    this.get('table_name');
  },

  getTableName: function () {
    return this.get('table_name') || '';
  },

  createNewAnalysisNode: function (nodeAttrs) {
    var nodeDefModel = this.collection.createNewAnalysisNode(nodeAttrs);

    this.save({
      cartocss: camshaftReference.getDefaultCartoCSSForType(nodeDefModel.get('type')),
      source: nodeDefModel.id
    });

    return nodeDefModel;
  },

  getAnalysisDefinitionNodeModel: function () {
    return this.findAnalysisDefinitionNodeModel(this.get('source'));
  },

  findAnalysisDefinitionNodeModel: function (id) {
    return this.collection.findAnalysisDefinitionNodeModel(id);
  },

  _onPosibleLayerSchemaChanged: function () {
    if (this.infowindowModel) {
      this.infowindowModel.clearFields();
    }
    if (this.tooltipModel) {
      this.tooltipModel.clearFields();
    }
    if (this.styleModel) {
      this.styleModel.resetStyles();
    }
  }
});
