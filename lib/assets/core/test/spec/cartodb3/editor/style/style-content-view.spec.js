var Backbone = require('backbone');
var _ = require('underscore');
var MetricsTracker = require('../../../../../javascripts/cartodb3/components/metrics/metrics-tracker');
var UserActions = require('../../../../../javascripts/cartodb3/data/user-actions');
var StyleContentView = require('../../../../../javascripts/cartodb3/editor/style/style-content-view');
var StyleDefinitionModel = require('../../../../../javascripts/cartodb3/editor/style/style-definition-model');
var QueryGeometryModel = require('../../../../../javascripts/cartodb3/data/query-geometry-model');
var QuerySchemaModel = require('../../../../../javascripts/cartodb3/data/query-schema-model');

describe('editor/style/style-content-view', function () {
  beforeEach(function () {
    this.overlayModel = new Backbone.Model();
    this.model = new StyleDefinitionModel({
      autogenerated: true
    });

    spyOn(MetricsTracker, 'track');

    var attrs = {
      query: 'SELECT * FROM table',
      status: 'unfetched',
      ready: true
    };
    var opts = {configModel: {}};
    this.querySchemaModel = new QuerySchemaModel(attrs, opts);
    this.queryGeometryModel = new QueryGeometryModel(attrs, opts);

    this.layerDefinitionModel = new Backbone.Model();
    spyOn(this.layerDefinitionModel, 'save');
    spyOn(this.querySchemaModel, 'fetch');
    spyOn(this.queryGeometryModel, 'fetch');
    spyOn(StyleContentView.prototype, 'render').and.callThrough();

    this.userActions = UserActions({
      userModel: new Backbone.Model({
        id: 'whatever'
      }),
      analysisDefinitionsCollection: {},
      analysisDefinitionNodesCollection: {},
      layerDefinitionsCollection: {},
      widgetDefinitionsCollection: {}
    });

    this.view = new StyleContentView({
      configModel: {},
      userModel: {
        featureEnabled: function () { return true; }
      },
      userActions: this.userActions,
      layerDefinitionsCollection: new Backbone.Collection(),
      layerDefinitionModel: this.layerDefinitionModel,
      queryGeometryModel: this.queryGeometryModel,
      querySchemaModel: this.querySchemaModel,
      modals: {},
      styleModel: this.model,
      overlayModel: this.overlayModel,
      editorModel: new Backbone.Model(),
      freezeTorgeAggregation: jasmine.createSpy('freezeTorgeAggregation')
    });
    this.view.render();
  });

  it('should fetch query schema model if it is unfetched', function () {
    expect(this.querySchemaModel.fetch).toHaveBeenCalled();
  });

  it('should fetch geometry if it unfetched', function () {
    expect(this.queryGeometryModel.fetch).toHaveBeenCalled();
  });

  describe('._initBinds', function () {
    it('should render when query schema is fetched', function () {
      StyleContentView.prototype.render.calls.reset();

      this.querySchemaModel.set('status', 'fetching');
      this.queryGeometryModel.set('status', 'fetched');
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled(); // not yet

      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set('status', 'fetched');
      expect(StyleContentView.prototype.render).toHaveBeenCalled();
    });

    it('should not render when query schema is loading/fetching', function () {
      StyleContentView.prototype.render.calls.reset();
      this.querySchemaModel.set('status', 'fetching');
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled();
      this.queryGeometryModel.set('status', 'fetching');
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled();
    });

    it('should render when styleModel is undone or redone', function () {
      StyleContentView.prototype.render.calls.reset();
      var fill = _.clone(this.model.get('fill'));
      fill.size = 34;
      this.model.set('fill', fill);
      expect(StyleContentView.prototype.render).not.toHaveBeenCalled();
      this.model.undo();
      expect(StyleContentView.prototype.render).toHaveBeenCalled();
      this.model.redo();
      expect(StyleContentView.prototype.render.calls.count()).toBe(2);
    });
  });

  describe('.render', function () {
    it('should render "placeholder" if state is loading', function () {
      this.view.modelView.set({state: 'loading'});
      expect(this.view.$('.FormPlaceholder-paragraph').length).toBe(4);
      expect(_.size(this.view._subviews)).toBe(0);
    });

    it('should render properly when models are fetched and have selector for onboarding', function () {
      this.view.modelView.set({state: 'ready'});
      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set('status', 'fetched');
      this.queryGeometryModel.set('simple_geom', 'point');
      this.view.render();
      expect(this.view.$('.Carousel').length).toBe(1);
      expect(this.view.$('.Editor-HeaderInfo').length).toBe(2);
      expect(this.view.$el.children().first().hasClass('js-aggregationTypes')).toBe(true);
      expect(_.size(this.view._subviews)).toBe(3); // overlay counts
    });

    it('should not render carousel view when geometry is not point', function () {
      this.view.modelView.set({state: 'ready'});
      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set({
        status: 'fetched',
        simple_geom: 'polygon'
      });
      this.view.render();
      expect(this.view.$('.Carousel').length).toBe(0);
      expect(this.view.$('.Editor-HeaderInfo').length).toBe(1);
      expect(_.size(this.view._subviews)).toBe(2);
    });

    it('should not render _renderForm when data has no geometry', function () {
      this.view.modelView.set({state: 'ready'});
      this.querySchemaModel.set('status', 'fetched');
      this.queryGeometryModel.set({
        status: 'fetched',
        simple_geom: ''
      });

      this.view.render();
      expect(this.view.$el.html()).toContain('editor.style.style-form.properties.placeholder-text');
    });

    it('should have correct class for onboarding when showing the placeholder', function () {
      spyOn(this.view, '_hasError').and.returnValue(false);
      spyOn(this.view, '_isLoading').and.returnValue(false);
      spyOn(this.view, '_isReady').and.returnValue(true);
      spyOn(this.view._queryGeometryModel, 'hasValue').and.returnValue(false);

      this.view.render();

      expect(this.view.$('.js-styleNoGeom').length).toBe(1);
    });
  });

  describe('on style changed', function () {
    beforeEach(function () {
      spyOn(this.model, 'removeStylesPreAutoStyle');
      this.layerDefinitionModel.save.calls.reset();
      // Fake styleModel change
      var fillAttrs = _.clone(this.model.get('fill'));
      fillAttrs.size = 34;
      this.model.set('fill', fillAttrs);
    });

    it('should remove styles pre autostyle and autogenerated attribute', function () {
      expect(this.model.get('autogenerated')).toBeFalsy();
      expect(this.model.removeStylesPreAutoStyle).toHaveBeenCalled();
    });

    it('should not change cartocss_custom property when styleModel changes', function () {
      this.layerDefinitionModel.set('cartocss_custom', true);
      var fillAttrs = _.clone(this.model.get('fill'));
      fillAttrs.size = 12;
      this.model.set('fill', fillAttrs);
      expect(this.layerDefinitionModel.get('cartocss_custom')).toBe(true);
    });

    it('should save the layer', function () {
      expect(this.layerDefinitionModel.save.calls.count()).toBe(1);
    });
  });

  describe('autoStyle', function () {
    it('render on autostyle changes', function () {
      this.layerDefinitionModel.set({autoStyle: false});
      expect(StyleContentView.prototype.render).toHaveBeenCalled();
    });
  });

  it('should not have leaks', function () {
    expect(this.view).toHaveNoLeaks();
  });
});
